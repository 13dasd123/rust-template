using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class BlackjackCardPlayer : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public List<int> splitCards;

	[NonSerialized]
	public int splitBetThisRound;

	[NonSerialized]
	public int insuranceBetThisRound;

	[NonSerialized]
	public bool playingSplitCards;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(BlackjackCardPlayer instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.splitCards != null)
			{
				List<int> list = instance.splitCards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.splitCards = list;
			}
			instance.splitBetThisRound = 0;
			instance.insuranceBetThisRound = 0;
			instance.playingSplitCards = false;
			Pool.Free<BlackjackCardPlayer>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose BlackjackCardPlayer with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(BlackjackCardPlayer instance)
	{
		if (splitCards != null)
		{
			instance.splitCards = Pool.Get<List<int>>();
			for (int i = 0; i < splitCards.Count; i++)
			{
				int item = splitCards[i];
				instance.splitCards.Add(item);
			}
		}
		else
		{
			instance.splitCards = null;
		}
		instance.splitBetThisRound = splitBetThisRound;
		instance.insuranceBetThisRound = insuranceBetThisRound;
		instance.playingSplitCards = playingSplitCards;
	}

	public BlackjackCardPlayer Copy()
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		CopyTo(blackjackCardPlayer);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer Deserialize(Stream stream)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		Deserialize(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer DeserializeLengthDelimited(Stream stream)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		DeserializeLengthDelimited(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer DeserializeLength(Stream stream, int length)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		DeserializeLength(stream, length, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public static BlackjackCardPlayer Deserialize(byte[] buffer)
	{
		BlackjackCardPlayer blackjackCardPlayer = Pool.Get<BlackjackCardPlayer>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, blackjackCardPlayer, isDelta: false);
		return blackjackCardPlayer;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, BlackjackCardPlayer previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static BlackjackCardPlayer Deserialize(byte[] buffer, BlackjackCardPlayer instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static BlackjackCardPlayer Deserialize(Stream stream, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static BlackjackCardPlayer DeserializeLengthDelimited(Stream stream, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static BlackjackCardPlayer DeserializeLength(Stream stream, int length, BlackjackCardPlayer instance, bool isDelta)
	{
		if (!isDelta && instance.splitCards == null)
		{
			instance.splitCards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.splitCards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.splitBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.insuranceBetThisRound = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.playingSplitCards = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, BlackjackCardPlayer instance, BlackjackCardPlayer previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.splitCards != null)
		{
			for (int i = 0; i < instance.splitCards.Count; i++)
			{
				int num = instance.splitCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.splitBetThisRound != previous.splitBetThisRound)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
		}
		if (instance.insuranceBetThisRound != previous.insuranceBetThisRound)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.playingSplitCards);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, BlackjackCardPlayer instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.splitCards != null)
		{
			for (int i = 0; i < instance.splitCards.Count; i++)
			{
				int num = instance.splitCards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		if (instance.splitBetThisRound != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.splitBetThisRound);
		}
		if (instance.insuranceBetThisRound != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.insuranceBetThisRound);
		}
		if (instance.playingSplitCards)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.playingSplitCards);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(BlackjackCardPlayer instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, BlackjackCardPlayer instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class CardList : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public List<int> cards;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CardList instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.cards != null)
			{
				List<int> list = instance.cards;
				Pool.FreeUnmanaged<int>(ref list);
				instance.cards = list;
			}
			Pool.Free<CardList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CardList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CardList instance)
	{
		if (cards != null)
		{
			instance.cards = Pool.Get<List<int>>();
			for (int i = 0; i < cards.Count; i++)
			{
				int item = cards[i];
				instance.cards.Add(item);
			}
		}
		else
		{
			instance.cards = null;
		}
	}

	public CardList Copy()
	{
		CardList cardList = Pool.Get<CardList>();
		CopyTo(cardList);
		return cardList;
	}

	public static CardList Deserialize(Stream stream)
	{
		CardList cardList = Pool.Get<CardList>();
		Deserialize(stream, cardList, isDelta: false);
		return cardList;
	}

	public static CardList DeserializeLengthDelimited(Stream stream)
	{
		CardList cardList = Pool.Get<CardList>();
		DeserializeLengthDelimited(stream, cardList, isDelta: false);
		return cardList;
	}

	public static CardList DeserializeLength(Stream stream, int length)
	{
		CardList cardList = Pool.Get<CardList>();
		DeserializeLength(stream, length, cardList, isDelta: false);
		return cardList;
	}

	public static CardList Deserialize(byte[] buffer)
	{
		CardList cardList = Pool.Get<CardList>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, cardList, isDelta: false);
		return cardList;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, CardList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CardList Deserialize(byte[] buffer, CardList instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static CardList Deserialize(Stream stream, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CardList DeserializeLengthDelimited(Stream stream, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CardList DeserializeLength(Stream stream, int length, CardList instance, bool isDelta)
	{
		if (!isDelta && instance.cards == null)
		{
			instance.cards = Pool.Get<List<int>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.cards.Add((int)ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, CardList instance, CardList previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, CardList instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.cards != null)
		{
			for (int i = 0; i < instance.cards.Count; i++)
			{
				int num = instance.cards[i];
				stream.WriteByte(8);
				ProtocolParser.WriteUInt64(stream, (ulong)num);
			}
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(CardList instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, CardList instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Design : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public List<Star> stars;

	[NonSerialized]
	public ulong editedBy;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Design instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				if (instance.stars[i] != null)
				{
					instance.stars[i].ResetToPool();
					instance.stars[i] = null;
				}
			}
			List<Star> list = instance.stars;
			Pool.Free<Star>(ref list, false);
			instance.stars = list;
		}
		instance.editedBy = 0uL;
		Pool.Free<Design>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Design with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Design instance)
	{
		if (stars != null)
		{
			instance.stars = Pool.Get<List<Star>>();
			for (int i = 0; i < stars.Count; i++)
			{
				Star item = stars[i].Copy();
				instance.stars.Add(item);
			}
		}
		else
		{
			instance.stars = null;
		}
		instance.editedBy = editedBy;
	}

	public Design Copy()
	{
		Design design = Pool.Get<Design>();
		CopyTo(design);
		return design;
	}

	public static Design Deserialize(Stream stream)
	{
		Design design = Pool.Get<Design>();
		Deserialize(stream, design, isDelta: false);
		return design;
	}

	public static Design DeserializeLengthDelimited(Stream stream)
	{
		Design design = Pool.Get<Design>();
		DeserializeLengthDelimited(stream, design, isDelta: false);
		return design;
	}

	public static Design DeserializeLength(Stream stream, int length)
	{
		Design design = Pool.Get<Design>();
		DeserializeLength(stream, length, design, isDelta: false);
		return design;
	}

	public static Design Deserialize(byte[] buffer)
	{
		Design design = Pool.Get<Design>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, design, isDelta: false);
		return design;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Design previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Design Deserialize(byte[] buffer, Design instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Design Deserialize(Stream stream, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Design DeserializeLengthDelimited(Stream stream, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Design DeserializeLength(Stream stream, int length, Design instance, bool isDelta)
	{
		if (!isDelta && instance.stars == null)
		{
			instance.stars = Pool.Get<List<Star>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.stars.Add(Star.DeserializeLengthDelimited(stream));
				continue;
			case 16:
				instance.editedBy = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Design instance, Design previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				Star star = instance.stars[i];
				stream.WriteByte(10);
				memoryStream.SetLength(0L);
				Star.SerializeDelta(memoryStream, star, star);
				uint num = (uint)memoryStream.Length;
				ProtocolParser.WriteUInt32(stream, num);
				stream.Write(memoryStream.GetBuffer(), 0, (int)num);
			}
		}
		if (instance.editedBy != previous.editedBy)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Design instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.stars != null)
		{
			for (int i = 0; i < instance.stars.Count; i++)
			{
				Star instance2 = instance.stars[i];
				stream.WriteByte(10);
				memoryStream.SetLength(0L);
				Star.Serialize(memoryStream, instance2);
				uint num = (uint)memoryStream.Length;
				ProtocolParser.WriteUInt32(stream, num);
				stream.Write(memoryStream.GetBuffer(), 0, (int)num);
			}
		}
		if (instance.editedBy != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.editedBy);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Design instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Design instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (stars != null)
		{
			for (int i = 0; i < stars.Count; i++)
			{
				stars[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Star : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public Vector2 position;

	[NonSerialized]
	public Color color;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Star instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.position = default(Vector2);
			instance.color = default(Color);
			Pool.Free<Star>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Star with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Star instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		instance.position = position;
		instance.color = color;
	}

	public Star Copy()
	{
		Star star = Pool.Get<Star>();
		CopyTo(star);
		return star;
	}

	public static Star Deserialize(Stream stream)
	{
		Star star = Pool.Get<Star>();
		Deserialize(stream, star, isDelta: false);
		return star;
	}

	public static Star DeserializeLengthDelimited(Stream stream)
	{
		Star star = Pool.Get<Star>();
		DeserializeLengthDelimited(stream, star, isDelta: false);
		return star;
	}

	public static Star DeserializeLength(Stream stream, int length)
	{
		Star star = Pool.Get<Star>();
		DeserializeLength(stream, length, star, isDelta: false);
		return star;
	}

	public static Star Deserialize(byte[] buffer)
	{
		Star star = Pool.Get<Star>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, star, isDelta: false);
		return star;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Star previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Star Deserialize(byte[] buffer, Star instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Star Deserialize(Stream stream, Star instance, bool isDelta)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Star DeserializeLengthDelimited(Stream stream, Star instance, bool isDelta)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Star DeserializeLength(Stream stream, int length, Star instance, bool isDelta)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector2Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 18:
				ColorSerialized.DeserializeLengthDelimited(stream, ref instance.color, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Star instance, Star previous)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.position != previous.position)
		{
			stream.WriteByte(10);
			memoryStream.SetLength(0L);
			Vector2Serialized.SerializeDelta(memoryStream, instance.position, previous.position);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.color != previous.color)
		{
			stream.WriteByte(18);
			memoryStream.SetLength(0L);
			ColorSerialized.SerializeDelta(memoryStream, instance.color, previous.color);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Star instance)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.position != default(Vector2))
		{
			stream.WriteByte(10);
			memoryStream.SetLength(0L);
			Vector2Serialized.Serialize(memoryStream, instance.position);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.color != default(Color))
		{
			stream.WriteByte(18);
			memoryStream.SetLength(0L);
			ColorSerialized.Serialize(memoryStream, instance.color);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Star instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Star instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SavedDesign : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int version;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public Design design;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SavedDesign instance)
	{
		if (instance.ShouldPool)
		{
			instance.version = 0;
			instance.name = string.Empty;
			if (instance.design != null)
			{
				instance.design.ResetToPool();
				instance.design = null;
			}
			Pool.Free<SavedDesign>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SavedDesign with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SavedDesign instance)
	{
		instance.version = version;
		instance.name = name;
		if (design != null)
		{
			if (instance.design == null)
			{
				instance.design = design.Copy();
			}
			else
			{
				design.CopyTo(instance.design);
			}
		}
		else
		{
			instance.design = null;
		}
	}

	public SavedDesign Copy()
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		CopyTo(savedDesign);
		return savedDesign;
	}

	public static SavedDesign Deserialize(Stream stream)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		Deserialize(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign DeserializeLengthDelimited(Stream stream)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		DeserializeLengthDelimited(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign DeserializeLength(Stream stream, int length)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		DeserializeLength(stream, length, savedDesign, isDelta: false);
		return savedDesign;
	}

	public static SavedDesign Deserialize(byte[] buffer)
	{
		SavedDesign savedDesign = Pool.Get<SavedDesign>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, savedDesign, isDelta: false);
		return savedDesign;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, SavedDesign previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SavedDesign Deserialize(byte[] buffer, SavedDesign instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static SavedDesign Deserialize(Stream stream, SavedDesign instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SavedDesign DeserializeLengthDelimited(Stream stream, SavedDesign instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SavedDesign DeserializeLength(Stream stream, int length, SavedDesign instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.version = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				if (instance.design == null)
				{
					instance.design = Design.DeserializeLengthDelimited(stream);
				}
				else
				{
					Design.DeserializeLengthDelimited(stream, instance.design, isDelta);
				}
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, SavedDesign instance, SavedDesign previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.version != previous.version)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.design == null)
		{
			throw new ArgumentNullException("design", "Required by proto specification.");
		}
		stream.WriteByte(26);
		memoryStream.SetLength(0L);
		Design.SerializeDelta(memoryStream, instance.design, previous.design);
		uint num = (uint)memoryStream.Length;
		ProtocolParser.WriteUInt32(stream, num);
		stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, SavedDesign instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.version != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.version);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.design == null)
		{
			throw new ArgumentNullException("design", "Required by proto specification.");
		}
		stream.WriteByte(26);
		memoryStream.SetLength(0L);
		Design.Serialize(memoryStream, instance.design);
		uint num = (uint)memoryStream.Length;
		ProtocolParser.WriteUInt32(stream, num);
		stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(SavedDesign instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, SavedDesign instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		design?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class CookingItem : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public int slotIndex;

	[NonSerialized]
	public int initialStackSize;

	[NonSerialized]
	public float cookingProgress;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(CookingItem instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemID = 0;
			instance.slotIndex = 0;
			instance.initialStackSize = 0;
			instance.cookingProgress = 0f;
			Pool.Free<CookingItem>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose CookingItem with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(CookingItem instance)
	{
		instance.itemID = itemID;
		instance.slotIndex = slotIndex;
		instance.initialStackSize = initialStackSize;
		instance.cookingProgress = cookingProgress;
	}

	public CookingItem Copy()
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		CopyTo(cookingItem);
		return cookingItem;
	}

	public static CookingItem Deserialize(Stream stream)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		Deserialize(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem DeserializeLengthDelimited(Stream stream)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		DeserializeLengthDelimited(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem DeserializeLength(Stream stream, int length)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		DeserializeLength(stream, length, cookingItem, isDelta: false);
		return cookingItem;
	}

	public static CookingItem Deserialize(byte[] buffer)
	{
		CookingItem cookingItem = Pool.Get<CookingItem>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, cookingItem, isDelta: false);
		return cookingItem;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, CookingItem previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static CookingItem Deserialize(byte[] buffer, CookingItem instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static CookingItem Deserialize(Stream stream, CookingItem instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static CookingItem DeserializeLengthDelimited(Stream stream, CookingItem instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static CookingItem DeserializeLength(Stream stream, int length, CookingItem instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.slotIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.initialStackSize = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 37:
				instance.cookingProgress = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, CookingItem instance, CookingItem previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.slotIndex != previous.slotIndex)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.initialStackSize != previous.initialStackSize)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
		}
		if (instance.cookingProgress != previous.cookingProgress)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.cookingProgress);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, CookingItem instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.slotIndex != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.slotIndex);
		}
		if (instance.initialStackSize != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.initialStackSize);
		}
		if (instance.cookingProgress != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.cookingProgress);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(CookingItem instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, CookingItem instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ItemFilter : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int itemDef;

	[NonSerialized]
	public int itemCategory;

	[NonSerialized]
	public int maxAmountInDestination;

	[NonSerialized]
	public int isBlueprint;

	[NonSerialized]
	public int bufferAmount;

	[NonSerialized]
	public int retainMinimum;

	[NonSerialized]
	public int bufferTransferRemaining;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemFilter instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemDef = 0;
			instance.itemCategory = 0;
			instance.maxAmountInDestination = 0;
			instance.isBlueprint = 0;
			instance.bufferAmount = 0;
			instance.retainMinimum = 0;
			instance.bufferTransferRemaining = 0;
			Pool.Free<ItemFilter>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemFilter with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemFilter instance)
	{
		instance.itemDef = itemDef;
		instance.itemCategory = itemCategory;
		instance.maxAmountInDestination = maxAmountInDestination;
		instance.isBlueprint = isBlueprint;
		instance.bufferAmount = bufferAmount;
		instance.retainMinimum = retainMinimum;
		instance.bufferTransferRemaining = bufferTransferRemaining;
	}

	public ItemFilter Copy()
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		CopyTo(itemFilter);
		return itemFilter;
	}

	public static ItemFilter Deserialize(Stream stream)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		Deserialize(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter DeserializeLengthDelimited(Stream stream)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		DeserializeLengthDelimited(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter DeserializeLength(Stream stream, int length)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		DeserializeLength(stream, length, itemFilter, isDelta: false);
		return itemFilter;
	}

	public static ItemFilter Deserialize(byte[] buffer)
	{
		ItemFilter itemFilter = Pool.Get<ItemFilter>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, itemFilter, isDelta: false);
		return itemFilter;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, ItemFilter previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemFilter Deserialize(byte[] buffer, ItemFilter instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static ItemFilter Deserialize(Stream stream, ItemFilter instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemFilter DeserializeLengthDelimited(Stream stream, ItemFilter instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemFilter DeserializeLength(Stream stream, int length, ItemFilter instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemDef = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.itemCategory = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.maxAmountInDestination = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.isBlueprint = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.bufferAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.retainMinimum = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.bufferTransferRemaining = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, ItemFilter instance, ItemFilter previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemDef != previous.itemDef)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
		}
		if (instance.itemCategory != previous.itemCategory)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
		}
		if (instance.maxAmountInDestination != previous.maxAmountInDestination)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
		}
		if (instance.isBlueprint != previous.isBlueprint)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
		}
		if (instance.bufferAmount != previous.bufferAmount)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
		}
		if (instance.retainMinimum != previous.retainMinimum)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
		}
		if (instance.bufferTransferRemaining != previous.bufferTransferRemaining)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, ItemFilter instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemDef != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemDef);
		}
		if (instance.itemCategory != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemCategory);
		}
		if (instance.maxAmountInDestination != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.maxAmountInDestination);
		}
		if (instance.isBlueprint != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.isBlueprint);
		}
		if (instance.bufferAmount != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferAmount);
		}
		if (instance.retainMinimum != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.retainMinimum);
		}
		if (instance.bufferTransferRemaining != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.bufferTransferRemaining);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(ItemFilter instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, ItemFilter instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ItemFilterList : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public List<ItemFilter> filters;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ItemFilterList instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				if (instance.filters[i] != null)
				{
					instance.filters[i].ResetToPool();
					instance.filters[i] = null;
				}
			}
			List<ItemFilter> list = instance.filters;
			Pool.Free<ItemFilter>(ref list, false);
			instance.filters = list;
		}
		Pool.Free<ItemFilterList>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ItemFilterList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ItemFilterList instance)
	{
		if (filters != null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
			for (int i = 0; i < filters.Count; i++)
			{
				ItemFilter item = filters[i].Copy();
				instance.filters.Add(item);
			}
		}
		else
		{
			instance.filters = null;
		}
	}

	public ItemFilterList Copy()
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		CopyTo(itemFilterList);
		return itemFilterList;
	}

	public static ItemFilterList Deserialize(Stream stream)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		Deserialize(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList DeserializeLengthDelimited(Stream stream)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		DeserializeLengthDelimited(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList DeserializeLength(Stream stream, int length)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		DeserializeLength(stream, length, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public static ItemFilterList Deserialize(byte[] buffer)
	{
		ItemFilterList itemFilterList = Pool.Get<ItemFilterList>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, itemFilterList, isDelta: false);
		return itemFilterList;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, ItemFilterList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ItemFilterList Deserialize(byte[] buffer, ItemFilterList instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static ItemFilterList Deserialize(Stream stream, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemFilterList DeserializeLengthDelimited(Stream stream, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemFilterList DeserializeLength(Stream stream, int length, ItemFilterList instance, bool isDelta)
	{
		if (!isDelta && instance.filters == null)
		{
			instance.filters = Pool.Get<List<ItemFilter>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.filters.Add(ItemFilter.DeserializeLengthDelimited(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, ItemFilterList instance, ItemFilterList previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter itemFilter = instance.filters[i];
				stream.WriteByte(10);
				memoryStream.SetLength(0L);
				ItemFilter.SerializeDelta(memoryStream, itemFilter, itemFilter);
				uint num = (uint)memoryStream.Length;
				ProtocolParser.WriteUInt32(stream, num);
				stream.Write(memoryStream.GetBuffer(), 0, (int)num);
			}
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, ItemFilterList instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.filters != null)
		{
			for (int i = 0; i < instance.filters.Count; i++)
			{
				ItemFilter instance2 = instance.filters[i];
				stream.WriteByte(10);
				memoryStream.SetLength(0L);
				ItemFilter.Serialize(memoryStream, instance2);
				uint num = (uint)memoryStream.Length;
				ProtocolParser.WriteUInt32(stream, num);
				stream.Write(memoryStream.GetBuffer(), 0, (int)num);
			}
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(ItemFilterList instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, ItemFilterList instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		if (filters != null)
		{
			for (int i = 0; i < filters.Count; i++)
			{
				filters[i]?.InspectUids(action);
			}
		}
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public struct ItemTransfer : IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int amount;

	public static void ResetToPool(ItemTransfer instance)
	{
		instance.itemId = 0;
		instance.amount = 0;
	}

	public void CopyTo(ItemTransfer instance)
	{
		instance.itemId = itemId;
		instance.amount = amount;
	}

	public ItemTransfer Copy()
	{
		ItemTransfer itemTransfer = default(ItemTransfer);
		CopyTo(itemTransfer);
		return itemTransfer;
	}

	public static ItemTransfer Deserialize(Stream stream)
	{
		ItemTransfer instance = default(ItemTransfer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer DeserializeLengthDelimited(Stream stream)
	{
		ItemTransfer instance = default(ItemTransfer);
		DeserializeLengthDelimited(stream, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer DeserializeLength(Stream stream, int length)
	{
		ItemTransfer instance = default(ItemTransfer);
		DeserializeLength(stream, length, ref instance, isDelta: false);
		return instance;
	}

	public static ItemTransfer Deserialize(byte[] buffer)
	{
		ItemTransfer instance = default(ItemTransfer);
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, ref instance, isDelta: false);
		return instance;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, ref this, isDelta);
	}

	public void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public void WriteToStreamDelta(Stream stream, ItemTransfer previous)
	{
		SerializeDelta(stream, this, previous);
	}

	public void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, ref this, isDelta);
	}

	public static ItemTransfer Deserialize(byte[] buffer, ref ItemTransfer instance, bool isDelta = false)
	{
		using (MemoryStream stream = new MemoryStream(buffer))
		{
			Deserialize(stream, ref instance, isDelta);
		}
		return instance;
	}

	public static ItemTransfer Deserialize(Stream stream, ref ItemTransfer instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ItemTransfer DeserializeLengthDelimited(Stream stream, ref ItemTransfer instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ItemTransfer DeserializeLength(Stream stream, int length, ref ItemTransfer instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, ItemTransfer instance, ItemTransfer previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, ItemTransfer instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(ItemTransfer instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, ItemTransfer instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class AssociatedFile : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public uint crc;

	[NonSerialized]
	public uint numID;

	[NonSerialized]
	public byte[] data;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(AssociatedFile instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.crc = 0u;
			instance.numID = 0u;
			instance.data = null;
			Pool.Free<AssociatedFile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose AssociatedFile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(AssociatedFile instance)
	{
		instance.type = type;
		instance.crc = crc;
		instance.numID = numID;
		if (data == null)
		{
			instance.data = null;
			return;
		}
		instance.data = new byte[data.Length];
		Array.Copy(data, instance.data, instance.data.Length);
	}

	public AssociatedFile Copy()
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		CopyTo(associatedFile);
		return associatedFile;
	}

	public static AssociatedFile Deserialize(Stream stream)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		Deserialize(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile DeserializeLengthDelimited(Stream stream)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		DeserializeLengthDelimited(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile DeserializeLength(Stream stream, int length)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		DeserializeLength(stream, length, associatedFile, isDelta: false);
		return associatedFile;
	}

	public static AssociatedFile Deserialize(byte[] buffer)
	{
		AssociatedFile associatedFile = Pool.Get<AssociatedFile>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, associatedFile, isDelta: false);
		return associatedFile;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, AssociatedFile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static AssociatedFile Deserialize(byte[] buffer, AssociatedFile instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static AssociatedFile Deserialize(Stream stream, AssociatedFile instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static AssociatedFile DeserializeLengthDelimited(Stream stream, AssociatedFile instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static AssociatedFile DeserializeLength(Stream stream, int length, AssociatedFile instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.crc = ProtocolParser.ReadUInt32(stream);
				continue;
			case 24:
				instance.numID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 34:
				instance.data = ProtocolParser.ReadBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, AssociatedFile instance, AssociatedFile previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.type != previous.type)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.crc != previous.crc)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.numID != previous.numID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numID);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteBytes(stream, instance.data);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, AssociatedFile instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.type != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.crc != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt32(stream, instance.crc);
		}
		if (instance.numID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.numID);
		}
		if (instance.data == null)
		{
			throw new ArgumentNullException("data", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteBytes(stream, instance.data);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(AssociatedFile instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, AssociatedFile instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ScheduleEntry : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int nextZoneId;

	[NonSerialized]
	public int estimate;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ScheduleEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.nextZoneId = 0;
			instance.estimate = 0;
			Pool.Free<ScheduleEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ScheduleEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ScheduleEntry instance)
	{
		instance.nextZoneId = nextZoneId;
		instance.estimate = estimate;
	}

	public ScheduleEntry Copy()
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		CopyTo(scheduleEntry);
		return scheduleEntry;
	}

	public static ScheduleEntry Deserialize(Stream stream)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		Deserialize(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry DeserializeLengthDelimited(Stream stream)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		DeserializeLengthDelimited(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry DeserializeLength(Stream stream, int length)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		DeserializeLength(stream, length, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public static ScheduleEntry Deserialize(byte[] buffer)
	{
		ScheduleEntry scheduleEntry = Pool.Get<ScheduleEntry>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, scheduleEntry, isDelta: false);
		return scheduleEntry;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, ScheduleEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ScheduleEntry Deserialize(byte[] buffer, ScheduleEntry instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static ScheduleEntry Deserialize(Stream stream, ScheduleEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ScheduleEntry DeserializeLengthDelimited(Stream stream, ScheduleEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ScheduleEntry DeserializeLength(Stream stream, int length, ScheduleEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.nextZoneId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.estimate = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, ScheduleEntry instance, ScheduleEntry previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.nextZoneId != previous.nextZoneId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
		}
		if (instance.estimate != previous.estimate)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, ScheduleEntry instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.nextZoneId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.nextZoneId);
		}
		if (instance.estimate != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.estimate);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(ScheduleEntry instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, ScheduleEntry instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class QueuedMove : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public NetworkableId targetEntity;

	[NonSerialized]
	public Vector3 targetWorldPosition;

	[NonSerialized]
	public Vector4 targetWorldRotation;

	[NonSerialized]
	public bool hasTarget;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(QueuedMove instance)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.targetEntity = default(NetworkableId);
			instance.targetWorldPosition = default(Vector3);
			instance.targetWorldRotation = default(Vector4);
			instance.hasTarget = false;
			Pool.Free<QueuedMove>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose QueuedMove with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(QueuedMove instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.targetEntity = targetEntity;
		instance.targetWorldPosition = targetWorldPosition;
		instance.targetWorldRotation = targetWorldRotation;
		instance.hasTarget = hasTarget;
	}

	public QueuedMove Copy()
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		CopyTo(queuedMove);
		return queuedMove;
	}

	public static QueuedMove Deserialize(Stream stream)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		Deserialize(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove DeserializeLengthDelimited(Stream stream)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		DeserializeLengthDelimited(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove DeserializeLength(Stream stream, int length)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		DeserializeLength(stream, length, queuedMove, isDelta: false);
		return queuedMove;
	}

	public static QueuedMove Deserialize(byte[] buffer)
	{
		QueuedMove queuedMove = Pool.Get<QueuedMove>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, queuedMove, isDelta: false);
		return queuedMove;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, QueuedMove previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static QueuedMove Deserialize(byte[] buffer, QueuedMove instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static QueuedMove Deserialize(Stream stream, QueuedMove instance, bool isDelta)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static QueuedMove DeserializeLengthDelimited(Stream stream, QueuedMove instance, bool isDelta)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static QueuedMove DeserializeLength(Stream stream, int length, QueuedMove instance, bool isDelta)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.targetEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldPosition, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.targetWorldRotation, isDelta);
				continue;
			case 32:
				instance.hasTarget = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, QueuedMove instance, QueuedMove previous)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
		if (instance.targetWorldPosition != previous.targetWorldPosition)
		{
			stream.WriteByte(18);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.targetWorldPosition, previous.targetWorldPosition);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.targetWorldRotation != previous.targetWorldRotation)
		{
			stream.WriteByte(26);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.targetWorldRotation, previous.targetWorldRotation);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.hasTarget);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, QueuedMove instance)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.targetEntity != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.targetEntity.Value);
		}
		if (instance.targetWorldPosition != default(Vector3))
		{
			stream.WriteByte(18);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.targetWorldPosition);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.targetWorldRotation != default(Vector4))
		{
			stream.WriteByte(26);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.targetWorldRotation);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		if (instance.hasTarget)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.hasTarget);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(QueuedMove instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, QueuedMove instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref targetEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class InstanceData : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int dataInt;

	[NonSerialized]
	public int blueprintTarget;

	[NonSerialized]
	public int blueprintAmount;

	[NonSerialized]
	public NetworkableId subEntity;

	[NonSerialized]
	public float dataFloat;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(InstanceData instance)
	{
		if (instance.ShouldPool)
		{
			instance.dataInt = 0;
			instance.blueprintTarget = 0;
			instance.blueprintAmount = 0;
			instance.subEntity = default(NetworkableId);
			instance.dataFloat = 0f;
			Pool.Free<InstanceData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose InstanceData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(InstanceData instance)
	{
		instance.dataInt = dataInt;
		instance.blueprintTarget = blueprintTarget;
		instance.blueprintAmount = blueprintAmount;
		instance.subEntity = subEntity;
		instance.dataFloat = dataFloat;
	}

	public InstanceData Copy()
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		CopyTo(instanceData);
		return instanceData;
	}

	public static InstanceData Deserialize(Stream stream)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		Deserialize(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData DeserializeLengthDelimited(Stream stream)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		DeserializeLengthDelimited(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData DeserializeLength(Stream stream, int length)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		DeserializeLength(stream, length, instanceData, isDelta: false);
		return instanceData;
	}

	public static InstanceData Deserialize(byte[] buffer)
	{
		InstanceData instanceData = Pool.Get<InstanceData>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instanceData, isDelta: false);
		return instanceData;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, InstanceData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static InstanceData Deserialize(byte[] buffer, InstanceData instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static InstanceData Deserialize(Stream stream, InstanceData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static InstanceData DeserializeLengthDelimited(Stream stream, InstanceData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static InstanceData DeserializeLength(Stream stream, int length, InstanceData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.dataInt = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.blueprintTarget = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.blueprintAmount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.subEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 45:
				instance.dataFloat = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, InstanceData instance, InstanceData previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.dataInt != previous.dataInt)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
		}
		if (instance.blueprintTarget != previous.blueprintTarget)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
		}
		if (instance.blueprintAmount != previous.blueprintAmount)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
		if (instance.dataFloat != previous.dataFloat)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.dataFloat);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, InstanceData instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.dataInt != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.dataInt);
		}
		if (instance.blueprintTarget != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintTarget);
		}
		if (instance.blueprintAmount != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.blueprintAmount);
		}
		if (instance.subEntity != default(NetworkableId))
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, instance.subEntity.Value);
		}
		if (instance.dataFloat != 0f)
		{
			stream.WriteByte(45);
			ProtocolParser.WriteSingle(stream, instance.dataFloat);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(InstanceData instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, InstanceData instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref subEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ConditionData : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public float condition;

	[NonSerialized]
	public float maxCondition;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ConditionData instance)
	{
		if (instance.ShouldPool)
		{
			instance.condition = 0f;
			instance.maxCondition = 0f;
			Pool.Free<ConditionData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ConditionData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ConditionData instance)
	{
		instance.condition = condition;
		instance.maxCondition = maxCondition;
	}

	public ConditionData Copy()
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		CopyTo(conditionData);
		return conditionData;
	}

	public static ConditionData Deserialize(Stream stream)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		Deserialize(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData DeserializeLengthDelimited(Stream stream)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		DeserializeLengthDelimited(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData DeserializeLength(Stream stream, int length)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		DeserializeLength(stream, length, conditionData, isDelta: false);
		return conditionData;
	}

	public static ConditionData Deserialize(byte[] buffer)
	{
		ConditionData conditionData = Pool.Get<ConditionData>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, conditionData, isDelta: false);
		return conditionData;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, ConditionData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ConditionData Deserialize(byte[] buffer, ConditionData instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static ConditionData Deserialize(Stream stream, ConditionData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ConditionData DeserializeLengthDelimited(Stream stream, ConditionData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ConditionData DeserializeLength(Stream stream, int length, ConditionData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 13:
				instance.condition = ProtocolParser.ReadSingle(stream);
				continue;
			case 21:
				instance.maxCondition = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, ConditionData instance, ConditionData previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.condition != previous.condition)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.maxCondition != previous.maxCondition)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxCondition);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, ConditionData instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.condition != 0f)
		{
			stream.WriteByte(13);
			ProtocolParser.WriteSingle(stream, instance.condition);
		}
		if (instance.maxCondition != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.maxCondition);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(ConditionData instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, ConditionData instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class TeamMember : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public string displayName;

	[NonSerialized]
	public ulong userID;

	[NonSerialized]
	public float healthFraction;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public bool online;

	[NonSerialized]
	public bool wounded;

	[NonSerialized]
	public ulong teamID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(TeamMember instance)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.displayName = string.Empty;
			instance.userID = 0uL;
			instance.healthFraction = 0f;
			instance.position = default(Vector3);
			instance.online = false;
			instance.wounded = false;
			instance.teamID = 0uL;
			Pool.Free<TeamMember>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose TeamMember with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(TeamMember instance)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		instance.displayName = displayName;
		instance.userID = userID;
		instance.healthFraction = healthFraction;
		instance.position = position;
		instance.online = online;
		instance.wounded = wounded;
		instance.teamID = teamID;
	}

	public TeamMember Copy()
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		CopyTo(teamMember);
		return teamMember;
	}

	public static TeamMember Deserialize(Stream stream)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		Deserialize(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember DeserializeLengthDelimited(Stream stream)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		DeserializeLengthDelimited(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember DeserializeLength(Stream stream, int length)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		DeserializeLength(stream, length, teamMember, isDelta: false);
		return teamMember;
	}

	public static TeamMember Deserialize(byte[] buffer)
	{
		TeamMember teamMember = Pool.Get<TeamMember>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, teamMember, isDelta: false);
		return teamMember;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, TeamMember previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static TeamMember Deserialize(byte[] buffer, TeamMember instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static TeamMember Deserialize(Stream stream, TeamMember instance, bool isDelta)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static TeamMember DeserializeLengthDelimited(Stream stream, TeamMember instance, bool isDelta)
	{
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static TeamMember DeserializeLength(Stream stream, int length, TeamMember instance, bool isDelta)
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.displayName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.userID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.healthFraction = ProtocolParser.ReadSingle(stream);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 40:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.wounded = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.teamID = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, TeamMember instance, TeamMember previous)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.displayName != null && instance.displayName != previous.displayName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.userID != previous.userID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userID);
		}
		if (instance.healthFraction != previous.healthFraction)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
		if (instance.position != previous.position)
		{
			stream.WriteByte(34);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.position, previous.position);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.online);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.wounded);
		if (instance.teamID != previous.teamID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, TeamMember instance)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.displayName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.displayName);
		}
		if (instance.userID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userID);
		}
		if (instance.healthFraction != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.healthFraction);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(34);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.position);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.online)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.online);
		}
		if (instance.wounded)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.wounded);
		}
		if (instance.teamID != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, instance.teamID);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(TeamMember instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, TeamMember instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class DeathInfo : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public string attackerName;

	[NonSerialized]
	public ulong attackerSteamID;

	[NonSerialized]
	public string hitBone;

	[NonSerialized]
	public string inflictorName;

	[NonSerialized]
	public int lastDamageType;

	[NonSerialized]
	public float attackerDistance;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DeathInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.attackerName = string.Empty;
			instance.attackerSteamID = 0uL;
			instance.hitBone = string.Empty;
			instance.inflictorName = string.Empty;
			instance.lastDamageType = 0;
			instance.attackerDistance = 0f;
			Pool.Free<DeathInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DeathInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DeathInfo instance)
	{
		instance.attackerName = attackerName;
		instance.attackerSteamID = attackerSteamID;
		instance.hitBone = hitBone;
		instance.inflictorName = inflictorName;
		instance.lastDamageType = lastDamageType;
		instance.attackerDistance = attackerDistance;
	}

	public DeathInfo Copy()
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		CopyTo(deathInfo);
		return deathInfo;
	}

	public static DeathInfo Deserialize(Stream stream)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		Deserialize(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo DeserializeLengthDelimited(Stream stream)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		DeserializeLengthDelimited(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo DeserializeLength(Stream stream, int length)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		DeserializeLength(stream, length, deathInfo, isDelta: false);
		return deathInfo;
	}

	public static DeathInfo Deserialize(byte[] buffer)
	{
		DeathInfo deathInfo = Pool.Get<DeathInfo>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, deathInfo, isDelta: false);
		return deathInfo;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, DeathInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DeathInfo Deserialize(byte[] buffer, DeathInfo instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static DeathInfo Deserialize(Stream stream, DeathInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DeathInfo DeserializeLengthDelimited(Stream stream, DeathInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DeathInfo DeserializeLength(Stream stream, int length, DeathInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.attackerName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.attackerSteamID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.hitBone = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.inflictorName = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.lastDamageType = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 53:
				instance.attackerDistance = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, DeathInfo instance, DeathInfo previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.attackerName != null && instance.attackerName != previous.attackerName)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.attackerName);
		}
		if (instance.attackerSteamID != previous.attackerSteamID)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
		}
		if (instance.hitBone != null && instance.hitBone != previous.hitBone)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hitBone);
		}
		if (instance.inflictorName != null && instance.inflictorName != previous.inflictorName)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.inflictorName);
		}
		if (instance.lastDamageType != previous.lastDamageType)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
		}
		if (instance.attackerDistance != previous.attackerDistance)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.attackerDistance);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, DeathInfo instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.attackerName != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.attackerName);
		}
		if (instance.attackerSteamID != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.attackerSteamID);
		}
		if (instance.hitBone != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.hitBone);
		}
		if (instance.inflictorName != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.inflictorName);
		}
		if (instance.lastDamageType != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastDamageType);
		}
		if (instance.attackerDistance != 0f)
		{
			stream.WriteByte(53);
			ProtocolParser.WriteSingle(stream, instance.attackerDistance);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(DeathInfo instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, DeathInfo instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class WeaponStats : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public string weaponName;

	[NonSerialized]
	public ulong shotsFired;

	[NonSerialized]
	public ulong shotsHit;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(WeaponStats instance)
	{
		if (instance.ShouldPool)
		{
			instance.weaponName = string.Empty;
			instance.shotsFired = 0uL;
			instance.shotsHit = 0uL;
			Pool.Free<WeaponStats>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose WeaponStats with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(WeaponStats instance)
	{
		instance.weaponName = weaponName;
		instance.shotsFired = shotsFired;
		instance.shotsHit = shotsHit;
	}

	public WeaponStats Copy()
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		CopyTo(weaponStats);
		return weaponStats;
	}

	public static WeaponStats Deserialize(Stream stream)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		Deserialize(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats DeserializeLengthDelimited(Stream stream)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		DeserializeLengthDelimited(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats DeserializeLength(Stream stream, int length)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		DeserializeLength(stream, length, weaponStats, isDelta: false);
		return weaponStats;
	}

	public static WeaponStats Deserialize(byte[] buffer)
	{
		WeaponStats weaponStats = Pool.Get<WeaponStats>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, weaponStats, isDelta: false);
		return weaponStats;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, WeaponStats previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static WeaponStats Deserialize(byte[] buffer, WeaponStats instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static WeaponStats Deserialize(Stream stream, WeaponStats instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static WeaponStats DeserializeLengthDelimited(Stream stream, WeaponStats instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static WeaponStats DeserializeLength(Stream stream, int length, WeaponStats instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.weaponName = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.shotsFired = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.shotsHit = ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, WeaponStats instance, WeaponStats previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.weaponName != previous.weaponName)
		{
			if (instance.weaponName == null)
			{
				throw new ArgumentNullException("weaponName", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.weaponName);
		}
		if (instance.shotsFired != previous.shotsFired)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.shotsFired);
		}
		if (instance.shotsHit != previous.shotsHit)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.shotsHit);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, WeaponStats instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.weaponName == null)
		{
			throw new ArgumentNullException("weaponName", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.weaponName);
		if (instance.shotsFired != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.shotsFired);
		}
		if (instance.shotsHit != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, instance.shotsHit);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(WeaponStats instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, WeaponStats instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class GenericStat : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public string key;

	[NonSerialized]
	public int value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(GenericStat instance)
	{
		if (instance.ShouldPool)
		{
			instance.key = string.Empty;
			instance.value = 0;
			Pool.Free<GenericStat>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose GenericStat with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(GenericStat instance)
	{
		instance.key = key;
		instance.value = value;
	}

	public GenericStat Copy()
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		CopyTo(genericStat);
		return genericStat;
	}

	public static GenericStat Deserialize(Stream stream)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		Deserialize(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat DeserializeLengthDelimited(Stream stream)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		DeserializeLengthDelimited(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat DeserializeLength(Stream stream, int length)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		DeserializeLength(stream, length, genericStat, isDelta: false);
		return genericStat;
	}

	public static GenericStat Deserialize(byte[] buffer)
	{
		GenericStat genericStat = Pool.Get<GenericStat>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, genericStat, isDelta: false);
		return genericStat;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, GenericStat previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static GenericStat Deserialize(byte[] buffer, GenericStat instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static GenericStat Deserialize(Stream stream, GenericStat instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static GenericStat DeserializeLengthDelimited(Stream stream, GenericStat instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static GenericStat DeserializeLength(Stream stream, int length, GenericStat instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.key = ProtocolParser.ReadString(stream);
				continue;
			case 16:
				instance.value = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, GenericStat instance, GenericStat previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.key != previous.key)
		{
			if (instance.key == null)
			{
				throw new ArgumentNullException("key", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.key);
		}
		if (instance.value != previous.value)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, GenericStat instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.key == null)
		{
			throw new ArgumentNullException("key", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.key);
		if (instance.value != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.value);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(GenericStat instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, GenericStat instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Task : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int itemID;

	[NonSerialized]
	public float remainingTime;

	[NonSerialized]
	public int taskUID;

	[NonSerialized]
	public bool cancelled;

	[NonSerialized]
	public Item.InstanceData instanceData;

	[NonSerialized]
	public int amount;

	[NonSerialized]
	public int skinID;

	[NonSerialized]
	public List<Item> takenItems;

	[NonSerialized]
	public int numCrafted;

	[NonSerialized]
	public float conditionScale;

	[NonSerialized]
	public NetworkableId workbenchEntity;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Task instance)
	{
		if (!instance.ShouldPool)
		{
			return;
		}
		instance.itemID = 0;
		instance.remainingTime = 0f;
		instance.taskUID = 0;
		instance.cancelled = false;
		if (instance.instanceData != null)
		{
			instance.instanceData.ResetToPool();
			instance.instanceData = null;
		}
		instance.amount = 0;
		instance.skinID = 0;
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				if (instance.takenItems[i] != null)
				{
					instance.takenItems[i].ResetToPool();
					instance.takenItems[i] = null;
				}
			}
			List<Item> list = instance.takenItems;
			Pool.Free<Item>(ref list, false);
			instance.takenItems = list;
		}
		instance.numCrafted = 0;
		instance.conditionScale = 0f;
		instance.workbenchEntity = default(NetworkableId);
		Pool.Free<Task>(ref instance);
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Task with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Task instance)
	{
		instance.itemID = itemID;
		instance.remainingTime = remainingTime;
		instance.taskUID = taskUID;
		instance.cancelled = cancelled;
		if (instanceData != null)
		{
			if (instance.instanceData == null)
			{
				instance.instanceData = instanceData.Copy();
			}
			else
			{
				instanceData.CopyTo(instance.instanceData);
			}
		}
		else
		{
			instance.instanceData = null;
		}
		instance.amount = amount;
		instance.skinID = skinID;
		if (takenItems != null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
			for (int i = 0; i < takenItems.Count; i++)
			{
				Item item = takenItems[i].Copy();
				instance.takenItems.Add(item);
			}
		}
		else
		{
			instance.takenItems = null;
		}
		instance.numCrafted = numCrafted;
		instance.conditionScale = conditionScale;
		instance.workbenchEntity = workbenchEntity;
	}

	public Task Copy()
	{
		Task task = Pool.Get<Task>();
		CopyTo(task);
		return task;
	}

	public static Task Deserialize(Stream stream)
	{
		Task task = Pool.Get<Task>();
		Deserialize(stream, task, isDelta: false);
		return task;
	}

	public static Task DeserializeLengthDelimited(Stream stream)
	{
		Task task = Pool.Get<Task>();
		DeserializeLengthDelimited(stream, task, isDelta: false);
		return task;
	}

	public static Task DeserializeLength(Stream stream, int length)
	{
		Task task = Pool.Get<Task>();
		DeserializeLength(stream, length, task, isDelta: false);
		return task;
	}

	public static Task Deserialize(byte[] buffer)
	{
		Task task = Pool.Get<Task>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, task, isDelta: false);
		return task;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Task previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Task Deserialize(byte[] buffer, Task instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Task Deserialize(Stream stream, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				continue;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Task DeserializeLengthDelimited(Stream stream, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				continue;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Task DeserializeLength(Stream stream, int length, Task instance, bool isDelta)
	{
		if (!isDelta && instance.takenItems == null)
		{
			instance.takenItems = Pool.Get<List<Item>>();
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 21:
				instance.remainingTime = ProtocolParser.ReadSingle(stream);
				continue;
			case 24:
				instance.taskUID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.cancelled = ProtocolParser.ReadBool(stream);
				continue;
			case 42:
				if (instance.instanceData == null)
				{
					instance.instanceData = Item.InstanceData.DeserializeLengthDelimited(stream);
				}
				else
				{
					Item.InstanceData.DeserializeLengthDelimited(stream, instance.instanceData, isDelta);
				}
				continue;
			case 48:
				instance.amount = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.skinID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.takenItems.Add(Item.DeserializeLengthDelimited(stream));
				continue;
			case 72:
				instance.numCrafted = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 85:
				instance.conditionScale = ProtocolParser.ReadSingle(stream);
				continue;
			case 88:
				instance.workbenchEntity = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Task instance, Task previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemID != previous.itemID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.remainingTime != previous.remainingTime)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingTime);
		}
		if (instance.taskUID != previous.taskUID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.cancelled);
		if (instance.instanceData != null)
		{
			stream.WriteByte(42);
			memoryStream.SetLength(0L);
			Item.InstanceData.SerializeDelta(memoryStream, instance.instanceData, previous.instanceData);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.amount != previous.amount)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.skinID != previous.skinID)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
		}
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				Item item = instance.takenItems[i];
				stream.WriteByte(66);
				memoryStream.SetLength(0L);
				Item.SerializeDelta(memoryStream, item, item);
				uint num2 = (uint)memoryStream.Length;
				ProtocolParser.WriteUInt32(stream, num2);
				stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
			}
		}
		if (instance.numCrafted != previous.numCrafted)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
		}
		if (instance.conditionScale != previous.conditionScale)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.conditionScale);
		}
		stream.WriteByte(88);
		ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Task instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemID);
		}
		if (instance.remainingTime != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.remainingTime);
		}
		if (instance.taskUID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.taskUID);
		}
		if (instance.cancelled)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.cancelled);
		}
		if (instance.instanceData != null)
		{
			stream.WriteByte(42);
			memoryStream.SetLength(0L);
			Item.InstanceData.Serialize(memoryStream, instance.instanceData);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.amount != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amount);
		}
		if (instance.skinID != 0)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.skinID);
		}
		if (instance.takenItems != null)
		{
			for (int i = 0; i < instance.takenItems.Count; i++)
			{
				Item instance2 = instance.takenItems[i];
				stream.WriteByte(66);
				memoryStream.SetLength(0L);
				Item.Serialize(memoryStream, instance2);
				uint num2 = (uint)memoryStream.Length;
				ProtocolParser.WriteUInt32(stream, num2);
				stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
			}
		}
		if (instance.numCrafted != 0)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.numCrafted);
		}
		if (instance.conditionScale != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.conditionScale);
		}
		if (instance.workbenchEntity != default(NetworkableId))
		{
			stream.WriteByte(88);
			ProtocolParser.WriteUInt64(stream, instance.workbenchEntity.Value);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Task instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Task instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		instanceData?.InspectUids(action);
		if (takenItems != null)
		{
			for (int i = 0; i < takenItems.Count; i++)
			{
				takenItems[i]?.InspectUids(action);
			}
		}
		action(UidType.Clear, ref workbenchEntity.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Projectile : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int projectileID;

	[NonSerialized]
	public Vector3 startPos;

	[NonSerialized]
	public Vector3 startVel;

	[NonSerialized]
	public int seed;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Projectile instance)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.projectileID = 0;
			instance.startPos = default(Vector3);
			instance.startVel = default(Vector3);
			instance.seed = 0;
			Pool.Free<Projectile>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Projectile with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Projectile instance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		instance.projectileID = projectileID;
		instance.startPos = startPos;
		instance.startVel = startVel;
		instance.seed = seed;
	}

	public Projectile Copy()
	{
		Projectile projectile = Pool.Get<Projectile>();
		CopyTo(projectile);
		return projectile;
	}

	public static Projectile Deserialize(Stream stream)
	{
		Projectile projectile = Pool.Get<Projectile>();
		Deserialize(stream, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile DeserializeLengthDelimited(Stream stream)
	{
		Projectile projectile = Pool.Get<Projectile>();
		DeserializeLengthDelimited(stream, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile DeserializeLength(Stream stream, int length)
	{
		Projectile projectile = Pool.Get<Projectile>();
		DeserializeLength(stream, length, projectile, isDelta: false);
		return projectile;
	}

	public static Projectile Deserialize(byte[] buffer)
	{
		Projectile projectile = Pool.Get<Projectile>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, projectile, isDelta: false);
		return projectile;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Projectile previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Projectile Deserialize(byte[] buffer, Projectile instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Projectile Deserialize(Stream stream, Projectile instance, bool isDelta)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Projectile DeserializeLengthDelimited(Stream stream, Projectile instance, bool isDelta)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Projectile DeserializeLength(Stream stream, int length, Projectile instance, bool isDelta)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.projectileID = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startPos, isDelta);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.startVel, isDelta);
				continue;
			case 32:
				instance.seed = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Projectile instance, Projectile previous)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.projectileID != previous.projectileID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.startPos != previous.startPos)
		{
			stream.WriteByte(18);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.startPos, previous.startPos);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.startVel != previous.startVel)
		{
			stream.WriteByte(26);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.startVel, previous.startVel);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		if (instance.seed != previous.seed)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Projectile instance)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.projectileID != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.projectileID);
		}
		if (instance.startPos != default(Vector3))
		{
			stream.WriteByte(18);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.startPos);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.startVel != default(Vector3))
		{
			stream.WriteByte(26);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.startVel);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		if (instance.seed != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.seed);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Projectile instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Projectile instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class SpawnOptions : IDisposable, IPooled, IProto
{
	public enum RespawnType
	{
		SleepingBag = 1,
		Bed,
		BeachTowel,
		Camper,
		Static
	}

	public enum RespawnState
	{
		OK = 1,
		Occupied,
		Underwater,
		InNoRespawnZone
	}

	[NonSerialized]
	public RespawnType type;

	[NonSerialized]
	public NetworkableId id;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public float unlockSeconds;

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public RespawnState respawnState;

	[NonSerialized]
	public bool mobile;

	[NonSerialized]
	public string nexusZone;

	[NonSerialized]
	public bool corpse;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SpawnOptions instance)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.type = (RespawnType)0;
			instance.id = default(NetworkableId);
			instance.name = string.Empty;
			instance.unlockSeconds = 0f;
			instance.worldPosition = default(Vector3);
			instance.respawnState = (RespawnState)0;
			instance.mobile = false;
			instance.nexusZone = string.Empty;
			instance.corpse = false;
			Pool.Free<SpawnOptions>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SpawnOptions with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SpawnOptions instance)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.type = type;
		instance.id = id;
		instance.name = name;
		instance.unlockSeconds = unlockSeconds;
		instance.worldPosition = worldPosition;
		instance.respawnState = respawnState;
		instance.mobile = mobile;
		instance.nexusZone = nexusZone;
		instance.corpse = corpse;
	}

	public SpawnOptions Copy()
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		CopyTo(spawnOptions);
		return spawnOptions;
	}

	public static SpawnOptions Deserialize(Stream stream)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		Deserialize(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions DeserializeLengthDelimited(Stream stream)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		DeserializeLengthDelimited(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions DeserializeLength(Stream stream, int length)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		DeserializeLength(stream, length, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public static SpawnOptions Deserialize(byte[] buffer)
	{
		SpawnOptions spawnOptions = Pool.Get<SpawnOptions>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, spawnOptions, isDelta: false);
		return spawnOptions;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, SpawnOptions previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SpawnOptions Deserialize(byte[] buffer, SpawnOptions instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static SpawnOptions Deserialize(Stream stream, SpawnOptions instance, bool isDelta)
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SpawnOptions DeserializeLengthDelimited(Stream stream, SpawnOptions instance, bool isDelta)
	{
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SpawnOptions DeserializeLength(Stream stream, int length, SpawnOptions instance, bool isDelta)
	{
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		if (!isDelta)
		{
			instance.respawnState = RespawnState.OK;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.type = (RespawnType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.id = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 37:
				instance.unlockSeconds = ProtocolParser.ReadSingle(stream);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.worldPosition, isDelta);
				continue;
			case 48:
				instance.respawnState = (RespawnState)ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.mobile = ProtocolParser.ReadBool(stream);
				continue;
			case 66:
				instance.nexusZone = ProtocolParser.ReadString(stream);
				continue;
			case 72:
				instance.corpse = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, SpawnOptions instance, SpawnOptions previous)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, instance.id.Value);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.unlockSeconds != previous.unlockSeconds)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
		}
		if (instance.worldPosition != previous.worldPosition)
		{
			stream.WriteByte(42);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.worldPosition, previous.worldPosition);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.mobile);
		if (instance.nexusZone != null && instance.nexusZone != previous.nexusZone)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.corpse);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, SpawnOptions instance)
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.id != default(NetworkableId))
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.id.Value);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.unlockSeconds != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.unlockSeconds);
		}
		if (instance.worldPosition != default(Vector3))
		{
			stream.WriteByte(42);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.worldPosition);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.respawnState);
		if (instance.mobile)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.mobile);
		}
		if (instance.nexusZone != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.nexusZone);
		}
		if (instance.corpse)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.corpse);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(SpawnOptions instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, SpawnOptions instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref id.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class ClientInfo : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public string name;

	[NonSerialized]
	public string value;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(ClientInfo instance)
	{
		if (instance.ShouldPool)
		{
			instance.name = string.Empty;
			instance.value = string.Empty;
			Pool.Free<ClientInfo>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose ClientInfo with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(ClientInfo instance)
	{
		instance.name = name;
		instance.value = value;
	}

	public ClientInfo Copy()
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		CopyTo(clientInfo);
		return clientInfo;
	}

	public static ClientInfo Deserialize(Stream stream)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		Deserialize(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo DeserializeLengthDelimited(Stream stream)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		DeserializeLengthDelimited(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo DeserializeLength(Stream stream, int length)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		DeserializeLength(stream, length, clientInfo, isDelta: false);
		return clientInfo;
	}

	public static ClientInfo Deserialize(byte[] buffer)
	{
		ClientInfo clientInfo = Pool.Get<ClientInfo>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, clientInfo, isDelta: false);
		return clientInfo;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, ClientInfo previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static ClientInfo Deserialize(byte[] buffer, ClientInfo instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static ClientInfo Deserialize(Stream stream, ClientInfo instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static ClientInfo DeserializeLengthDelimited(Stream stream, ClientInfo instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static ClientInfo DeserializeLength(Stream stream, int length, ClientInfo instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.value = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, ClientInfo instance, ClientInfo previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.value != previous.value)
		{
			if (instance.value == null)
			{
				throw new ArgumentNullException("value", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.value);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, ClientInfo instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.value == null)
		{
			throw new ArgumentNullException("value", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.value);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(ClientInfo instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, ClientInfo instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum MessageType
{
	Request = 1,
	Receive,
	Done
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class arcadeEnt : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public uint id;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public uint spriteID;

	[NonSerialized]
	public uint soundID;

	[NonSerialized]
	public bool visible;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 heading;

	[NonSerialized]
	public bool enabled;

	[NonSerialized]
	public Vector3 scale;

	[NonSerialized]
	public Vector3 colliderScale;

	[NonSerialized]
	public float alpha;

	[NonSerialized]
	public uint prefabID;

	[NonSerialized]
	public uint parentID;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(arcadeEnt instance)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.id = 0u;
			instance.name = string.Empty;
			instance.spriteID = 0u;
			instance.soundID = 0u;
			instance.visible = false;
			instance.position = default(Vector3);
			instance.heading = default(Vector3);
			instance.enabled = false;
			instance.scale = default(Vector3);
			instance.colliderScale = default(Vector3);
			instance.alpha = 0f;
			instance.prefabID = 0u;
			instance.parentID = 0u;
			Pool.Free<arcadeEnt>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose arcadeEnt with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(arcadeEnt instance)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		instance.id = id;
		instance.name = name;
		instance.spriteID = spriteID;
		instance.soundID = soundID;
		instance.visible = visible;
		instance.position = position;
		instance.heading = heading;
		instance.enabled = enabled;
		instance.scale = scale;
		instance.colliderScale = colliderScale;
		instance.alpha = alpha;
		instance.prefabID = prefabID;
		instance.parentID = parentID;
	}

	public arcadeEnt Copy()
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		CopyTo(arcadeEnt);
		return arcadeEnt;
	}

	public static arcadeEnt Deserialize(Stream stream)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		Deserialize(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt DeserializeLengthDelimited(Stream stream)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		DeserializeLengthDelimited(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt DeserializeLength(Stream stream, int length)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		DeserializeLength(stream, length, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public static arcadeEnt Deserialize(byte[] buffer)
	{
		arcadeEnt arcadeEnt = Pool.Get<arcadeEnt>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, arcadeEnt, isDelta: false);
		return arcadeEnt;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, arcadeEnt previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static arcadeEnt Deserialize(byte[] buffer, arcadeEnt instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static arcadeEnt Deserialize(Stream stream, arcadeEnt instance, bool isDelta)
	{
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static arcadeEnt DeserializeLengthDelimited(Stream stream, arcadeEnt instance, bool isDelta)
	{
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static arcadeEnt DeserializeLength(Stream stream, int length, arcadeEnt instance, bool isDelta)
	{
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.id = ProtocolParser.ReadUInt32(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.spriteID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 32:
				instance.soundID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 40:
				instance.visible = ProtocolParser.ReadBool(stream);
				continue;
			case 50:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 58:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.heading, isDelta);
				continue;
			case 64:
				instance.enabled = ProtocolParser.ReadBool(stream);
				continue;
			case 74:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.scale, isDelta);
				continue;
			case 82:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.colliderScale, isDelta);
				continue;
			case 93:
				instance.alpha = ProtocolParser.ReadSingle(stream);
				continue;
			case 96:
				instance.prefabID = ProtocolParser.ReadUInt32(stream);
				continue;
			case 104:
				instance.parentID = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, arcadeEnt instance, arcadeEnt previous)
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.id != previous.id)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.spriteID != previous.spriteID)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.spriteID);
		}
		if (instance.soundID != previous.soundID)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.soundID);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.visible);
		if (instance.position != previous.position)
		{
			stream.WriteByte(50);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.position, previous.position);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.heading != previous.heading)
		{
			stream.WriteByte(58);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.heading, previous.heading);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.enabled);
		if (instance.scale != previous.scale)
		{
			stream.WriteByte(74);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.scale, previous.scale);
			uint num3 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num3);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num3);
		}
		if (instance.colliderScale != previous.colliderScale)
		{
			stream.WriteByte(82);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.colliderScale, previous.colliderScale);
			uint num4 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num4);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num4);
		}
		if (instance.alpha != previous.alpha)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.prefabID != previous.prefabID)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
		if (instance.parentID != previous.parentID)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt32(stream, instance.parentID);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, arcadeEnt instance)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.id != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt32(stream, instance.id);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.spriteID != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt32(stream, instance.spriteID);
		}
		if (instance.soundID != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt32(stream, instance.soundID);
		}
		if (instance.visible)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.visible);
		}
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(50);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.position);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.heading != default(Vector3))
		{
			stream.WriteByte(58);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.heading);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		if (instance.enabled)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.enabled);
		}
		if (instance.scale != default(Vector3))
		{
			stream.WriteByte(74);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.scale);
			uint num3 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num3);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num3);
		}
		if (instance.colliderScale != default(Vector3))
		{
			stream.WriteByte(82);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.colliderScale);
			uint num4 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num4);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num4);
		}
		if (instance.alpha != 0f)
		{
			stream.WriteByte(93);
			ProtocolParser.WriteSingle(stream, instance.alpha);
		}
		if (instance.prefabID != 0)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteUInt32(stream, instance.prefabID);
		}
		if (instance.parentID != 0)
		{
			stream.WriteByte(104);
			ProtocolParser.WriteUInt32(stream, instance.parentID);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(arcadeEnt instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, arcadeEnt instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class DirectoryEntry : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int phoneNumber;

	[NonSerialized]
	public string phoneName;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(DirectoryEntry instance)
	{
		if (instance.ShouldPool)
		{
			instance.phoneNumber = 0;
			instance.phoneName = string.Empty;
			Pool.Free<DirectoryEntry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose DirectoryEntry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(DirectoryEntry instance)
	{
		instance.phoneNumber = phoneNumber;
		instance.phoneName = phoneName;
	}

	public DirectoryEntry Copy()
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		CopyTo(directoryEntry);
		return directoryEntry;
	}

	public static DirectoryEntry Deserialize(Stream stream)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		Deserialize(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry DeserializeLengthDelimited(Stream stream)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		DeserializeLengthDelimited(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry DeserializeLength(Stream stream, int length)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		DeserializeLength(stream, length, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public static DirectoryEntry Deserialize(byte[] buffer)
	{
		DirectoryEntry directoryEntry = Pool.Get<DirectoryEntry>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, directoryEntry, isDelta: false);
		return directoryEntry;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, DirectoryEntry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static DirectoryEntry Deserialize(byte[] buffer, DirectoryEntry instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static DirectoryEntry Deserialize(Stream stream, DirectoryEntry instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static DirectoryEntry DeserializeLengthDelimited(Stream stream, DirectoryEntry instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static DirectoryEntry DeserializeLength(Stream stream, int length, DirectoryEntry instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.phoneNumber = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.phoneName = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, DirectoryEntry instance, DirectoryEntry previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.phoneNumber != previous.phoneNumber)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.phoneName != previous.phoneName)
		{
			if (instance.phoneName == null)
			{
				throw new ArgumentNullException("phoneName", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.phoneName);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, DirectoryEntry instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.phoneNumber != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.phoneNumber);
		}
		if (instance.phoneName == null)
		{
			throw new ArgumentNullException("phoneName", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.phoneName);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(DirectoryEntry instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, DirectoryEntry instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum Category
{
	Line,
	Log,
	Text,
	Sphere,
	Box
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Monument : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public string token;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Monument instance)
	{
		if (instance.ShouldPool)
		{
			instance.token = string.Empty;
			instance.x = 0f;
			instance.y = 0f;
			Pool.Free<Monument>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Monument with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Monument instance)
	{
		instance.token = token;
		instance.x = x;
		instance.y = y;
	}

	public Monument Copy()
	{
		Monument monument = Pool.Get<Monument>();
		CopyTo(monument);
		return monument;
	}

	public static Monument Deserialize(Stream stream)
	{
		Monument monument = Pool.Get<Monument>();
		Deserialize(stream, monument, isDelta: false);
		return monument;
	}

	public static Monument DeserializeLengthDelimited(Stream stream)
	{
		Monument monument = Pool.Get<Monument>();
		DeserializeLengthDelimited(stream, monument, isDelta: false);
		return monument;
	}

	public static Monument DeserializeLength(Stream stream, int length)
	{
		Monument monument = Pool.Get<Monument>();
		DeserializeLength(stream, length, monument, isDelta: false);
		return monument;
	}

	public static Monument Deserialize(byte[] buffer)
	{
		Monument monument = Pool.Get<Monument>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, monument, isDelta: false);
		return monument;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Monument previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Monument Deserialize(byte[] buffer, Monument instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Monument Deserialize(Stream stream, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Monument DeserializeLengthDelimited(Stream stream, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Monument DeserializeLength(Stream stream, int length, Monument instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.x = 0f;
			instance.y = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.token = ProtocolParser.ReadString(stream);
				continue;
			case 21:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 29:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Monument instance, Monument previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.token != previous.token)
		{
			if (instance.token == null)
			{
				throw new ArgumentNullException("token", "Required by proto specification.");
			}
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.token);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Monument instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.token == null)
		{
			throw new ArgumentNullException("token", "Required by proto specification.");
		}
		stream.WriteByte(10);
		ProtocolParser.WriteString(stream, instance.token);
		if (instance.x != 0f)
		{
			stream.WriteByte(21);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Monument instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Monument instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Item : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int quantity;

	[NonSerialized]
	public bool itemIsBlueprint;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Item instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
			Pool.Free<Item>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Item with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Item instance)
	{
		instance.itemId = itemId;
		instance.quantity = quantity;
		instance.itemIsBlueprint = itemIsBlueprint;
	}

	public Item Copy()
	{
		Item item = Pool.Get<Item>();
		CopyTo(item);
		return item;
	}

	public static Item Deserialize(Stream stream)
	{
		Item item = Pool.Get<Item>();
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLengthDelimited(Stream stream)
	{
		Item item = Pool.Get<Item>();
		DeserializeLengthDelimited(stream, item, isDelta: false);
		return item;
	}

	public static Item DeserializeLength(Stream stream, int length)
	{
		Item item = Pool.Get<Item>();
		DeserializeLength(stream, length, item, isDelta: false);
		return item;
	}

	public static Item Deserialize(byte[] buffer)
	{
		Item item = Pool.Get<Item>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, item, isDelta: false);
		return item;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Item previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Item Deserialize(byte[] buffer, Item instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Item Deserialize(Stream stream, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Item DeserializeLengthDelimited(Stream stream, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Item DeserializeLength(Stream stream, int length, Item instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.itemIsBlueprint = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Item instance, Item previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != previous.quantity)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Item instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.itemIsBlueprint)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Item instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Item instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Member : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public bool isOnline;

	[NonSerialized]
	public uint spawnTime;

	[NonSerialized]
	public bool isAlive;

	[NonSerialized]
	public uint deathTime;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Member instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.name = string.Empty;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
			Pool.Free<Member>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Member with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Member instance)
	{
		instance.steamId = steamId;
		instance.name = name;
		instance.x = x;
		instance.y = y;
		instance.isOnline = isOnline;
		instance.spawnTime = spawnTime;
		instance.isAlive = isAlive;
		instance.deathTime = deathTime;
	}

	public Member Copy()
	{
		Member member = Pool.Get<Member>();
		CopyTo(member);
		return member;
	}

	public static Member Deserialize(Stream stream)
	{
		Member member = Pool.Get<Member>();
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLengthDelimited(Stream stream)
	{
		Member member = Pool.Get<Member>();
		DeserializeLengthDelimited(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLength(Stream stream, int length)
	{
		Member member = Pool.Get<Member>();
		DeserializeLength(stream, length, member, isDelta: false);
		return member;
	}

	public static Member Deserialize(byte[] buffer)
	{
		Member member = Pool.Get<Member>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Member previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Member Deserialize(byte[] buffer, Member instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Member Deserialize(Stream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Member DeserializeLengthDelimited(Stream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Member DeserializeLength(Stream stream, int length, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.x = 0f;
			instance.y = 0f;
			instance.isOnline = false;
			instance.spawnTime = 0u;
			instance.isAlive = false;
			instance.deathTime = 0u;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.isOnline = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.spawnTime = ProtocolParser.ReadUInt32(stream);
				continue;
			case 56:
				instance.isAlive = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.deathTime = ProtocolParser.ReadUInt32(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Member instance, Member previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.isOnline);
		if (instance.spawnTime != previous.spawnTime)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.spawnTime);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.isAlive);
		if (instance.deathTime != previous.deathTime)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deathTime);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Member instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.isOnline)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.isOnline);
		}
		if (instance.spawnTime != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt32(stream, instance.spawnTime);
		}
		if (instance.isAlive)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.isAlive);
		}
		if (instance.deathTime != 0)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteUInt32(stream, instance.deathTime);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Member instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Member instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Note : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int type;

	[NonSerialized]
	public float x;

	[NonSerialized]
	public float y;

	[NonSerialized]
	public int icon;

	[NonSerialized]
	public int colourIndex;

	[NonSerialized]
	public string label;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Note instance)
	{
		if (instance.ShouldPool)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
			instance.label = string.Empty;
			Pool.Free<Note>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Note with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Note instance)
	{
		instance.type = type;
		instance.x = x;
		instance.y = y;
		instance.icon = icon;
		instance.colourIndex = colourIndex;
		instance.label = label;
	}

	public Note Copy()
	{
		Note note = Pool.Get<Note>();
		CopyTo(note);
		return note;
	}

	public static Note Deserialize(Stream stream)
	{
		Note note = Pool.Get<Note>();
		Deserialize(stream, note, isDelta: false);
		return note;
	}

	public static Note DeserializeLengthDelimited(Stream stream)
	{
		Note note = Pool.Get<Note>();
		DeserializeLengthDelimited(stream, note, isDelta: false);
		return note;
	}

	public static Note DeserializeLength(Stream stream, int length)
	{
		Note note = Pool.Get<Note>();
		DeserializeLength(stream, length, note, isDelta: false);
		return note;
	}

	public static Note Deserialize(byte[] buffer)
	{
		Note note = Pool.Get<Note>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, note, isDelta: false);
		return note;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Note previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Note Deserialize(byte[] buffer, Note instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Note Deserialize(Stream stream, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Note DeserializeLengthDelimited(Stream stream, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Note DeserializeLength(Stream stream, int length, Note instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.type = 0;
			instance.x = 0f;
			instance.y = 0f;
			instance.icon = 0;
			instance.colourIndex = 0;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 29:
				instance.x = ProtocolParser.ReadSingle(stream);
				continue;
			case 37:
				instance.y = ProtocolParser.ReadSingle(stream);
				continue;
			case 40:
				instance.icon = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.colourIndex = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 58:
				instance.label = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Note instance, Note previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.x != previous.x)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != previous.y)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.icon != previous.icon)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != previous.colourIndex)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null && instance.label != previous.label)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.label);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Note instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.x != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.x);
		}
		if (instance.y != 0f)
		{
			stream.WriteByte(37);
			ProtocolParser.WriteSingle(stream, instance.y);
		}
		if (instance.icon != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.icon);
		}
		if (instance.colourIndex != 0)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.colourIndex);
		}
		if (instance.label != null)
		{
			stream.WriteByte(58);
			ProtocolParser.WriteString(stream, instance.label);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Note instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Note instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class SellOrder : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int itemId;

	[NonSerialized]
	public int quantity;

	[NonSerialized]
	public int currencyId;

	[NonSerialized]
	public int costPerItem;

	[NonSerialized]
	public int amountInStock;

	[NonSerialized]
	public bool itemIsBlueprint;

	[NonSerialized]
	public bool currencyIsBlueprint;

	[NonSerialized]
	public float itemCondition;

	[NonSerialized]
	public float itemConditionMax;

	[NonSerialized]
	public float priceMultiplier;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(SellOrder instance)
	{
		if (instance.ShouldPool)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
			Pool.Free<SellOrder>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose SellOrder with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(SellOrder instance)
	{
		instance.itemId = itemId;
		instance.quantity = quantity;
		instance.currencyId = currencyId;
		instance.costPerItem = costPerItem;
		instance.amountInStock = amountInStock;
		instance.itemIsBlueprint = itemIsBlueprint;
		instance.currencyIsBlueprint = currencyIsBlueprint;
		instance.itemCondition = itemCondition;
		instance.itemConditionMax = itemConditionMax;
		instance.priceMultiplier = priceMultiplier;
	}

	public SellOrder Copy()
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		CopyTo(sellOrder);
		return sellOrder;
	}

	public static SellOrder Deserialize(Stream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLengthDelimited(Stream stream)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLengthDelimited(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder DeserializeLength(Stream stream, int length)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		DeserializeLength(stream, length, sellOrder, isDelta: false);
		return sellOrder;
	}

	public static SellOrder Deserialize(byte[] buffer)
	{
		SellOrder sellOrder = Pool.Get<SellOrder>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, sellOrder, isDelta: false);
		return sellOrder;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, SellOrder previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static SellOrder Deserialize(byte[] buffer, SellOrder instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static SellOrder Deserialize(Stream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static SellOrder DeserializeLengthDelimited(Stream stream, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static SellOrder DeserializeLength(Stream stream, int length, SellOrder instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.itemId = 0;
			instance.quantity = 0;
			instance.currencyId = 0;
			instance.costPerItem = 0;
			instance.amountInStock = 0;
			instance.itemIsBlueprint = false;
			instance.currencyIsBlueprint = false;
			instance.itemCondition = 0f;
			instance.itemConditionMax = 0f;
			instance.priceMultiplier = 0f;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.itemId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.quantity = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.currencyId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.costPerItem = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.amountInStock = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.itemIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.currencyIsBlueprint = ProtocolParser.ReadBool(stream);
				continue;
			case 69:
				instance.itemCondition = ProtocolParser.ReadSingle(stream);
				continue;
			case 77:
				instance.itemConditionMax = ProtocolParser.ReadSingle(stream);
				continue;
			case 85:
				instance.priceMultiplier = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, SellOrder instance, SellOrder previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemId != previous.itemId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != previous.quantity)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.currencyId != previous.currencyId)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
		}
		if (instance.costPerItem != previous.costPerItem)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
		}
		if (instance.amountInStock != previous.amountInStock)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
		if (instance.itemCondition != previous.itemCondition)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != previous.itemConditionMax)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.priceMultiplier != previous.priceMultiplier)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, SellOrder instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.itemId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.itemId);
		}
		if (instance.quantity != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.quantity);
		}
		if (instance.currencyId != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.currencyId);
		}
		if (instance.costPerItem != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.costPerItem);
		}
		if (instance.amountInStock != 0)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.amountInStock);
		}
		if (instance.itemIsBlueprint)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.itemIsBlueprint);
		}
		if (instance.currencyIsBlueprint)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.currencyIsBlueprint);
		}
		if (instance.itemCondition != 0f)
		{
			stream.WriteByte(69);
			ProtocolParser.WriteSingle(stream, instance.itemCondition);
		}
		if (instance.itemConditionMax != 0f)
		{
			stream.WriteByte(77);
			ProtocolParser.WriteSingle(stream, instance.itemConditionMax);
		}
		if (instance.priceMultiplier != 0f)
		{
			stream.WriteByte(85);
			ProtocolParser.WriteSingle(stream, instance.priceMultiplier);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(SellOrder instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, SellOrder instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum EntityType
{
	Tree = 1,
	Player
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class Entity : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public NetworkableId entityId;

	[NonSerialized]
	public EntityType type;

	[NonSerialized]
	public Vector3 position;

	[NonSerialized]
	public Vector3 rotation;

	[NonSerialized]
	public Vector3 size;

	[NonSerialized]
	public string name;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entity instance)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.entityId = default(NetworkableId);
			instance.type = (EntityType)0;
			instance.position = default(Vector3);
			instance.rotation = default(Vector3);
			instance.size = default(Vector3);
			instance.name = string.Empty;
			Pool.Free<Entity>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entity with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entity instance)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		instance.entityId = entityId;
		instance.type = type;
		instance.position = position;
		instance.rotation = rotation;
		instance.size = size;
		instance.name = name;
	}

	public Entity Copy()
	{
		Entity entity = Pool.Get<Entity>();
		CopyTo(entity);
		return entity;
	}

	public static Entity Deserialize(Stream stream)
	{
		Entity entity = Pool.Get<Entity>();
		Deserialize(stream, entity, isDelta: false);
		return entity;
	}

	public static Entity DeserializeLengthDelimited(Stream stream)
	{
		Entity entity = Pool.Get<Entity>();
		DeserializeLengthDelimited(stream, entity, isDelta: false);
		return entity;
	}

	public static Entity DeserializeLength(Stream stream, int length)
	{
		Entity entity = Pool.Get<Entity>();
		DeserializeLength(stream, length, entity, isDelta: false);
		return entity;
	}

	public static Entity Deserialize(byte[] buffer)
	{
		Entity entity = Pool.Get<Entity>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, entity, isDelta: false);
		return entity;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Entity previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entity Deserialize(byte[] buffer, Entity instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Entity Deserialize(Stream stream, Entity instance, bool isDelta)
	{
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entity DeserializeLengthDelimited(Stream stream, Entity instance, bool isDelta)
	{
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entity DeserializeLength(Stream stream, int length, Entity instance, bool isDelta)
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.entityId = new NetworkableId(ProtocolParser.ReadUInt64(stream));
				continue;
			case 16:
				instance.type = (EntityType)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.position, isDelta);
				continue;
			case 34:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.rotation, isDelta);
				continue;
			case 42:
				Vector3Serialized.DeserializeLengthDelimited(stream, ref instance.size, isDelta);
				continue;
			case 50:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Entity instance, Entity previous)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.position != previous.position)
		{
			stream.WriteByte(26);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.position, previous.position);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.rotation != previous.rotation)
		{
			stream.WriteByte(34);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.rotation, previous.rotation);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		if (instance.size != previous.size)
		{
			stream.WriteByte(42);
			memoryStream.SetLength(0L);
			Vector3Serialized.SerializeDelta(memoryStream, instance.size, previous.size);
			uint num3 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num3);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num3);
		}
		if (instance.name != null && instance.name != previous.name)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.name);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Entity instance)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.entityId != default(NetworkableId))
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.entityId.Value);
		}
		stream.WriteByte(16);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		if (instance.position != default(Vector3))
		{
			stream.WriteByte(26);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.position);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.rotation != default(Vector3))
		{
			stream.WriteByte(34);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.rotation);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		if (instance.size != default(Vector3))
		{
			stream.WriteByte(42);
			memoryStream.SetLength(0L);
			Vector3Serialized.Serialize(memoryStream, instance.size);
			uint num3 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num3);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num3);
		}
		if (instance.name != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.name);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Entity instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Entity instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		action(UidType.NetworkableId, ref entityId.Value);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Role : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public int roleId;

	[NonSerialized]
	public int rank;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public bool canSetMotd;

	[NonSerialized]
	public bool canSetLogo;

	[NonSerialized]
	public bool canInvite;

	[NonSerialized]
	public bool canKick;

	[NonSerialized]
	public bool canPromote;

	[NonSerialized]
	public bool canDemote;

	[NonSerialized]
	public bool canSetPlayerNotes;

	[NonSerialized]
	public bool canAccessLogs;

	[NonSerialized]
	public bool canAccessScoreEvents;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Role instance)
	{
		if (instance.ShouldPool)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.name = string.Empty;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
			Pool.Free<Role>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Role with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Role instance)
	{
		instance.roleId = roleId;
		instance.rank = rank;
		instance.name = name;
		instance.canSetMotd = canSetMotd;
		instance.canSetLogo = canSetLogo;
		instance.canInvite = canInvite;
		instance.canKick = canKick;
		instance.canPromote = canPromote;
		instance.canDemote = canDemote;
		instance.canSetPlayerNotes = canSetPlayerNotes;
		instance.canAccessLogs = canAccessLogs;
		instance.canAccessScoreEvents = canAccessScoreEvents;
	}

	public Role Copy()
	{
		Role role = Pool.Get<Role>();
		CopyTo(role);
		return role;
	}

	public static Role Deserialize(Stream stream)
	{
		Role role = Pool.Get<Role>();
		Deserialize(stream, role, isDelta: false);
		return role;
	}

	public static Role DeserializeLengthDelimited(Stream stream)
	{
		Role role = Pool.Get<Role>();
		DeserializeLengthDelimited(stream, role, isDelta: false);
		return role;
	}

	public static Role DeserializeLength(Stream stream, int length)
	{
		Role role = Pool.Get<Role>();
		DeserializeLength(stream, length, role, isDelta: false);
		return role;
	}

	public static Role Deserialize(byte[] buffer)
	{
		Role role = Pool.Get<Role>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, role, isDelta: false);
		return role;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Role previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Role Deserialize(byte[] buffer, Role instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Role Deserialize(Stream stream, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Role DeserializeLengthDelimited(Stream stream, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Role DeserializeLength(Stream stream, int length, Role instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.roleId = 0;
			instance.rank = 0;
			instance.canSetMotd = false;
			instance.canSetLogo = false;
			instance.canInvite = false;
			instance.canKick = false;
			instance.canPromote = false;
			instance.canDemote = false;
			instance.canSetPlayerNotes = false;
			instance.canAccessLogs = false;
			instance.canAccessScoreEvents = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.rank = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 32:
				instance.canSetMotd = ProtocolParser.ReadBool(stream);
				continue;
			case 40:
				instance.canSetLogo = ProtocolParser.ReadBool(stream);
				continue;
			case 48:
				instance.canInvite = ProtocolParser.ReadBool(stream);
				continue;
			case 56:
				instance.canKick = ProtocolParser.ReadBool(stream);
				continue;
			case 64:
				instance.canPromote = ProtocolParser.ReadBool(stream);
				continue;
			case 72:
				instance.canDemote = ProtocolParser.ReadBool(stream);
				continue;
			case 80:
				instance.canSetPlayerNotes = ProtocolParser.ReadBool(stream);
				continue;
			case 88:
				instance.canAccessLogs = ProtocolParser.ReadBool(stream);
				continue;
			case 96:
				instance.canAccessScoreEvents = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Role instance, Role previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.roleId != previous.roleId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.rank != previous.rank)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(32);
		ProtocolParser.WriteBool(stream, instance.canSetMotd);
		stream.WriteByte(40);
		ProtocolParser.WriteBool(stream, instance.canSetLogo);
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.canInvite);
		stream.WriteByte(56);
		ProtocolParser.WriteBool(stream, instance.canKick);
		stream.WriteByte(64);
		ProtocolParser.WriteBool(stream, instance.canPromote);
		stream.WriteByte(72);
		ProtocolParser.WriteBool(stream, instance.canDemote);
		stream.WriteByte(80);
		ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
		stream.WriteByte(88);
		ProtocolParser.WriteBool(stream, instance.canAccessLogs);
		stream.WriteByte(96);
		ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Role instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.roleId != 0)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.rank != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.rank);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.canSetMotd)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteBool(stream, instance.canSetMotd);
		}
		if (instance.canSetLogo)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteBool(stream, instance.canSetLogo);
		}
		if (instance.canInvite)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.canInvite);
		}
		if (instance.canKick)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteBool(stream, instance.canKick);
		}
		if (instance.canPromote)
		{
			stream.WriteByte(64);
			ProtocolParser.WriteBool(stream, instance.canPromote);
		}
		if (instance.canDemote)
		{
			stream.WriteByte(72);
			ProtocolParser.WriteBool(stream, instance.canDemote);
		}
		if (instance.canSetPlayerNotes)
		{
			stream.WriteByte(80);
			ProtocolParser.WriteBool(stream, instance.canSetPlayerNotes);
		}
		if (instance.canAccessLogs)
		{
			stream.WriteByte(88);
			ProtocolParser.WriteBool(stream, instance.canAccessLogs);
		}
		if (instance.canAccessScoreEvents)
		{
			stream.WriteByte(96);
			ProtocolParser.WriteBool(stream, instance.canAccessScoreEvents);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Role instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Role instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Member : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public int roleId;

	[NonSerialized]
	public long joined;

	[NonSerialized]
	public long lastSeen;

	[NonSerialized]
	public string notes;

	[NonSerialized]
	public bool online;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Member instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.notes = string.Empty;
			instance.online = false;
			Pool.Free<Member>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Member with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Member instance)
	{
		instance.steamId = steamId;
		instance.roleId = roleId;
		instance.joined = joined;
		instance.lastSeen = lastSeen;
		instance.notes = notes;
		instance.online = online;
	}

	public Member Copy()
	{
		Member member = Pool.Get<Member>();
		CopyTo(member);
		return member;
	}

	public static Member Deserialize(Stream stream)
	{
		Member member = Pool.Get<Member>();
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLengthDelimited(Stream stream)
	{
		Member member = Pool.Get<Member>();
		DeserializeLengthDelimited(stream, member, isDelta: false);
		return member;
	}

	public static Member DeserializeLength(Stream stream, int length)
	{
		Member member = Pool.Get<Member>();
		DeserializeLength(stream, length, member, isDelta: false);
		return member;
	}

	public static Member Deserialize(byte[] buffer)
	{
		Member member = Pool.Get<Member>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, member, isDelta: false);
		return member;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Member previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Member Deserialize(byte[] buffer, Member instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Member Deserialize(Stream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Member DeserializeLengthDelimited(Stream stream, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Member DeserializeLength(Stream stream, int length, Member instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.roleId = 0;
			instance.joined = 0L;
			instance.lastSeen = 0L;
			instance.online = false;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.roleId = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.joined = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.lastSeen = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 42:
				instance.notes = ProtocolParser.ReadString(stream);
				continue;
			case 48:
				instance.online = ProtocolParser.ReadBool(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Member instance, Member previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.roleId != previous.roleId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
		stream.WriteByte(32);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
		if (instance.notes != null && instance.notes != previous.notes)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		stream.WriteByte(48);
		ProtocolParser.WriteBool(stream, instance.online);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Member instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.roleId != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.roleId);
		}
		if (instance.joined != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.joined);
		}
		if (instance.lastSeen != 0L)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.lastSeen);
		}
		if (instance.notes != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.notes);
		}
		if (instance.online)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteBool(stream, instance.online);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Member instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Member instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Invite : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public ulong recruiter;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Invite instance)
	{
		if (instance.ShouldPool)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Invite>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Invite with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Invite instance)
	{
		instance.steamId = steamId;
		instance.recruiter = recruiter;
		instance.timestamp = timestamp;
	}

	public Invite Copy()
	{
		Invite invite = Pool.Get<Invite>();
		CopyTo(invite);
		return invite;
	}

	public static Invite Deserialize(Stream stream)
	{
		Invite invite = Pool.Get<Invite>();
		Deserialize(stream, invite, isDelta: false);
		return invite;
	}

	public static Invite DeserializeLengthDelimited(Stream stream)
	{
		Invite invite = Pool.Get<Invite>();
		DeserializeLengthDelimited(stream, invite, isDelta: false);
		return invite;
	}

	public static Invite DeserializeLength(Stream stream, int length)
	{
		Invite invite = Pool.Get<Invite>();
		DeserializeLength(stream, length, invite, isDelta: false);
		return invite;
	}

	public static Invite Deserialize(byte[] buffer)
	{
		Invite invite = Pool.Get<Invite>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, invite, isDelta: false);
		return invite;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Invite previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Invite Deserialize(byte[] buffer, Invite instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Invite Deserialize(Stream stream, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Invite DeserializeLengthDelimited(Stream stream, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Invite DeserializeLength(Stream stream, int length, Invite instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.steamId = 0uL;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Invite instance, Invite previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.recruiter != previous.recruiter)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Invite instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.steamId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.recruiter != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Invite instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Invite instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public string eventKey;

	[NonSerialized]
	public string arg1;

	[NonSerialized]
	public string arg2;

	[NonSerialized]
	public string arg3;

	[NonSerialized]
	public string arg4;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.eventKey = string.Empty;
			instance.arg1 = string.Empty;
			instance.arg2 = string.Empty;
			instance.arg3 = string.Empty;
			instance.arg4 = string.Empty;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.timestamp = timestamp;
		instance.eventKey = eventKey;
		instance.arg1 = arg1;
		instance.arg2 = arg2;
		instance.arg3 = arg3;
		instance.arg4 = arg4;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(Stream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(Stream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(Stream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(byte[] buffer, Entry instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Entry Deserialize(Stream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(Stream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(Stream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.eventKey = ProtocolParser.ReadString(stream);
				continue;
			case 26:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case 42:
				instance.arg3 = ProtocolParser.ReadString(stream);
				continue;
			case 50:
				instance.arg4 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Entry instance, Entry previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.eventKey != previous.eventKey)
		{
			if (instance.eventKey == null)
			{
				throw new ArgumentNullException("eventKey", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.eventKey);
		}
		if (instance.arg1 != null && instance.arg1 != previous.arg1)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null && instance.arg2 != previous.arg2)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		if (instance.arg3 != null && instance.arg3 != previous.arg3)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.arg3);
		}
		if (instance.arg4 != null && instance.arg4 != previous.arg4)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.arg4);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Entry instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.eventKey == null)
		{
			throw new ArgumentNullException("eventKey", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.eventKey);
		if (instance.arg1 != null)
		{
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null)
		{
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		if (instance.arg3 != null)
		{
			stream.WriteByte(42);
			ProtocolParser.WriteString(stream, instance.arg3);
		}
		if (instance.arg4 != null)
		{
			stream.WriteByte(50);
			ProtocolParser.WriteString(stream, instance.arg4);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Entry instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Entry instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public long timestamp;

	[NonSerialized]
	public int type;

	[NonSerialized]
	public int score;

	[NonSerialized]
	public int multiplier;

	[NonSerialized]
	public ulong steamId;

	[NonSerialized]
	public ulong otherSteamId;

	[NonSerialized]
	public long otherClanId;

	[NonSerialized]
	public string arg1;

	[NonSerialized]
	public string arg2;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
			instance.arg1 = string.Empty;
			instance.arg2 = string.Empty;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.timestamp = timestamp;
		instance.type = type;
		instance.score = score;
		instance.multiplier = multiplier;
		instance.steamId = steamId;
		instance.otherSteamId = otherSteamId;
		instance.otherClanId = otherClanId;
		instance.arg1 = arg1;
		instance.arg2 = arg2;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(Stream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(Stream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(Stream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(byte[] buffer, Entry instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Entry Deserialize(Stream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(Stream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(Stream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.timestamp = 0L;
			instance.type = 0;
			instance.score = 0;
			instance.multiplier = 0;
			instance.steamId = 0uL;
			instance.otherSteamId = 0uL;
			instance.otherClanId = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.type = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.score = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 32:
				instance.multiplier = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 40:
				instance.steamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 48:
				instance.otherSteamId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 56:
				instance.otherClanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 66:
				instance.arg1 = ProtocolParser.ReadString(stream);
				continue;
			case 74:
				instance.arg2 = ProtocolParser.ReadString(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Entry instance, Entry previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		if (instance.type != previous.type)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.score != previous.score)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		if (instance.multiplier != previous.multiplier)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
		if (instance.steamId != previous.steamId)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.otherSteamId != previous.otherSteamId)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
		}
		stream.WriteByte(56);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
		if (instance.arg1 != null && instance.arg1 != previous.arg1)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null && instance.arg2 != previous.arg2)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Entry instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		if (instance.type != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.type);
		}
		if (instance.score != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		if (instance.multiplier != 0)
		{
			stream.WriteByte(32);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.multiplier);
		}
		if (instance.steamId != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, instance.steamId);
		}
		if (instance.otherSteamId != 0L)
		{
			stream.WriteByte(48);
			ProtocolParser.WriteUInt64(stream, instance.otherSteamId);
		}
		if (instance.otherClanId != 0L)
		{
			stream.WriteByte(56);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.otherClanId);
		}
		if (instance.arg1 != null)
		{
			stream.WriteByte(66);
			ProtocolParser.WriteString(stream, instance.arg1);
		}
		if (instance.arg2 != null)
		{
			stream.WriteByte(74);
			ProtocolParser.WriteString(stream, instance.arg2);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Entry instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Entry instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Invitation : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ulong recruiter;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Invitation instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
			Pool.Free<Invitation>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Invitation with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Invitation instance)
	{
		instance.clanId = clanId;
		instance.recruiter = recruiter;
		instance.timestamp = timestamp;
	}

	public Invitation Copy()
	{
		Invitation invitation = Pool.Get<Invitation>();
		CopyTo(invitation);
		return invitation;
	}

	public static Invitation Deserialize(Stream stream)
	{
		Invitation invitation = Pool.Get<Invitation>();
		Deserialize(stream, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation DeserializeLengthDelimited(Stream stream)
	{
		Invitation invitation = Pool.Get<Invitation>();
		DeserializeLengthDelimited(stream, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation DeserializeLength(Stream stream, int length)
	{
		Invitation invitation = Pool.Get<Invitation>();
		DeserializeLength(stream, length, invitation, isDelta: false);
		return invitation;
	}

	public static Invitation Deserialize(byte[] buffer)
	{
		Invitation invitation = Pool.Get<Invitation>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, invitation, isDelta: false);
		return invitation;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Invitation previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Invitation Deserialize(byte[] buffer, Invitation instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Invitation Deserialize(Stream stream, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Invitation DeserializeLengthDelimited(Stream stream, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Invitation DeserializeLength(Stream stream, int length, Invitation instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.recruiter = 0uL;
			instance.timestamp = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.recruiter = ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Invitation instance, Invitation previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.recruiter != previous.recruiter)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Invitation instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.recruiter != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.recruiter);
		}
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Invitation instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Invitation instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Entry : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long score;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Entry instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.name = string.Empty;
			instance.score = 0L;
			Pool.Free<Entry>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Entry with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Entry instance)
	{
		instance.clanId = clanId;
		instance.name = name;
		instance.score = score;
	}

	public Entry Copy()
	{
		Entry entry = Pool.Get<Entry>();
		CopyTo(entry);
		return entry;
	}

	public static Entry Deserialize(Stream stream)
	{
		Entry entry = Pool.Get<Entry>();
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLengthDelimited(Stream stream)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLengthDelimited(stream, entry, isDelta: false);
		return entry;
	}

	public static Entry DeserializeLength(Stream stream, int length)
	{
		Entry entry = Pool.Get<Entry>();
		DeserializeLength(stream, length, entry, isDelta: false);
		return entry;
	}

	public static Entry Deserialize(byte[] buffer)
	{
		Entry entry = Pool.Get<Entry>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, entry, isDelta: false);
		return entry;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Entry previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Entry Deserialize(byte[] buffer, Entry instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Entry Deserialize(Stream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Entry DeserializeLengthDelimited(Stream stream, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Entry DeserializeLength(Stream stream, int length, Entry instance, bool isDelta)
	{
		if (!isDelta)
		{
			instance.clanId = 0L;
			instance.score = 0L;
		}
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 18:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 24:
				instance.score = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Entry instance, Entry previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(24);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Entry instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(18);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.score != 0L)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.score);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Entry instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Entry instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.Buffers;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class RelationshipData : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public RelationshipManager.PlayerRelationshipInfo info;

	[NonSerialized]
	public ArraySegment<byte> mugshotData;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(RelationshipData instance)
	{
		if (instance.ShouldPool)
		{
			if (instance.info != null)
			{
				instance.info.ResetToPool();
				instance.info = null;
			}
			if (instance.mugshotData.Array != null)
			{
				ArrayPool<byte>.Shared.Return(instance.mugshotData.Array);
			}
			instance.mugshotData = default(ArraySegment<byte>);
			Pool.Free<RelationshipData>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose RelationshipData with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(RelationshipData instance)
	{
		if (info != null)
		{
			if (instance.info == null)
			{
				instance.info = info.Copy();
			}
			else
			{
				info.CopyTo(instance.info);
			}
		}
		else
		{
			instance.info = null;
		}
		if (mugshotData.Array == null)
		{
			instance.mugshotData = default(ArraySegment<byte>);
			return;
		}
		byte[] array = ArrayPool<byte>.Shared.Rent(mugshotData.Count);
		Array.Copy(mugshotData.Array, 0, array, 0, mugshotData.Count);
		instance.mugshotData = new ArraySegment<byte>(array, 0, mugshotData.Count);
	}

	public RelationshipData Copy()
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		CopyTo(relationshipData);
		return relationshipData;
	}

	public static RelationshipData Deserialize(Stream stream)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		Deserialize(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData DeserializeLengthDelimited(Stream stream)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		DeserializeLengthDelimited(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData DeserializeLength(Stream stream, int length)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		DeserializeLength(stream, length, relationshipData, isDelta: false);
		return relationshipData;
	}

	public static RelationshipData Deserialize(byte[] buffer)
	{
		RelationshipData relationshipData = Pool.Get<RelationshipData>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, relationshipData, isDelta: false);
		return relationshipData;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, RelationshipData previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static RelationshipData Deserialize(byte[] buffer, RelationshipData instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static RelationshipData Deserialize(Stream stream, RelationshipData instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static RelationshipData DeserializeLengthDelimited(Stream stream, RelationshipData instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static RelationshipData DeserializeLength(Stream stream, int length, RelationshipData instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				if (instance.info == null)
				{
					instance.info = RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream);
				}
				else
				{
					RelationshipManager.PlayerRelationshipInfo.DeserializeLengthDelimited(stream, instance.info, isDelta);
				}
				continue;
			case 18:
				instance.mugshotData = ProtocolParser.ReadPooledBytes(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, RelationshipData instance, RelationshipData previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.info == null)
		{
			throw new ArgumentNullException("info", "Required by proto specification.");
		}
		stream.WriteByte(10);
		memoryStream.SetLength(0L);
		RelationshipManager.PlayerRelationshipInfo.SerializeDelta(memoryStream, instance.info, previous.info);
		uint num = (uint)memoryStream.Length;
		ProtocolParser.WriteUInt32(stream, num);
		stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		if (instance.mugshotData.Array != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, RelationshipData instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.info == null)
		{
			throw new ArgumentNullException("info", "Required by proto specification.");
		}
		stream.WriteByte(10);
		memoryStream.SetLength(0L);
		RelationshipManager.PlayerRelationshipInfo.Serialize(memoryStream, instance.info);
		uint num = (uint)memoryStream.Length;
		ProtocolParser.WriteUInt32(stream, num);
		stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		if (instance.mugshotData.Array != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WritePooledBytes(stream, instance.mugshotData);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(RelationshipData instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, RelationshipData instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
		info?.InspectUids(action);
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Message : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public long clanId;

	[NonSerialized]
	public ulong userId;

	[NonSerialized]
	public string text;

	[NonSerialized]
	public string name;

	[NonSerialized]
	public long timestamp;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Message instance)
	{
		if (instance.ShouldPool)
		{
			instance.clanId = 0L;
			instance.userId = 0uL;
			instance.text = string.Empty;
			instance.name = string.Empty;
			instance.timestamp = 0L;
			Pool.Free<Message>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Message with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Message instance)
	{
		instance.clanId = clanId;
		instance.userId = userId;
		instance.text = text;
		instance.name = name;
		instance.timestamp = timestamp;
	}

	public Message Copy()
	{
		Message message = Pool.Get<Message>();
		CopyTo(message);
		return message;
	}

	public static Message Deserialize(Stream stream)
	{
		Message message = Pool.Get<Message>();
		Deserialize(stream, message, isDelta: false);
		return message;
	}

	public static Message DeserializeLengthDelimited(Stream stream)
	{
		Message message = Pool.Get<Message>();
		DeserializeLengthDelimited(stream, message, isDelta: false);
		return message;
	}

	public static Message DeserializeLength(Stream stream, int length)
	{
		Message message = Pool.Get<Message>();
		DeserializeLength(stream, length, message, isDelta: false);
		return message;
	}

	public static Message Deserialize(byte[] buffer)
	{
		Message message = Pool.Get<Message>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, message, isDelta: false);
		return message;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Message previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Message Deserialize(byte[] buffer, Message instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Message Deserialize(Stream stream, Message instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Message DeserializeLengthDelimited(Stream stream, Message instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Message DeserializeLength(Stream stream, int length, Message instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.clanId = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.userId = ProtocolParser.ReadUInt64(stream);
				continue;
			case 26:
				instance.text = ProtocolParser.ReadString(stream);
				continue;
			case 34:
				instance.name = ProtocolParser.ReadString(stream);
				continue;
			case 40:
				instance.timestamp = (long)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Message instance, Message previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		stream.WriteByte(8);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		if (instance.userId != previous.userId)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.text != previous.text)
		{
			if (instance.text == null)
			{
				throw new ArgumentNullException("text", "Required by proto specification.");
			}
			stream.WriteByte(26);
			ProtocolParser.WriteString(stream, instance.text);
		}
		if (instance.name != previous.name)
		{
			if (instance.name == null)
			{
				throw new ArgumentNullException("name", "Required by proto specification.");
			}
			stream.WriteByte(34);
			ProtocolParser.WriteString(stream, instance.name);
		}
		stream.WriteByte(40);
		ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Message instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.clanId != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.clanId);
		}
		if (instance.userId != 0L)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, instance.userId);
		}
		if (instance.text == null)
		{
			throw new ArgumentNullException("text", "Required by proto specification.");
		}
		stream.WriteByte(26);
		ProtocolParser.WriteString(stream, instance.text);
		if (instance.name == null)
		{
			throw new ArgumentNullException("name", "Required by proto specification.");
		}
		stream.WriteByte(34);
		ProtocolParser.WriteString(stream, instance.name);
		if (instance.timestamp != 0L)
		{
			stream.WriteByte(40);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.timestamp);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Message instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Message instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LineVec : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public Vector4 vec;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LineVec instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.vec = default(Vector4);
			Pool.Free<LineVec>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LineVec with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LineVec instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		instance.vec = vec;
	}

	public LineVec Copy()
	{
		LineVec lineVec = Pool.Get<LineVec>();
		CopyTo(lineVec);
		return lineVec;
	}

	public static LineVec Deserialize(Stream stream)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		Deserialize(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec DeserializeLengthDelimited(Stream stream)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		DeserializeLengthDelimited(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec DeserializeLength(Stream stream, int length)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		DeserializeLength(stream, length, lineVec, isDelta: false);
		return lineVec;
	}

	public static LineVec Deserialize(byte[] buffer)
	{
		LineVec lineVec = Pool.Get<LineVec>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, lineVec, isDelta: false);
		return lineVec;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, LineVec previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LineVec Deserialize(byte[] buffer, LineVec instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static LineVec Deserialize(Stream stream, LineVec instance, bool isDelta)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LineVec DeserializeLengthDelimited(Stream stream, LineVec instance, bool isDelta)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LineVec DeserializeLength(Stream stream, int length, LineVec instance, bool isDelta)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.vec, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, LineVec instance, LineVec previous)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.vec != previous.vec)
		{
			stream.WriteByte(10);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.vec, previous.vec);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, LineVec instance)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.vec != default(Vector4))
		{
			stream.WriteByte(10);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.vec);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(LineVec instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, LineVec instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class LinePointList : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public Vector4 a;

	[NonSerialized]
	public Vector4 b;

	[NonSerialized]
	public Vector4 c;

	[NonSerialized]
	public Vector4 d;

	[NonSerialized]
	public Vector4 e;

	[NonSerialized]
	public Vector4 f;

	[NonSerialized]
	public Vector4 g;

	[NonSerialized]
	public Vector4 h;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(LinePointList instance)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (instance.ShouldPool)
		{
			instance.a = default(Vector4);
			instance.b = default(Vector4);
			instance.c = default(Vector4);
			instance.d = default(Vector4);
			instance.e = default(Vector4);
			instance.f = default(Vector4);
			instance.g = default(Vector4);
			instance.h = default(Vector4);
			Pool.Free<LinePointList>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose LinePointList with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(LinePointList instance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		instance.a = a;
		instance.b = b;
		instance.c = c;
		instance.d = d;
		instance.e = e;
		instance.f = f;
		instance.g = g;
		instance.h = h;
	}

	public LinePointList Copy()
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		CopyTo(linePointList);
		return linePointList;
	}

	public static LinePointList Deserialize(Stream stream)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		Deserialize(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList DeserializeLengthDelimited(Stream stream)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		DeserializeLengthDelimited(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList DeserializeLength(Stream stream, int length)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		DeserializeLength(stream, length, linePointList, isDelta: false);
		return linePointList;
	}

	public static LinePointList Deserialize(byte[] buffer)
	{
		LinePointList linePointList = Pool.Get<LinePointList>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, linePointList, isDelta: false);
		return linePointList;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, LinePointList previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static LinePointList Deserialize(byte[] buffer, LinePointList instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static LinePointList Deserialize(Stream stream, LinePointList instance, bool isDelta)
	{
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static LinePointList DeserializeLengthDelimited(Stream stream, LinePointList instance, bool isDelta)
	{
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static LinePointList DeserializeLength(Stream stream, int length, LinePointList instance, bool isDelta)
	{
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.a, isDelta);
				continue;
			case 18:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.b, isDelta);
				continue;
			case 26:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.c, isDelta);
				continue;
			case 34:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.d, isDelta);
				continue;
			case 42:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.e, isDelta);
				continue;
			case 50:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.f, isDelta);
				continue;
			case 58:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.g, isDelta);
				continue;
			case 66:
				Vector4Serialized.DeserializeLengthDelimited(stream, ref instance.h, isDelta);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, LinePointList instance, LinePointList previous)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.a != previous.a)
		{
			stream.WriteByte(10);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.a, previous.a);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.b != previous.b)
		{
			stream.WriteByte(18);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.b, previous.b);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		if (instance.c != previous.c)
		{
			stream.WriteByte(26);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.c, previous.c);
			uint num3 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num3);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num3);
		}
		if (instance.d != previous.d)
		{
			stream.WriteByte(34);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.d, previous.d);
			uint num4 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num4);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num4);
		}
		if (instance.e != previous.e)
		{
			stream.WriteByte(42);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.e, previous.e);
			uint num5 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num5);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num5);
		}
		if (instance.f != previous.f)
		{
			stream.WriteByte(50);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.f, previous.f);
			uint num6 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num6);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num6);
		}
		if (instance.g != previous.g)
		{
			stream.WriteByte(58);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.g, previous.g);
			uint num7 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num7);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num7);
		}
		if (instance.h != previous.h)
		{
			stream.WriteByte(66);
			memoryStream.SetLength(0L);
			Vector4Serialized.SerializeDelta(memoryStream, instance.h, previous.h);
			uint num8 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num8);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num8);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, LinePointList instance)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.a != default(Vector4))
		{
			stream.WriteByte(10);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.a);
			uint num = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num);
		}
		if (instance.b != default(Vector4))
		{
			stream.WriteByte(18);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.b);
			uint num2 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num2);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num2);
		}
		if (instance.c != default(Vector4))
		{
			stream.WriteByte(26);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.c);
			uint num3 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num3);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num3);
		}
		if (instance.d != default(Vector4))
		{
			stream.WriteByte(34);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.d);
			uint num4 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num4);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num4);
		}
		if (instance.e != default(Vector4))
		{
			stream.WriteByte(42);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.e);
			uint num5 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num5);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num5);
		}
		if (instance.f != default(Vector4))
		{
			stream.WriteByte(50);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.f);
			uint num6 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num6);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num6);
		}
		if (instance.g != default(Vector4))
		{
			stream.WriteByte(58);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.g);
			uint num7 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num7);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num7);
		}
		if (instance.h != default(Vector4))
		{
			stream.WriteByte(66);
			memoryStream.SetLength(0L);
			Vector4Serialized.Serialize(memoryStream, instance.h);
			uint num8 = (uint)memoryStream.Length;
			ProtocolParser.WriteUInt32(stream, num8);
			stream.Write(memoryStream.GetBuffer(), 0, (int)num8);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(LinePointList instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, LinePointList instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class PlayerStoredVehicle : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public string shortname;

	[NonSerialized]
	public string resourcePath;

	[NonSerialized]
	public float health;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(PlayerStoredVehicle instance)
	{
		if (instance.ShouldPool)
		{
			instance.shortname = string.Empty;
			instance.resourcePath = string.Empty;
			instance.health = 0f;
			Pool.Free<PlayerStoredVehicle>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose PlayerStoredVehicle with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(PlayerStoredVehicle instance)
	{
		instance.shortname = shortname;
		instance.resourcePath = resourcePath;
		instance.health = health;
	}

	public PlayerStoredVehicle Copy()
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		CopyTo(playerStoredVehicle);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle Deserialize(Stream stream)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		Deserialize(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle DeserializeLengthDelimited(Stream stream)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		DeserializeLengthDelimited(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle DeserializeLength(Stream stream, int length)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		DeserializeLength(stream, length, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public static PlayerStoredVehicle Deserialize(byte[] buffer)
	{
		PlayerStoredVehicle playerStoredVehicle = Pool.Get<PlayerStoredVehicle>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, playerStoredVehicle, isDelta: false);
		return playerStoredVehicle;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, PlayerStoredVehicle previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static PlayerStoredVehicle Deserialize(byte[] buffer, PlayerStoredVehicle instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static PlayerStoredVehicle Deserialize(Stream stream, PlayerStoredVehicle instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static PlayerStoredVehicle DeserializeLengthDelimited(Stream stream, PlayerStoredVehicle instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static PlayerStoredVehicle DeserializeLength(Stream stream, int length, PlayerStoredVehicle instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 10:
				instance.shortname = ProtocolParser.ReadString(stream);
				continue;
			case 18:
				instance.resourcePath = ProtocolParser.ReadString(stream);
				continue;
			case 29:
				instance.health = ProtocolParser.ReadSingle(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, PlayerStoredVehicle instance, PlayerStoredVehicle previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.shortname != null && instance.shortname != previous.shortname)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shortname);
		}
		if (instance.resourcePath != null && instance.resourcePath != previous.resourcePath)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.resourcePath);
		}
		if (instance.health != previous.health)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, PlayerStoredVehicle instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.shortname != null)
		{
			stream.WriteByte(10);
			ProtocolParser.WriteString(stream, instance.shortname);
		}
		if (instance.resourcePath != null)
		{
			stream.WriteByte(18);
			ProtocolParser.WriteString(stream, instance.resourcePath);
		}
		if (instance.health != 0f)
		{
			stream.WriteByte(29);
			ProtocolParser.WriteSingle(stream, instance.health);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(PlayerStoredVehicle instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, PlayerStoredVehicle instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


using System;
using System.IO;
using Facepunch;
using SilentOrbit.ProtocolBuffers;

public class Result : IDisposable, IPooled, IProto
{
	[NonSerialized]
	public ulong ID;

	[NonSerialized]
	public int winnings;

	[NonSerialized]
	public int resultCode;

	public bool ShouldPool = true;

	private bool _disposed;

	public static void ResetToPool(Result instance)
	{
		if (instance.ShouldPool)
		{
			instance.ID = 0uL;
			instance.winnings = 0;
			instance.resultCode = 0;
			Pool.Free<Result>(ref instance);
		}
	}

	public void ResetToPool()
	{
		ResetToPool(this);
	}

	public virtual void Dispose()
	{
		if (!ShouldPool)
		{
			throw new Exception("Trying to dispose Result with ShouldPool set to false!");
		}
		if (!_disposed)
		{
			ResetToPool();
			_disposed = true;
		}
	}

	public virtual void EnterPool()
	{
		_disposed = true;
	}

	public virtual void LeavePool()
	{
		_disposed = false;
	}

	public void CopyTo(Result instance)
	{
		instance.ID = ID;
		instance.winnings = winnings;
		instance.resultCode = resultCode;
	}

	public Result Copy()
	{
		Result result = Pool.Get<Result>();
		CopyTo(result);
		return result;
	}

	public static Result Deserialize(Stream stream)
	{
		Result result = Pool.Get<Result>();
		Deserialize(stream, result, isDelta: false);
		return result;
	}

	public static Result DeserializeLengthDelimited(Stream stream)
	{
		Result result = Pool.Get<Result>();
		DeserializeLengthDelimited(stream, result, isDelta: false);
		return result;
	}

	public static Result DeserializeLength(Stream stream, int length)
	{
		Result result = Pool.Get<Result>();
		DeserializeLength(stream, length, result, isDelta: false);
		return result;
	}

	public static Result Deserialize(byte[] buffer)
	{
		Result result = Pool.Get<Result>();
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, result, isDelta: false);
		return result;
	}

	public void FromProto(Stream stream, bool isDelta = false)
	{
		Deserialize(stream, this, isDelta);
	}

	public virtual void WriteToStream(Stream stream)
	{
		Serialize(stream, this);
	}

	public virtual void WriteToStreamDelta(Stream stream, Result previous)
	{
		if (previous == null)
		{
			Serialize(stream, this);
		}
		else
		{
			SerializeDelta(stream, this, previous);
		}
	}

	public virtual void ReadFromStream(Stream stream, int size, bool isDelta = false)
	{
		DeserializeLength(stream, size, this, isDelta);
	}

	public static Result Deserialize(byte[] buffer, Result instance, bool isDelta = false)
	{
		using MemoryStream stream = new MemoryStream(buffer);
		Deserialize(stream, instance, isDelta);
		return instance;
	}

	public static Result Deserialize(Stream stream, Result instance, bool isDelta)
	{
		while (true)
		{
			int num = stream.ReadByte();
			switch (num)
			{
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case -1:
				return instance;
			}
			Key key = ProtocolParser.ReadKey((byte)num, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
	}

	public static Result DeserializeLengthDelimited(Stream stream, Result instance, bool isDelta)
	{
		long num = ProtocolParser.ReadUInt32(stream);
		num += stream.Position;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static Result DeserializeLength(Stream stream, int length, Result instance, bool isDelta)
	{
		long num = stream.Position + length;
		while (stream.Position < num)
		{
			int num2 = stream.ReadByte();
			switch (num2)
			{
			case -1:
				throw new EndOfStreamException();
			case 8:
				instance.ID = ProtocolParser.ReadUInt64(stream);
				continue;
			case 16:
				instance.winnings = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			case 24:
				instance.resultCode = (int)ProtocolParser.ReadUInt64(stream);
				continue;
			}
			Key key = ProtocolParser.ReadKey((byte)num2, stream);
			if (key.Field == 0)
			{
				throw new ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
			}
			ProtocolParser.SkipKey(stream, key);
		}
		if (stream.Position != num)
		{
			throw new ProtocolBufferException("Read past max limit");
		}
		return instance;
	}

	public static void SerializeDelta(Stream stream, Result instance, Result previous)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.ID != previous.ID)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ID);
		}
		if (instance.winnings != previous.winnings)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
		}
		if (instance.resultCode != previous.resultCode)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public static void Serialize(Stream stream, Result instance)
	{
		MemoryStream memoryStream = Pool.Get<MemoryStream>();
		if (instance.ID != 0L)
		{
			stream.WriteByte(8);
			ProtocolParser.WriteUInt64(stream, instance.ID);
		}
		if (instance.winnings != 0)
		{
			stream.WriteByte(16);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.winnings);
		}
		if (instance.resultCode != 0)
		{
			stream.WriteByte(24);
			ProtocolParser.WriteUInt64(stream, (ulong)instance.resultCode);
		}
		Pool.FreeUnmanaged(ref memoryStream);
	}

	public byte[] ToProtoBytes()
	{
		return SerializeToBytes(this);
	}

	public void ToProto(Stream stream)
	{
		Serialize(stream, this);
	}

	public static byte[] SerializeToBytes(Result instance)
	{
		using MemoryStream memoryStream = new MemoryStream();
		Serialize(memoryStream, instance);
		return memoryStream.ToArray();
	}

	public static void SerializeLengthDelimited(Stream stream, Result instance)
	{
		byte[] array = SerializeToBytes(instance);
		ProtocolParser.WriteUInt32(stream, (uint)array.Length);
		stream.Write(array, 0, array.Length);
	}

	public void InspectUids(UidInspector<ulong> action)
	{
	}
}


public enum RespawnType
{
	SleepingBag = 1,
	Bed,
	BeachTowel,
	Camper,
	Static
}


public enum RespawnState
{
	OK = 1,
	Occupied,
	Underwater,
	InNoRespawnZone
}


