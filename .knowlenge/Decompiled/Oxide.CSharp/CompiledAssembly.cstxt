using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using Mono.Cecil;
using Oxide.Core;
using Oxide.Core.CSharp;
using Oxide.Plugins;

public class CompiledAssembly
{
	public CompilablePlugin[] CompilablePlugins;

	public string[] PluginNames;

	public string Name;

	public DateTime CompiledAt;

	public byte[] RawAssembly;

	public byte[] PatchedAssembly;

	public float Duration;

	public Assembly LoadedAssembly;

	public bool IsLoading;

	private List<Action<bool>> loadCallbacks = new List<Action<bool>>();

	private bool isPatching;

	private bool isLoaded;

	public bool IsBatch => CompilablePlugins.Length > 1;

	public CompiledAssembly(string name, CompilablePlugin[] plugins, byte[] rawAssembly, float duration)
	{
		Name = name;
		CompilablePlugins = plugins;
		RawAssembly = rawAssembly;
		Duration = duration;
		PluginNames = CompilablePlugins.Select((CompilablePlugin pl) => pl.Name).ToArray();
	}

	public void LoadAssembly(Action<bool> callback)
	{
		if (isLoaded)
		{
			callback(obj: true);
			return;
		}
		IsLoading = true;
		loadCallbacks.Add(callback);
		if (isPatching)
		{
			return;
		}
		ValidateAssembly(delegate(byte[] rawAssembly)
		{
			if (rawAssembly == null)
			{
				foreach (Action<bool> loadCallback in loadCallbacks)
				{
					loadCallback(obj: true);
				}
				loadCallbacks.Clear();
				IsLoading = false;
			}
			else
			{
				LoadedAssembly = Assembly.Load(rawAssembly);
				isLoaded = true;
				foreach (Action<bool> loadCallback2 in loadCallbacks)
				{
					loadCallback2(obj: true);
				}
				loadCallbacks.Clear();
				IsLoading = false;
			}
		});
	}

	private void ValidateAssembly(Action<byte[]> callback)
	{
		if (isPatching)
		{
			Interface.Oxide.LogWarning("Already patching plugin assembly: {0} (ignoring)", Oxide.Plugins.ExtensionMethods.ToSentence(PluginNames));
			return;
		}
		isPatching = true;
		ThreadPool.QueueUserWorkItem(delegate
		{
			try
			{
				AssemblyDefinition assemblyDefinition;
				using (MemoryStream stream = new MemoryStream(RawAssembly))
				{
					assemblyDefinition = AssemblyDefinition.ReadAssembly(stream);
				}
				foreach (TypeDefinition type in assemblyDefinition.MainModule.Types)
				{
					if (!IsCompilerGenerated(type))
					{
						if (type.Namespace == "Oxide.Plugins")
						{
							if (Oxide.Plugins.ExtensionMethods.Contains(PluginNames, type.Name))
							{
								if (type.Methods.FirstOrDefault((MethodDefinition m) => !m.IsStatic && m.IsConstructor && !m.HasParameters && !m.IsPublic) != null)
								{
									CompilablePlugin compilablePlugin = CompilablePlugins.SingleOrDefault((CompilablePlugin p) => p.Name == type.Name);
									if (compilablePlugin != null)
									{
										compilablePlugin.CompilerErrors = "Primary constructor in main class must be public";
									}
								}
								else
								{
									new DirectCallMethod(assemblyDefinition.MainModule, type);
								}
							}
							else
							{
								Interface.Oxide.LogWarning((PluginNames.Length == 1) ? (PluginNames[0] + " has polluted the global namespace by defining " + type.Name) : ("A plugin has polluted the global namespace by defining " + type.Name));
							}
						}
						else if (type.FullName != "<Module>" && !PluginNames.Any((string plugin) => type.FullName.StartsWith("Oxide.Plugins." + plugin)))
						{
							Interface.Oxide.LogWarning((PluginNames.Length == 1) ? (PluginNames[0] + " has polluted the global namespace by defining " + type.FullName) : ("A plugin has polluted the global namespace by defining " + type.FullName));
						}
					}
				}
				using (MemoryStream memoryStream = new MemoryStream())
				{
					assemblyDefinition.Write(memoryStream);
					PatchedAssembly = memoryStream.ToArray();
				}
				Interface.Oxide.NextTick(delegate
				{
					isPatching = false;
					callback(PatchedAssembly);
				});
			}
			catch (Exception ex)
			{
				Exception ex2 = ex;
				Exception ex3 = ex2;
				Interface.Oxide.NextTick(delegate
				{
					isPatching = false;
					Interface.Oxide.LogException("Exception while patching: " + Oxide.Plugins.ExtensionMethods.ToSentence(PluginNames), ex3);
					callback(null);
				});
			}
		});
	}

	public bool IsOutdated()
	{
		return CompilablePlugins.Any((CompilablePlugin pl) => pl.GetLastModificationTime() != CompiledAt);
	}

	private bool IsCompilerGenerated(TypeDefinition type)
	{
		return type.CustomAttributes.Any((CustomAttribute attr) => attr.Constructor.DeclaringType.ToString().Contains("CompilerGeneratedAttribute"));
	}
}
