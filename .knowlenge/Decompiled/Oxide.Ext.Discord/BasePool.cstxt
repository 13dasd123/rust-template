using System;
using System.Collections.Concurrent;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Exceptions;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Plugins;
using Oxide.Ext.Discord.Types;

public abstract class BasePool<TPooled, TPool> : IPool<TPooled>, IPool, IDebugLoggable where TPooled : class where TPool : BasePool<TPooled, TPool>, new()
{
	protected DiscordPluginPool PluginPool;

	private TPooled[] _pool;

	private int _index;

	private readonly object _lock = new object();

	private PoolSize _size;

	private bool _isFirstLeakError = true;

	private DateTime _nextLeakError;

	private bool _isInitialized;

	private static readonly ConcurrentDictionary<PluginId, TPool> Pools = new ConcurrentDictionary<PluginId, TPool>();

	private void InitPool(DiscordPluginPool pluginPool)
	{
		lock (_lock)
		{
			if (!_isInitialized)
			{
				_size = GetPoolSize(pluginPool.Settings);
				InvalidPoolException.ThrowIfInvalidPoolSize(_size);
				PluginPool = pluginPool;
				pluginPool.AddPool(this);
				_pool = new TPooled[_size.StartingSize];
				_isInitialized = true;
				DiscordExtension.GlobalLogger.Debug("Creating Pool. Plugin ID: {0} Type: {1}", pluginPool.PluginName, typeof(TPool).GetRealTypeName());
			}
		}
	}

	protected abstract PoolSize GetPoolSize(PoolSettings settings);

	public static TPool ForPlugin(DiscordPluginPool pluginPool)
	{
		TPool orAdd = Pools.GetOrAdd(pluginPool.PluginId, CreatePool);
		if (!orAdd._isInitialized)
		{
			orAdd.InitPool(pluginPool);
		}
		return orAdd;
	}

	private static TPool CreatePool(PluginId id)
	{
		return new TPool();
	}

	public TPooled Get()
	{
		TPooled val = null;
		lock (_lock)
		{
			if (_index == _pool.Length && _size.CanResize(_pool.Length))
			{
				int nextSize = _size.GetNextSize(_pool.Length);
				DiscordExtension.GlobalLogger.Debug("{0} Resizing Pool {1} Current Size: {2} Next Size: {3}", PluginPool.PluginName, GetType(), _pool.Length, nextSize);
				Array.Resize(ref _pool, nextSize);
			}
			if (_index < _pool.Length)
			{
				val = _pool[_index];
				_pool[_index] = null;
				_index++;
			}
			else if (ShouldLogLeak())
			{
				DiscordExtension.GlobalLogger.Warning("{0} Pool {1} is leaking entities!!! {2}/{3}", PluginPool.PluginName, GetType(), _index, _pool.Length);
			}
		}
		if (val == null)
		{
			val = CreateNew();
		}
		OnGetItem(val);
		return val;
	}

	private bool ShouldLogLeak()
	{
		if (!PluginPool.PluginId.IsExtensionPlugin)
		{
			return true;
		}
		if (_isFirstLeakError)
		{
			_isFirstLeakError = false;
			return false;
		}
		if (_nextLeakError < DateTime.UtcNow)
		{
			return false;
		}
		_nextLeakError = DateTime.UtcNow + TimeSpan.FromSeconds(30.0);
		return true;
	}

	protected abstract TPooled CreateNew();

	public void Free(TPooled item)
	{
		Free(ref item);
	}

	private void Free(ref TPooled item)
	{
		if (item == null || !OnFreeItem(ref item))
		{
			return;
		}
		lock (_lock)
		{
			if (_index != 0)
			{
				_index--;
				_pool[_index] = item;
			}
		}
		item = null;
	}

	public void OnPluginUnloaded(DiscordPluginPool pluginPool)
	{
		Pools.TryRemove(pluginPool.PluginId, out var _);
	}

	public void ClearPoolEntities()
	{
		lock (_lock)
		{
			for (int num = _pool.Length - 1; num >= 0; num--)
			{
				_pool[num] = null;
			}
			_index = 0;
		}
	}

	public void RemoveAllPools()
	{
		Pools.Clear();
	}

	protected virtual void OnGetItem(TPooled item)
	{
	}

	protected virtual bool OnFreeItem(ref TPooled item)
	{
		return true;
	}

	public void LogDebug(DebugLogger logger)
	{
		logger.StartObject(GetType().GetRealTypeName() ?? "");
		logger.AppendFieldOutOf("Pool", _pool.Length - _index, _pool.Length);
		logger.EndObject();
	}
}
