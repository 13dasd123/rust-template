using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using Oxide.Core;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Callbacks;
using Oxide.Ext.Discord.Exceptions;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Types;

public sealed class Promise<TPromised> : BasePromise, IPendingPromise<TPromised>, IPromise<TPromised>, IRejectable
{
	private TPromised _resolveValue;

	private readonly List<ResolveHandler<TPromised>> _resolves = new List<ResolveHandler<TPromised>>(1);

	private readonly Action<TPromised> _onResolve;

	private readonly Action _onResolveInternal;

	private readonly ManualResetValueTaskSource<TPromised> _taskSource = new ManualResetValueTaskSource<TPromised>();

	public Promise()
	{
		_onResolve = Resolve;
		_onResolveInternal = InvokeResolveHandlersInternal;
	}

	public static Promise<TPromised> Create()
	{
		return DiscordPool.Internal.Get<Promise<TPromised>>();
	}

	public static Promise<TConvert> Create<TConvert>()
	{
		return DiscordPool.Internal.Get<Promise<TConvert>>();
	}

	public static IPromise<TPromised> Create(Action<Action<TPromised>, Action<Exception>> resolver)
	{
		Promise<TPromised> promise = Create();
		try
		{
			resolver(promise._onResolve, promise.OnReject);
		}
		catch (Exception ex)
		{
			DiscordExtension.GlobalLogger.Exception("An error occured during create of Promise<" + typeof(TPromised).Name + ">", ex);
			promise.Reject(ex);
		}
		return promise;
	}

	public static IPromise<TPromised> Resolved(TPromised promisedValue)
	{
		Promise<TPromised> promise = Create();
		promise.State = PromiseState.Resolved;
		promise._resolveValue = promisedValue;
		promise.DelayedDispose();
		return promise;
	}

	public static IPromise<TPromised> Rejected(Exception ex)
	{
		Promise<TPromised> promise = Create();
		promise.State = PromiseState.Rejected;
		promise.Exception = ex;
		promise.DelayedDispose();
		return promise;
	}

	public void Resolve(TPromised value)
	{
		PromiseException.ThrowIfDisposed(this);
		PromiseException.ThrowIfNotPending(base.State);
		_resolveValue = value;
		base.State = PromiseState.Resolved;
		_taskSource.SetResult(value);
		InvokeResolveHandlers(value);
	}

	public override void Reject(Exception ex)
	{
		base.Reject(ex);
		_taskSource.SetException(ex);
	}

	private void InvokeResolveHandlers(TPromised value)
	{
		_resolveValue = value;
		if (ThreadEx.IsMain)
		{
			InvokeResolveHandlersInternal();
		}
		else
		{
			Interface.Oxide.NextTick(_onResolveInternal);
		}
	}

	private void InvokeResolveHandlersInternal()
	{
		for (int i = 0; i < _resolves.Count; i++)
		{
			_resolves[i].Resolve(_resolveValue);
		}
		ClearHandlers();
		DelayedDispose();
	}

	public IPromise Catch(Action<Exception> onRejected)
	{
		if (base.State == PromiseState.Resolved)
		{
			return Promise.Resolved();
		}
		Promise resultPromise = Promise.Create();
		AddHandlers(new ResolveHandler<TPromised>(ResolveHandler, resultPromise), new RejectHandler(RejectHandler, resultPromise));
		return resultPromise;
		void RejectHandler(Exception ex)
		{
			try
			{
				onRejected(ex);
				resultPromise.Resolve();
			}
			catch (Exception ex2)
			{
				DiscordExtension.GlobalLogger.Exception("An error occured during catch reject of Promise<" + typeof(TPromised).Name + ">", ex);
				resultPromise.Reject(ex2);
			}
		}
		void ResolveHandler(TPromised _)
		{
			resultPromise.Resolve();
		}
	}

	public IPromise Catch<TException>(Action<TException> onRejected) where TException : Exception
	{
		return Catch(delegate(Exception ex)
		{
			if (ex is TException obj)
			{
				onRejected(obj);
			}
		});
	}

	public IPromise<TPromised> Catch(Func<Exception, TPromised> onRejected)
	{
		if (base.State == PromiseState.Resolved)
		{
			return this;
		}
		Promise<TPromised> resultPromise = Create();
		AddHandlers(new ResolveHandler<TPromised>(resultPromise._onResolve, resultPromise), new RejectHandler(RejectHandler, resultPromise));
		return resultPromise;
		void RejectHandler(Exception ex)
		{
			try
			{
				resultPromise.Resolve(onRejected(ex));
			}
			catch (Exception ex2)
			{
				DiscordExtension.GlobalLogger.Exception("An error occured during catch reject of Promise<" + typeof(TPromised).Name + ">", ex);
				resultPromise.Reject(ex2);
			}
		}
	}

	public IPromise<TConvert> Then<TConvert>(Func<TPromised, IPromise<TConvert>> onResolved)
	{
		return Then(onResolved, null);
	}

	public IPromise<TPromised> Then(Action<TPromised> onResolved)
	{
		return Then(onResolved, null);
	}

	public IPromise<TConvert> Then<TConvert>(Func<TPromised, IPromise<TConvert>> onResolved, Func<Exception, IPromise<TConvert>> onRejected)
	{
		if (base.State == PromiseState.Resolved)
		{
			try
			{
				return onResolved(_resolveValue);
			}
			catch (Exception ex2)
			{
				DiscordExtension.GlobalLogger.Exception("An error occured during then resolved of Promise<" + typeof(TPromised).Name + ">", ex2);
				return Promise<TConvert>.Rejected(ex2);
			}
		}
		Promise<TConvert> resultPromise = Create<TConvert>();
		AddHandlers(new ResolveHandler<TPromised>(ResolveHandler, resultPromise), new RejectHandler(RejectHandler, resultPromise));
		return resultPromise;
		void RejectHandler(Exception ex)
		{
			if (onRejected == null)
			{
				resultPromise.Reject(ex);
				return;
			}
			try
			{
				onRejected(ex).Then(resultPromise);
			}
			catch (Exception ex3)
			{
				DiscordExtension.GlobalLogger.Exception("An error occured during convert of Promise<" + typeof(TPromised).Name + "> to Promise<" + typeof(TConvert).Name + ">", ex);
				resultPromise.Reject(ex3);
			}
		}
		void ResolveHandler(TPromised promised)
		{
			onResolved(promised).Then(resultPromise);
		}
	}

	public IPromise Then(Func<TPromised, IPromise> onResolved, Action<Exception> onRejected)
	{
		if (base.State == PromiseState.Resolved)
		{
			try
			{
				return onResolved(_resolveValue);
			}
			catch (Exception ex2)
			{
				DiscordExtension.GlobalLogger.Exception("An error occured during then reject of Promise<" + typeof(TPromised).Name + ">", ex2);
				return Promise.Rejected(ex2);
			}
		}
		Promise resultPromise = Promise.Create();
		AddHandlers(reject: new RejectHandler((onRejected == null) ? resultPromise.OnReject : new Action<Exception>(RejectHandler), resultPromise), resolve: new ResolveHandler<TPromised>(ResolveHandler, resultPromise));
		return resultPromise;
		void RejectHandler(Exception ex)
		{
			onRejected(ex);
			resultPromise.Reject(ex);
		}
		void ResolveHandler(TPromised promised)
		{
			if (onResolved != null)
			{
				onResolved(promised).Then(resultPromise);
			}
			else
			{
				resultPromise.Resolve();
			}
		}
	}

	public IPromise<TPromised> Then(IPromise<TPromised> promise)
	{
		Promise<TPromised> promise2 = (Promise<TPromised>)promise;
		return Then(promise2._onResolve, promise2.OnReject);
	}

	public IPromise<TPromised> Then(Action<TPromised> onResolved, Action<Exception> onRejected)
	{
		if (base.State == PromiseState.Resolved)
		{
			try
			{
				onResolved(_resolveValue);
				return Resolved(_resolveValue);
			}
			catch (Exception ex)
			{
				DiscordExtension.GlobalLogger.Exception("An error occured during resolve of Promise<" + typeof(TPromised).Name + ">", ex);
				return Rejected(ex);
			}
		}
		Promise<TPromised> promise = Create();
		PromiseCallback<TPromised> promiseCallback = PromiseCallback<TPromised>.Create(promise, onResolved, onRejected);
		AddHandlers(new ResolveHandler<TPromised>(promiseCallback.RunResolve, promise), new RejectHandler(promiseCallback.RunRejected, promise));
		return promise;
	}

	public IPromise<TConvert> Then<TConvert>(Func<TPromised, TConvert> transform)
	{
		return Then((TPromised value) => Promise<TConvert>.Resolved(transform(value)));
	}

	private void AddHandlers(ResolveHandler<TPromised> resolve, RejectHandler reject)
	{
		if (base.State == PromiseState.Resolved)
		{
			resolve.Resolve(_resolveValue);
			return;
		}
		if (base.State == PromiseState.Rejected)
		{
			reject.Reject(Exception);
			return;
		}
		_resolves.Add(resolve);
		Rejects.Add(reject);
	}

	public IPromise<IEnumerable<TConvert>> ThenAll<TConvert>(Func<TPromised, IEnumerable<IPromise<TConvert>>> chain)
	{
		return Then((TPromised value) => Promise<TConvert>.All(chain(value)));
	}

	public IPromise ThenAll(Func<TPromised, IEnumerable<IPromise>> chain)
	{
		return Then((TPromised value) => Promise.All(chain(value)), null);
	}

	public static IPromise<IEnumerable<TPromised>> All(params IPromise<TPromised>[] promises)
	{
		return All((IEnumerable<IPromise<TPromised>>)promises);
	}

	public static IPromise<IEnumerable<TPromised>> All(IEnumerable<IPromise<TPromised>> promisesEnumerable)
	{
		List<IPromise<TPromised>> list = DiscordPool.Internal.GetList<IPromise<TPromised>>();
		list.AddRange(promisesEnumerable);
		if (list.Count == 0)
		{
			return Promise<IEnumerable<TPromised>>.Resolved((IEnumerable<TPromised>)Array.Empty<TPromised>());
		}
		int remainingCount = list.Count;
		TPromised[] results = new TPromised[remainingCount];
		Promise<IEnumerable<TPromised>> resultPromise = Create<IEnumerable<TPromised>>();
		for (int i = 0; i < list.Count; i++)
		{
			int resultIndex = i;
			IPromise<TPromised> promise = list[i];
			promise.Then(delegate(TPromised result)
			{
				results[resultIndex] = result;
				int num = remainingCount - 1;
				remainingCount = num;
				if (remainingCount <= 0 && resultPromise.State == PromiseState.Pending)
				{
					resultPromise.Resolve(results);
				}
			}).Catch(delegate(Exception ex)
			{
				if (resultPromise.State == PromiseState.Pending)
				{
					resultPromise.Reject(ex);
				}
			});
		}
		DiscordPool.Internal.FreeList(list);
		return resultPromise;
	}

	public IPromise<TPromised> Finally(Action onComplete)
	{
		if (base.State == PromiseState.Resolved)
		{
			try
			{
				onComplete();
				return this;
			}
			catch (Exception ex)
			{
				DiscordExtension.GlobalLogger.Exception("An error occured during resolved finally of Promise<" + typeof(TPromised).Name + ">", ex);
				return Rejected(ex);
			}
		}
		Promise<TPromised> promise = Create();
		Then(promise._onResolve);
		Catch(delegate(Exception e)
		{
			try
			{
				onComplete();
				promise.Reject(e);
			}
			catch (Exception ex2)
			{
				DiscordExtension.GlobalLogger.Exception("An error occured during catch finally of Promise<" + typeof(TPromised).Name + ">", ex2);
				promise.Reject(ex2);
			}
		});
		return promise.Then(delegate(TPromised promised)
		{
			onComplete();
			return promised;
		});
	}

	public IPromise ContinueWith(Func<IPromise> onComplete)
	{
		Promise promise = Promise.Create();
		Then(delegate
		{
			promise.Resolve();
		});
		Catch(delegate
		{
			promise.Resolve();
		});
		return promise.Then(onComplete);
	}

	public IPromise<TConvert> ContinueWith<TConvert>(Func<IPromise<TConvert>> onComplete)
	{
		Promise promise = Promise.Create();
		Then(delegate
		{
			promise.Resolve();
		});
		Catch(delegate
		{
			promise.Resolve();
		});
		return promise.Then(onComplete);
	}

	public ValueTask<TPromised> AsTask()
	{
		return _taskSource.GetTask();
	}

	public ValueTaskAwaiter<TPromised> GetAwaiter()
	{
		return AsTask().GetAwaiter();
	}

	protected override void ClearHandlers()
	{
		_resolves.Clear();
		base.ClearHandlers();
	}

	protected override void EnterPool()
	{
		base.EnterPool();
		_resolveValue = default(TPromised);
		_resolves.Clear();
		_taskSource.Reset();
	}
}
