using System;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Oxide.Core.Libraries;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Factory;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Rest;
using Oxide.Ext.Discord.Types;

public abstract class BaseRequest : BasePoolable, IDebugLoggable
{
	public Snowflake Id;

	public RequestMethod Method;

	public RequestStatus Status;

	public string Route;

	public object Data;

	public RequestOptions Options;

	internal DiscordClient Client;

	internal HttpClient HttpClient;

	internal CancellationTokenSource Source;

	internal Bucket Bucket;

	private DateTimeOffset _errorResetAt;

	protected ILogger Logger;

	internal bool IsCancelled => Source.IsCancellationRequested;

	protected void Init(DiscordClient client, HttpClient httpClient, RequestMethod method, string route, object data, RequestOptions options)
	{
		Id = Singleton<SnowflakeIdFactory>.Instance.Generate();
		Client = client;
		HttpClient = httpClient;
		Method = method;
		Route = route;
		Data = data;
		Options = options;
		Source = new CancellationTokenSource();
		Logger = client.Logger;
		Logger.Debug("BaseRequest.Init Request Created Plugin: {0} Request ID: {1} Method: {2} Route: {3}", client.PluginName, Id, Method, route);
	}

	internal ValueTask WaitUntilRequestCanStart(CancellationToken token)
	{
		if (_errorResetAt > DateTimeOffset.UtcNow)
		{
			Logger.Debug("BaseRequest.WaitUntilRequestCanStart Request ID: {0} Can't Start Request Due to Previous Error Reset Waiting For: {1} Seconds", Id, (_errorResetAt - DateTimeOffset.UtcNow).TotalSeconds);
			return _errorResetAt.DelayUntil(token);
		}
		return default(ValueTask);
	}

	internal void OnRequestCompleted(RequestHandler handler, RequestResponse response)
	{
		if (Status != RequestStatus.Cancelled)
		{
			Status = RequestStatus.Completed;
			BaseRequest request = handler.Request;
			switch (response.Status)
			{
			case RequestCompletedStatus.Success:
				OnRequestSuccess(response);
				break;
			case RequestCompletedStatus.Cancelled:
				Client.Logger.Debug("BaseRequest.OnRequestCompleted Request Cancelled Bucket ID: {0} Request ID: {1} Plugin: {2} Method: {3} Route: {4}", Bucket.Id, request.Id, request.Client.PluginName, request.Method, request.Route);
				break;
			case RequestCompletedStatus.ErrorFatal:
			case RequestCompletedStatus.ErrorRetry:
				OnRequestError(response);
				break;
			}
			Bucket.OnRequestCompleted(handler, response);
			Client.Logger.Debug("BaseRequest.OnRequestCompleted Bucket ID: {0} Request ID: {1} Plugin: {2} Method: {3} Route: {4}", Bucket.Id, request.Id, request.Client.PluginName, request.Method, request.Route);
		}
	}

	protected abstract void OnRequestSuccess(RequestResponse response);

	protected abstract void OnRequestError(RequestResponse response);

	internal void OnRequestErrored()
	{
		_errorResetAt = MathExt.Max(_errorResetAt, DateTimeOffset.UtcNow + TimeSpan.FromSeconds(1.0));
		Logger.Debug("BaseRequest.OnRequestErrored Request ID: {0} Waiting For {1} Seconds", Id, (_errorResetAt - DateTimeOffset.UtcNow).TotalSeconds);
	}

	internal virtual void Abort()
	{
		if (!Source.IsCancellationRequested)
		{
			Source.Cancel();
			Status = RequestStatus.Cancelled;
		}
	}

	protected override void EnterPool()
	{
		Id = default(Snowflake);
		Method = RequestMethod.DELETE;
		Status = RequestStatus.InQueue;
		Route = null;
		HttpClient = null;
		Data = null;
		Client = null;
		Source = null;
		Bucket = null;
		_errorResetAt = DateTimeOffset.MinValue;
		Logger = null;
	}

	protected override void LeavePool()
	{
		Status = RequestStatus.InQueue;
	}

	public void LogDebug(DebugLogger logger)
	{
		logger.AppendField("ID", Id);
		logger.AppendFieldEnum("Method", Method);
		logger.AppendField("Route", Route);
		logger.AppendFieldEnum("Status", Status);
		logger.AppendField("Type", GetType().GetRealTypeName());
	}
}
