using System;
using Newtonsoft.Json;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Helpers;
using Oxide.Ext.Discord.Interfaces;

[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
public class DiscordEmoji : EmojiUpdate, ISnowflakeEntity
{
	public Snowflake Id => EmojiId.GetValueOrDefault();

	[JsonProperty("id")]
	public Snowflake? EmojiId { get; set; }

	[JsonProperty("user")]
	public DiscordUser User { get; set; }

	[JsonProperty("require_colons")]
	public bool? RequireColons { get; set; }

	[JsonProperty("managed")]
	public bool? Managed { get; set; }

	[JsonProperty("animated")]
	public bool? Animated { get; set; }

	[JsonProperty("available")]
	public bool? Available { get; set; }

	public string Url => EmojiId.HasValue ? DiscordCdn.GetCustomEmojiUrl(EmojiId.Value, (Animated.HasValue && Animated.Value) ? DiscordImageFormat.Gif : DiscordImageFormat.Png) : null;

	public string Mention => DiscordFormatting.EmojiMessageString(this);

	public static DiscordEmoji FromCharacter(string emoji)
	{
		return new DiscordEmoji
		{
			Name = emoji
		};
	}

	public static DiscordEmoji FromCustom(Snowflake id, bool animated = false)
	{
		return new DiscordEmoji
		{
			EmojiId = id,
			Animated = animated
		};
	}

	public string ToDataString()
	{
		if (!EmojiId.HasValue)
		{
			return base.Name;
		}
		return Uri.EscapeDataString(DiscordFormatting.CustomEmojiDataString(EmojiId.Value, base.Name, Animated == true));
	}

	internal void Update(DiscordEmoji emoji)
	{
		if (emoji.Name != null)
		{
			base.Name = emoji.Name;
		}
		if (emoji.Roles != null)
		{
			base.Roles = emoji.Roles;
		}
		if (emoji.User != null)
		{
			User = emoji.User;
		}
		if (emoji.RequireColons.HasValue)
		{
			RequireColons = emoji.RequireColons;
		}
		if (emoji.Managed.HasValue)
		{
			Managed = emoji.Managed;
		}
		if (emoji.Animated.HasValue)
		{
			Animated = emoji.Animated;
		}
		if (emoji.Available.HasValue)
		{
			Available = emoji.Available;
		}
	}
}
