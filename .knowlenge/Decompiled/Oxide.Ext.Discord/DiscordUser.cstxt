using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Cache;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Data;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Exceptions;
using Oxide.Ext.Discord.Helpers;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Types;
using Oxide.Plugins;

[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
public class DiscordUser : ISnowflakeEntity, IDiscordCacheable<DiscordUser>, IDebugLoggable
{
	[JsonProperty("id")]
	public Snowflake Id { get; set; }

	[JsonProperty("username")]
	public string Username { get; set; }

	[JsonProperty("global_name")]
	public string GlobalName { get; set; }

	[JsonProperty("discriminator")]
	[Obsolete("This field will be removed by discord in a future API version")]
	public string Discriminator { get; set; }

	[JsonProperty("avatar")]
	public string Avatar { get; set; }

	[JsonProperty("bot")]
	public bool? Bot { get; set; }

	[JsonProperty("system")]
	public bool? System { get; set; }

	[JsonProperty("mfa_enabled")]
	public bool? MfaEnabled { get; set; }

	[JsonProperty("banner")]
	public string Banner { get; set; }

	[JsonProperty("accent_color")]
	public DiscordColor? AccentColor { get; set; }

	[JsonProperty("locale")]
	public string Locale { get; set; }

	[JsonProperty("verified")]
	public bool? Verified { get; set; }

	[JsonProperty("email")]
	public string Email { get; set; }

	[JsonProperty("flags")]
	public UserFlags? Flags { get; set; }

	[JsonProperty("premium_type")]
	public UserPremiumType? PremiumType { get; set; }

	[JsonProperty("public_flags")]
	public UserFlags? PublicFlags { get; set; }

	[JsonProperty("avatar_decoration_data")]
	public AvatarDecorationData AvatarDecoration { get; set; }

	public string Mention => DiscordFormatting.MentionUser(Id);

	public string GetDefaultAvatarUrl => DiscordCdn.GetUserDefaultAvatarUrl(Discriminator);

	public string GetAvatarUrl => DiscordCdn.GetUserAvatarUrl(Id, Avatar);

	public string GetAvatarDecorationUrl => DiscordCdn.GetUserAvatarDecoration(AvatarDecoration);

	public string GetBannerUrl => DiscordCdn.GetUserBanner(Id, Banner);

	public string FullUserName => (Discriminator == "0") ? Username : (Username + "#" + Discriminator);

	public string DisplayName => GlobalName ?? Username;

	public bool IsBot => Bot.HasValue && Bot.Value;

	public bool IsSystem => System.HasValue && System.Value;

	public bool HasUpdatedUsername => !string.IsNullOrEmpty(Discriminator) && Discriminator == "0";

	public IPlayer Player => BaseDiscordLibrary<DiscordLink>.Instance.GetPlayer(Id);

	public static IPromise<DiscordUser> GetCurrentUser(DiscordClient client)
	{
		return client.Bot.Rest.Get<DiscordUser>(client, "users/@me", null);
	}

	public static IPromise<DiscordUser> GetUser(DiscordClient client, Snowflake userId)
	{
		InvalidSnowflakeException.ThrowIfInvalid(userId);
		return client.Bot.Rest.Get<DiscordUser>(client, $"users/{userId}", null);
	}

	public IPromise<DiscordMessage> SendDirectMessage(DiscordClient client, MessageCreate message)
	{
		if (message == null)
		{
			throw new ArgumentNullException("message");
		}
		return CreateDirectMessageChannel(client, Id).Then((DiscordChannel channel) => channel.CreateMessage(client, message));
	}

	public IPromise<DiscordMessage> SendDirectMessage(DiscordClient client, string message)
	{
		return SendDirectMessage(client, new MessageCreate
		{
			Content = message
		});
	}

	public IPromise<DiscordMessage> SendDirectMessage(DiscordClient client, List<DiscordEmbed> embeds)
	{
		if (embeds == null)
		{
			throw new ArgumentNullException("embeds");
		}
		return SendDirectMessage(client, new MessageCreate
		{
			Embeds = embeds
		});
	}

	public IPromise<DiscordMessage> SendTemplateDirectMessage(DiscordClient client, TemplateKey templateName, string language = "en", MessageCreate message = null, PlaceholderData placeholders = null)
	{
		MessageCreate message2 = DiscordExtension.DiscordMessageTemplates.GetLocalizedTemplate(client.Plugin, templateName, language).ToMessage(placeholders, message);
		return SendDirectMessage(client, message2);
	}

	public IPromise<DiscordMessage> SendGlobalTemplateDirectMessage(DiscordClient client, TemplateKey templateName, MessageCreate message = null, PlaceholderData placeholders = null)
	{
		MessageCreate message2 = DiscordExtension.DiscordMessageTemplates.GetGlobalTemplate(client.Plugin, templateName).ToMessage(placeholders, message);
		return SendDirectMessage(client, message2);
	}

	public IPromise<DiscordUser> ModifyCurrentUser(DiscordClient client, UserModifyCurrent current)
	{
		if (current == null)
		{
			throw new ArgumentNullException("current");
		}
		return client.Bot.Rest.Patch<DiscordUser>(client, "users/@me", current, null);
	}

	public IPromise<List<DiscordGuild>> GetCurrentUserGuilds(DiscordClient client, UserGuildsRequest request = null)
	{
		return client.Bot.Rest.Get<List<DiscordGuild>>(client, "users/@me/guilds" + request?.ToQueryString(), null);
	}

	public IPromise LeaveGuild(DiscordClient client, Snowflake guildId)
	{
		InvalidSnowflakeException.ThrowIfInvalid(guildId);
		return client.Bot.Rest.Delete(client, $"users/@me/guilds/{guildId}", null);
	}

	public IPromise<DiscordChannel> CreateDirectMessageChannel(DiscordClient client)
	{
		return CreateDirectMessageChannel(client, Id);
	}

	public static IPromise<DiscordChannel> CreateDirectMessageChannel(DiscordClient client, Snowflake userId)
	{
		InvalidSnowflakeException.ThrowIfInvalid(userId);
		InvalidChannelException.ThrowIfChannelToSelf(userId, client);
		UserData userData = client.Bot.DirectMessagesByUserId[userId]?.UserData;
		DateTime? dateTime = userData?.GetBlockedUntil();
		if (dateTime.HasValue && dateTime.Value > DateTime.UtcNow)
		{
			DiscordUser user = userData.GetUser();
			client.Logger.Debug("Blocking CreateMessage. User {0} ({1}) is DM blocked until {2}.", user.FullUserName, user.Id, userData.GetBlockedUntil());
			return Promise<DiscordChannel>.Rejected(new BlockedUserException(userData.GetUser(), dateTime.Value));
		}
		DiscordChannel discordChannel = client.Bot.DirectMessagesByUserId[userId];
		if (discordChannel != null)
		{
			return Promise<DiscordChannel>.Resolved(discordChannel);
		}
		Dictionary<string, object> data = new Dictionary<string, object> { ["recipient_id"] = userId };
		IPromise<DiscordChannel> promise = client.Bot.Rest.Post<DiscordChannel>(client, "users/@me/channels", data, null).Then(delegate(DiscordChannel newChannel)
		{
			client.Bot.AddDirectChannel(newChannel);
		});
		promise.Catch(delegate(ResponseError error)
		{
			if (error.DiscordError != null && error.DiscordError.Code == 50007)
			{
				if (userData == null)
				{
					BotData botData = BaseDataFile<DiscordUserData>.Instance.GetBotData(client.Bot.BotUser.Id);
					userData = botData.GetUserData(userId);
				}
				userData.ProcessError(client, error);
			}
		});
		return promise;
	}

	public IPromise<DiscordChannel> CreateGroupDm(DiscordClient client, string[] accessTokens, Hash<Snowflake, string> nicks)
	{
		Dictionary<string, object> data = new Dictionary<string, object>
		{
			["access_tokens"] = accessTokens,
			["nicks"] = nicks
		};
		return client.Bot.Rest.Post<DiscordChannel>(client, "users/@me/channels", data, null);
	}

	public IPromise<List<Connection>> GetUserConnections(DiscordClient client)
	{
		return client.Bot.Rest.Get<List<Connection>>(client, "users/@me/connections", null);
	}

	public IPromise GroupDmAddRecipient(DiscordClient client, DiscordChannel channel, string accessToken)
	{
		return GroupDmAddRecipient(client, channel.Id, accessToken, Username);
	}

	public IPromise GroupDmAddRecipient(DiscordClient client, Snowflake channelId, string accessToken, string nick)
	{
		InvalidSnowflakeException.ThrowIfInvalid(channelId);
		Dictionary<string, string> data = new Dictionary<string, string>
		{
			["access_token"] = accessToken,
			["nick"] = nick
		};
		return client.Bot.Rest.Put(client, $"channels/{channelId}/recipients/{Id}", data, null);
	}

	public IPromise GroupDmRemoveRecipient(DiscordClient client, DiscordChannel channel)
	{
		return GroupDmRemoveRecipient(client, channel.Id);
	}

	public IPromise GroupDmRemoveRecipient(DiscordClient client, Snowflake channelId)
	{
		InvalidSnowflakeException.ThrowIfInvalid(channelId);
		return client.Bot.Rest.Delete(client, $"channels/{channelId}/recipients/{Id}", null);
	}

	[OnDeserialized]
	internal void OnDeserializedMethod(StreamingContext context)
	{
		DiscordUser update = Singleton<EntityCache<DiscordUser>>.Instance.Update(this);
		Update(update);
	}

	public void Update(DiscordUser update)
	{
		if (update.Username != null)
		{
			Username = update.Username;
		}
		if (update.GlobalName != null)
		{
			GlobalName = update.GlobalName;
		}
		if (update.Discriminator != null)
		{
			Discriminator = update.Discriminator;
		}
		if (update.Avatar != null)
		{
			Avatar = update.Avatar;
		}
		if (update.MfaEnabled.HasValue)
		{
			MfaEnabled = update.MfaEnabled;
		}
		if (update.Banner != null)
		{
			Banner = update.Banner;
		}
		if (update.AccentColor.HasValue)
		{
			AccentColor = update.AccentColor;
		}
		if (update.Locale != null)
		{
			Locale = update.Locale;
		}
		if (update.Verified.HasValue)
		{
			Verified = update.Verified;
		}
		if (update.Email != null)
		{
			Email = update.Email;
		}
		if (update.Flags.HasValue)
		{
			Flags = update.Flags;
		}
		if (update.PremiumType.HasValue)
		{
			PremiumType = update.PremiumType;
		}
		if (update.PublicFlags.HasValue)
		{
			PublicFlags = update.PublicFlags;
		}
		if (update.AvatarDecoration != null)
		{
			AvatarDecoration = update.AvatarDecoration;
		}
	}

	public void LogDebug(DebugLogger logger)
	{
		logger.AppendField("Id", Id);
		logger.AppendField("Name", FullUserName);
		logger.AppendField("Bot", IsBot);
	}
}
