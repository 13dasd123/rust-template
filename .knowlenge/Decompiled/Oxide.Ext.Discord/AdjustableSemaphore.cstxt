using System;
using System.Threading;
using System.Threading.Tasks;

internal class AdjustableSemaphore
{
	private readonly object _syncRoot = new object();

	private int _maximum;

	public int Available { get; private set; }

	public int MaximumCount
	{
		get
		{
			lock (_syncRoot)
			{
				return _maximum;
			}
		}
		set
		{
			lock (_syncRoot)
			{
				if (value < 0)
				{
					throw new ArgumentException("Must be greater than or equal to 0.", "MaximumCount");
				}
				Available += value - _maximum;
				_maximum = value;
				Monitor.PulseAll(_syncRoot);
			}
		}
	}

	public AdjustableSemaphore(int maximumCount)
	{
		MaximumCount = maximumCount;
	}

	public ValueTask WaitOneAsync()
	{
		lock (_syncRoot)
		{
			while (Available <= 0)
			{
				Monitor.Wait(_syncRoot);
			}
			Available--;
		}
		return default(ValueTask);
	}

	public void Release()
	{
		lock (_syncRoot)
		{
			if (Available + 1 <= _maximum)
			{
				Available++;
				Monitor.Pulse(_syncRoot);
				return;
			}
			throw new Exception($"Adding 1 the given count to the semaphore would cause it to exceed its maximum count of {_maximum}.");
		}
	}

	public void AllowAllThrough()
	{
		MaximumCount = int.MaxValue;
		lock (_syncRoot)
		{
			Monitor.PulseAll(_syncRoot);
		}
	}

	public void Reset()
	{
		MaximumCount = 1;
	}
}
