using System;
using System.Net.WebSockets;
using System.Threading;
using System.Threading.Tasks;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Factory;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Types;
using Oxide.Ext.Discord.WebSockets;

internal class DiscordWebsocketClient : IDisposable
{
	public readonly Snowflake WebsocketId;

	private readonly ClientWebSocket _socket = new ClientWebSocket();

	private readonly CancellationTokenSource _source = new CancellationTokenSource();

	private readonly ILogger _logger;

	private bool _isDisposed;

	private bool _socketClosed;

	public SocketState SocketState { get; private set; }

	public CancellationToken Token => _source.Token;

	public WebSocketState WebSocketState => _socket.State;

	public bool IsCancelRequested => _source.IsCancellationRequested;

	public WebSocketCloseStatus? CloseStatus => _socket.CloseStatus;

	public string CloseStatusDescription => _socket.CloseStatusDescription;

	public DiscordWebsocketClient(ILogger logger)
	{
		_logger = logger;
		WebsocketId = Singleton<SnowflakeIdFactory>.Instance.Generate();
		SocketState = SocketState.Connecting;
		_socket.Options.KeepAliveInterval = TimeSpan.Zero;
	}

	private void SetSocketState(SocketState state)
	{
		if ((int)SocketState > (int)state)
		{
			throw new Exception($"Trying to set SocketState to a lower state {state} < {SocketState}");
		}
		SocketState = state;
	}

	public async ValueTask ConnectAsync(Uri uri)
	{
		await _socket.ConnectAsync(uri, Token).ConfigureAwait(continueOnCapturedContext: false);
		SetSocketState(SocketState.Connected);
	}

	public ValueTask<ValueWebSocketReceiveResult> ReceiveAsync(Memory<byte> buffer)
	{
		return _socket.ReceiveAsync(buffer, Token);
	}

	public ValueTask SendAsync(Memory<byte> buffer, WebSocketMessageType messageType, bool endOfMessage)
	{
		return _socket.SendAsync(buffer, messageType, endOfMessage, Token);
	}

	public async ValueTask CloseSocket(WebSocketCloseStatus status, string reason)
	{
		SetSocketState(SocketState.Disconnecting);
		if (_socket.State == WebSocketState.CloseReceived)
		{
			_logger.Debug("Closing Socket Output for ID: {0}", WebsocketId);
			await _socket.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, string.Empty, Token).ConfigureAwait(continueOnCapturedContext: false);
		}
		else
		{
			_logger.Debug("Closing Socket for ID: {0}", WebsocketId);
			await _socket.CloseAsync(status, reason, Token).ConfigureAwait(continueOnCapturedContext: false);
		}
		_socketClosed = true;
		_logger.Debug("{0} Socket Closed Successfully", WebsocketId);
	}

	public void Dispose()
	{
		_logger.Debug("Disposing Client {0}", WebsocketId);
		if (_isDisposed)
		{
			_logger.Debug("{0} already disposed", WebsocketId);
			return;
		}
		_isDisposed = true;
		SetSocketState(SocketState.Disconnected);
		if (Token.CanBeCanceled)
		{
			_source.Cancel();
		}
		if (!_socketClosed)
		{
			_socket.Dispose();
		}
		_logger.Debug("{0} Dispose Complete", WebsocketId);
	}
}
