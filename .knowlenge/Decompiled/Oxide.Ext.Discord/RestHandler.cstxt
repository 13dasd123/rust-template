using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using Newtonsoft.Json;
using Oxide.Core.Libraries;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Configuration;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Factory;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Json;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Rest;
using Oxide.Ext.Discord.Types;

public class RestHandler : IDebugLoggable
{
	public readonly HttpClient Client;

	public readonly RestRateLimit RateLimit;

	public readonly ConcurrentDictionary<BucketId, Bucket> Buckets = new ConcurrentDictionary<BucketId, Bucket>();

	public readonly ConcurrentDictionary<BucketId, BucketId> RouteToBucketId = new ConcurrentDictionary<BucketId, BucketId>();

	private readonly ILogger _logger;

	internal static readonly RestHandler Global = new RestHandler(DiscordExtension.GlobalLogger);

	public RestHandler(ILogger logger)
	{
		HttpClientHandler handler = new HttpClientHandler
		{
			AutomaticDecompression = (DecompressionMethods.GZip | DecompressionMethods.Deflate),
			UseCookies = false
		};
		Client = new HttpClient(handler)
		{
			Timeout = TimeSpan.FromSeconds(15.0),
			BaseAddress = new Uri("https://discord.com/api/v10/")
		};
		Client.DefaultRequestHeaders.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json"));
		Client.DefaultRequestHeaders.AcceptEncoding.Add(StringWithQualityHeaderValue.Parse("gzip"));
		Client.DefaultRequestHeaders.AcceptEncoding.Add(StringWithQualityHeaderValue.Parse("deflate"));
		Client.DefaultRequestHeaders.Add("user-agent", "DiscordBot (https://github.com/dassjosh/Oxide.Ext.Discord, v" + DiscordExtension.FullExtensionVersion + ")");
		_logger = logger;
		RateLimit = new RestRateLimit(logger);
	}

	public RestHandler(BotClient client, ILogger logger)
		: this(logger)
	{
		Client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bot", client.Connection.ApiToken);
	}

	public IPromise<TResult> Get<TResult>(DiscordClient client, string url, RequestOptions? options = null)
	{
		return CreateRequest<TResult>(client, url, RequestMethod.GET, null, options);
	}

	public IPromise Post(DiscordClient client, string url, object data, RequestOptions? options = null)
	{
		return CreateRequest(client, url, RequestMethod.POST, data, options);
	}

	public IPromise<TResult> Post<TResult>(DiscordClient client, string url, object data, RequestOptions? options = null)
	{
		return CreateRequest<TResult>(client, url, RequestMethod.POST, data, options);
	}

	public IPromise Put(DiscordClient client, string url, object data, RequestOptions? options = null)
	{
		return CreateRequest(client, url, RequestMethod.PUT, data, options);
	}

	public IPromise<TResult> Put<TResult>(DiscordClient client, string url, object data, RequestOptions? options = null)
	{
		return CreateRequest<TResult>(client, url, RequestMethod.PUT, data, options);
	}

	public IPromise Patch(DiscordClient client, string url, object data, RequestOptions? options = null)
	{
		return CreateRequest(client, url, RequestMethod.PATCH, data, options);
	}

	public IPromise<TResult> Patch<TResult>(DiscordClient client, string url, object data, RequestOptions? options = null)
	{
		return CreateRequest<TResult>(client, url, RequestMethod.PATCH, data, options);
	}

	public IPromise Delete(DiscordClient client, string url, RequestOptions? options = null)
	{
		return CreateRequest(client, url, RequestMethod.DELETE, null, options);
	}

	public IPromise<TResult> Delete<TResult>(DiscordClient client, string url, RequestOptions? options = null)
	{
		return CreateRequest<TResult>(client, url, RequestMethod.DELETE, null, options);
	}

	private IPromise CreateRequest(DiscordClient client, string url, RequestMethod method, object data, RequestOptions? options)
	{
		PerformValidation(data);
		IPendingPromise pendingPromise = Promise.Create();
		Request request = Request.CreateRequest(DiscordPool.Internal, client, Client, method, url, data, pendingPromise, options.GetValueOrDefault());
		StartRequest(request);
		return pendingPromise;
	}

	private IPromise<T> CreateRequest<T>(DiscordClient client, string url, RequestMethod method, object data, RequestOptions? options)
	{
		PerformValidation(data);
		IPendingPromise<T> pendingPromise = Promise<T>.Create();
		Request<T> request = Request<T>.CreateRequest(DiscordPool.Internal, client, Client, method, url, data, pendingPromise, options.GetValueOrDefault());
		StartRequest(request);
		return pendingPromise;
	}

	private void PerformValidation(object data)
	{
		if (!DiscordConfig.Instance.Validation.EnableValidation || !(data is IDiscordValidation discordValidation))
		{
			return;
		}
		try
		{
			discordValidation.Validate();
		}
		catch (Exception)
		{
			_logger.Error("An error occured duration object validation.\n" + JsonConvert.SerializeObject(data, DiscordJson.IndentedSettings));
			throw;
		}
	}

	public void StartRequest(BaseRequest request)
	{
		_logger.Debug("RestHandler.StartRequest Method: {0} Route: {1}", request.Method, request.Route);
		RequestHandler handler = RequestHandler.CreateRequest(request);
		QueueBucket(handler, request);
	}

	public void QueueBucket(RequestHandler handler, BaseRequest request)
	{
		BucketId bucketId = BucketIdFactory.GenerateId(request.Method, request.Route);
		_logger.Debug("RestHandler Queuing Bucket for {0} bucket {1}", request.Route, bucketId);
		Bucket bucket = GetBucket(bucketId);
		bucket.QueueRequest(handler);
	}

	internal void UpgradeToKnownBucket(Bucket bucket, BucketId newBucketId)
	{
		_logger.Debug("RestHandler Upgrading To Known Bucket for Old ID: {0} New ID: {1}", bucket.Id, newBucketId);
		RouteToBucketId[bucket.Id] = newBucketId;
		if (Buckets.TryGetValue(newBucketId, out var value))
		{
			value.Merge(bucket);
			bucket.Dispose();
			return;
		}
		Buckets.TryRemove(bucket.Id, out var _);
		bucket.Id = newBucketId;
		bucket.IsKnownBucket = true;
		Buckets[newBucketId] = bucket;
	}

	internal void RemoveBucket(Bucket bucket)
	{
		Buckets.TryRemove(bucket.Id, out var _);
		bucket.ShutDown();
		bucket.Dispose();
	}

	public Bucket GetBucket(BucketId bucketId)
	{
		if (RouteToBucketId.TryGetValue(bucketId, out var value))
		{
			bucketId = value;
		}
		if (!Buckets.TryGetValue(bucketId, out var value2))
		{
			value2 = DiscordPool.Internal.Get<Bucket>();
			value2.Init(bucketId, this, _logger);
			Buckets[bucketId] = value2;
		}
		return value2;
	}

	internal void OnClientClosed(DiscordClient client)
	{
		_logger.Debug("RestHandler.OnClientClosed Client: {0}", client.Plugin.FullName());
		foreach (Bucket value in Buckets.Values)
		{
			value.AbortClientRequests(client);
		}
	}

	public void Shutdown()
	{
		foreach (KeyValuePair<BucketId, Bucket> bucket in Buckets)
		{
			bucket.Value.ShutDown();
			bucket.Value.Dispose();
		}
		RouteToBucketId.Clear();
		Buckets.Clear();
		RateLimit.Shutdown();
	}

	public void LogDebug(DebugLogger logger)
	{
		logger.AppendList("Buckets", Buckets.Values);
	}
}
