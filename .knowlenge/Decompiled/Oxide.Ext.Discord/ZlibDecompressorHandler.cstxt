using System;
using System.IO;
using System.IO.Compression;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Logging;

internal class ZlibDecompressorHandler
{
	private readonly Encoding _encoding;

	private readonly ILogger _logger;

	private static readonly byte[] ZlibSuffix = new byte[4] { 0, 0, 255, 255 };

	private const byte ZlibPrefix = 120;

	public ZlibDecompressorHandler(Encoding encoding, ILogger logger)
	{
		_encoding = encoding;
		_logger = logger;
	}

	public async Task<string> DecompressMessage(ArraySegment<byte> bytes, CancellationToken token)
	{
		try
		{
			byte[] array = bytes.Array ?? throw new ArgumentNullException("bytes");
			if (bytes.Count < 4)
			{
				_logger.Warning("Tried to decompress a message with less than 4 bytes. Count: {0}", bytes.Count);
				return string.Empty;
			}
			using (MemoryStream input = new MemoryStream())
			{
				if (array[0] != 120)
				{
					await input.WriteAsync(array, bytes.Offset, bytes.Count, token).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					await input.WriteAsync(array, bytes.Offset + 2, bytes.Count - 2, token).ConfigureAwait(continueOnCapturedContext: false);
				}
				await input.FlushAsync(token).ConfigureAwait(continueOnCapturedContext: false);
				input.Position = 0L;
				string result;
				await using (DeflateStream zlib = new DeflateStream(input, CompressionMode.Decompress, leaveOpen: true))
				{
					using MemoryStream output = new MemoryStream();
					await zlib.CopyToAsync(output, token).ConfigureAwait(continueOnCapturedContext: false);
					output.Position = 0L;
					using StreamReader reader = new StreamReader(output, _encoding);
					string message = await reader.ReadToEndAsync().ConfigureAwait(continueOnCapturedContext: false);
					_logger.Debug($"Processed Message: String Length: {message.Length} Output Length: {output.Length}");
					result = message;
				}
				return result;
			}
			IL_0589:
			string result2;
			return result2;
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			_logger.Exception("An error occured decompression zlib stream", ex2);
			return string.Empty;
		}
	}

	private bool IsValidZlibStream(ArraySegment<byte> bytes)
	{
		byte[] array = bytes.Array ?? throw new InvalidOperationException();
		for (int i = 0; i < 4; i++)
		{
			if (array[array.Length - 1 - i] != ZlibSuffix[ZlibSuffix.Length - 1 - i])
			{
				return false;
			}
		}
		return true;
	}
}
