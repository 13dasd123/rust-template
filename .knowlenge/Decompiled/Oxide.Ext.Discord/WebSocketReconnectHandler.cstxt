using System;
using System.Threading;
using System.Threading.Tasks;
using Oxide.Core;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.WebSockets;

internal class WebSocketReconnectHandler
{
	internal readonly DiscordWebSocket WebSocket;

	private readonly BotClient _client;

	private readonly ILogger _logger;

	private int _reconnectRetries;

	private CancellationTokenSource _source;

	public bool IsPendingReconnect { get; private set; }

	internal bool AttemptGatewayUpdate => _reconnectRetries >= 3;

	public WebSocketReconnectHandler(BotClient client, DiscordWebSocket webSocket, ILogger logger)
	{
		_client = client;
		WebSocket = webSocket;
		_logger = logger;
	}

	public async ValueTask StartReconnect()
	{
		if (!_client.Initialized)
		{
			_logger.Debug("Skipping reconnect. BotClient is not Initialized");
			return;
		}
		if (!WebSocket.IsDisconnected() && !WebSocket.IsDisconnecting())
		{
			_logger.Debug("Skipping reconnect. Websocket is not Disconnected or Disconnecting");
			return;
		}
		if (IsPendingReconnect)
		{
			_logger.Debug("Skipping reconnect. Reconnect is already in progress.");
			return;
		}
		try
		{
			IsPendingReconnect = true;
			CancelReconnect();
			_source = new CancellationTokenSource();
			int delay = GetReconnectDelay();
			if (_reconnectRetries == 0)
			{
				_logger.Info("Reconnecting to Discord.");
			}
			else
			{
				_logger.Info("Reconnecting to Discord. Retry: #{0} Delay: {1}ms", _reconnectRetries, delay);
			}
			_reconnectRetries++;
			await Task.Delay(delay, _source.Token).ConfigureAwait(continueOnCapturedContext: false);
			Connect();
		}
		catch (OperationCanceledException)
		{
		}
		catch (Exception ex2)
		{
			Exception ex3 = ex2;
			_logger.Exception("An error occured during websocket reconnect", ex3);
		}
		finally
		{
			IsPendingReconnect = false;
		}
	}

	private void Connect()
	{
		if (WebSocket.IsConnected() || WebSocket.IsConnecting())
		{
			_logger.Debug("Skipping Connect. Socket is: {0}", WebSocket.Handler.SocketState);
		}
		else
		{
			WebSocket.Connect();
		}
	}

	public void CancelReconnect()
	{
		CancellationTokenSource source = _source;
		if (source != null && !source.IsCancellationRequested)
		{
			_source.Cancel();
		}
	}

	public void OnWebsocketReady()
	{
		_reconnectRetries = 0;
	}

	public void OnSocketShutdown()
	{
		CancelReconnect();
	}

	private int GetReconnectDelay()
	{
		int reconnectRetries = _reconnectRetries;
		if (1 == 0)
		{
		}
		int result = ((reconnectRetries <= 3) ? ((reconnectRetries != 0) ? (1000 + Oxide.Core.Random.Range(100, 250)) : 16) : ((reconnectRetries > 25) ? (60000 + Oxide.Core.Random.Range(500, 1000)) : (15000 + Oxide.Core.Random.Range(250, 500))));
		if (1 == 0)
		{
		}
		return result;
	}
}
