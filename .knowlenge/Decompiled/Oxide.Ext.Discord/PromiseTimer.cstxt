using System;
using System.Collections.Generic;
using Oxide.Ext.Discord.Exceptions;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Types;

internal sealed class PromiseTimer : Singleton<PromiseTimer>
{
	private float _currentTime;

	private readonly List<BaseTimerInstance> _waiting = new List<BaseTimerInstance>();

	private PromiseTimer()
	{
	}

	public IPromise WaitFor(float seconds)
	{
		return SetupTimer(DelayTimerInstance.Create(_currentTime + seconds));
	}

	public IPromise WaitWhile(Func<float, bool> predicate)
	{
		return SetupTimer(EventTimerInstance.Create(predicate, _currentTime, state: false));
	}

	public IPromise WaitUntil(Func<float, bool> predicate)
	{
		return SetupTimer(EventTimerInstance.Create(predicate, _currentTime, state: true));
	}

	private IPromise SetupTimer(BaseTimerInstance timer)
	{
		_waiting.Add(timer);
		return timer.PendingPromise;
	}

	public bool Cancel(IPromise promise)
	{
		BaseTimerInstance baseTimerInstance = FindInWaiting(promise);
		if (baseTimerInstance == null)
		{
			return false;
		}
		baseTimerInstance.Reject(new PromiseCancelledException("Promise was cancelled by user."));
		_waiting.Remove(baseTimerInstance);
		return true;
	}

	internal void Update(float deltaTime)
	{
		_currentTime += deltaTime;
		if (_waiting.Count == 0)
		{
			return;
		}
		int num = 0;
		while (num < _waiting.Count)
		{
			BaseTimerInstance baseTimerInstance = _waiting[num];
			baseTimerInstance.Update(_currentTime);
			if (baseTimerInstance.IsCompleted)
			{
				_waiting.Remove(baseTimerInstance);
			}
		}
	}

	private BaseTimerInstance FindInWaiting(IPromise promise)
	{
		for (int i = 0; i < _waiting.Count; i++)
		{
			BaseTimerInstance baseTimerInstance = _waiting[i];
			if (baseTimerInstance.Id == promise.Id)
			{
				return baseTimerInstance;
			}
		}
		return null;
	}
}
