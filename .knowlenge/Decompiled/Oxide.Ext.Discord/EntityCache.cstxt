using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Oxide.Ext.Discord.Cache;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Types;

public sealed class EntityCache<T> : Singleton<EntityCache<T>> where T : class, IDiscordCacheable<T>, new()
{
	private readonly ConcurrentDictionary<Snowflake, T> _cache = new ConcurrentDictionary<Snowflake, T>();

	private readonly Func<Snowflake, T> _valueFactory = (Snowflake id) => new T
	{
		Id = id
	};

	public readonly IReadOnlyDictionary<Snowflake, T> Cache;

	private EntityCache()
	{
		Cache = new ReadOnlyDictionary<Snowflake, T>(_cache);
	}

	public T Get(Snowflake id)
	{
		return _cache.GetValueOrDefault(id);
	}

	public T GetOrCreate(Snowflake id)
	{
		return id.IsValid() ? _cache.GetOrAdd(id, _valueFactory) : null;
	}

	public T Update(T entity)
	{
		if (entity == null || !entity.Id.IsValid())
		{
			return entity;
		}
		if (!_cache.TryGetValue(entity.Id, out var value))
		{
			_cache[entity.Id] = entity;
			return entity;
		}
		value.Update(entity);
		return value;
	}
}
