using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Factory;
using Oxide.Ext.Discord.Interfaces;
using Oxide.Ext.Discord.Json;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Logging;
using Oxide.Ext.Discord.Plugins;
using Oxide.Ext.Discord.Types;

public class DiscordClient
{
	public readonly PluginId PluginId;

	public readonly string PluginName;

	private readonly List<WebhookClient> _webhooks = new List<WebhookClient>();

	public readonly IReadOnlyList<WebhookClient> Webhooks;

	internal ILogger Logger;

	public Plugin Plugin { get; private set; }

	public BotClient Bot { get; private set; }

	public JsonSerializerSettings JsonSettings => Bot?.JsonSettings ?? DiscordJson.Settings;

	internal BotConnection Connection { get; private set; }

	internal PluginSetup PluginSetup { get; private set; }

	internal DiscordClient(Plugin plugin)
	{
		Plugin = plugin;
		PluginExt.OnPluginLoaded(Plugin);
		PluginId = plugin.Id();
		PluginName = plugin.FullName();
		Webhooks = new ReadOnlyCollection<WebhookClient>(_webhooks);
		BaseDiscordLibrary.ProcessPluginLoaded(this);
	}

	public void Connect(string apiKey, GatewayIntents intents)
	{
		Connect(new BotConnection(apiKey, intents));
	}

	public void Connect(BotConnection connection)
	{
		Connection = connection ?? throw new ArgumentNullException("connection");
		if (Logger == null)
		{
			Logger = Singleton<DiscordLoggerFactory>.Instance.CreateExtensionLogger(connection.LogLevel);
		}
		if (string.IsNullOrEmpty(Connection.ApiToken))
		{
			Logger.Error("API Token is null or empty!");
			return;
		}
		if (!string.IsNullOrEmpty(""))
		{
			Logger.Warning("Using Discord Test Version: {0}", DiscordExtension.FullExtensionVersion);
		}
		Logger.Debug("DiscordClient.Connect Bot connect for {0}", Plugin.FullName());
		Connection.Initialize(this);
		PluginSetup = new PluginSetup(Plugin, Logger);
		BaseDiscordLibrary.ProcessBotConnection(this);
		Bot = Singleton<BotClientFactory>.Instance.InitializeBotClient(this, Connection);
		Bot.AddClient(this);
	}

	public WebhookClient Connect(string webhookUrl)
	{
		return Connect(new WebhookConnection(webhookUrl));
	}

	public WebhookClient Connect(WebhookConnection connection)
	{
		if (Logger == null)
		{
			Logger = Singleton<DiscordLoggerFactory>.Instance.CreateExtensionLogger(connection.LogLevel);
		}
		if (string.IsNullOrEmpty(connection.WebhookUrl) || !connection.WebhookUrl.StartsWith("https://discord.com/api/webhooks/"))
		{
			Logger.Debug("Skipping Webhook connect. Webhook URL is null, empty, or invalid: {0}", connection.WebhookUrl);
			return null;
		}
		if (string.IsNullOrEmpty(connection.WebhookToken))
		{
			Logger.Error("Failed to parse Webhook token from webhook URL: {0}", connection.WebhookUrl);
			return null;
		}
		if (connection.WebhookId == default(Snowflake))
		{
			Logger.Error("Failed to parse webhook ID from webhook URL: {0}", connection.WebhookUrl);
			return null;
		}
		if (!string.IsNullOrEmpty(""))
		{
			Logger.Warning("Using Discord Test Version: {0}", DiscordExtension.FullExtensionVersion);
		}
		Logger.Debug("DiscordClient.Connect Webhook connect for {0}", Plugin.FullName());
		WebhookClient webhookClient = Singleton<WebhookClientFactory>.Instance.InitializeWebhookClient(this, connection);
		webhookClient.AddClient(this);
		_webhooks.Add(webhookClient);
		return webhookClient;
	}

	public void Disconnect()
	{
		Bot?.RemoveClient(this);
		Bot = null;
		for (int num = _webhooks.Count - 1; num >= 0; num--)
		{
			WebhookClient webhookClient = _webhooks[num];
			webhookClient.RemoveClient(this);
			_webhooks.RemoveAt(num);
		}
	}

	public bool IsConnected()
	{
		return Bot?.Initialized ?? _webhooks.Any((WebhookClient w) => w.Initialized);
	}

	public void RequestGuildMembers(GuildMembersRequestCommand request)
	{
		Bot?.SendWebSocketCommand(this, GatewayCommandCode.RequestGuildMembers, request);
	}

	public void UpdateVoiceState(UpdateVoiceStatusCommand voiceState)
	{
		Bot?.SendWebSocketCommand(this, GatewayCommandCode.VoiceStateUpdate, voiceState);
	}

	public void UpdateStatus(UpdatePresenceCommand presenceUpdate)
	{
		Bot?.SendWebSocketCommand(this, GatewayCommandCode.PresenceUpdate, presenceUpdate);
	}

	internal void UpdateLogLevel()
	{
		Logger.UpdateLogLevel(Singleton<DiscordLoggerFactory>.Instance.GetLogLevel(Connection.LogLevel));
	}

	internal void CloseClient()
	{
		try
		{
			DiscordExtension.GlobalLogger.Debug("DiscordClient.CloseClient Closing DiscordClient for plugin {0}", PluginName);
			Disconnect();
		}
		catch (Exception exception)
		{
			Logger.Exception("Failed to close the DiscordClient for {0}", PluginName, exception);
		}
		finally
		{
			Singleton<DiscordClientFactory>.Instance.RemoveClient(this);
			Plugin plugin = Plugin;
			if (plugin != null && plugin.IsLoaded && plugin is IDiscordPlugin discordPlugin)
			{
				discordPlugin.Client = null;
			}
			Plugin = null;
			PluginSetup = null;
		}
	}
}
