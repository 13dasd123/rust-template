using System;
using System.Collections.Generic;
using Oxide.Ext.Discord.Libraries;
using Oxide.Ext.Discord.Types;

public class UkkonenTrie<T>
{
	private readonly Node<T> _root;

	private readonly Func<T, T, bool> _equalsFunc;

	public long Size => _root.Size();

	public UkkonenTrie()
		: this((Func<T, T, bool>)((T left, T right) => left.Equals(right)))
	{
	}

	public UkkonenTrie(Func<T, T, bool> equalsFunc)
	{
		_equalsFunc = equalsFunc;
		_root = new Node<T>(_equalsFunc);
	}

	public IEnumerable<T> Search(string search)
	{
		HashSet<T> matches = DiscordPool.Internal.GetHashSet<T>();
		foreach (WordKey<T> item in RetrieveSubstrings(search))
		{
			T value = item.Value;
			if (matches.Add(value))
			{
				yield return value;
			}
		}
		DiscordPool.Internal.FreeHashSet(matches);
	}

	private IEnumerable<WordKey<T>> RetrieveSubstrings(string word)
	{
		if (string.IsNullOrEmpty(word))
		{
			return _root.GetData();
		}
		StringSlice word2 = new StringSlice(word);
		Node<T> node = SearchNode(word2);
		if (node == null)
		{
			return Array.Empty<WordKey<T>>();
		}
		return node.GetData();
	}

	public void Add(string key, T value)
	{
		StringSlice stringSlice = new StringSlice(key);
		AddState<T> input = new AddState<T>(_root, _root, stringSlice.Slice(0, 0), 0);
		int length = key.Length;
		for (int i = 0; i < length; i++)
		{
			input.Text.EndIndex++;
			input = Update(input, stringSlice.Slice(i), value);
			input = GetFurthestNode(input);
		}
		if (input.Leaf.Suffix == null && input.Leaf != _root && input.Leaf != input.Node)
		{
			input.Leaf.Suffix = input.Node;
		}
	}

	public void Remove(string key, T value)
	{
		StringSlice stringSlice = new StringSlice(key).Slice(0, 0);
		int length = key.Length;
		for (int i = 0; i < length; i++)
		{
			stringSlice.EndIndex++;
			SearchNode(stringSlice)?.Remove(stringSlice, value);
		}
	}

	private static bool RegionMatches(StringSlice first, int firstOffset, StringSlice second, int secondOffset, int length)
	{
		for (int i = 0; i < length; i++)
		{
			if (first[firstOffset + i] != second[secondOffset + i])
			{
				return false;
			}
		}
		return true;
	}

	private Node<T> SearchNode(StringSlice word)
	{
		Node<T> node = _root;
		int num;
		for (num = 0; num < word.Length; num++)
		{
			char ch = word[num];
			Edge<T> edge = node.GetEdge(ch);
			if (edge == null)
			{
				return null;
			}
			StringSlice label = edge.Label;
			int num2 = Math.Min(word.Length - num, label.Length);
			if (!RegionMatches(word, num, label, 0, num2))
			{
				return null;
			}
			if (label.Length >= word.Length - num)
			{
				return edge.Node;
			}
			node = edge.Node;
			num += num2 - 1;
		}
		return null;
	}

	private SplitResult<T> TestAndSplit(AddState<T> input, char character, StringSlice remainder, T value)
	{
		input = GetFurthestNode(input);
		if (input.Text.Length > 0)
		{
			Edge<T> edge = input.Node.GetEdge(input.Text[0]);
			StringSlice label = edge.Label;
			if (label.Length > input.Text.Length && label[input.Text.Length].Equals(character))
			{
				return new SplitResult<T>(input.Node, endpoint: true);
			}
			StringSlice stringSlice = (edge.Label = label.Slice(input.Text.Length));
			Node<T> node = new Node<T>(_equalsFunc);
			node.AddEdge(stringSlice[0], edge);
			input.Node.AddEdge(input.Text[0], new Edge<T>(input.Text, node));
			return new SplitResult<T>(node, endpoint: false);
		}
		Edge<T> edge2 = input.Node.GetEdge(character);
		if (edge2 == null)
		{
			return new SplitResult<T>(input.Node, endpoint: false);
		}
		StringSlice label2 = edge2.Label;
		if (remainder == label2)
		{
			edge2.Node.AddData(new WordKey<T>(input.Text.Original, value));
			return new SplitResult<T>(input.Node, endpoint: true);
		}
		if (remainder.StartsWith(label2) || !label2.StartsWith(remainder))
		{
			return new SplitResult<T>(input.Node, endpoint: true);
		}
		Node<T> node2 = new Node<T>(_equalsFunc);
		node2.AddData(new WordKey<T>(input.Text.Original, value));
		edge2.Label = edge2.Label.Slice(remainder.Length);
		node2.AddEdge(edge2.Label[0], edge2);
		input.Node.AddEdge(character, new Edge<T>(remainder, node2));
		return new SplitResult<T>(input.Node, endpoint: false);
	}

	private static AddState<T> GetFurthestNode(AddState<T> input)
	{
		if (input.Text.Length == 0)
		{
			return input;
		}
		Edge<T> edge = input.Node.GetEdge(input.Text[0]);
		while (edge != null && input.Text.Length >= edge.Label.Length && input.Text.StartsWith(edge.Label))
		{
			input.Text.StartIndex += edge.Label.Length;
			input.Offset += edge.Label.Length;
			input.Node = edge.Node;
			if (input.Text.Length > 0)
			{
				edge = input.Node.GetEdge(input.Text[0]);
			}
		}
		return input;
	}

	private AddState<T> Update(AddState<T> input, StringSlice rest, T value)
	{
		char c = input.Text[input.Text.Length - 1];
		Node<T> node = _root;
		SplitResult<T> splitResult = TestAndSplit(input.SliceLastChar(), c, rest, value);
		while (!splitResult.Endpoint)
		{
			Edge<T> edge = splitResult.Node.GetEdge(c);
			Node<T> node2;
			if (edge != null)
			{
				node2 = edge.Node;
			}
			else
			{
				node2 = new Node<T>(_equalsFunc);
				node2.AddData(new WordKey<T>(input.Text.Original, value));
				splitResult.Node.AddEdge(c, new Edge<T>(rest, node2));
			}
			if (input.Leaf != _root)
			{
				input.Leaf.Suffix = node2;
			}
			input.Leaf = node2;
			if (node != _root)
			{
				node.Suffix = splitResult.Node;
			}
			node = splitResult.Node;
			if (input.Node.Suffix == null)
			{
				input.Text = input.Text.Slice(1);
			}
			else
			{
				input.Text.EndIndex--;
				input = GetFurthestNode(input.TraverseNodeLevel());
				input.Text.EndIndex++;
			}
			splitResult = TestAndSplit(input.SliceLastChar(), c, rest, value);
		}
		if (node != _root)
		{
			node.Suffix = splitResult.Node;
		}
		return input;
	}
}
