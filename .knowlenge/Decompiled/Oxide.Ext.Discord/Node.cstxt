using System;
using System.Collections.Generic;
using Oxide.Ext.Discord.Types;

internal class Node<T>
{
	public Node<T> Suffix;

	private readonly List<EdgeKey<T>> _edges = new List<EdgeKey<T>>(0);

	private readonly List<WordKey<T>> _data = new List<WordKey<T>>(0);

	private readonly Func<T, T, bool> _equalsFunc;

	public IReadOnlyList<EdgeKey<T>> Edges => _edges;

	public Node(Func<T, T, bool> equalsFunc)
	{
		_equalsFunc = equalsFunc;
	}

	public long Size()
	{
		long num = 1L;
		for (int i = 0; i < _edges.Count; i++)
		{
			num += _edges[i].Value.Node.Size();
		}
		return num;
	}

	public IEnumerable<WordKey<T>> GetData()
	{
		for (int index = 0; index < _data.Count; index++)
		{
			yield return _data[index];
		}
		for (int i = 0; i < _edges.Count; i++)
		{
			foreach (WordKey<T> datum in _edges[i].Value.Node.GetData())
			{
				yield return datum;
			}
		}
	}

	public void AddData(WordKey<T> value)
	{
		if (!_data.Contains(value))
		{
			_data.Add(value);
			Suffix?.AddData(value);
		}
	}

	public void Remove(StringSlice slice, T value)
	{
		for (int num = _data.Count - 1; num >= 0; num--)
		{
			WordKey<T> wordKey = _data[num];
			if (wordKey.Key == slice.Original && _equalsFunc(wordKey.Value, value))
			{
				_data.RemoveAt(num);
			}
		}
	}

	public void AddEdge(char ch, Edge<T> edge)
	{
		int num = IndexOf(ch);
		if (num < 0)
		{
			_edges.Insert(~num, new EdgeKey<T>(ch, edge));
		}
		else
		{
			_edges[num] = new EdgeKey<T>(ch, edge);
		}
	}

	public Edge<T> GetEdge(char ch)
	{
		int num = IndexOf(ch);
		return (num < 0) ? null : _edges[num].Value;
	}

	private int IndexOf(char ch)
	{
		int num = 0;
		int num2 = _edges.Count - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num) / 2;
			char key = _edges[num3].Key;
			if (ch < key)
			{
				num2 = num3 - 1;
				continue;
			}
			if (ch > key)
			{
				num = num3 + 1;
				continue;
			}
			return num3;
		}
		return ~num;
	}
}
