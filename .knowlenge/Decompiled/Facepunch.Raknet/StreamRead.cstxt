using System.IO;
using Facepunch.Network.Raknet;
using Network;

internal class StreamRead : Read
{
	private NetworkPeer net;

	private Peer peer;

	private MemoryStream stream;

	public override long Length => stream.Length;

	public override long Position
	{
		get
		{
			return stream.Position;
		}
		set
		{
			stream.Position = value;
		}
	}

	public override bool CanSeek => stream.CanSeek;

	public StreamRead(NetworkPeer net, Peer peer)
	{
		this.net = net;
		this.peer = peer;
		stream = new MemoryStream();
	}

	public void Shutdown()
	{
		stream.Dispose();
		stream = null;
		peer = null;
		net = null;
	}

	public override bool Start()
	{
		if (peer == null)
		{
			return false;
		}
		stream.Position = 0L;
		stream.SetLength(0L);
		peer.ReadBytes(stream, peer.incomingBytesUnread);
		return true;
	}

	public override bool Start(Connection connection)
	{
		if (!Start())
		{
			return false;
		}
		if (stream.Length > 1 && net.cryptography != null && net.cryptography.IsEnabledIncoming(connection))
		{
			net.cryptography.Decrypt(connection, stream, 1);
		}
		return true;
	}

	public override byte PacketID()
	{
		return UInt8();
	}

	public override bool Bit()
	{
		if (base.unread < 1)
		{
			return false;
		}
		return stream.ReadByte() != 0;
	}

	public override byte UInt8()
	{
		if (base.unread < 1)
		{
			return 0;
		}
		return Read8().u;
	}

	public override ushort UInt16()
	{
		if (base.unread < 2)
		{
			return 0;
		}
		return Read16().u;
	}

	public override uint UInt32()
	{
		if (base.unread < 4)
		{
			return 0u;
		}
		return Read32().u;
	}

	public override ulong UInt64()
	{
		if (base.unread < 8)
		{
			return 0uL;
		}
		return Read64().u;
	}

	public override sbyte Int8()
	{
		if (base.unread < 1)
		{
			return 0;
		}
		return Read8().i;
	}

	public override short Int16()
	{
		if (base.unread < 2)
		{
			return 0;
		}
		return Read16().i;
	}

	public override int Int32()
	{
		if (base.unread < 4)
		{
			return 0;
		}
		return Read32().i;
	}

	public override long Int64()
	{
		if (base.unread < 8)
		{
			return 0L;
		}
		return Read64().i;
	}

	public override float Float()
	{
		if (base.unread < 4)
		{
			return 0f;
		}
		return Read32().f;
	}

	public override double Double()
	{
		if (base.unread < 8)
		{
			return 0.0;
		}
		return Read64().f;
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		return stream.Read(buffer, offset, count);
	}

	public override int ReadByte()
	{
		return stream.ReadByte();
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		return stream.Seek(offset, origin);
	}

	private byte[] GetReadBuffer()
	{
		return stream.GetBuffer();
	}

	private long GetReadOffset(long i)
	{
		long num = stream.Position;
		stream.Position = num + i;
		return num;
	}

	private Union8 Read8()
	{
		long readOffset = GetReadOffset(1L);
		byte[] readBuffer = GetReadBuffer();
		Union8 result = default(Union8);
		result.b1 = readBuffer[readOffset];
		return result;
	}

	private Union16 Read16()
	{
		long readOffset = GetReadOffset(2L);
		byte[] readBuffer = GetReadBuffer();
		Union16 result = default(Union16);
		result.b1 = readBuffer[readOffset];
		result.b2 = readBuffer[readOffset + 1];
		return result;
	}

	private Union32 Read32()
	{
		long readOffset = GetReadOffset(4L);
		byte[] readBuffer = GetReadBuffer();
		Union32 result = default(Union32);
		result.b1 = readBuffer[readOffset];
		result.b2 = readBuffer[readOffset + 1];
		result.b3 = readBuffer[readOffset + 2];
		result.b4 = readBuffer[readOffset + 3];
		return result;
	}

	private Union64 Read64()
	{
		long readOffset = GetReadOffset(8L);
		byte[] readBuffer = GetReadBuffer();
		Union64 result = default(Union64);
		result.b1 = readBuffer[readOffset];
		result.b2 = readBuffer[readOffset + 1];
		result.b3 = readBuffer[readOffset + 2];
		result.b4 = readBuffer[readOffset + 3];
		result.b5 = readBuffer[readOffset + 4];
		result.b6 = readBuffer[readOffset + 5];
		result.b7 = readBuffer[readOffset + 6];
		result.b8 = readBuffer[readOffset + 7];
		return result;
	}
}
