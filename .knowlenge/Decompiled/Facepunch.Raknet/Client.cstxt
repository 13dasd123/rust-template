using System;
using System.Diagnostics;
using System.IO;
using Facepunch;
using Facepunch.Network.Raknet;
using Network;
using UnityEngine;

public class Client : Network.Client
{
	private Peer peer;

	public static byte[] ReusableBytes = new byte[1048576];

	private Stopwatch cycleTimer = Stopwatch.StartNew();

	public override bool IsConnected()
	{
		return peer != null;
	}

	public override bool Connect(string strURL, int port)
	{
		base.Connect(strURL, port);
		peer = Peer.CreateConnection(strURL, port, 12, 400, 0);
		if (peer == null)
		{
			return false;
		}
		base.ConnectedAddress = strURL;
		base.ConnectedPort = port;
		base.ServerName = "";
		base.Connection = new Connection();
		return true;
	}

	internal bool HandleRaknetPacket(byte type)
	{
		if (type >= 140)
		{
			return false;
		}
		switch (type)
		{
		case 16:
			if (base.Connection.guid != 0L)
			{
				Console.WriteLine("Multiple PacketType.CONNECTION_REQUEST_ACCEPTED");
			}
			base.Connection.guid = peer.incomingGUID;
			IncomingStats.Add("Unconnected", "RequestAccepted", base.read.Length);
			return true;
		case 17:
			Disconnect("Connection Attempt Failed", sendReasonToServer: false);
			return true;
		case 20:
			Disconnect("Server is Full", sendReasonToServer: false);
			return true;
		case 21:
			if (base.Connection != null && base.Connection.guid != peer.incomingGUID)
			{
				return true;
			}
			Disconnect(Network.Client.disconnectReason, sendReasonToServer: false);
			return true;
		case 22:
			if (base.Connection == null && base.Connection.guid != peer.incomingGUID)
			{
				return true;
			}
			Disconnect("Timed Out", sendReasonToServer: false);
			return true;
		case 23:
			if (base.Connection == null && base.Connection.guid != peer.incomingGUID)
			{
				return true;
			}
			Disconnect("Connection Banned", sendReasonToServer: false);
			return true;
		default:
			IncomingStats.Add("Unconnected", "Unhandled", base.read.Length);
			if (base.Connection != null && peer.incomingGUID != base.Connection.guid)
			{
				UnityEngine.Debug.LogWarning("[CLIENT] Unhandled Raknet packet " + type + " from unknown source " + peer.incomingAddress);
				return true;
			}
			UnityEngine.Debug.LogWarning("Unhandled Raknet packet " + type);
			return true;
		}
	}

	protected void HandleMessage()
	{
		base.read.Start(peer.RawData(), peer.incomingBytesUnread);
		Decrypt(base.Connection, base.read);
		Record(base.Connection, base.read);
		byte b = base.read.PacketID();
		if (HandleRaknetPacket(b))
		{
			return;
		}
		b -= 140;
		if (peer.incomingGUID != base.Connection.guid)
		{
			IncomingStats.Add("Error", "WrongGuid", base.read.Length);
			return;
		}
		if (base.Connection == null)
		{
			UnityEngine.Debug.LogWarning(string.Concat("[CLIENT] Ignoring message ", (Message.Type)b, " ", b, " clientConnection is null"));
			return;
		}
		if (b > 25)
		{
			UnityEngine.Debug.LogWarning(string.Concat("Invalid Packet (higher than ", Message.Type.ConsoleReplicatedVars, ")"));
			Disconnect("Invalid Packet (" + b + ") " + peer.incomingBytes + "b", sendReasonToServer: true);
			return;
		}
		Message obj = StartMessage((Message.Type)b, base.Connection);
		if (callbackHandler != null)
		{
			try
			{
				using (TimeWarning.New("OnMessage"))
				{
					callbackHandler.OnNetworkMessage(obj);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogException(ex);
				Disconnect(ex.Message + "\n" + ex.StackTrace, sendReasonToServer: true);
			}
		}
		obj.Clear();
		Pool.Free(ref obj);
	}

	public override void Cycle()
	{
		using (TimeWarning.New("Raknet.Client.Cycle"))
		{
			if (!IsConnected())
			{
				return;
			}
			cycleTimer.Reset();
			cycleTimer.Start();
			int num = Mathf.CeilToInt((float)peer.PendingReceiveCount() * Network.Client.MinReceiveFraction);
			int num2 = 0;
			while (peer.Receive())
			{
				using (TimeWarning.New("HandleMessage"))
				{
					HandleMessage();
				}
				num2++;
				if ((num2 > num && cycleTimer.Elapsed.TotalMilliseconds > (double)Network.Client.MaxReceiveTime) || !IsConnected())
				{
					break;
				}
			}
		}
	}

	public override void Disconnect(string reason, bool sendReasonToServer)
	{
		if (sendReasonToServer && base.write != null && base.write.Start())
		{
			base.write.PacketID(Message.Type.DisconnectReason);
			base.write.String(reason);
			base.write.Send(new SendInfo(base.Connection)
			{
				method = SendMethod.ReliableUnordered,
				priority = Priority.Immediate
			});
		}
		if (peer != null)
		{
			peer.Close();
			peer = null;
		}
		base.ConnectedAddress = "";
		base.ConnectedPort = 0;
		base.Connection = null;
		OnDisconnected(reason);
	}

	public override string GetDebug(Connection connection)
	{
		if (peer == null)
		{
			return "";
		}
		if (connection == null)
		{
			return peer.GetStatisticsString(0uL);
		}
		return peer.GetStatisticsString(connection.guid);
	}

	public override ulong GetStat(Connection connection, StatTypeLong type)
	{
		if (peer == null)
		{
			return 0uL;
		}
		return peer.GetStat(connection, type);
	}

	public override int GetLastPing()
	{
		if (base.Connection == null)
		{
			return 1;
		}
		return peer.GetPingLast(base.Connection.guid);
	}

	public override void Send(SendInfo sendinfo, MemoryStream data)
	{
		if (peer != null)
		{
			Encrypt(base.Connection, ref data);
			peer.SendStart();
			peer.WriteBytes(data);
			peer.SendTo(base.Connection.guid, sendinfo.priority, sendinfo.method, sendinfo.channel);
		}
	}
}
