using System;
using System.Diagnostics;
using System.IO;
using Facepunch;
using Facepunch.Network.Raknet;
using Network;
using Rust.Demo;
using UnityEngine;

public class Client : Network.Client
{
	public static float MaxReceiveTime = 10f;

	public static float MinReceiveFraction = 0.05f;

	private Peer peer;

	public static byte[] ReusableBytes = new byte[1048576];

	private Stopwatch cycleTimer = Stopwatch.StartNew();

	protected FileStream recordStream;

	protected BinaryWriter recordWriter;

	protected Stopwatch recordTime;

	protected Reader demoFile;

	private long lastPlayedPacketTime;

	public override bool IsRecording => recordStream != null;

	public override bool IsPlaying => demoFile != null;

	public override bool PlayingFinished => demoFile.IsFinished;

	public override bool IsConnected()
	{
		return peer != null;
	}

	public override bool Connect(string strURL, int port)
	{
		base.Connect(strURL, port);
		peer = Peer.CreateConnection(strURL, port, 12, 400, 0);
		if (peer == null)
		{
			return false;
		}
		write = new StreamWrite(this, peer);
		connectedAddress = strURL;
		connectedPort = port;
		ServerName = "";
		base.Connection = new Connection();
		return true;
	}

	internal bool HandleRaknetPacket(byte type)
	{
		if (type >= 140)
		{
			return false;
		}
		if (IsPlaying)
		{
			return true;
		}
		switch (type)
		{
		case 16:
			base.ConnectionAccepted = true;
			if (base.Connection.guid != 0L)
			{
				Console.WriteLine("Multiple PacketType.CONNECTION_REQUEST_ACCEPTED");
			}
			base.Connection.guid = peer.incomingGUID;
			IncomingStats.Add("Unconnected", "RequestAccepted", base.read.Length);
			return true;
		case 17:
			Disconnect("Connection Attempt Failed", sendReasonToServer: false);
			return true;
		case 20:
			Disconnect("Server is Full", sendReasonToServer: false);
			return true;
		case 21:
			if (base.Connection != null && base.Connection.guid != peer.incomingGUID)
			{
				return true;
			}
			Disconnect(Network.Client.disconnectReason, sendReasonToServer: false);
			return true;
		case 22:
			if (base.Connection == null && base.Connection.guid != peer.incomingGUID)
			{
				return true;
			}
			Disconnect("Timed Out", sendReasonToServer: false);
			return true;
		case 23:
			if (base.Connection == null && base.Connection.guid != peer.incomingGUID)
			{
				return true;
			}
			Disconnect("Connection Banned", sendReasonToServer: false);
			return true;
		default:
			IncomingStats.Add("Unconnected", "Unhandled", base.read.Length);
			if (base.Connection != null && peer.incomingGUID != base.Connection.guid)
			{
				UnityEngine.Debug.LogWarning("[CLIENT] Unhandled Raknet packet " + type + " from unknown source " + peer.incomingAddress);
				return true;
			}
			UnityEngine.Debug.LogWarning("Unhandled Raknet packet " + type);
			return true;
		}
	}

	protected void HandleMessage()
	{
		base.read.Start(peer.RawData(), peer.incomingBytesUnread);
		Decrypt(base.Connection, base.read);
		if (IsRecording && !IsPlaying)
		{
			int unread = base.read.Unread;
			long position = base.read.Position;
			base.read.Position = 0L;
			base.read.Read(ReusableBytes, 0, unread);
			base.read.Position = position;
			recordWriter.Write(unread);
			recordWriter.Write((long)recordTime.Elapsed.TotalMilliseconds);
			recordWriter.Write(ReusableBytes, 0, unread);
			recordWriter.Write('\0');
			recordWriter.Write('\0');
		}
		byte b = base.read.PacketID();
		if (HandleRaknetPacket(b))
		{
			return;
		}
		b -= 140;
		if (!IsPlaying && peer.incomingGUID != base.Connection.guid)
		{
			IncomingStats.Add("Error", "WrongGuid", base.read.Length);
			return;
		}
		if (!IsPlaying && base.Connection == null)
		{
			UnityEngine.Debug.LogWarning(string.Concat("[CLIENT] Ignoring message ", (Message.Type)b, " ", b, " clientConnection is null"));
			return;
		}
		if (b > 25)
		{
			UnityEngine.Debug.LogWarning(string.Concat("Invalid Packet (higher than ", Message.Type.ConsoleReplicatedVars, ")"));
			Disconnect("Invalid Packet (" + b + ") " + peer.incomingBytes + "b", sendReasonToServer: true);
			return;
		}
		Message obj = StartMessage((Message.Type)b, base.Connection);
		if (callbackHandler != null)
		{
			try
			{
				using (TimeWarning.New("OnMessage"))
				{
					callbackHandler.OnNetworkMessage(obj);
				}
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogException(ex);
				if (!IsPlaying)
				{
					Disconnect(ex.Message + "\n" + ex.StackTrace, sendReasonToServer: true);
				}
			}
		}
		obj.Clear();
		Pool.Free(ref obj);
	}

	public override void Cycle()
	{
		using (TimeWarning.New("Raknet.Client.Cycle"))
		{
			if (IsPlaying || !IsConnected())
			{
				return;
			}
			cycleTimer.Reset();
			cycleTimer.Start();
			int num = Mathf.CeilToInt((float)peer.PendingReceiveCount() * MinReceiveFraction);
			int num2 = 0;
			while (peer.Receive())
			{
				using (TimeWarning.New("HandleMessage"))
				{
					HandleMessage();
				}
				num2++;
				if ((num2 > num && cycleTimer.Elapsed.TotalMilliseconds > (double)MaxReceiveTime) || !IsConnected())
				{
					break;
				}
			}
		}
	}

	public override void Disconnect(string reason, bool sendReasonToServer)
	{
		if (sendReasonToServer && write != null && write.Start())
		{
			write.PacketID(Message.Type.DisconnectReason);
			write.String(reason);
			write.Send(new SendInfo(base.Connection)
			{
				method = SendMethod.ReliableUnordered,
				priority = Priority.Immediate
			});
		}
		if (peer != null)
		{
			peer.Close();
			peer = null;
		}
		write = null;
		connectedAddress = "";
		connectedPort = 0;
		base.Connection = null;
		OnDisconnected(reason);
	}

	public override string GetDebug(Connection connection)
	{
		if (peer == null)
		{
			return "";
		}
		if (connection == null)
		{
			return peer.GetStatisticsString(0uL);
		}
		return peer.GetStatisticsString(connection.guid);
	}

	public override ulong GetStat(Connection connection, StatTypeLong type)
	{
		if (peer == null)
		{
			return 0uL;
		}
		return peer.GetStat(connection, type);
	}

	public override int GetAveragePing()
	{
		if (base.Connection == null)
		{
			return 1;
		}
		return peer.GetPingAverage(base.Connection.guid);
	}

	public override int GetLastPing()
	{
		if (base.Connection == null)
		{
			return 1;
		}
		return peer.GetPingLast(base.Connection.guid);
	}

	public override int GetLowestPing()
	{
		if (base.Connection == null)
		{
			return 1;
		}
		return peer.GetPingLowest(base.Connection.guid);
	}

	public override bool StartRecording(string targetFilename, byte[] header)
	{
		if (recordStream != null)
		{
			return false;
		}
		recordStream = new FileStream(targetFilename, FileMode.Create);
		recordWriter = new BinaryWriter(recordStream);
		recordTime = Stopwatch.StartNew();
		recordWriter.Write("RUST DEMO FORMAT");
		recordWriter.Write(header.Length);
		recordWriter.Write(header);
		recordWriter.Write('\0');
		return true;
	}

	public override void StopRecording()
	{
		if (recordStream != null)
		{
			recordTime = null;
			recordWriter.Close();
			recordWriter = null;
			recordStream.Dispose();
			recordStream = null;
		}
	}

	public override void ManualRecordPacket(byte packetId, byte[] data, int length)
	{
		if (IsRecording)
		{
			recordWriter.Write(length + 1);
			recordWriter.Write((long)recordTime.Elapsed.TotalMilliseconds);
			recordWriter.Write((byte)(packetId + 140));
			recordWriter.Write(data, 0, length);
			recordWriter.Write('\0');
			recordWriter.Write('\0');
		}
	}

	public override void StartPlayback(Reader demoFile)
	{
		this.demoFile = demoFile;
		peer = new DemoPeer();
		write = new StreamWrite(this, peer);
	}

	public override void StopPlayback()
	{
		demoFile?.Stop();
		demoFile = null;
		peer = null;
		write = null;
	}

	public override void UpdatePlayback(long frameTime)
	{
		if (!PlayingFinished)
		{
			demoFile.Progress(frameTime);
			Stopwatch.StartNew();
			while (!demoFile.IsFinished && PlaybackPacket())
			{
			}
		}
	}

	private unsafe bool PlaybackPacket()
	{
		Packet packet = demoFile.ReadPacket();
		if (!packet.isValid)
		{
			return false;
		}
		DemoPeer demoPeer = (DemoPeer)peer;
		try
		{
			fixed (byte* data = packet.Data)
			{
				demoPeer.Length = packet.Size;
				demoPeer.Data = data;
				demoPeer.SetReadPos(0);
				HandleMessage();
			}
		}
		finally
		{
			demoPeer.Data = null;
			demoPeer.Length = 0;
		}
		return IsPlaying;
	}
}
