using System;
using System.Diagnostics;
using System.IO;
using Facepunch;
using Facepunch.Network.Raknet;
using Network;
using UnityEngine;

public class Server : Network.Server
{
	private Peer peer;

	public override string ProtocolId => "rak";

	public override bool AllowPassthroughMessages => true;

	public override bool IsConnected()
	{
		return peer != null;
	}

	public override bool Start()
	{
		peer = Peer.CreateServer(ip, port, 1024);
		if (peer == null)
		{
			return false;
		}
		return true;
	}

	public override void Stop(string shutdownMsg)
	{
		if (peer == null)
		{
			return;
		}
		Console.WriteLine("[Raknet] Server Shutting Down (" + shutdownMsg + ")");
		using (TimeWarning.New("ServerStop"))
		{
			peer.Close();
			peer = null;
			base.Stop(shutdownMsg);
		}
	}

	public override void Disconnect(Connection cn)
	{
		if (peer != null)
		{
			peer.Kick(cn);
			OnDisconnected("Disconnected", cn);
		}
	}

	public override void Kick(Connection cn, string message, bool logfile)
	{
		if (peer != null)
		{
			if (base.write.Start())
			{
				base.write.PacketID(Message.Type.DisconnectReason);
				base.write.String(message);
				base.write.Send(new SendInfo(cn)
				{
					method = SendMethod.ReliableUnordered,
					priority = Priority.Immediate
				});
			}
			string text = cn.ToString() + " kicked: " + message;
			if (logfile)
			{
				DebugEx.LogWarning(text);
			}
			else
			{
				Console.WriteLine(text);
			}
			peer.Kick(cn);
			OnDisconnected("Kicked: " + message, cn);
		}
	}

	internal bool HandleRaknetPacket(byte type, Connection connection)
	{
		if (type >= 140)
		{
			return false;
		}
		switch (type)
		{
		case 19:
			using (TimeWarning.New("OnNewConnection", 20))
			{
				OnNewConnection();
			}
			return true;
		case 21:
			if (connection != null)
			{
				using (TimeWarning.New("OnDisconnected", 20))
				{
					OnDisconnected("Disconnected", connection);
				}
			}
			return true;
		case 22:
			if (connection != null)
			{
				using (TimeWarning.New("OnDisconnected (timed out)", 20))
				{
					OnDisconnected("Timed Out", connection);
				}
			}
			return true;
		default:
			return true;
		}
	}

	internal void UnconnectedPacket()
	{
		base.read.Start(peer.RawData(), peer.incomingBytesUnread);
		byte type = base.read.PacketID();
		if (callbackHandler == null || !callbackHandler.OnUnconnectedMessage(type, base.read, peer.incomingAddressInt, (int)peer.incomingPort))
		{
			HandleRaknetPacket(type, null);
		}
	}

	internal void ConnectedPacket(Connection connection)
	{
		if (connection.GetPacketsPerSecond() >= Network.Server.MaxPacketsPerSecond)
		{
			Kick(connection, "Packet Flooding", connection.connected);
			return;
		}
		connection.AddPacketsPerSecond();
		base.read.Start(peer.RawData(), peer.incomingBytesUnread);
		Decrypt(connection, base.read);
		byte b = base.read.PacketID();
		if (!HandleRaknetPacket(b, connection))
		{
			b -= 140;
			Message obj = StartMessage((Message.Type)b, connection);
			if (callbackHandler != null)
			{
				callbackHandler.OnNetworkMessage(obj);
			}
			obj.Clear();
			Pool.Free(ref obj);
		}
	}

	public override void Cycle()
	{
		base.Cycle();
		if (!IsConnected())
		{
			return;
		}
		Stopwatch obj = Pool.Get<Stopwatch>();
		obj.Reset();
		obj.Start();
		while (peer.Receive())
		{
			if (peer.incomingBytesUnread > Network.Server.MaxPacketSize)
			{
				continue;
			}
			Connection connection = FindConnection(peer.incomingGUID);
			if (connection == null)
			{
				using (TimeWarning.New("UnconnectedPacket", 20))
				{
					UnconnectedPacket();
				}
			}
			else
			{
				using (TimeWarning.New("ConnectedPacket", 20))
				{
					ConnectedPacket(connection);
				}
			}
			if (obj.Elapsed.TotalMilliseconds > (double)Network.Server.MaxReceiveTime)
			{
				break;
			}
		}
		Pool.Free(ref obj);
	}

	protected override void OnNewConnection()
	{
		ulong incomingGUID = peer.incomingGUID;
		string incomingAddress = peer.incomingAddress;
		if (!string.IsNullOrEmpty(incomingAddress) && !(incomingAddress == "UNASSIGNED_SYSTEM_ADDRESS"))
		{
			Connection connection = new Connection();
			connection.guid = incomingGUID;
			connection.ipaddress = incomingAddress;
			connection.active = true;
			OnNewConnection(connection);
		}
	}

	public override string GetDebug(Connection connection)
	{
		if (peer == null)
		{
			return string.Empty;
		}
		if (connection == null)
		{
			return peer.GetStatisticsString(0uL);
		}
		return peer.GetStatisticsString(connection.guid);
	}

	public override int GetAveragePing(Connection connection)
	{
		if (peer == null)
		{
			return 0;
		}
		return peer.GetPingAverage(connection.guid);
	}

	public override ulong GetStat(Connection connection, StatTypeLong type)
	{
		if (peer == null)
		{
			return 0uL;
		}
		return peer.GetStat(connection, type);
	}

	public unsafe override void SendUnconnected(uint netAddr, ushort netPort, byte[] data, int size)
	{
		fixed (byte* data2 = data)
		{
			peer.SendUnconnectedMessage(data2, size, netAddr, netPort);
		}
	}

	public override void Send(SendInfo sendinfo, MemoryStream data)
	{
		if (sendinfo.connections != null)
		{
			foreach (Connection connection in sendinfo.connections)
			{
				Send(sendinfo, data, connection);
			}
		}
		if (sendinfo.connection != null)
		{
			Send(sendinfo, data, sendinfo.connection);
		}
	}

	private void Send(SendInfo sendinfo, MemoryStream data, Connection connection)
	{
		if (peer != null)
		{
			Record(connection, data);
			Encrypt(connection, ref data);
			peer.SendStart();
			peer.WriteBytes(data);
			peer.SendTo(connection.guid, sendinfo.priority, sendinfo.method, sendinfo.channel);
		}
	}
}
