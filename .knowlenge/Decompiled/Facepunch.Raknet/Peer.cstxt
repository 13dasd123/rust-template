using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using Facepunch.Network.Raknet;
using Network;
using UnityEngine;

[SuppressUnmanagedCodeSecurity]
internal class Peer
{
	public enum PacketReliability
	{
		UNRELIABLE,
		UNRELIABLE_SEQUENCED,
		RELIABLE,
		RELIABLE_ORDERED,
		RELIABLE_SEQUENCED,
		UNRELIABLE_WITH_ACK_RECEIPT,
		RELIABLE_WITH_ACK_RECEIPT,
		RELIABLE_ORDERED_WITH_ACK_RECEIPT
	}

	private IntPtr ptr;

	private static byte[] ReadBuffer = new byte[1024];

	private static MemoryStream memoryStream = new MemoryStream();

	private static byte[] ByteBuffer = new byte[512];

	public virtual ulong incomingGUID
	{
		get
		{
			Check();
			return Native.NETRCV_GUID(ptr);
		}
	}

	public virtual uint incomingAddressInt
	{
		get
		{
			Check();
			return Native.NETRCV_Address(ptr);
		}
	}

	public virtual uint incomingPort
	{
		get
		{
			Check();
			return Native.NETRCV_Port(ptr);
		}
	}

	public string incomingAddress => GetAddress(incomingGUID);

	public virtual int incomingBits
	{
		get
		{
			Check();
			return Native.NETRCV_LengthBits(ptr);
		}
	}

	public virtual int incomingBitsUnread
	{
		get
		{
			Check();
			return Native.NETRCV_UnreadBits(ptr);
		}
	}

	public virtual int incomingBytes => incomingBits / 8;

	public virtual int incomingBytesUnread => incomingBitsUnread / 8;

	public static Peer CreateServer(string ip, int port, int maxConnections)
	{
		Peer peer = new Peer();
		peer.ptr = Native.NET_Create();
		if (Native.NET_StartServer(peer.ptr, ip, port, maxConnections) == 0)
		{
			return peer;
		}
		peer.Close();
		string text = StringFromPointer(Native.NET_LastStartupError(peer.ptr));
		Debug.LogWarning("Couldn't create server on port " + port + " (" + text + ")");
		return null;
	}

	public static Peer CreateConnection(string hostname, int port, int retries, int retryDelay, int timeout)
	{
		Peer peer = new Peer();
		peer.ptr = Native.NET_Create();
		if (Native.NET_StartClient(peer.ptr, hostname, port, retries, retryDelay, timeout) == 0)
		{
			return peer;
		}
		string text = StringFromPointer(Native.NET_LastStartupError(peer.ptr));
		Debug.LogWarning("Couldn't connect to server " + hostname + ":" + port + " (" + text + ")");
		peer.Close();
		peer = null;
		return null;
	}

	public void Close()
	{
		if (ptr != IntPtr.Zero)
		{
			Native.NET_Close(ptr);
			ptr = IntPtr.Zero;
		}
	}

	public bool Receive()
	{
		if (ptr == IntPtr.Zero)
		{
			return false;
		}
		return Native.NET_Receive(ptr);
	}

	public virtual void SetReadPos(int bitsOffset)
	{
		Check();
		Native.NETRCV_SetReadPointer(ptr, bitsOffset);
	}

	public unsafe virtual bool ReadBytes(byte* data, int length)
	{
		Check();
		return Native.NETRCV_ReadBytes(ptr, data, length);
	}

	public unsafe int Read(byte[] buffer, int offset, int length)
	{
		if (offset != 0)
		{
			throw new NotImplementedException("Offset != 0");
		}
		fixed (byte* data = buffer)
		{
			if (!ReadBytes(data, length))
			{
				Debug.LogError("NETRCV_ReadBytes returned false");
				return 0;
			}
		}
		return length;
	}

	public byte ReadUInt8()
	{
		return ReadByte();
	}

	public bool ReadBit()
	{
		return ReadUInt8() != 0;
	}

	public sbyte ReadInt8()
	{
		return (sbyte)ReadUInt8();
	}

	public unsafe long ReadInt64()
	{
		fixed (byte* data = &ReadBuffer[0])
		{
			return *(long*)Read(8, data);
		}
	}

	public unsafe int ReadInt32()
	{
		fixed (byte* data = &ReadBuffer[0])
		{
			return *(int*)Read(4, data);
		}
	}

	public unsafe short ReadInt16()
	{
		fixed (byte* data = &ReadBuffer[0])
		{
			return *(short*)Read(2, data);
		}
	}

	public unsafe ulong ReadUInt64()
	{
		fixed (byte* data = &ReadBuffer[0])
		{
			return *(ulong*)Read(8, data);
		}
	}

	public unsafe uint ReadUInt32()
	{
		fixed (byte* data = &ReadBuffer[0])
		{
			return *(uint*)Read(4, data);
		}
	}

	public unsafe ushort ReadUInt16()
	{
		fixed (byte* data = &ReadBuffer[0])
		{
			return *(ushort*)Read(2, data);
		}
	}

	public unsafe float ReadFloat()
	{
		fixed (byte* data = &ReadBuffer[0])
		{
			return *(float*)Read(4, data);
		}
	}

	public unsafe double ReadDouble()
	{
		fixed (byte* data = &ReadBuffer[0])
		{
			return *(double*)Read(8, data);
		}
	}

	public unsafe byte ReadByte()
	{
		fixed (byte* byteBuffer = ByteBuffer)
		{
			if (!ReadBytes(byteBuffer, 1))
			{
				Debug.LogError("NETRCV_ReadBytes returned false");
				return 0;
			}
		}
		return ByteBuffer[0];
	}

	public IntPtr RawData()
	{
		Check();
		return Native.NETRCV_RawData(ptr);
	}

	public unsafe MemoryStream ReadBytes(int length)
	{
		if (length == -1)
		{
			length = incomingBytesUnread;
		}
		if (memoryStream.Capacity < length)
		{
			memoryStream.Capacity = length + 32;
		}
		fixed (byte* buffer = memoryStream.GetBuffer())
		{
			memoryStream.SetLength(memoryStream.Capacity);
			if (!ReadBytes(buffer, length))
			{
				Debug.LogError("NETRCV_ReadBytes returned false");
				return null;
			}
			memoryStream.SetLength(length);
		}
		return memoryStream;
	}

	private unsafe byte* Read(int size, byte* data)
	{
		if (size > ReadBuffer.Length)
		{
			throw new Exception("Size > ReadBuffer.Length");
		}
		if (!ReadBytes(data, size))
		{
			Debug.LogError("NETRCV_ReadBytes returned false");
			return null;
		}
		return data;
	}

	public virtual void SendStart()
	{
		Check();
		Native.NETSND_Start(ptr);
	}

	public void WriteBool(bool val)
	{
		WriteUInt8((byte)(val ? 1u : 0u));
	}

	public unsafe void WriteUInt16(ushort val)
	{
		Write((byte*)(&val), 2);
	}

	public unsafe void WriteUInt32(uint val)
	{
		Write((byte*)(&val), 4);
	}

	public unsafe void WriteUInt64(ulong val)
	{
		Write((byte*)(&val), 8);
	}

	public unsafe void WriteInt8(sbyte val)
	{
		Write((byte*)(&val), 1);
	}

	public unsafe void WriteInt16(short val)
	{
		Write((byte*)(&val), 2);
	}

	public unsafe void WriteInt32(int val)
	{
		Write((byte*)(&val), 4);
	}

	public unsafe void WriteInt64(long val)
	{
		Write((byte*)(&val), 8);
	}

	public unsafe void WriteFloat(float val)
	{
		Write((byte*)(&val), 4);
	}

	public unsafe void WriteDouble(double val)
	{
		Write((byte*)(&val), 8);
	}

	public unsafe void WriteUInt8(byte val)
	{
		Write(&val, 1);
	}

	public unsafe void WriteBytes(byte[] val, int offset, int length)
	{
		if (offset != 0)
		{
			throw new NotSupportedException("offset != 0");
		}
		fixed (byte* data = val)
		{
			Write(data, length);
		}
	}

	public unsafe void WriteBytes(byte[] val)
	{
		fixed (byte* data = val)
		{
			Write(data, val.Length);
		}
	}

	protected unsafe virtual void Write(byte* data, int size)
	{
		if (size != 0)
		{
			if (data == null)
			{
				throw new InvalidOperationException("data is NULL");
			}
			Check();
			Native.NETSND_WriteBytes(ptr, data, size);
		}
	}

	public virtual uint SendBroadcast(Priority priority, SendMethod reliability, sbyte channel)
	{
		Check();
		return Native.NETSND_Broadcast(ptr, ToRaknetPriority(priority), ToRaknetPacketReliability(reliability), channel);
	}

	public virtual uint SendTo(ulong guid, Priority priority, SendMethod reliability, sbyte channel)
	{
		Check();
		return Native.NETSND_Send(ptr, guid, ToRaknetPriority(priority), ToRaknetPacketReliability(reliability), channel);
	}

	public unsafe void SendUnconnectedMessage(byte* data, int length, uint adr, ushort port)
	{
		Check();
		Native.NET_SendMessage(ptr, data, length, adr, port);
	}

	public string GetAddress(ulong guid)
	{
		Check();
		return StringFromPointer(Native.NET_GetAddress(ptr, guid));
	}

	private static string StringFromPointer(IntPtr p)
	{
		if (p == IntPtr.Zero)
		{
			return string.Empty;
		}
		return Marshal.PtrToStringAnsi(p);
	}

	public int ToRaknetPriority(Priority priority)
	{
		return priority switch
		{
			Priority.Immediate => 0, 
			Priority.High => 1, 
			Priority.Medium => 2, 
			_ => 3, 
		};
	}

	public int ToRaknetPacketReliability(SendMethod priority)
	{
		return priority switch
		{
			SendMethod.ReliableUnordered => 2, 
			SendMethod.Reliable => 3, 
			SendMethod.ReliableSequenced => 4, 
			SendMethod.Unreliable => 0, 
			SendMethod.UnreliableSequenced => 1, 
			_ => 3, 
		};
	}

	public void Kick(Connection connection)
	{
		Check();
		Native.NET_CloseConnection(ptr, connection.guid);
	}

	protected virtual void Check()
	{
		if (ptr == IntPtr.Zero)
		{
			throw new NullReferenceException("Peer has already shut down!");
		}
	}

	public virtual string GetStatisticsString(ulong guid)
	{
		Check();
		return $"Average Ping:\t\t{GetPingAverage(guid)}\nLast Ping:\t\t{GetPingLast(guid)}\nLowest Ping:\t\t{GetPingLowest(guid)}\n{StringFromPointer(Native.NET_GetStatisticsString(ptr, guid))}";
	}

	public virtual int GetPingAverage(ulong guid)
	{
		Check();
		return Native.NET_GetAveragePing(ptr, guid);
	}

	public virtual int GetPingLast(ulong guid)
	{
		Check();
		return Native.NET_GetLastPing(ptr, guid);
	}

	public virtual int GetPingLowest(ulong guid)
	{
		Check();
		return Native.NET_GetLowestPing(ptr, guid);
	}

	public unsafe virtual Native.RaknetStats GetStatistics(ulong guid)
	{
		Check();
		Native.RaknetStats data = default(Native.RaknetStats);
		int num = sizeof(Native.RaknetStats);
		if (!Native.NET_GetStatistics(ptr, guid, ref data, num))
		{
			Debug.Log("NET_GetStatistics:  Wrong size " + num);
		}
		return data;
	}

	public unsafe virtual ulong GetStat(Connection connection, NetworkPeer.StatTypeLong type)
	{
		Check();
		Native.RaknetStats raknetStats = ((connection == null) ? GetStatistics(0uL) : GetStatistics(connection.guid));
		switch (type)
		{
		case NetworkPeer.StatTypeLong.BytesReceived:
			return raknetStats.runningTotal[6];
		case NetworkPeer.StatTypeLong.BytesReceived_LastSecond:
			return raknetStats.valueOverLastSecond[6];
		case NetworkPeer.StatTypeLong.BytesSent:
			return raknetStats.runningTotal[5];
		case NetworkPeer.StatTypeLong.BytesSent_LastSecond:
			return raknetStats.valueOverLastSecond[5];
		case NetworkPeer.StatTypeLong.BytesInSendBuffer:
			return (ulong)raknetStats.bytesInSendBuffer;
		case NetworkPeer.StatTypeLong.BytesInResendBuffer:
			return raknetStats.bytesInResendBuffer;
		case NetworkPeer.StatTypeLong.PacketLossAverage:
			return (ulong)raknetStats.packetlossTotal * 10000;
		case NetworkPeer.StatTypeLong.PacketLossLastSecond:
			return (ulong)raknetStats.packetlossLastSecond * 10000;
		case NetworkPeer.StatTypeLong.ThrottleBytes:
			if (raknetStats.isLimitedByCongestionControl == 0)
			{
				return 0uL;
			}
			return raknetStats.BPSLimitByCongestionControl;
		default:
			return 0uL;
		}
	}
}
