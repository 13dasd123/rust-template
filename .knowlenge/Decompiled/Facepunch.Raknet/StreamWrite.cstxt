using Facepunch.Network.Raknet;
using Network;

internal class StreamWrite : Write
{
	private Peer peer;

	public StreamWrite(Peer peer)
	{
		this.peer = peer;
	}

	public void Shutdown()
	{
		peer = null;
	}

	public override bool Start()
	{
		if (peer == null)
		{
			return false;
		}
		peer.SendStart();
		return true;
	}

	public override void Send(SendInfo info)
	{
		if (info.broadcast)
		{
			peer.SendBroadcast(info.priority, info.method, info.channel);
		}
		if (info.connection != null)
		{
			peer.SendTo(info.connection.guid, info.priority, info.method, info.channel);
		}
		if (info.connections != null)
		{
			for (int i = 0; i < info.connections.Count; i++)
			{
				peer.SendTo(info.connections[i].guid, info.priority, info.method, info.channel);
			}
		}
		if (info.connectionGUID != 0L)
		{
			peer.SendTo(info.connectionGUID, info.priority, info.method, info.channel);
		}
	}

	public override void PacketID(Message.Type val)
	{
		byte b = (byte)val;
		b += 140;
		UInt8(b);
	}

	public override void UInt8(byte val)
	{
		peer.WriteUInt8(val);
	}

	public override void UInt16(ushort val)
	{
		peer.WriteUInt16(val);
	}

	public override void UInt32(uint val)
	{
		peer.WriteUInt32(val);
	}

	public override void UInt64(ulong val)
	{
		peer.WriteUInt64(val);
	}

	public override void Int8(sbyte val)
	{
		peer.WriteInt8(val);
	}

	public override void Int16(short val)
	{
		peer.WriteInt16(val);
	}

	public override void Int32(int val)
	{
		peer.WriteInt32(val);
	}

	public override void Int64(long val)
	{
		peer.WriteInt64(val);
	}

	public override void Bool(bool val)
	{
		peer.WriteBool(val);
	}

	public override void Float(float val)
	{
		peer.WriteFloat(val);
	}

	public override void Double(double val)
	{
		peer.WriteDouble(val);
	}

	public override void Bytes(byte[] val)
	{
		peer.WriteBytes(val);
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		peer.WriteBytes(buffer, offset, count);
	}

	public override void WriteByte(byte value)
	{
		peer.WriteUInt8(value);
	}
}
