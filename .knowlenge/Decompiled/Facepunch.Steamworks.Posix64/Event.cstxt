using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using Steamworks;

internal class Event : IDisposable
{
	internal static List<IDisposable> AllClient = new List<IDisposable>();

	internal static List<IDisposable> AllServer = new List<IDisposable>();

	private bool IsAllocated;

	private List<GCHandle> Allocations = new List<GCHandle>();

	internal IntPtr vTablePtr;

	internal GCHandle PinnedCallback;

	internal static void DisposeAllClient()
	{
		IDisposable[] array = AllClient.ToArray();
		foreach (IDisposable disposable in array)
		{
			disposable.Dispose();
		}
		AllClient.Clear();
	}

	internal static void DisposeAllServer()
	{
		IDisposable[] array = AllServer.ToArray();
		foreach (IDisposable disposable in array)
		{
			disposable.Dispose();
		}
		AllServer.Clear();
	}

	internal static void Register(Callback.Run func, int size, int callbackId, bool gameserver)
	{
		Event @event = new Event();
		@event.vTablePtr = BuildVTable(func, @event.Allocations);
		Callback callback = new Callback();
		callback.vTablePtr = @event.vTablePtr;
		callback.CallbackFlags = (byte)(gameserver ? 2 : 0);
		callback.CallbackId = callbackId;
		@event.PinnedCallback = GCHandle.Alloc(callback, GCHandleType.Pinned);
		SteamClient.RegisterCallback(@event.PinnedCallback.AddrOfPinnedObject(), callback.CallbackId);
		@event.IsAllocated = true;
		if (gameserver)
		{
			AllServer.Add(@event);
		}
		else
		{
			AllClient.Add(@event);
		}
	}

	private static IntPtr BuildVTable(Callback.Run run, List<GCHandle> allocations)
	{
		Callback.RunCall runCall = Callback.RunStub;
		Callback.GetCallbackSizeBytes getCallbackSizeBytes = Callback.SizeStub;
		allocations.Add(GCHandle.Alloc(run));
		allocations.Add(GCHandle.Alloc(runCall));
		allocations.Add(GCHandle.Alloc(getCallbackSizeBytes));
		IntPtr functionPointerForDelegate = Marshal.GetFunctionPointerForDelegate(run);
		IntPtr functionPointerForDelegate2 = Marshal.GetFunctionPointerForDelegate(runCall);
		IntPtr functionPointerForDelegate3 = Marshal.GetFunctionPointerForDelegate(getCallbackSizeBytes);
		IntPtr intPtr = Marshal.AllocHGlobal(IntPtr.Size * 3);
		_ = IntPtr.Size;
		Marshal.WriteIntPtr(intPtr, 0, functionPointerForDelegate);
		Marshal.WriteIntPtr(intPtr, IntPtr.Size, functionPointerForDelegate2);
		Marshal.WriteIntPtr(intPtr, IntPtr.Size * 2, functionPointerForDelegate3);
		return intPtr;
	}

	public void Dispose()
	{
		if (!IsAllocated)
		{
			return;
		}
		IsAllocated = false;
		if (!PinnedCallback.IsAllocated)
		{
			throw new Exception("Callback isn't allocated!?");
		}
		SteamClient.UnregisterCallback(PinnedCallback.AddrOfPinnedObject());
		foreach (GCHandle allocation in Allocations)
		{
			if (allocation.IsAllocated)
			{
				allocation.Free();
			}
		}
		Allocations = null;
		PinnedCallback.Free();
		if (vTablePtr != IntPtr.Zero)
		{
			Marshal.FreeHGlobal(vTablePtr);
			vTablePtr = IntPtr.Zero;
		}
	}

	~Event()
	{
		Dispose();
	}
}
