using System;
using System.Collections.Generic;
using System.Threading;
using Facepunch.Steamworks;
using Facepunch.Steamworks.Interop;
using SteamNative;

public class BaseSteamworks : IDisposable
{
	internal NativeInterface native;

	private List<CallbackHandle> CallbackHandles = new List<CallbackHandle>();

	public uint AppId { get; internal set; }

	public Networking Networking { get; internal set; }

	public Inventory Inventory { get; internal set; }

	public Workshop Workshop { get; internal set; }

	public bool IsValid => native != null;

	internal virtual bool IsGameServer => false;

	internal event Action OnUpdate;

	public virtual void Dispose()
	{
		foreach (CallbackHandle callbackHandle in CallbackHandles)
		{
			callbackHandle.Dispose();
		}
		CallbackHandles.Clear();
		if (Workshop != null)
		{
			Workshop.Dispose();
			Workshop = null;
		}
		if (Inventory != null)
		{
			Inventory.Dispose();
			Inventory = null;
		}
		if (Networking != null)
		{
			Networking.Dispose();
			Networking = null;
		}
		if (native != null)
		{
			native.Dispose();
			native = null;
		}
	}

	protected void SetupCommonInterfaces()
	{
		Networking = new Networking(this, native.networking);
		Inventory = new Inventory(this, native.inventory, IsGameServer);
		Workshop = new Workshop(this, native.ugc, native.remoteStorage);
	}

	internal void RegisterCallbackHandle(CallbackHandle handle)
	{
		CallbackHandles.Add(handle);
	}

	public virtual void Update()
	{
		Inventory.Update();
		Networking.Update();
		RunUpdateCallbacks();
	}

	public void RunUpdateCallbacks()
	{
		if (this.OnUpdate != null)
		{
			this.OnUpdate();
		}
	}

	public void UpdateWhile(Func<bool> func)
	{
		while (func())
		{
			Update();
			Thread.Sleep(1);
		}
	}
}
