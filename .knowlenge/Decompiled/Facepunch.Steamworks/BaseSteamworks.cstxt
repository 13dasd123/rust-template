using System;
using System.Collections.Generic;
using System.Threading;
using Facepunch.Steamworks;
using Facepunch.Steamworks.Interop;
using SteamNative;

public class BaseSteamworks : IDisposable
{
	internal NativeInterface native;

	private List<CallbackHandle> CallbackHandles = new List<CallbackHandle>();

	private List<CallResult> CallResults = new List<CallResult>();

	protected bool disposed;

	public Action<object> OnAnyCallback;

	private Dictionary<Type, List<Action<object>>> Callbacks = new Dictionary<Type, List<Action<object>>>();

	public uint AppId { get; internal set; }

	public Networking Networking { get; internal set; }

	public Inventory Inventory { get; internal set; }

	public Workshop Workshop { get; internal set; }

	public bool IsValid => native != null;

	internal virtual bool IsGameServer => false;

	internal event Action OnUpdate;

	protected BaseSteamworks(uint appId)
	{
		AppId = appId;
		Environment.SetEnvironmentVariable("SteamAppId", AppId.ToString());
		Environment.SetEnvironmentVariable("SteamGameId", AppId.ToString());
	}

	~BaseSteamworks()
	{
		Dispose();
	}

	public virtual void Dispose()
	{
		if (disposed)
		{
			return;
		}
		Callbacks.Clear();
		foreach (CallbackHandle callbackHandle in CallbackHandles)
		{
			callbackHandle.Dispose();
		}
		CallbackHandles.Clear();
		foreach (CallResult callResult in CallResults)
		{
			callResult.Dispose();
		}
		CallResults.Clear();
		if (Workshop != null)
		{
			Workshop.Dispose();
			Workshop = null;
		}
		if (Inventory != null)
		{
			Inventory.Dispose();
			Inventory = null;
		}
		if (Networking != null)
		{
			Networking.Dispose();
			Networking = null;
		}
		if (native != null)
		{
			native.Dispose();
			native = null;
		}
		Environment.SetEnvironmentVariable("SteamAppId", null);
		Environment.SetEnvironmentVariable("SteamGameId", null);
		disposed = true;
	}

	protected void SetupCommonInterfaces()
	{
		Networking = new Networking(this, native.networking);
		Inventory = new Inventory(this, native.inventory, IsGameServer);
		Workshop = new Workshop(this, native.ugc, native.remoteStorage);
	}

	internal void RegisterCallbackHandle(CallbackHandle handle)
	{
		CallbackHandles.Add(handle);
	}

	internal void RegisterCallResult(CallResult handle)
	{
		CallResults.Add(handle);
	}

	internal void UnregisterCallResult(CallResult handle)
	{
		CallResults.Remove(handle);
	}

	public virtual void Update()
	{
		Networking.Update();
		RunUpdateCallbacks();
	}

	public void RunUpdateCallbacks()
	{
		if (this.OnUpdate != null)
		{
			this.OnUpdate();
		}
		for (int i = 0; i < CallResults.Count; i++)
		{
			CallResults[i].Try();
		}
		SourceServerQuery.Cycle();
	}

	public void UpdateWhile(Func<bool> func)
	{
		while (func())
		{
			Update();
			Thread.Sleep(1);
		}
	}

	internal List<Action<object>> CallbackList(Type T)
	{
		List<Action<object>> value = null;
		if (!Callbacks.TryGetValue(T, out value))
		{
			value = new List<Action<object>>();
			Callbacks[T] = value;
		}
		return value;
	}

	internal void OnCallback<T>(T data)
	{
		foreach (Action<object> item in CallbackList(typeof(T)))
		{
			item(data);
		}
		if (OnAnyCallback != null)
		{
			OnAnyCallback(data);
		}
	}

	internal void RegisterCallback<T>(Action<T> func)
	{
		CallbackList(typeof(T)).Add(delegate(object o)
		{
			func((T)o);
		});
	}
}
