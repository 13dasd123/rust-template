using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch.Steamworks;
using SteamNative;

public class RemoteStorage : IDisposable
{
	internal Client client;

	internal SteamRemoteStorage native;

	private bool _filesInvalid = true;

	private readonly List<RemoteFile> _files = new List<RemoteFile>();

	public bool IsCloudEnabledForAccount => native.IsCloudEnabledForAccount();

	public bool IsCloudEnabledForApp => native.IsCloudEnabledForApp();

	public int FileCount => native.GetFileCount();

	public IEnumerable<RemoteFile> Files
	{
		get
		{
			UpdateFiles();
			return _files;
		}
	}

	public ulong QuotaUsed
	{
		get
		{
			ulong pnTotalBytes = 0uL;
			ulong puAvailableBytes = 0uL;
			if (!native.GetQuota(out pnTotalBytes, out puAvailableBytes))
			{
				return 0uL;
			}
			return pnTotalBytes - puAvailableBytes;
		}
	}

	public ulong QuotaTotal
	{
		get
		{
			ulong pnTotalBytes = 0uL;
			ulong puAvailableBytes = 0uL;
			if (!native.GetQuota(out pnTotalBytes, out puAvailableBytes))
			{
				return 0uL;
			}
			return pnTotalBytes;
		}
	}

	public ulong QuotaRemaining
	{
		get
		{
			ulong pnTotalBytes = 0uL;
			ulong puAvailableBytes = 0uL;
			if (!native.GetQuota(out pnTotalBytes, out puAvailableBytes))
			{
				return 0uL;
			}
			return puAvailableBytes;
		}
	}

	private static string NormalizePath(string path)
	{
		return Platform.IsWindows ? new FileInfo($"x:/{path}").FullName.Substring(3) : new FileInfo($"/x/{path}").FullName.Substring(3);
	}

	internal RemoteStorage(Client c)
	{
		client = c;
		native = client.native.remoteStorage;
	}

	public RemoteFile CreateFile(string path)
	{
		path = NormalizePath(path);
		InvalidateFiles();
		RemoteFile remoteFile = Files.FirstOrDefault((RemoteFile x) => x.FileName == path);
		return remoteFile ?? new RemoteFile(this, path, client.SteamId, 0);
	}

	public RemoteFile OpenFile(string path)
	{
		path = NormalizePath(path);
		InvalidateFiles();
		return Files.FirstOrDefault((RemoteFile x) => x.FileName == path);
	}

	public RemoteFile OpenSharedFile(ulong sharingId)
	{
		return new RemoteFile(this, sharingId);
	}

	public bool WriteString(string path, string text, Encoding encoding = null)
	{
		RemoteFile remoteFile = CreateFile(path);
		remoteFile.WriteAllText(text, encoding);
		return remoteFile.Exists;
	}

	public bool WriteBytes(string path, byte[] data)
	{
		RemoteFile remoteFile = CreateFile(path);
		remoteFile.WriteAllBytes(data);
		return remoteFile.Exists;
	}

	public string ReadString(string path, Encoding encoding = null)
	{
		return OpenFile(path)?.ReadAllText(encoding);
	}

	public byte[] ReadBytes(string path)
	{
		return OpenFile(path)?.ReadAllBytes();
	}

	internal void OnWrittenNewFile(RemoteFile file)
	{
		if (!_files.Any((RemoteFile x) => x.FileName == file.FileName))
		{
			_files.Add(file);
			file.Exists = true;
			InvalidateFiles();
		}
	}

	internal void InvalidateFiles()
	{
		_filesInvalid = true;
	}

	private void UpdateFiles()
	{
		if (!_filesInvalid)
		{
			return;
		}
		_filesInvalid = false;
		foreach (RemoteFile file in _files)
		{
			file.Exists = false;
		}
		int fileCount = FileCount;
		for (int i = 0; i < fileCount; i++)
		{
			int pnFileSizeInBytes;
			string name = NormalizePath(native.GetFileNameAndSize(i, out pnFileSizeInBytes));
			RemoteFile remoteFile = _files.FirstOrDefault((RemoteFile x) => x.FileName == name);
			if (remoteFile == null)
			{
				remoteFile = new RemoteFile(this, name, client.SteamId, pnFileSizeInBytes);
				_files.Add(remoteFile);
			}
			else
			{
				remoteFile.SizeInBytes = pnFileSizeInBytes;
			}
			remoteFile.Exists = true;
		}
		for (int num = _files.Count - 1; num >= 0; num--)
		{
			if (!_files[num].Exists)
			{
				_files.RemoveAt(num);
			}
		}
	}

	public bool FileExists(string path)
	{
		return native.FileExists(path);
	}

	public void Dispose()
	{
		client = null;
		native = null;
	}
}
