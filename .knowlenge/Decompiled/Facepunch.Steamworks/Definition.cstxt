using System;
using System.Collections.Generic;
using System.Linq;
using SteamNative;

public class Definition
{
	internal Inventory inventory;

	private Dictionary<string, string> customProperties;

	public int Id { get; private set; }

	public string Name { get; set; }

	public string Description { get; set; }

	public string IconUrl { get; set; }

	public string IconLargeUrl { get; set; }

	public string Type { get; set; }

	public string ExchangeSchema { get; set; }

	public Recipe[] Recipes { get; set; }

	public Recipe[] IngredientFor { get; set; }

	public DateTime Created { get; set; }

	public DateTime Modified { get; set; }

	public string PriceCategory { get; set; }

	public double PriceDollars { get; internal set; }

	public double LocalPrice { get; internal set; }

	public string LocalPriceFormatted { get; internal set; }

	public bool Marketable { get; set; }

	public bool IsGenerator => Type == "generator";

	internal Definition(Inventory i, int id)
	{
		inventory = i;
		Id = id;
		SetupCommonProperties();
		UpdatePrice();
	}

	public void SetProperty(string name, string value)
	{
		if (customProperties == null)
		{
			customProperties = new Dictionary<string, string>();
		}
		if (!customProperties.ContainsKey(name))
		{
			customProperties.Add(name, value);
		}
		else
		{
			customProperties[name] = value;
		}
	}

	public T GetProperty<T>(string name)
	{
		string stringProperty = GetStringProperty(name);
		if (string.IsNullOrEmpty(stringProperty))
		{
			return default(T);
		}
		try
		{
			return (T)Convert.ChangeType(stringProperty, typeof(T));
		}
		catch (Exception)
		{
			return default(T);
		}
	}

	public string GetStringProperty(string name)
	{
		string pchValueBuffer = string.Empty;
		if (customProperties != null && customProperties.ContainsKey(name))
		{
			return customProperties[name];
		}
		if (!inventory.inventory.GetItemDefinitionProperty(Id, name, out pchValueBuffer))
		{
			return string.Empty;
		}
		return pchValueBuffer;
	}

	public bool GetBoolProperty(string name)
	{
		string stringProperty = GetStringProperty(name);
		if (stringProperty.Length == 0)
		{
			return false;
		}
		if (stringProperty[0] == '0' || stringProperty[0] == 'F' || stringProperty[0] == 'f')
		{
			return false;
		}
		return true;
	}

	internal void SetupCommonProperties()
	{
		Name = GetStringProperty("name");
		Description = GetStringProperty("description");
		Created = GetProperty<DateTime>("timestamp");
		Modified = GetProperty<DateTime>("modified");
		ExchangeSchema = GetStringProperty("exchange");
		IconUrl = GetStringProperty("icon_url");
		IconLargeUrl = GetStringProperty("icon_url_large");
		Type = GetStringProperty("type");
		PriceCategory = GetStringProperty("price_category");
		Marketable = GetBoolProperty("marketable");
		if (!string.IsNullOrEmpty(PriceCategory))
		{
			PriceDollars = PriceCategoryToFloat(PriceCategory);
		}
	}

	public void TriggerItemDrop()
	{
		SteamInventoryResult_t pResultHandle = 0;
		inventory.inventory.TriggerItemDrop(ref pResultHandle, Id);
		inventory.inventory.DestroyResult(pResultHandle);
	}

	internal void Link(Definition[] definitions)
	{
		LinkExchange(definitions);
	}

	private void LinkExchange(Definition[] definitions)
	{
		if (!string.IsNullOrEmpty(ExchangeSchema))
		{
			string[] source = ExchangeSchema.Split(new char[1] { ';' }, StringSplitOptions.RemoveEmptyEntries);
			Recipes = source.Select((string x) => Recipe.FromString(x, definitions, this)).ToArray();
		}
	}

	internal void InRecipe(Recipe r)
	{
		if (IngredientFor == null)
		{
			IngredientFor = new Recipe[0];
		}
		List<Recipe> list = new List<Recipe>(IngredientFor);
		list.Add(r);
		IngredientFor = list.ToArray();
	}

	internal void UpdatePrice()
	{
		if (inventory.inventory.GetItemPrice(Id, out var pPrice))
		{
			LocalPrice = (double)pPrice / 100.0;
			LocalPriceFormatted = Utility.FormatPrice(inventory.Currency, pPrice);
		}
		else
		{
			LocalPrice = 0.0;
			LocalPriceFormatted = null;
		}
	}
}
