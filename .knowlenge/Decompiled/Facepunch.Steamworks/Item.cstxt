using System;
using System.IO;
using System.Linq;
using Facepunch.Steamworks.Callbacks;
using SteamNative;

public class Item
{
	internal Workshop workshop;

	private DirectoryInfo _directory;

	private ulong _BytesDownloaded;

	private ulong _BytesTotal;

	private int YourVote;

	private string _ownerName;

	public string Description { get; private set; }

	public ulong Id { get; private set; }

	public ulong OwnerId { get; private set; }

	public float Score { get; private set; }

	public string[] Tags { get; private set; }

	public string Title { get; private set; }

	public uint VotesDown { get; private set; }

	public uint VotesUp { get; private set; }

	public DateTime Modified { get; private set; }

	public DateTime Created { get; private set; }

	public ulong BytesDownloaded
	{
		get
		{
			UpdateDownloadProgress();
			return _BytesDownloaded;
		}
	}

	public ulong BytesTotalDownload
	{
		get
		{
			UpdateDownloadProgress();
			return _BytesTotal;
		}
	}

	public double DownloadProgress
	{
		get
		{
			UpdateDownloadProgress();
			if (_BytesTotal == 0L)
			{
				return 0.0;
			}
			return (double)_BytesDownloaded / (double)_BytesTotal;
		}
	}

	public bool Installed => (State & ItemState.Installed) != 0;

	public bool Downloading => (State & ItemState.Downloading) != 0;

	public bool DownloadPending => (State & ItemState.DownloadPending) != 0;

	public bool Subscribed => (State & ItemState.Subscribed) != 0;

	public bool NeedsUpdate => (State & ItemState.NeedsUpdate) != 0;

	private ItemState State => (ItemState)workshop.ugc.GetItemState(Id);

	public DirectoryInfo Directory
	{
		get
		{
			if (_directory != null)
			{
				return _directory;
			}
			if (!Installed)
			{
				return null;
			}
			if (workshop.ugc.GetItemInstallInfo(Id, out var punSizeOnDisk, out var pchFolder, out var _))
			{
				_directory = new DirectoryInfo(pchFolder);
				Size = punSizeOnDisk;
				_ = _directory.Exists;
			}
			return _directory;
		}
	}

	public ulong Size { get; private set; }

	public string Url => $"http://steamcommunity.com/sharedfiles/filedetails/?source=Facepunch.Steamworks&id={Id}";

	public string ChangelogUrl => $"http://steamcommunity.com/sharedfiles/filedetails/changelog/{Id}";

	public string CommentsUrl => $"http://steamcommunity.com/sharedfiles/filedetails/comments/{Id}";

	public string DiscussUrl => $"http://steamcommunity.com/sharedfiles/filedetails/discussions/{Id}";

	public string StartsUrl => $"http://steamcommunity.com/sharedfiles/filedetails/stats/{Id}";

	public int SubscriptionCount { get; internal set; }

	public int FavouriteCount { get; internal set; }

	public int FollowerCount { get; internal set; }

	public int WebsiteViews { get; internal set; }

	public int ReportScore { get; internal set; }

	public string PreviewImageUrl { get; internal set; }

	public string OwnerName
	{
		get
		{
			if (_ownerName == null && workshop.friends != null)
			{
				_ownerName = workshop.friends.GetName(OwnerId);
				if (_ownerName == "[unknown]")
				{
					_ownerName = null;
					return string.Empty;
				}
			}
			if (_ownerName == null)
			{
				return string.Empty;
			}
			return _ownerName;
		}
	}

	public Item(ulong Id, Workshop workshop)
	{
		this.Id = Id;
		this.workshop = workshop;
	}

	internal static Item From(SteamUGCDetails_t details, Workshop workshop)
	{
		Item item = new Item(details.PublishedFileId, workshop);
		item.Title = details.Title;
		item.Description = details.Description;
		item.OwnerId = details.SteamIDOwner;
		item.Tags = (from x in details.Tags.Split(',')
			select x.ToLower()).ToArray();
		item.Score = details.Score;
		item.VotesUp = details.VotesUp;
		item.VotesDown = details.VotesDown;
		item.Modified = Utility.Epoch.ToDateTime(details.TimeUpdated);
		item.Created = Utility.Epoch.ToDateTime(details.TimeCreated);
		return item;
	}

	public bool Download(bool highPriority = true)
	{
		if (Installed)
		{
			return true;
		}
		if (Downloading)
		{
			return true;
		}
		if (!workshop.ugc.DownloadItem(Id, highPriority))
		{
			Console.WriteLine("Download Failed");
			return false;
		}
		workshop.OnFileDownloaded += OnFileDownloaded;
		workshop.OnItemInstalled += OnItemInstalled;
		return true;
	}

	public void Subscribe()
	{
		workshop.ugc.SubscribeItem(Id);
		SubscriptionCount++;
	}

	public void UnSubscribe()
	{
		workshop.ugc.UnsubscribeItem(Id);
		SubscriptionCount--;
	}

	private void OnFileDownloaded(ulong fileid, Facepunch.Steamworks.Callbacks.Result result)
	{
		if (fileid == Id)
		{
			workshop.OnFileDownloaded -= OnFileDownloaded;
		}
	}

	private void OnItemInstalled(ulong fileid)
	{
		if (fileid == Id)
		{
			workshop.OnItemInstalled -= OnItemInstalled;
		}
	}

	internal void UpdateDownloadProgress()
	{
		workshop.ugc.GetItemDownloadInfo(Id, out _BytesDownloaded, out _BytesTotal);
	}

	public void VoteUp()
	{
		if (YourVote != 1)
		{
			if (YourVote == -1)
			{
				VotesDown--;
			}
			VotesUp++;
			workshop.ugc.SetUserItemVote(Id, bVoteUp: true);
			YourVote = 1;
		}
	}

	public void VoteDown()
	{
		if (YourVote != -1)
		{
			if (YourVote == 1)
			{
				VotesUp--;
			}
			VotesDown++;
			workshop.ugc.SetUserItemVote(Id, bVoteUp: false);
			YourVote = -1;
		}
	}

	public Editor Edit()
	{
		return workshop.EditItem(Id);
	}
}
