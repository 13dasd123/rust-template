using System;
using System.Collections.Generic;
using Facepunch.Steamworks.Callbacks;
using SteamNative;

public class Result : IDisposable
{
	internal static Dictionary<int, Result> Pending;

	internal Inventory inventory;

	public Action<Result> OnResult;

	protected bool _gotResult;

	private SteamInventoryResult_t Handle { get; set; } = -1;

	public Item[] Items { get; internal set; }

	public Item[] Removed { get; internal set; }

	public Item[] Consumed { get; internal set; }

	public bool IsPending
	{
		get
		{
			if (_gotResult)
			{
				return false;
			}
			if (Status() == Facepunch.Steamworks.Callbacks.Result.OK)
			{
				Fill();
				return false;
			}
			return Status() == Facepunch.Steamworks.Callbacks.Result.Pending;
		}
	}

	internal uint Timestamp { get; private set; }

	internal bool IsSuccess
	{
		get
		{
			if (Items != null)
			{
				return true;
			}
			if ((int)Handle == -1)
			{
				return false;
			}
			return Status() == Facepunch.Steamworks.Callbacks.Result.OK;
		}
	}

	internal Facepunch.Steamworks.Callbacks.Result Status()
	{
		if ((int)Handle == -1)
		{
			return Facepunch.Steamworks.Callbacks.Result.InvalidParam;
		}
		return (Facepunch.Steamworks.Callbacks.Result)inventory.inventory.GetResultStatus(Handle);
	}

	internal Result(Inventory inventory, int Handle, bool pending)
	{
		if (pending)
		{
			Pending.Add(Handle, this);
		}
		this.Handle = Handle;
		this.inventory = inventory;
	}

	internal void Fill()
	{
		if (_gotResult || Items != null || Status() != Facepunch.Steamworks.Callbacks.Result.OK)
		{
			return;
		}
		_gotResult = true;
		Timestamp = inventory.inventory.GetResultTimestamp(Handle);
		SteamItemDetails_t[] resultItems = inventory.inventory.GetResultItems(Handle);
		if (resultItems == null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		List<Item> list2 = new List<Item>();
		List<Item> list3 = new List<Item>();
		for (int i = 0; i < resultItems.Length; i++)
		{
			Item item = inventory.ItemFrom(Handle, resultItems[i], i);
			if ((resultItems[i].Flags & 0x100) != 0)
			{
				list2.Add(item);
			}
			else if ((resultItems[i].Flags & 0x200) != 0)
			{
				list3.Add(item);
			}
			else
			{
				list.Add(item);
			}
		}
		Items = list.ToArray();
		Removed = list2.ToArray();
		Consumed = list3.ToArray();
		if (OnResult != null)
		{
			OnResult(this);
		}
	}

	internal void OnSteamResult(SteamInventoryResultReady_t data)
	{
		if (data.Result == SteamNative.Result.OK)
		{
			Fill();
		}
	}

	internal unsafe byte[] Serialize()
	{
		uint punOutBufferSize = 0u;
		if (!inventory.inventory.SerializeResult(Handle, IntPtr.Zero, out punOutBufferSize))
		{
			return null;
		}
		byte[] array = new byte[punOutBufferSize];
		fixed (byte* ptr = array)
		{
			if (!inventory.inventory.SerializeResult(Handle, (IntPtr)ptr, out punOutBufferSize))
			{
				return null;
			}
		}
		return array;
	}

	public void Dispose()
	{
		if ((int)Handle != -1 && inventory != null)
		{
			inventory.inventory.DestroyResult(Handle);
			Handle = -1;
		}
		inventory = null;
	}
}
