using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using Facepunch.Steamworks;
using Facepunch.Steamworks.Callbacks;
using SteamNative;

public class Workshop : IDisposable
{
	public enum Order
	{
		RankedByVote,
		RankedByPublicationDate,
		AcceptedForGameRankedByAcceptanceDate,
		RankedByTrend,
		FavoritedByFriendsRankedByPublicationDate,
		CreatedByFriendsRankedByPublicationDate,
		RankedByNumTimesReported,
		CreatedByFollowedUsersRankedByPublicationDate,
		NotYetRated,
		RankedByTotalVotesAsc,
		RankedByVotesUp,
		RankedByTextSearch,
		RankedByTotalUniqueSubscriptions
	}

	public enum QueryType
	{
		Items,
		MicrotransactionItems,
		SubscriptionItems,
		Collections,
		Artwork,
		Videos,
		Screenshots,
		AllGuides,
		WebGuides,
		IntegratedGuides,
		UsableInGame,
		ControllerBindings,
		GameManagedItems
	}

	public enum ItemType
	{
		Community,
		Microtransaction,
		Collection,
		Art,
		Video,
		Screenshot,
		Game,
		Software,
		Concept,
		WebGuide,
		IntegratedGuide,
		Merch,
		ControllerBinding,
		SteamworksAccessInvite,
		SteamVideo,
		GameManagedItem
	}

	public enum UserQueryType : uint
	{
		Published,
		VotedOn,
		VotedUp,
		VotedDown,
		WillVoteLater,
		Favorited,
		Subscribed,
		UsedOrPlayed,
		Followed
	}

	public class Editor
	{
		public enum VisibilityType
		{
			Public,
			FriendsOnly,
			Private
		}

		internal Workshop workshop;

		internal CallbackHandle CreateItem;

		internal CallbackHandle SubmitItemUpdate;

		internal UGCUpdateHandle_t UpdateHandle;

		public ulong Id { get; internal set; }

		public string Title { get; set; } = null;

		public string Description { get; set; } = null;

		public string Folder { get; set; } = null;

		public string PreviewImage { get; set; } = null;

		public List<string> Tags { get; set; } = new List<string>();

		public bool Publishing { get; internal set; }

		public ItemType? Type { get; set; }

		public string Error { get; internal set; } = null;

		public string ChangeNote { get; set; } = "";

		public VisibilityType? Visibility { get; set; }

		public bool NeedToAgreeToWorkshopLegal { get; internal set; }

		public double Progress
		{
			get
			{
				if (!Publishing)
				{
					return 1.0;
				}
				if (CreateItem != null)
				{
					return 0.0;
				}
				if (SubmitItemUpdate == null)
				{
					return 1.0;
				}
				ulong punBytesProcessed = 0uL;
				ulong punBytesTotal = 0uL;
				workshop.steamworks.native.ugc.GetItemUpdateProgress(UpdateHandle, out punBytesProcessed, out punBytesTotal);
				if (punBytesTotal == 0)
				{
					return 0.0;
				}
				return (double)punBytesProcessed / (double)punBytesTotal;
			}
		}

		public int BytesUploaded
		{
			get
			{
				if (!Publishing)
				{
					return 0;
				}
				if (CreateItem != null)
				{
					return 0;
				}
				if (SubmitItemUpdate == null)
				{
					return 0;
				}
				ulong punBytesProcessed = 0uL;
				ulong punBytesTotal = 0uL;
				workshop.steamworks.native.ugc.GetItemUpdateProgress(UpdateHandle, out punBytesProcessed, out punBytesTotal);
				return (int)punBytesProcessed;
			}
		}

		public int BytesTotal
		{
			get
			{
				if (!Publishing)
				{
					return 0;
				}
				if (CreateItem != null)
				{
					return 0;
				}
				if (SubmitItemUpdate == null)
				{
					return 0;
				}
				ulong punBytesProcessed = 0uL;
				ulong punBytesTotal = 0uL;
				workshop.steamworks.native.ugc.GetItemUpdateProgress(UpdateHandle, out punBytesProcessed, out punBytesTotal);
				return (int)punBytesTotal;
			}
		}

		public void Publish()
		{
			Publishing = true;
			Error = null;
			if (Id == 0)
			{
				StartCreatingItem();
			}
			else
			{
				PublishChanges();
			}
		}

		private void StartCreatingItem()
		{
			if (!Type.HasValue)
			{
				throw new Exception("Editor.Type must be set when creating a new item!");
			}
			CreateItem = workshop.ugc.CreateItem(workshop.steamworks.AppId, (WorkshopFileType)Type.Value, OnItemCreated);
		}

		private void OnItemCreated(CreateItemResult_t obj, bool Failed)
		{
			NeedToAgreeToWorkshopLegal = obj.UserNeedsToAcceptWorkshopLegalAgreement;
			CreateItem.Dispose();
			if (obj.Result == SteamNative.Result.OK && !Failed)
			{
				Id = obj.PublishedFileId;
				PublishChanges();
				return;
			}
			Error = "Error creating new file: " + obj.Result.ToString() + "(" + obj.PublishedFileId + ")";
			Publishing = false;
		}

		private void PublishChanges()
		{
			UpdateHandle = workshop.ugc.StartItemUpdate(workshop.steamworks.AppId, Id);
			if (Title != null)
			{
				workshop.ugc.SetItemTitle(UpdateHandle, Title);
			}
			if (Description != null)
			{
				workshop.ugc.SetItemDescription(UpdateHandle, Description);
			}
			if (Folder != null)
			{
				DirectoryInfo directoryInfo = new DirectoryInfo(Folder);
				if (!directoryInfo.Exists)
				{
					throw new Exception($"Folder doesn't exist ({Folder})");
				}
				workshop.ugc.SetItemContent(UpdateHandle, Folder);
			}
			if (Tags != null && Tags.Count > 0)
			{
				workshop.ugc.SetItemTags(UpdateHandle, Tags.ToArray());
			}
			if (Visibility.HasValue)
			{
				workshop.ugc.SetItemVisibility(UpdateHandle, (RemoteStoragePublishedFileVisibility)Visibility.Value);
			}
			if (PreviewImage != null)
			{
				FileInfo fileInfo = new FileInfo(PreviewImage);
				if (!fileInfo.Exists)
				{
					throw new Exception($"PreviewImage doesn't exist ({PreviewImage})");
				}
				if (fileInfo.Length >= 1048576)
				{
					throw new Exception($"PreviewImage should be under 1MB ({fileInfo.Length})");
				}
				workshop.ugc.SetItemPreview(UpdateHandle, PreviewImage);
			}
			SubmitItemUpdate = workshop.ugc.SubmitItemUpdate(UpdateHandle, ChangeNote, OnChangesSubmitted);
		}

		private void OnChangesSubmitted(SubmitItemUpdateResult_t obj, bool Failed)
		{
			if (Failed)
			{
				throw new Exception("CreateItemResult_t Failed");
			}
			SubmitItemUpdate = null;
			NeedToAgreeToWorkshopLegal = obj.UserNeedsToAcceptWorkshopLegalAgreement;
			Publishing = false;
			if (obj.Result != SteamNative.Result.OK)
			{
				Error = "Error publishing changes: " + obj.Result.ToString() + " (" + NeedToAgreeToWorkshopLegal + ")";
			}
		}

		public void Delete()
		{
			workshop.remoteStorage.DeletePublishedFile(Id);
			Id = 0uL;
		}
	}

	public class Item
	{
		internal Workshop workshop;

		private DirectoryInfo _directory;

		private ulong _BytesDownloaded;

		private ulong _BytesTotal;

		private int YourVote = 0;

		private string _ownerName = null;

		public string Description { get; private set; }

		public ulong Id { get; private set; }

		public ulong OwnerId { get; private set; }

		public float Score { get; private set; }

		public string[] Tags { get; private set; }

		public string Title { get; private set; }

		public uint VotesDown { get; private set; }

		public uint VotesUp { get; private set; }

		public DateTime Modified { get; private set; }

		public DateTime Created { get; private set; }

		public ulong BytesDownloaded
		{
			get
			{
				UpdateDownloadProgress();
				return _BytesDownloaded;
			}
		}

		public ulong BytesTotalDownload
		{
			get
			{
				UpdateDownloadProgress();
				return _BytesTotal;
			}
		}

		public double DownloadProgress
		{
			get
			{
				UpdateDownloadProgress();
				if (_BytesTotal == 0)
				{
					return 0.0;
				}
				return (double)_BytesDownloaded / (double)_BytesTotal;
			}
		}

		public bool Installed => (State & ItemState.Installed) != 0;

		public bool Downloading => (State & ItemState.Downloading) != 0;

		public bool DownloadPending => (State & ItemState.DownloadPending) != 0;

		public bool Subscribed => (State & ItemState.Subscribed) != 0;

		public bool NeedsUpdate => (State & ItemState.NeedsUpdate) != 0;

		private ItemState State => (ItemState)workshop.ugc.GetItemState(Id);

		public DirectoryInfo Directory
		{
			get
			{
				if (_directory != null)
				{
					return _directory;
				}
				if (!Installed)
				{
					return null;
				}
				if (workshop.ugc.GetItemInstallInfo(Id, out var punSizeOnDisk, out var pchFolder, out var _))
				{
					_directory = new DirectoryInfo(pchFolder);
					Size = punSizeOnDisk;
					if (_directory.Exists)
					{
					}
				}
				return _directory;
			}
		}

		public ulong Size { get; private set; }

		public string Url => $"http://steamcommunity.com/sharedfiles/filedetails/?source=Facepunch.Steamworks&id={Id}";

		public string ChangelogUrl => $"http://steamcommunity.com/sharedfiles/filedetails/changelog/{Id}";

		public string CommentsUrl => $"http://steamcommunity.com/sharedfiles/filedetails/comments/{Id}";

		public string DiscussUrl => $"http://steamcommunity.com/sharedfiles/filedetails/discussions/{Id}";

		public string StartsUrl => $"http://steamcommunity.com/sharedfiles/filedetails/stats/{Id}";

		public int SubscriptionCount { get; internal set; }

		public int FavouriteCount { get; internal set; }

		public int FollowerCount { get; internal set; }

		public int WebsiteViews { get; internal set; }

		public int ReportScore { get; internal set; }

		public string PreviewImageUrl { get; internal set; }

		public string OwnerName
		{
			get
			{
				if (_ownerName == null && workshop.friends != null)
				{
					_ownerName = workshop.friends.GetName(OwnerId);
					if (_ownerName == "[unknown]")
					{
						_ownerName = null;
						return string.Empty;
					}
				}
				if (_ownerName == null)
				{
					return string.Empty;
				}
				return _ownerName;
			}
		}

		public Item(ulong Id, Workshop workshop)
		{
			this.Id = Id;
			this.workshop = workshop;
		}

		internal static Item From(SteamUGCDetails_t details, Workshop workshop)
		{
			Item item = new Item(details.PublishedFileId, workshop);
			item.Title = details.Title;
			item.Description = details.Description;
			item.OwnerId = details.SteamIDOwner;
			item.Tags = (from x in details.Tags.Split(',')
				select x.ToLower()).ToArray();
			item.Score = details.Score;
			item.VotesUp = details.VotesUp;
			item.VotesDown = details.VotesDown;
			item.Modified = Utility.Epoch.ToDateTime(details.TimeUpdated);
			item.Created = Utility.Epoch.ToDateTime(details.TimeCreated);
			return item;
		}

		public void Download(bool highPriority = true)
		{
			if (!Installed && !Downloading)
			{
				if (!workshop.ugc.DownloadItem(Id, highPriority))
				{
					Console.WriteLine("Download Failed");
					return;
				}
				workshop.OnFileDownloaded += OnFileDownloaded;
				workshop.OnItemInstalled += OnItemInstalled;
			}
		}

		public void Subscribe()
		{
			workshop.ugc.SubscribeItem(Id);
			SubscriptionCount++;
		}

		public void UnSubscribe()
		{
			workshop.ugc.UnsubscribeItem(Id);
			SubscriptionCount--;
		}

		private void OnFileDownloaded(ulong fileid, Facepunch.Steamworks.Callbacks.Result result)
		{
			if (fileid == Id)
			{
				workshop.OnFileDownloaded -= OnFileDownloaded;
			}
		}

		private void OnItemInstalled(ulong fileid)
		{
			if (fileid == Id)
			{
				workshop.OnItemInstalled -= OnItemInstalled;
			}
		}

		internal void UpdateDownloadProgress()
		{
			workshop.ugc.GetItemDownloadInfo(Id, out _BytesDownloaded, out _BytesTotal);
		}

		public void VoteUp()
		{
			if (YourVote != 1)
			{
				if (YourVote == -1)
				{
					VotesDown--;
				}
				VotesUp++;
				workshop.ugc.SetUserItemVote(Id, bVoteUp: true);
				YourVote = 1;
			}
		}

		public void VoteDown()
		{
			if (YourVote != -1)
			{
				if (YourVote == 1)
				{
					VotesUp--;
				}
				VotesDown++;
				workshop.ugc.SetUserItemVote(Id, bVoteUp: false);
				YourVote = -1;
			}
		}

		public Editor Edit()
		{
			return workshop.EditItem(Id);
		}
	}

	public class Query : IDisposable
	{
		internal const int SteamResponseSize = 50;

		internal UGCQueryHandle_t Handle;

		internal CallbackHandle Callback;

		public Action<Query> OnResult;

		internal Workshop workshop;

		internal Friends friends;

		private int _resultPage = 0;

		private int _resultsRemain = 0;

		private int _resultSkip = 0;

		private List<Item> _results;

		public uint AppId { get; set; }

		public uint UploaderAppId { get; set; }

		public QueryType QueryType { get; set; } = QueryType.Items;

		public Order Order { get; set; } = Order.RankedByVote;

		public string SearchText { get; set; }

		public Item[] Items { get; set; }

		public int TotalResults { get; set; }

		public ulong? UserId { get; set; }

		public int RankedByTrendDays { get; set; }

		public UserQueryType UserQueryType { get; set; } = UserQueryType.Published;

		public int Page { get; set; } = 1;

		public int PerPage { get; set; } = 50;

		public bool IsRunning => Callback != null;

		public List<string> RequireTags { get; set; } = new List<string>();

		public bool RequireAllTags { get; set; } = false;

		public List<string> ExcludeTags { get; set; } = new List<string>();

		public List<ulong> FileId { get; set; } = new List<ulong>();

		public void Run()
		{
			if (Callback == null)
			{
				if (Page <= 0)
				{
					throw new Exception("Page should be 1 or above");
				}
				int num = (Page - 1) * PerPage;
				TotalResults = 0;
				_resultSkip = num % 50;
				_resultsRemain = PerPage;
				_resultPage = (int)Math.Floor((float)num / 50f);
				_results = new List<Item>();
				RunInternal();
			}
		}

		private void RunInternal()
		{
			if (FileId.Count != 0)
			{
				PublishedFileId_t[] array = ((IEnumerable<ulong>)FileId).Select((Func<ulong, PublishedFileId_t>)((ulong x) => x)).ToArray();
				_resultsRemain = array.Length;
				Handle = workshop.ugc.CreateQueryUGCDetailsRequest(array);
			}
			else if (UserId.HasValue)
			{
				uint num = (uint)(UserId.Value & 0xFFFFFFFFu);
				Handle = workshop.ugc.CreateQueryUserUGCRequest(num, (UserUGCList)UserQueryType, (UGCMatchingUGCType)QueryType, UserUGCListSortOrder.LastUpdatedDesc, UploaderAppId, AppId, (uint)(_resultPage + 1));
			}
			else
			{
				Handle = workshop.ugc.CreateQueryAllUGCRequest((UGCQuery)Order, (UGCMatchingUGCType)QueryType, UploaderAppId, AppId, (uint)(_resultPage + 1));
			}
			if (!string.IsNullOrEmpty(SearchText))
			{
				workshop.ugc.SetSearchText(Handle, SearchText);
			}
			foreach (string requireTag in RequireTags)
			{
				workshop.ugc.AddRequiredTag(Handle, requireTag);
			}
			if (RequireTags.Count > 0)
			{
				workshop.ugc.SetMatchAnyTag(Handle, !RequireAllTags);
			}
			if (RankedByTrendDays > 0)
			{
				workshop.ugc.SetRankedByTrendDays(Handle, (uint)RankedByTrendDays);
			}
			foreach (string excludeTag in ExcludeTags)
			{
				workshop.ugc.AddExcludedTag(Handle, excludeTag);
			}
			Callback = workshop.ugc.SendQueryUGCRequest(Handle, ResultCallback);
		}

		private void ResultCallback(SteamUGCQueryCompleted_t data, bool bFailed)
		{
			if (bFailed)
			{
				throw new Exception("bFailed!");
			}
			int num = 0;
			for (int i = 0; i < data.NumResultsReturned; i++)
			{
				if (_resultSkip > 0)
				{
					_resultSkip--;
					continue;
				}
				SteamUGCDetails_t details = default(SteamUGCDetails_t);
				if (workshop.ugc.GetQueryUGCResult(data.Handle, (uint)i, ref details) && !_results.Any((Item x) => x.Id == details.PublishedFileId))
				{
					Item item = Item.From(details, workshop);
					item.SubscriptionCount = GetStat(data.Handle, i, ItemStatistic.NumSubscriptions);
					item.FavouriteCount = GetStat(data.Handle, i, ItemStatistic.NumFavorites);
					item.FollowerCount = GetStat(data.Handle, i, ItemStatistic.NumFollowers);
					item.WebsiteViews = GetStat(data.Handle, i, ItemStatistic.NumUniqueWebsiteViews);
					item.ReportScore = GetStat(data.Handle, i, ItemStatistic.ReportScore);
					string pchURL = null;
					if (workshop.ugc.GetQueryUGCPreviewURL(data.Handle, (uint)i, out pchURL))
					{
						item.PreviewImageUrl = pchURL;
					}
					_results.Add(item);
					_resultsRemain--;
					num++;
					if (_resultsRemain <= 0)
					{
						break;
					}
				}
			}
			TotalResults = ((TotalResults > data.TotalMatchingResults) ? TotalResults : ((int)data.TotalMatchingResults));
			Callback.Dispose();
			Callback = null;
			_resultPage++;
			if (_resultsRemain > 0 && num > 0)
			{
				RunInternal();
				return;
			}
			Items = _results.ToArray();
			if (OnResult != null)
			{
				OnResult(this);
			}
		}

		private int GetStat(ulong handle, int index, ItemStatistic stat)
		{
			ulong pStatValue = 0uL;
			if (!workshop.ugc.GetQueryUGCStatistic(handle, (uint)index, (SteamNative.ItemStatistic)stat, out pStatValue))
			{
				return 0;
			}
			return (int)pStatValue;
		}

		public void Block()
		{
			workshop.steamworks.Update();
			while (IsRunning)
			{
				Thread.Sleep(10);
				workshop.steamworks.Update();
			}
		}

		public void Dispose()
		{
		}
	}

	private enum ItemStatistic : uint
	{
		NumSubscriptions,
		NumFavorites,
		NumFollowers,
		NumUniqueSubscriptions,
		NumUniqueFavorites,
		NumUniqueFollowers,
		NumUniqueWebsiteViews,
		ReportScore
	}

	internal const ulong InvalidHandle = ulong.MaxValue;

	internal SteamUGC ugc;

	internal Friends friends;

	internal BaseSteamworks steamworks;

	internal SteamRemoteStorage remoteStorage;

	public event Action<ulong, Facepunch.Steamworks.Callbacks.Result> OnFileDownloaded;

	public event Action<ulong> OnItemInstalled;

	internal Workshop(BaseSteamworks steamworks, SteamUGC ugc, SteamRemoteStorage remoteStorage)
	{
		this.ugc = ugc;
		this.steamworks = steamworks;
		this.remoteStorage = remoteStorage;
		DownloadItemResult_t.RegisterCallback(steamworks, onDownloadResult);
		ItemInstalled_t.RegisterCallback(steamworks, onItemInstalled);
	}

	public void Dispose()
	{
		ugc = null;
		steamworks = null;
		remoteStorage = null;
		friends = null;
		this.OnFileDownloaded = null;
		this.OnItemInstalled = null;
	}

	private void onItemInstalled(ItemInstalled_t obj, bool failed)
	{
		if (this.OnItemInstalled != null && obj.AppID == Client.Instance.AppId)
		{
			this.OnItemInstalled(obj.PublishedFileId);
		}
	}

	private void onDownloadResult(DownloadItemResult_t obj, bool failed)
	{
		if (this.OnFileDownloaded != null && obj.AppID == Client.Instance.AppId)
		{
			this.OnFileDownloaded(obj.PublishedFileId, (Facepunch.Steamworks.Callbacks.Result)obj.Result);
		}
	}

	public Query CreateQuery()
	{
		return new Query
		{
			AppId = steamworks.AppId,
			workshop = this,
			friends = friends
		};
	}

	public Editor CreateItem(ItemType type)
	{
		return new Editor
		{
			workshop = this,
			Type = type
		};
	}

	public Editor EditItem(ulong itemId)
	{
		return new Editor
		{
			workshop = this,
			Id = itemId
		};
	}

	public Item GetItem(ulong itemid)
	{
		return new Item(itemid, this);
	}
}
