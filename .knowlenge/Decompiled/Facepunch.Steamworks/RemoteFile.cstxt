using System;
using System.IO;
using System.Text;
using Facepunch.Steamworks;
using Facepunch.Steamworks.Callbacks;
using SteamNative;

public class RemoteFile
{
	public delegate void DownloadCallback();

	public delegate void ShareCallback();

	internal readonly RemoteStorage remoteStorage;

	private readonly bool _isUgc;

	private string _fileName;

	private int _sizeInBytes = -1;

	private long _timestamp;

	private UGCHandle_t _handle;

	private ulong _ownerId;

	private bool _isDownloading;

	private byte[] _downloadedData;

	public bool Exists { get; internal set; }

	public bool IsDownloading
	{
		get
		{
			if (_isUgc && _isDownloading)
			{
				return _downloadedData == null;
			}
			return false;
		}
	}

	public bool IsDownloaded
	{
		get
		{
			if (_isUgc)
			{
				return _downloadedData != null;
			}
			return true;
		}
	}

	public bool IsShared => _handle.Value != 0;

	internal UGCHandle_t UGCHandle => _handle;

	public ulong SharingId => UGCHandle.Value;

	public string FileName
	{
		get
		{
			if (_fileName != null)
			{
				return _fileName;
			}
			GetUGCDetails();
			return _fileName;
		}
	}

	public ulong OwnerId
	{
		get
		{
			if (_ownerId != 0L)
			{
				return _ownerId;
			}
			GetUGCDetails();
			return _ownerId;
		}
	}

	public int SizeInBytes
	{
		get
		{
			if (_sizeInBytes != -1)
			{
				return _sizeInBytes;
			}
			if (_isUgc)
			{
				throw new NotImplementedException();
			}
			_sizeInBytes = remoteStorage.native.GetFileSize(FileName);
			return _sizeInBytes;
		}
		internal set
		{
			_sizeInBytes = value;
		}
	}

	public long FileTimestamp
	{
		get
		{
			if (_timestamp != 0L)
			{
				return _timestamp;
			}
			if (_isUgc)
			{
				throw new NotImplementedException();
			}
			_timestamp = remoteStorage.native.GetFileTimestamp(FileName);
			return _timestamp;
		}
		internal set
		{
			_timestamp = value;
		}
	}

	internal RemoteFile(RemoteStorage r, UGCHandle_t handle)
	{
		Exists = true;
		remoteStorage = r;
		_isUgc = true;
		_handle = handle;
	}

	internal RemoteFile(RemoteStorage r, string name, ulong ownerId, int sizeInBytes = -1, long timestamp = 0L)
	{
		remoteStorage = r;
		_isUgc = false;
		_fileName = name;
		_ownerId = ownerId;
		_sizeInBytes = sizeInBytes;
		_timestamp = timestamp;
	}

	public RemoteFileWriteStream OpenWrite()
	{
		if (_isUgc)
		{
			throw new InvalidOperationException("Cannot write to a shared file.");
		}
		return new RemoteFileWriteStream(remoteStorage, this);
	}

	public void WriteAllBytes(byte[] buffer)
	{
		using RemoteFileWriteStream remoteFileWriteStream = OpenWrite();
		remoteFileWriteStream.Write(buffer, 0, buffer.Length);
	}

	public void WriteAllText(string text, Encoding encoding = null)
	{
		if (encoding == null)
		{
			encoding = Encoding.UTF8;
		}
		WriteAllBytes(encoding.GetBytes(text));
	}

	public bool GetDownloadProgress(out int bytesDownloaded, out int bytesExpected)
	{
		return remoteStorage.native.GetUGCDownloadProgress(_handle, out bytesDownloaded, out bytesExpected);
	}

	public unsafe bool Download(DownloadCallback onSuccess = null, FailureCallback onFailure = null)
	{
		if (!_isUgc)
		{
			return false;
		}
		if (_isDownloading)
		{
			return false;
		}
		if (IsDownloaded)
		{
			return false;
		}
		_isDownloading = true;
		remoteStorage.native.UGCDownload(_handle, 1000u, delegate(RemoteStorageDownloadUGCResult_t result, bool error)
		{
			_isDownloading = false;
			if (error || result.Result != SteamNative.Result.OK)
			{
				onFailure?.Invoke((Facepunch.Steamworks.Callbacks.Result)((result.Result == (SteamNative.Result)0) ? SteamNative.Result.IOFailure : result.Result));
			}
			else
			{
				_ownerId = result.SteamIDOwner;
				_sizeInBytes = result.SizeInBytes;
				_fileName = result.PchFileName;
				_downloadedData = new byte[_sizeInBytes];
				fixed (byte* downloadedData = _downloadedData)
				{
					remoteStorage.native.UGCRead(_handle, (IntPtr)downloadedData, _sizeInBytes, 0u, UGCReadAction.ontinueReading);
				}
				onSuccess?.Invoke();
			}
		});
		return true;
	}

	public Stream OpenRead()
	{
		return new MemoryStream(ReadAllBytes(), writable: false);
	}

	public unsafe byte[] ReadAllBytes()
	{
		if (_isUgc)
		{
			if (!IsDownloaded)
			{
				throw new Exception("Cannot read a file that hasn't been downloaded.");
			}
			return _downloadedData;
		}
		int sizeInBytes = SizeInBytes;
		byte[] array = new byte[sizeInBytes];
		fixed (byte* ptr = array)
		{
			remoteStorage.native.FileRead(FileName, (IntPtr)ptr, sizeInBytes);
		}
		return array;
	}

	public string ReadAllText(Encoding encoding = null)
	{
		if (encoding == null)
		{
			encoding = Encoding.UTF8;
		}
		return encoding.GetString(ReadAllBytes());
	}

	public bool Share(ShareCallback onSuccess = null, FailureCallback onFailure = null)
	{
		if (_isUgc)
		{
			return false;
		}
		if (_handle.Value != 0L)
		{
			return false;
		}
		remoteStorage.native.FileShare(FileName, delegate(RemoteStorageFileShareResult_t result, bool error)
		{
			if (!error && result.Result == SteamNative.Result.OK)
			{
				_handle.Value = result.File;
				onSuccess?.Invoke();
			}
			else
			{
				onFailure?.Invoke((Facepunch.Steamworks.Callbacks.Result)((result.Result == (SteamNative.Result)0) ? SteamNative.Result.IOFailure : result.Result));
			}
		});
		return true;
	}

	public bool Delete()
	{
		if (!Exists)
		{
			return false;
		}
		if (_isUgc)
		{
			return false;
		}
		if (!remoteStorage.native.FileDelete(FileName))
		{
			return false;
		}
		Exists = false;
		remoteStorage.InvalidateFiles();
		return true;
	}

	public bool Forget()
	{
		if (!Exists)
		{
			return false;
		}
		if (_isUgc)
		{
			return false;
		}
		return remoteStorage.native.FileForget(FileName);
	}

	private void GetUGCDetails()
	{
		if (!_isUgc)
		{
			throw new InvalidOperationException();
		}
		AppId_t appId_t = default(AppId_t);
		appId_t.Value = remoteStorage.native.steamworks.AppId;
		AppId_t pnAppID = appId_t;
		remoteStorage.native.GetUGCDetails(_handle, ref pnAppID, out _fileName, out var pSteamIDOwner);
		_ownerId = pSteamIDOwner.Value;
	}
}
