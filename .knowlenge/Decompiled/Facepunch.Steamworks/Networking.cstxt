using System;
using System.Collections.Generic;
using System.Diagnostics;
using Facepunch.Steamworks;
using SteamNative;

public class Networking : IDisposable
{
	public delegate void OnRecievedP2PData(ulong steamid, byte[] data, int dataLength, int channel);

	public enum SessionError : byte
	{
		None,
		NotRunningApp,
		NoRightsToApp,
		DestinationNotLoggedIn,
		Timeout,
		Max
	}

	public enum SendType
	{
		Unreliable,
		UnreliableNoDelay,
		Reliable,
		ReliableWithBuffering
	}

	private static byte[] ReceiveBuffer = new byte[65536];

	public OnRecievedP2PData OnP2PData;

	public Func<ulong, bool> OnIncomingConnection;

	public Action<ulong, SessionError> OnConnectionFailed;

	private List<int> ListenChannels = new List<int>();

	private Stopwatch UpdateTimer = Stopwatch.StartNew();

	internal SteamNetworking networking;

	internal Networking(BaseSteamworks steamworks, SteamNetworking networking)
	{
		this.networking = networking;
		steamworks.RegisterCallback<P2PSessionRequest_t>(onP2PConnectionRequest);
		steamworks.RegisterCallback<P2PSessionConnectFail_t>(onP2PConnectionFailed);
	}

	public void Dispose()
	{
		networking = null;
		OnIncomingConnection = null;
		OnConnectionFailed = null;
		OnP2PData = null;
		ListenChannels.Clear();
	}

	public void Update()
	{
		if (OnP2PData == null || UpdateTimer.Elapsed.TotalSeconds < 1.0 / 60.0)
		{
			return;
		}
		UpdateTimer.Reset();
		UpdateTimer.Start();
		foreach (int listenChannel in ListenChannels)
		{
			while (ReadP2PPacket(listenChannel))
			{
			}
		}
	}

	public void SetListenChannel(int ChannelId, bool Listen)
	{
		ListenChannels.RemoveAll((int x) => x == ChannelId);
		if (Listen)
		{
			ListenChannels.Add(ChannelId);
		}
	}

	private void onP2PConnectionRequest(P2PSessionRequest_t o)
	{
		if (OnIncomingConnection != null)
		{
			if (OnIncomingConnection(o.SteamIDRemote))
			{
				networking.AcceptP2PSessionWithUser(o.SteamIDRemote);
			}
			else
			{
				networking.CloseP2PSessionWithUser(o.SteamIDRemote);
			}
		}
		else
		{
			networking.CloseP2PSessionWithUser(o.SteamIDRemote);
		}
	}

	private void onP2PConnectionFailed(P2PSessionConnectFail_t o)
	{
		if (OnConnectionFailed != null)
		{
			OnConnectionFailed(o.SteamIDRemote, (SessionError)o.P2PSessionError);
		}
	}

	public unsafe bool SendP2PPacket(ulong steamid, byte[] data, int length, SendType eP2PSendType = SendType.Reliable, int nChannel = 0)
	{
		fixed (byte* ptr = data)
		{
			return networking.SendP2PPacket(steamid, (IntPtr)ptr, (uint)length, (P2PSend)eP2PSendType, nChannel);
		}
	}

	private unsafe bool ReadP2PPacket(int channel)
	{
		uint pcubMsgSize = 0u;
		if (!networking.IsP2PPacketAvailable(out pcubMsgSize, channel))
		{
			return false;
		}
		if (ReceiveBuffer.Length < pcubMsgSize)
		{
			ReceiveBuffer = new byte[pcubMsgSize + 1024];
		}
		fixed (byte* receiveBuffer = ReceiveBuffer)
		{
			CSteamID psteamIDRemote = 1uL;
			if (!networking.ReadP2PPacket((IntPtr)receiveBuffer, pcubMsgSize, out pcubMsgSize, out psteamIDRemote, channel) || pcubMsgSize == 0)
			{
				return false;
			}
			OnP2PData?.Invoke(psteamIDRemote, ReceiveBuffer, (int)pcubMsgSize, channel);
			return true;
		}
	}

	public bool CloseSession(ulong steamId)
	{
		return networking.CloseP2PSessionWithUser(steamId);
	}
}
