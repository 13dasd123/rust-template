using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Facepunch.Steamworks;
using Facepunch.Steamworks.Callbacks;
using SteamNative;

public class Inventory : IDisposable
{
	public class Definition
	{
		internal SteamInventory inventory;

		private Dictionary<string, string> customProperties;

		public int Id { get; private set; }

		public string Name { get; set; }

		public string Description { get; set; }

		public string IconUrl { get; set; }

		public string IconLargeUrl { get; set; }

		public string Type { get; set; }

		public string ExchangeSchema { get; set; }

		public Recipe[] Recipes { get; set; }

		public Recipe[] IngredientFor { get; set; }

		public DateTime Created { get; set; }

		public DateTime Modified { get; set; }

		public string PriceRaw { get; set; }

		public double PriceDollars { get; set; }

		public bool Marketable { get; set; }

		public bool IsGenerator => Type == "generator";

		internal Definition(SteamInventory i, int id)
		{
			inventory = i;
			Id = id;
			SetupCommonProperties();
		}

		public void SetProperty(string name, string value)
		{
			if (customProperties == null)
			{
				customProperties = new Dictionary<string, string>();
			}
			if (!customProperties.ContainsKey(name))
			{
				customProperties.Add(name, value);
			}
			else
			{
				customProperties[name] = value;
			}
		}

		public T GetProperty<T>(string name)
		{
			string stringProperty = GetStringProperty(name);
			if (string.IsNullOrEmpty(stringProperty))
			{
				return default(T);
			}
			try
			{
				return (T)Convert.ChangeType(stringProperty, typeof(T));
			}
			catch (Exception)
			{
				return default(T);
			}
		}

		public string GetStringProperty(string name)
		{
			string pchValueBuffer = string.Empty;
			if (customProperties != null && customProperties.ContainsKey(name))
			{
				return customProperties[name];
			}
			if (!inventory.GetItemDefinitionProperty(Id, name, out pchValueBuffer))
			{
				return string.Empty;
			}
			return pchValueBuffer;
		}

		public bool GetBoolProperty(string name)
		{
			string stringProperty = GetStringProperty(name);
			if (stringProperty.Length == 0)
			{
				return false;
			}
			if (stringProperty[0] == '0' || stringProperty[0] == 'F' || stringProperty[0] == 'f')
			{
				return false;
			}
			return true;
		}

		internal void SetupCommonProperties()
		{
			Name = GetStringProperty("name");
			Description = GetStringProperty("description");
			Created = GetProperty<DateTime>("timestamp");
			Modified = GetProperty<DateTime>("modified");
			ExchangeSchema = GetStringProperty("exchange");
			IconUrl = GetStringProperty("icon_url");
			IconLargeUrl = GetStringProperty("icon_url_large");
			Type = GetStringProperty("type");
			PriceRaw = GetStringProperty("price_category");
			Marketable = GetBoolProperty("marketable");
			if (!string.IsNullOrEmpty(PriceRaw))
			{
				PriceDollars = PriceCategoryToFloat(PriceRaw);
			}
		}

		public void TriggerItemDrop()
		{
			SteamInventoryResult_t pResultHandle = 0;
			inventory.TriggerItemDrop(ref pResultHandle, Id);
			inventory.DestroyResult(pResultHandle);
		}

		internal void Link(Definition[] definitions)
		{
			LinkExchange(definitions);
		}

		private void LinkExchange(Definition[] definitions)
		{
			if (!string.IsNullOrEmpty(ExchangeSchema))
			{
				string[] source = ExchangeSchema.Split(new char[1] { ';' }, StringSplitOptions.RemoveEmptyEntries);
				Recipes = source.Select((string x) => Recipe.FromString(x, definitions, this)).ToArray();
			}
		}

		internal void InRecipe(Recipe r)
		{
			if (IngredientFor == null)
			{
				IngredientFor = new Recipe[0];
			}
			List<Recipe> list = new List<Recipe>(IngredientFor);
			list.Add(r);
			IngredientFor = list.ToArray();
		}
	}

	public struct Recipe
	{
		public struct Ingredient
		{
			public int DefinitionId;

			public Definition Definition;

			public int Count;

			internal static Ingredient FromString(string part, Definition[] definitions)
			{
				Ingredient i = default(Ingredient);
				i.Count = 1;
				try
				{
					if (part.Contains('x'))
					{
						int num = part.IndexOf('x');
						int result = 0;
						if (int.TryParse(part.Substring(num + 1), out result))
						{
							i.Count = result;
						}
						part = part.Substring(0, num);
					}
					i.DefinitionId = int.Parse(part);
					i.Definition = definitions.FirstOrDefault((Definition x) => x.Id == i.DefinitionId);
				}
				catch (Exception)
				{
					return i;
				}
				return i;
			}
		}

		public Definition Result;

		public Ingredient[] Ingredients;

		internal static Recipe FromString(string part, Definition[] definitions, Definition Result)
		{
			Recipe recipe = default(Recipe);
			recipe.Result = Result;
			string[] source = part.Split(new char[1] { ',' }, StringSplitOptions.RemoveEmptyEntries);
			recipe.Ingredients = (from x in source
				select Ingredient.FromString(x, definitions) into x
				where x.DefinitionId != 0
				select x).ToArray();
			Ingredient[] ingredients = recipe.Ingredients;
			for (int i = 0; i < ingredients.Length; i++)
			{
				Ingredient ingredient = ingredients[i];
				if (ingredient.Definition != null)
				{
					ingredient.Definition.InRecipe(recipe);
				}
			}
			return recipe;
		}
	}

	public struct Item : IEquatable<Item>
	{
		public struct Amount
		{
			public Item Item;

			public int Quantity;
		}

		public ulong Id;

		public int Quantity;

		public int DefinitionId;

		public Definition Definition;

		public bool TradeLocked;

		public bool Equals(Item other)
		{
			return object.Equals(other, this);
		}

		public override bool Equals(object obj)
		{
			if (obj == null || GetType() != obj.GetType())
			{
				return false;
			}
			return ((Item)obj).Id == Id;
		}

		public override int GetHashCode()
		{
			return Id.GetHashCode();
		}

		public static bool operator ==(Item c1, Item c2)
		{
			return c1.Equals(c2);
		}

		public static bool operator !=(Item c1, Item c2)
		{
			return !c1.Equals(c2);
		}
	}

	public class Result : IDisposable
	{
		internal static Dictionary<int, Result> Pending;

		internal Inventory inventory;

		public Action<Result> OnResult;

		protected bool _gotResult = false;

		private SteamInventoryResult_t Handle { get; set; }

		public Item[] Items { get; internal set; }

		public Item[] Removed { get; internal set; }

		public Item[] Consumed { get; internal set; }

		public bool IsPending
		{
			get
			{
				if (_gotResult)
				{
					return false;
				}
				if (Status() == Facepunch.Steamworks.Callbacks.Result.OK)
				{
					Fill();
					return false;
				}
				return Status() == Facepunch.Steamworks.Callbacks.Result.Pending;
			}
		}

		internal uint Timestamp { get; private set; }

		internal bool IsSuccess
		{
			get
			{
				if (Items != null)
				{
					return true;
				}
				if ((int)Handle == -1)
				{
					return false;
				}
				return Status() == Facepunch.Steamworks.Callbacks.Result.OK;
			}
		}

		internal Facepunch.Steamworks.Callbacks.Result Status()
		{
			if ((int)Handle == -1)
			{
				return Facepunch.Steamworks.Callbacks.Result.InvalidParam;
			}
			return (Facepunch.Steamworks.Callbacks.Result)inventory.inventory.GetResultStatus(Handle);
		}

		internal Result(Inventory inventory, int Handle, bool pending)
		{
			if (pending)
			{
				Pending.Add(Handle, this);
			}
			this.Handle = Handle;
			this.inventory = inventory;
		}

		internal void Fill()
		{
			if (_gotResult || Items != null || Status() != Facepunch.Steamworks.Callbacks.Result.OK)
			{
				return;
			}
			_gotResult = true;
			Timestamp = inventory.inventory.GetResultTimestamp(Handle);
			SteamItemDetails_t[] resultItems = inventory.inventory.GetResultItems(Handle);
			if (resultItems != null)
			{
				Items = resultItems.Where((SteamItemDetails_t x) => (x.Flags & 0x100) != 256 && (x.Flags & 0x200) != 512).Select(delegate(SteamItemDetails_t x)
				{
					Item result = default(Item);
					result.Quantity = x.Quantity;
					result.Id = x.ItemId;
					result.DefinitionId = x.Definition;
					result.TradeLocked = (x.Flags & 1) != 0;
					result.Definition = inventory.FindDefinition(x.Definition);
					return result;
				}).ToArray();
				Removed = resultItems.Where((SteamItemDetails_t x) => (x.Flags & 0x100) != 0).Select(delegate(SteamItemDetails_t x)
				{
					Item result2 = default(Item);
					result2.Quantity = x.Quantity;
					result2.Id = x.ItemId;
					result2.DefinitionId = x.Definition;
					result2.TradeLocked = (x.Flags & 1) != 0;
					result2.Definition = inventory.FindDefinition(x.Definition);
					return result2;
				}).ToArray();
				Consumed = resultItems.Where((SteamItemDetails_t x) => (x.Flags & 0x200) != 0).Select(delegate(SteamItemDetails_t x)
				{
					Item result3 = default(Item);
					result3.Quantity = x.Quantity;
					result3.Id = x.ItemId;
					result3.DefinitionId = x.Definition;
					result3.TradeLocked = (x.Flags & 1) != 0;
					result3.Definition = inventory.FindDefinition(x.Definition);
					return result3;
				}).ToArray();
				if (OnResult != null)
				{
					OnResult(this);
				}
			}
		}

		internal void OnSteamResult(SteamInventoryResultReady_t data, bool error)
		{
			if (data.Esult == SteamNative.Result.OK && !error)
			{
				Fill();
			}
		}

		internal unsafe byte[] Serialize()
		{
			uint punOutBufferSize = 0u;
			if (!inventory.inventory.SerializeResult(Handle, IntPtr.Zero, out punOutBufferSize))
			{
				return null;
			}
			byte[] array = new byte[punOutBufferSize];
			fixed (byte* ptr = array)
			{
				if (!inventory.inventory.SerializeResult(Handle, (IntPtr)ptr, out punOutBufferSize))
				{
					return null;
				}
			}
			return array;
		}

		public void Dispose()
		{
			inventory.inventory.DestroyResult(Handle);
			Handle = -1;
			inventory = null;
		}
	}

	public Action OnUpdate;

	public Item[] Items;

	public byte[] SerializedItems;

	public DateTime SerializedExpireTime;

	internal uint LastTimestamp = 0u;

	internal SteamInventory inventory;

	private Stopwatch fetchRetryTimer;

	public Definition[] Definitions;

	private bool IsServer { get; set; }

	internal Inventory(BaseSteamworks steamworks, SteamInventory c, bool server)
	{
		IsServer = server;
		inventory = c;
		Result.Pending = new Dictionary<int, Result>();
		inventory.LoadItemDefinitions();
		FetchItemDefinitions();
		if (!server)
		{
			SteamInventoryResultReady_t.RegisterCallback(steamworks, onResultReady);
			SteamInventoryFullUpdate_t.RegisterCallback(steamworks, onFullUpdate);
			Refresh();
		}
	}

	private void onFullUpdate(SteamInventoryFullUpdate_t data, bool error)
	{
		if (!error)
		{
			Result result = new Result(this, data.Handle, pending: false);
			result.Fill();
			onResult(result, serialize: true);
		}
	}

	private void onResultReady(SteamInventoryResultReady_t data, bool error)
	{
		if (Result.Pending.ContainsKey(data.Handle))
		{
			Result result = Result.Pending[data.Handle];
			result.OnSteamResult(data, error);
			if (!error && data.Esult == SteamNative.Result.OK)
			{
				onResult(result, serialize: false);
			}
			Result.Pending.Remove(data.Handle);
		}
	}

	private void onResult(Result r, bool serialize)
	{
		if (r.IsSuccess)
		{
			if (serialize)
			{
				if (r.Timestamp < LastTimestamp)
				{
					return;
				}
				SerializedItems = r.Serialize();
				SerializedExpireTime = DateTime.Now.Add(TimeSpan.FromMinutes(60.0));
			}
			LastTimestamp = r.Timestamp;
			ApplyResult(r);
		}
		r.Dispose();
		r = null;
	}

	internal void ApplyResult(Result r)
	{
		if (!IsServer && r.IsSuccess && r.Items != null)
		{
			if (Items == null)
			{
				Items = new Item[0];
			}
			Items = (from x in Items.Union(r.Items).Distinct()
				where !r.Removed.Contains(x)
				where !r.Consumed.Contains(x)
				select x).ToArray();
			OnUpdate?.Invoke();
		}
	}

	public void Dispose()
	{
		inventory = null;
		Items = null;
		SerializedItems = null;
		Result.Pending = null;
	}

	[Obsolete("No longer required, will be removed in a later version")]
	public void PlaytimeHeartbeat()
	{
	}

	public void Refresh()
	{
		if (!IsServer)
		{
			SteamInventoryResult_t pResultHandle = 0;
			if (!inventory.GetAllItems(ref pResultHandle) || (int)pResultHandle == -1)
			{
				Console.WriteLine("GetAllItems failed!?");
			}
		}
	}

	public Definition CreateDefinition(int id)
	{
		return new Definition(inventory, id);
	}

	internal void FetchItemDefinitions()
	{
		SteamItemDef_t[] itemDefinitionIDs = inventory.GetItemDefinitionIDs();
		if (itemDefinitionIDs != null)
		{
			Definitions = itemDefinitionIDs.Select((SteamItemDef_t x) => CreateDefinition(x)).ToArray();
			Definition[] definitions = Definitions;
			foreach (Definition definition in definitions)
			{
				definition.Link(Definitions);
			}
		}
	}

	public void Update()
	{
		if (Definitions == null && (fetchRetryTimer == null || !(fetchRetryTimer.Elapsed.TotalSeconds < 10.0)))
		{
			if (fetchRetryTimer == null)
			{
				fetchRetryTimer = Stopwatch.StartNew();
			}
			fetchRetryTimer.Reset();
			fetchRetryTimer.Start();
			FetchItemDefinitions();
			inventory.LoadItemDefinitions();
		}
	}

	public static float PriceCategoryToFloat(string price)
	{
		if (string.IsNullOrEmpty(price))
		{
			return 0f;
		}
		price = price.Replace("1;VLV", "");
		int result = 0;
		if (!int.TryParse(price, out result))
		{
			return 0f;
		}
		return (float)int.Parse(price) / 100f;
	}

	public Definition FindDefinition(int DefinitionId)
	{
		if (Definitions == null)
		{
			return null;
		}
		return Definitions.FirstOrDefault((Definition x) => x.Id == DefinitionId);
	}

	public unsafe Result Deserialize(byte[] data, int dataLength = -1)
	{
		if (dataLength == -1)
		{
			dataLength = data.Length;
		}
		SteamInventoryResult_t pOutResultHandle = -1;
		fixed (byte* ptr = data)
		{
			if (!inventory.DeserializeResult(ref pOutResultHandle, (IntPtr)ptr, (uint)dataLength, bRESERVED_MUST_BE_FALSE: false) || (int)pOutResultHandle == -1)
			{
				return null;
			}
			Result result = new Result(this, pOutResultHandle, pending: false);
			result.Fill();
			return result;
		}
	}

	public Result CraftItem(Item[] list, Definition target)
	{
		SteamInventoryResult_t pResultHandle = -1;
		SteamItemDef_t[] pArrayGenerate = new SteamItemDef_t[1]
		{
			new SteamItemDef_t
			{
				Value = target.Id
			}
		};
		uint[] punArrayGenerateQuantity = new uint[1] { 1u };
		SteamItemInstanceID_t[] array = ((IEnumerable<Item>)list).Select((Func<Item, SteamItemInstanceID_t>)((Item x) => x.Id)).ToArray();
		uint[] punArrayDestroyQuantity = list.Select((Item x) => 1u).ToArray();
		if (!inventory.ExchangeItems(ref pResultHandle, pArrayGenerate, punArrayGenerateQuantity, 1u, array, punArrayDestroyQuantity, (uint)array.Length))
		{
			return null;
		}
		return new Result(this, pResultHandle, pending: true);
	}

	public Result CraftItem(Item.Amount[] list, Definition target)
	{
		SteamInventoryResult_t pResultHandle = -1;
		SteamItemDef_t[] pArrayGenerate = new SteamItemDef_t[1]
		{
			new SteamItemDef_t
			{
				Value = target.Id
			}
		};
		uint[] punArrayGenerateQuantity = new uint[1] { 1u };
		SteamItemInstanceID_t[] array = ((IEnumerable<Item.Amount>)list).Select((Func<Item.Amount, SteamItemInstanceID_t>)((Item.Amount x) => x.Item.Id)).ToArray();
		uint[] punArrayDestroyQuantity = list.Select((Item.Amount x) => (uint)x.Quantity).ToArray();
		if (!inventory.ExchangeItems(ref pResultHandle, pArrayGenerate, punArrayGenerateQuantity, 1u, array, punArrayDestroyQuantity, (uint)array.Length))
		{
			return null;
		}
		return new Result(this, pResultHandle, pending: true);
	}

	public Result SplitStack(Item item, int quantity = 1)
	{
		SteamInventoryResult_t pResultHandle = -1;
		if (!inventory.TransferItemQuantity(ref pResultHandle, item.Id, (uint)quantity, ulong.MaxValue))
		{
			return null;
		}
		return new Result(this, pResultHandle, pending: true);
	}

	public Result Stack(Item source, Item dest, int quantity = 1)
	{
		SteamInventoryResult_t pResultHandle = -1;
		if (!inventory.TransferItemQuantity(ref pResultHandle, source.Id, (uint)quantity, dest.Id))
		{
			return null;
		}
		return new Result(this, pResultHandle, pending: true);
	}

	public Result GenerateItem(Definition target, int amount)
	{
		SteamInventoryResult_t pResultHandle = -1;
		SteamItemDef_t[] pArrayItemDefs = new SteamItemDef_t[1]
		{
			new SteamItemDef_t
			{
				Value = target.Id
			}
		};
		uint[] punArrayQuantity = new uint[1] { (uint)amount };
		if (!inventory.GenerateItems(ref pResultHandle, pArrayItemDefs, punArrayQuantity, 1u))
		{
			return null;
		}
		return new Result(this, pResultHandle, pending: true);
	}
}
