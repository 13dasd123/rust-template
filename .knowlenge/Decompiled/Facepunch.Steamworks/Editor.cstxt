using System;
using System.Collections.Generic;
using System.IO;
using Facepunch.Steamworks.Callbacks;
using SteamNative;

public class Editor
{
	public enum VisibilityType
	{
		Public,
		FriendsOnly,
		Private
	}

	internal Workshop workshop;

	internal CallbackHandle CreateItem;

	internal CallbackHandle SubmitItemUpdate;

	internal UGCUpdateHandle_t UpdateHandle;

	private int bytesUploaded;

	private int bytesTotal;

	public ulong Id { get; internal set; }

	public string Title { get; set; }

	public string Description { get; set; }

	public string Folder { get; set; }

	public string PreviewImage { get; set; }

	public List<string> Tags { get; set; } = new List<string>();

	public bool Publishing { get; internal set; }

	public ItemType? Type { get; set; }

	public string Error { get; internal set; }

	public string ChangeNote { get; set; } = "";

	public uint WorkshopUploadAppId { get; set; }

	public string MetaData { get; set; }

	public Dictionary<string, string[]> KeyValues { get; set; } = new Dictionary<string, string[]>();

	public VisibilityType? Visibility { get; set; }

	public bool NeedToAgreeToWorkshopLegal { get; internal set; }

	public double Progress
	{
		get
		{
			int num = BytesTotal;
			if (num == 0)
			{
				return 0.0;
			}
			return (double)BytesUploaded / (double)num;
		}
	}

	public int BytesUploaded
	{
		get
		{
			if (!Publishing)
			{
				return bytesUploaded;
			}
			if ((ulong)UpdateHandle == 0L)
			{
				return bytesUploaded;
			}
			ulong punBytesProcessed = 0uL;
			ulong punBytesTotal = 0uL;
			workshop.steamworks.native.ugc.GetItemUpdateProgress(UpdateHandle, out punBytesProcessed, out punBytesTotal);
			bytesUploaded = Math.Max(bytesUploaded, (int)punBytesProcessed);
			return bytesUploaded;
		}
	}

	public int BytesTotal
	{
		get
		{
			if (!Publishing)
			{
				return bytesTotal;
			}
			if ((ulong)UpdateHandle == 0L)
			{
				return bytesTotal;
			}
			ulong punBytesProcessed = 0uL;
			ulong punBytesTotal = 0uL;
			workshop.steamworks.native.ugc.GetItemUpdateProgress(UpdateHandle, out punBytesProcessed, out punBytesTotal);
			bytesTotal = Math.Max(bytesTotal, (int)punBytesTotal);
			return bytesTotal;
		}
	}

	public event Action<Facepunch.Steamworks.Callbacks.Result> OnChangesSubmitted;

	public void Publish()
	{
		bytesUploaded = 0;
		bytesTotal = 0;
		Publishing = true;
		Error = null;
		if (Id == 0L)
		{
			StartCreatingItem();
		}
		else
		{
			PublishChanges();
		}
	}

	private void StartCreatingItem()
	{
		if (!Type.HasValue)
		{
			throw new Exception("Editor.Type must be set when creating a new item!");
		}
		if (WorkshopUploadAppId == 0)
		{
			throw new Exception("WorkshopUploadAppId should not be 0");
		}
		CreateItem = workshop.ugc.CreateItem(WorkshopUploadAppId, (WorkshopFileType)Type.Value, OnItemCreated);
	}

	private void OnItemCreated(CreateItemResult_t obj, bool Failed)
	{
		NeedToAgreeToWorkshopLegal = obj.UserNeedsToAcceptWorkshopLegalAgreement;
		CreateItem.Dispose();
		CreateItem = null;
		if (obj.Result == SteamNative.Result.OK && !Failed)
		{
			Error = null;
			Id = obj.PublishedFileId;
			PublishChanges();
		}
		else
		{
			Error = $"Error creating new file: {obj.Result} ({obj.PublishedFileId})";
			Publishing = false;
			this.OnChangesSubmitted?.Invoke((Facepunch.Steamworks.Callbacks.Result)obj.Result);
		}
	}

	private void PublishChanges()
	{
		if (WorkshopUploadAppId == 0)
		{
			throw new Exception("WorkshopUploadAppId should not be 0");
		}
		UpdateHandle = workshop.ugc.StartItemUpdate(WorkshopUploadAppId, Id);
		if (Title != null)
		{
			workshop.ugc.SetItemTitle(UpdateHandle, Title);
		}
		if (Description != null)
		{
			workshop.ugc.SetItemDescription(UpdateHandle, Description);
		}
		if (Folder != null)
		{
			if (!new DirectoryInfo(Folder).Exists)
			{
				throw new Exception($"Folder doesn't exist ({Folder})");
			}
			workshop.ugc.SetItemContent(UpdateHandle, Folder);
		}
		if (Tags != null && Tags.Count > 0)
		{
			workshop.ugc.SetItemTags(UpdateHandle, Tags.ToArray());
		}
		if (Visibility.HasValue)
		{
			workshop.ugc.SetItemVisibility(UpdateHandle, (RemoteStoragePublishedFileVisibility)Visibility.Value);
		}
		if (PreviewImage != null)
		{
			FileInfo fileInfo = new FileInfo(PreviewImage);
			if (!fileInfo.Exists)
			{
				throw new Exception($"PreviewImage doesn't exist ({PreviewImage})");
			}
			if (fileInfo.Length >= 1048576)
			{
				throw new Exception($"PreviewImage should be under 1MB ({fileInfo.Length})");
			}
			workshop.ugc.SetItemPreview(UpdateHandle, PreviewImage);
		}
		if (MetaData != null)
		{
			workshop.ugc.SetItemMetadata(UpdateHandle, MetaData);
		}
		if (KeyValues != null)
		{
			foreach (KeyValuePair<string, string[]> keyValue in KeyValues)
			{
				string[] value = keyValue.Value;
				foreach (string pchValue in value)
				{
					workshop.ugc.AddItemKeyValueTag(UpdateHandle, keyValue.Key, pchValue);
				}
			}
		}
		SubmitItemUpdate = workshop.ugc.SubmitItemUpdate(UpdateHandle, ChangeNote, OnChangesSubmittedInternal);
	}

	private void OnChangesSubmittedInternal(SubmitItemUpdateResult_t obj, bool Failed)
	{
		if (Failed)
		{
			throw new Exception("CreateItemResult_t Failed");
		}
		UpdateHandle = 0uL;
		SubmitItemUpdate = null;
		NeedToAgreeToWorkshopLegal = obj.UserNeedsToAcceptWorkshopLegalAgreement;
		Publishing = false;
		Error = ((obj.Result != SteamNative.Result.OK) ? $"Error publishing changes: {obj.Result} ({NeedToAgreeToWorkshopLegal})" : null);
		this.OnChangesSubmitted?.Invoke((Facepunch.Steamworks.Callbacks.Result)obj.Result);
	}

	public void Delete()
	{
		workshop.ugc.DeleteItem(Id);
		Id = 0uL;
	}
}
