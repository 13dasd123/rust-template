using System;
using System.Diagnostics;
using System.IO;
using Facepunch.Steamworks;
using SteamNative;

public class Voice
{
	private const int ReadBufferSize = 131072;

	internal Client client;

	internal byte[] ReadCompressedBuffer = new byte[131072];

	internal byte[] ReadUncompressedBuffer = new byte[131072];

	internal byte[] UncompressBuffer = new byte[262144];

	public Action<byte[], int> OnCompressedData;

	public Action<byte[], int> OnUncompressedData;

	private Stopwatch UpdateTimer = Stopwatch.StartNew();

	private bool _wantsrecording;

	public bool IsRecording;

	public uint DesiredSampleRate;

	public uint OptimalSampleRate => client.native.user.GetVoiceOptimalSampleRate();

	public bool WantsRecording
	{
		get
		{
			return _wantsrecording;
		}
		set
		{
			_wantsrecording = value;
			if (value)
			{
				client.native.user.StartVoiceRecording();
			}
			else
			{
				client.native.user.StopVoiceRecording();
			}
		}
	}

	public DateTime LastVoiceRecordTime { get; private set; }

	public TimeSpan TimeSinceLastVoiceRecord => DateTime.Now.Subtract(LastVoiceRecordTime);

	internal Voice(Client client)
	{
		this.client = client;
	}

	public unsafe void Update()
	{
		if ((OnCompressedData == null && OnUncompressedData == null) || UpdateTimer.Elapsed.TotalSeconds < 0.10000000149011612)
		{
			return;
		}
		UpdateTimer.Reset();
		UpdateTimer.Start();
		uint pcbUncompressed_Deprecated = 0u;
		uint pcbCompressed = 0u;
		VoiceResult availableVoice = client.native.user.GetAvailableVoice(out pcbCompressed, out pcbUncompressed_Deprecated, (DesiredSampleRate == 0) ? OptimalSampleRate : DesiredSampleRate);
		if (availableVoice == VoiceResult.NotRecording || availableVoice == VoiceResult.NotInitialized)
		{
			IsRecording = false;
			return;
		}
		fixed (byte* readCompressedBuffer = ReadCompressedBuffer)
		{
			fixed (byte* readUncompressedBuffer = ReadUncompressedBuffer)
			{
				availableVoice = client.native.user.GetVoice(OnCompressedData != null, (IntPtr)readCompressedBuffer, 131072u, out pcbCompressed, OnUncompressedData != null, (IntPtr)readUncompressedBuffer, 131072u, out pcbUncompressed_Deprecated, (DesiredSampleRate == 0) ? OptimalSampleRate : DesiredSampleRate);
			}
		}
		IsRecording = true;
		if (availableVoice == VoiceResult.OK)
		{
			if (OnCompressedData != null && pcbCompressed != 0)
			{
				OnCompressedData(ReadCompressedBuffer, (int)pcbCompressed);
			}
			if (OnUncompressedData != null && pcbUncompressed_Deprecated != 0)
			{
				OnUncompressedData(ReadUncompressedBuffer, (int)pcbUncompressed_Deprecated);
			}
			LastVoiceRecordTime = DateTime.Now;
		}
		if (availableVoice == VoiceResult.NotRecording || availableVoice == VoiceResult.NotInitialized)
		{
			IsRecording = false;
		}
	}

	public bool Decompress(byte[] input, MemoryStream output, uint samepleRate = 0u)
	{
		return Decompress(input, 0, input.Length, output, samepleRate);
	}

	public bool Decompress(byte[] input, int inputsize, MemoryStream output, uint samepleRate = 0u)
	{
		return Decompress(input, 0, inputsize, output, samepleRate);
	}

	public unsafe bool Decompress(byte[] input, int inputoffset, int inputsize, MemoryStream output, uint samepleRate = 0u)
	{
		if (inputoffset < 0 || inputoffset >= input.Length)
		{
			throw new ArgumentOutOfRangeException("inputoffset");
		}
		if (inputsize <= 0 || inputoffset + inputsize > input.Length)
		{
			throw new ArgumentOutOfRangeException("inputsize");
		}
		fixed (byte* ptr = input)
		{
			return Decompress((IntPtr)ptr, inputoffset, inputsize, output, samepleRate);
		}
	}

	private unsafe bool Decompress(IntPtr input, int inputoffset, int inputsize, MemoryStream output, uint samepleRate = 0u)
	{
		if (samepleRate == 0)
		{
			samepleRate = OptimalSampleRate;
		}
		uint nBytesWritten = 0u;
		VoiceResult num;
		fixed (byte* uncompressBuffer = UncompressBuffer)
		{
			num = client.native.user.DecompressVoice((IntPtr)((byte*)(void*)input + inputoffset), (uint)inputsize, (IntPtr)uncompressBuffer, (uint)UncompressBuffer.Length, out nBytesWritten, samepleRate);
		}
		if (num == VoiceResult.OK)
		{
			output.Write(UncompressBuffer, 0, (int)nBytesWritten);
			return true;
		}
		return false;
	}
}
