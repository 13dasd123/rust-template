using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using Facepunch.Steamworks;
using SteamNative;

public class Voice : IDisposable
{
	private const int ReadBufferSize = 131072;

	internal Client client;

	internal IntPtr ReadCompressedBuffer;

	internal IntPtr ReadUncompressedBuffer;

	internal byte[] UncompressBuffer = new byte[262144];

	public Action<IntPtr, int> OnCompressedData;

	public Action<IntPtr, int> OnUncompressedData;

	private Stopwatch UpdateTimer = Stopwatch.StartNew();

	private bool _wantsrecording = false;

	public bool IsRecording = false;

	public uint DesiredSampleRate = 0u;

	public uint OptimalSampleRate => client.native.user.GetVoiceOptimalSampleRate();

	public bool WantsRecording
	{
		get
		{
			return _wantsrecording;
		}
		set
		{
			_wantsrecording = value;
			if (value)
			{
				client.native.user.StartVoiceRecording();
			}
			else
			{
				client.native.user.StopVoiceRecording();
			}
		}
	}

	public DateTime LastVoiceRecordTime { get; private set; }

	public TimeSpan TimeSinceLastVoiceRecord => DateTime.Now.Subtract(LastVoiceRecordTime);

	internal Voice(Client client)
	{
		this.client = client;
		ReadCompressedBuffer = Marshal.AllocHGlobal(131072);
		ReadUncompressedBuffer = Marshal.AllocHGlobal(131072);
	}

	public void Dispose()
	{
		Marshal.FreeHGlobal(ReadCompressedBuffer);
		Marshal.FreeHGlobal(ReadUncompressedBuffer);
	}

	public void Update()
	{
		if ((OnCompressedData == null && OnUncompressedData == null) || UpdateTimer.Elapsed.TotalSeconds < 0.10000000149011612)
		{
			return;
		}
		UpdateTimer.Reset();
		UpdateTimer.Start();
		uint pcbUncompressed_Deprecated = 0u;
		uint pcbCompressed = 0u;
		VoiceResult availableVoice = client.native.user.GetAvailableVoice(out pcbCompressed, out pcbUncompressed_Deprecated, (DesiredSampleRate == 0) ? OptimalSampleRate : DesiredSampleRate);
		if (availableVoice == VoiceResult.NotRecording || availableVoice == VoiceResult.NotInitialized)
		{
			IsRecording = false;
			return;
		}
		availableVoice = client.native.user.GetVoice(OnCompressedData != null, ReadCompressedBuffer, 131072u, out pcbCompressed, OnUncompressedData != null, ReadUncompressedBuffer, 131072u, out pcbUncompressed_Deprecated, (DesiredSampleRate == 0) ? OptimalSampleRate : DesiredSampleRate);
		IsRecording = true;
		if (availableVoice == VoiceResult.OK)
		{
			if (OnCompressedData != null && pcbCompressed != 0)
			{
				OnCompressedData(ReadCompressedBuffer, (int)pcbCompressed);
			}
			if (OnUncompressedData != null && pcbUncompressed_Deprecated != 0)
			{
				OnUncompressedData(ReadUncompressedBuffer, (int)pcbUncompressed_Deprecated);
			}
			LastVoiceRecordTime = DateTime.Now;
		}
		if (availableVoice == VoiceResult.NotRecording || availableVoice == VoiceResult.NotInitialized)
		{
			IsRecording = false;
		}
	}

	public unsafe bool Decompress(byte[] input, MemoryStream output, uint samepleRate = 0u)
	{
		fixed (byte* ptr = input)
		{
			return Decompress((IntPtr)ptr, 0, input.Length, output, samepleRate);
		}
	}

	public unsafe bool Decompress(IntPtr input, int inputoffset, int inputsize, MemoryStream output, uint samepleRate = 0u)
	{
		if (samepleRate == 0)
		{
			samepleRate = OptimalSampleRate;
		}
		uint nBytesWritten = 0u;
		VoiceResult voiceResult = VoiceResult.NoData;
		fixed (byte* uncompressBuffer = UncompressBuffer)
		{
			voiceResult = client.native.user.DecompressVoice((IntPtr)((byte*)(void*)input + inputoffset), (uint)inputsize, (IntPtr)uncompressBuffer, (uint)UncompressBuffer.Length, out nBytesWritten, samepleRate);
		}
		if (voiceResult == VoiceResult.OK)
		{
			output.Write(UncompressBuffer, 0, (int)nBytesWritten);
			return true;
		}
		return false;
	}
}
