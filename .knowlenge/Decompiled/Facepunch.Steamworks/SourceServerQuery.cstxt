using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Facepunch.Steamworks;

internal class SourceServerQuery : IDisposable
{
	public static List<SourceServerQuery> Current = new List<SourceServerQuery>();

	private static readonly byte[] A2S_SERVERQUERY_GETCHALLENGE = new byte[5] { 85, 255, 255, 255, 255 };

	private static readonly byte A2S_RULES = 86;

	public volatile bool IsRunning;

	public volatile bool IsSuccessful;

	private ServerList.Server Server;

	private UdpClient udpClient;

	private IPEndPoint endPoint;

	private Thread thread;

	private byte[] _challengeBytes;

	private Dictionary<string, string> rules = new Dictionary<string, string>();

	private byte[] readBuffer = new byte[4096];

	private byte[] sendBuffer = new byte[1024];

	public static void Cycle()
	{
		if (Current.Count != 0)
		{
			for (int num = Current.Count; num > 0; num--)
			{
				Current[num - 1].Update();
			}
		}
	}

	public SourceServerQuery(ServerList.Server server, IPAddress address, int queryPort)
	{
		Server = server;
		endPoint = new IPEndPoint(address, queryPort);
		Current.Add(this);
		IsRunning = true;
		IsSuccessful = false;
		thread = new Thread(ThreadedStart);
		thread.Start();
	}

	private void Update()
	{
		if (!IsRunning)
		{
			Current.Remove(this);
			Server.OnServerRulesReceiveFinished(rules, IsSuccessful);
		}
	}

	private void ThreadedStart(object obj)
	{
		try
		{
			using (this.udpClient = new UdpClient())
			{
				this.udpClient.Client.SendTimeout = 3000;
				this.udpClient.Client.ReceiveTimeout = 3000;
				this.udpClient.Connect(endPoint);
				GetRules();
				IsSuccessful = true;
			}
		}
		catch (Exception)
		{
			IsSuccessful = false;
		}
		this.udpClient = null;
		IsRunning = false;
	}

	private void GetRules()
	{
		GetChallengeData();
		_challengeBytes[0] = A2S_RULES;
		Send(_challengeBytes);
		using BinaryReader binaryReader = new BinaryReader(new MemoryStream(Receive()));
		if (binaryReader.ReadByte() != 69)
		{
			throw new Exception("Invalid data received in response to A2S_RULES request");
		}
		ushort num = binaryReader.ReadUInt16();
		for (int i = 0; i < num; i++)
		{
			rules.Add(binaryReader.ReadNullTerminatedUTF8String(readBuffer), binaryReader.ReadNullTerminatedUTF8String(readBuffer));
		}
	}

	private byte[] Receive()
	{
		byte[][] array = null;
		byte b = 0;
		byte b2 = 1;
		do
		{
			byte[] array2 = udpClient.Receive(ref endPoint);
			using BinaryReader binaryReader = new BinaryReader(new MemoryStream(array2));
			switch (binaryReader.ReadInt32())
			{
			case -1:
			{
				byte[] array4 = new byte[array2.Length - binaryReader.BaseStream.Position];
				Buffer.BlockCopy(array2, (int)binaryReader.BaseStream.Position, array4, 0, array4.Length);
				return array4;
			}
			case -2:
			{
				binaryReader.ReadInt32();
				b = binaryReader.ReadByte();
				b2 = binaryReader.ReadByte();
				binaryReader.ReadInt32();
				if (array == null)
				{
					array = new byte[b2][];
				}
				byte[] array3 = new byte[array2.Length - binaryReader.BaseStream.Position];
				Buffer.BlockCopy(array2, (int)binaryReader.BaseStream.Position, array3, 0, array3.Length);
				array[b] = array3;
				break;
			}
			default:
				throw new Exception("Invalid Header");
			}
		}
		while (array.Any((byte[] p) => p == null));
		return Combine(array);
	}

	private void GetChallengeData()
	{
		if (_challengeBytes == null)
		{
			Send(A2S_SERVERQUERY_GETCHALLENGE);
			byte[] array = Receive();
			if (array[0] != 65)
			{
				throw new Exception("Invalid Challenge");
			}
			_challengeBytes = array;
		}
	}

	private void Send(byte[] message)
	{
		sendBuffer[0] = byte.MaxValue;
		sendBuffer[1] = byte.MaxValue;
		sendBuffer[2] = byte.MaxValue;
		sendBuffer[3] = byte.MaxValue;
		Buffer.BlockCopy(message, 0, sendBuffer, 4, message.Length);
		udpClient.Send(sendBuffer, message.Length + 4);
	}

	private byte[] Combine(byte[][] arrays)
	{
		byte[] array = new byte[arrays.Sum((byte[] a) => a.Length)];
		int num = 0;
		foreach (byte[] array2 in arrays)
		{
			Buffer.BlockCopy(array2, 0, array, num, array2.Length);
			num += array2.Length;
		}
		return array;
	}

	public void Dispose()
	{
		if (thread != null && thread.IsAlive)
		{
			thread.Abort();
		}
		thread = null;
	}
}
