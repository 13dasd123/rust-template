using System;
using System.Runtime.InteropServices;
using System.Text;

internal static class Helpers
{
	public const int MemoryBufferSize = 32768;

	private static IntPtr[] MemoryPool = new IntPtr[4]
	{
		Marshal.AllocHGlobal(32768),
		Marshal.AllocHGlobal(32768),
		Marshal.AllocHGlobal(32768),
		Marshal.AllocHGlobal(32768)
	};

	private static int MemoryPoolIndex;

	private static byte[][] BufferPool = new byte[4][];

	private static int BufferPoolIndex;

	public unsafe static IntPtr TakeMemory()
	{
		lock (MemoryPool)
		{
			MemoryPoolIndex++;
			if (MemoryPoolIndex >= MemoryPool.Length)
			{
				MemoryPoolIndex = 0;
			}
			IntPtr intPtr = MemoryPool[MemoryPoolIndex];
			*(sbyte*)(void*)intPtr = 0;
			return intPtr;
		}
	}

	public static byte[] TakeBuffer(int minSize)
	{
		lock (BufferPool)
		{
			BufferPoolIndex++;
			if (BufferPoolIndex >= BufferPool.Length)
			{
				BufferPoolIndex = 0;
			}
			if (BufferPool[BufferPoolIndex] == null)
			{
				BufferPool[BufferPoolIndex] = new byte[262144];
			}
			if (BufferPool[BufferPoolIndex].Length < minSize)
			{
				BufferPool[BufferPoolIndex] = new byte[minSize + 1024];
			}
			return BufferPool[BufferPoolIndex];
		}
	}

	internal unsafe static string MemoryToString(IntPtr ptr)
	{
		int num = 0;
		for (num = 0; num < 32768 && ((byte*)(void*)ptr)[num] != 0; num++)
		{
		}
		if (num == 0)
		{
			return string.Empty;
		}
		return Encoding.UTF8.GetString((byte*)(void*)ptr, num);
	}
}
