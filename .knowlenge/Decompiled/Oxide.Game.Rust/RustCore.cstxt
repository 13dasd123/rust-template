using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using Facepunch;
using Network;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core.RemoteConsole;
using Oxide.Core.ServerConsole;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries;
using Oxide.Game.Rust.Libraries.Covalence;
using UnityEngine;

public class RustCore : CSPlugin
{
	internal readonly Command cmdlib = Interface.Oxide.GetLibrary<Command>();

	internal readonly Lang lang = Interface.Oxide.GetLibrary<Lang>();

	internal readonly Permission permission = Interface.Oxide.GetLibrary<Permission>();

	internal readonly Player Player = Interface.Oxide.GetLibrary<Player>();

	internal static readonly RustCovalenceProvider Covalence = RustCovalenceProvider.Instance;

	internal readonly PluginManager pluginManager = Interface.Oxide.RootPluginManager;

	internal readonly IServer Server = Covalence.CreateServer();

	internal bool serverInitialized;

	internal readonly Dictionary<string, string> messages = new Dictionary<string, string>
	{
		{ "CommandUsageGrant", "Usage: grant <group|user> <name|id> <permission>" },
		{ "CommandUsageGroup", "Usage: group <add|set> <name> [title] [rank]" },
		{ "CommandUsageGroupParent", "Usage: group <parent> <name> <parentName>" },
		{ "CommandUsageGroupRemove", "Usage: group <remove> <name>" },
		{ "CommandUsageLang", "Usage: lang <two-digit language code>" },
		{ "CommandUsageLoad", "Usage: load *|<pluginname>+" },
		{ "CommandUsageReload", "Usage: reload *|<pluginname>+" },
		{ "CommandUsageRevoke", "Usage: revoke <group|user> <name|id> <permission>" },
		{ "CommandUsageShow", "Usage: show <group|user> <name>\nUsage: show <groups|perms>" },
		{ "CommandUsageUnload", "Usage: unload *|<pluginname>+" },
		{ "CommandUsageUserGroup", "Usage: usergroup <add|remove> <username> <groupname>" },
		{ "ConnectionRejected", "Connection was rejected" },
		{ "GroupAlreadyExists", "Group '{0}' already exists" },
		{ "GroupAlreadyHasPermission", "Group '{0}' already has permission '{1}'" },
		{ "GroupDoesNotHavePermission", "Group '{0}' does not have permission '{1}'" },
		{ "GroupChanged", "Group '{0}' changed" },
		{ "GroupCreated", "Group '{0}' created" },
		{ "GroupDeleted", "Group '{0}' deleted" },
		{ "GroupNotFound", "Group '{0}' doesn't exist" },
		{ "GroupParentChanged", "Group '{0}' parent changed to '{1}'" },
		{ "GroupParentNotChanged", "Group '{0}' parent was not changed" },
		{ "GroupParentNotFound", "Group parent '{0}' doesn't exist" },
		{ "GroupPermissionGranted", "Group '{0}' granted permission '{1}'" },
		{ "GroupPermissionRevoked", "Group '{0}' revoked permission '{1}'" },
		{ "GroupPermissions", "Group '{0}' permissions" },
		{ "GroupUsers", "Group '{0}' users" },
		{ "Groups", "Groups" },
		{ "NoGroupPermissions", "No permissions currently granted" },
		{ "NoPermissionGroups", "No groups with this permission" },
		{ "NoPermissionUsers", "No users with this permission" },
		{ "NoPluginsFound", "No plugins are currently available" },
		{ "NoUserGroups", "User is not assigned to any groups" },
		{ "NoUserPermissions", "No permissions currently granted" },
		{ "NoUsersInGroup", "No users currently in group" },
		{ "NotAllowed", "You are not allowed to use the '{0}' command" },
		{ "ParentGroupPermissions", "Parent group '{0}' permissions" },
		{ "PermissionGroups", "Permission '{0}' Groups" },
		{ "PermissionUsers", "Permission '{0}' Users" },
		{ "PermissionNotFound", "Permission '{0}' doesn't exist" },
		{ "Permissions", "Permissions" },
		{ "PermissionsNotLoaded", "Unable to load permission files! Permissions will not work until resolved.\n => {0}" },
		{ "PlayerLanguage", "Player language set to {0}" },
		{ "PluginNotLoaded", "Plugin '{0}' not loaded." },
		{ "PluginReloaded", "Reloaded plugin {0} v{1} by {2}" },
		{ "PluginUnloaded", "Unloaded plugin {0} v{1} by {2}" },
		{ "ServerLanguage", "Server language set to {0}" },
		{ "UnknownCommand", "Unknown command: {0}" },
		{ "UserAddedToGroup", "User '{0}' added to group: {1}" },
		{ "UserAlreadyHasPermission", "User '{0}' already has permission '{1}'" },
		{ "UserDoesNotHavePermission", "User '{0}' does not have permission '{1}'" },
		{ "UserNotFound", "User '{0}' not found" },
		{ "UserGroups", "User '{0}' groups" },
		{ "UserPermissions", "User '{0}' permissions" },
		{ "UserPermissionGranted", "User '{0}' granted permission '{1}'" },
		{ "UserPermissionRevoked", "User '{0}' revoked permission '{1}'" },
		{ "UserRemovedFromGroup", "User '{0}' removed from group '{1}'" },
		{ "YouAreNotAdmin", "You are not an admin" }
	};

	internal bool isPlayerTakingDamage;

	internal static string ipPattern = ":{1}[0-9]{1}\\d*";

	internal static IEnumerable<string> RestrictedCommands => new string[2] { "ownerid", "moderatorid" };

	[HookMethod("GrantCommand")]
	private void GrantCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (!player.IsAdmin && !player.HasPermission("oxide.grant"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id), command);
			return;
		}
		if (args.Length < 3)
		{
			player.Reply(lang.GetMessage("CommandUsageGrant", this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = args[1];
		string text3 = args[2];
		if (!permission.PermissionExists(text3))
		{
			player.Reply(lang.GetMessage("PermissionNotFound", this, player.Id), text3);
		}
		else if (text.Equals("group"))
		{
			if (!permission.GroupExists(text2))
			{
				player.Reply(lang.GetMessage("GroupNotFound", this, player.Id), text2);
			}
			else if (permission.GroupHasPermission(text2, text3))
			{
				player.Reply(lang.GetMessage("GroupAlreadyHasPermission", this, player.Id), text2, text3);
			}
			else
			{
				permission.GrantGroupPermission(text2, text3, null);
				player.Reply(lang.GetMessage("GroupPermissionGranted", this, player.Id), text2, text3);
			}
		}
		else if (text.Equals("user"))
		{
			IPlayer player2 = Covalence.PlayerManager.FindPlayer(text2);
			if (player2 == null && !permission.UserIdValid(text2))
			{
				player.Reply(lang.GetMessage("UserNotFound", this, player.Id), text2);
				return;
			}
			string text4 = text2;
			if (player2 != null)
			{
				text4 = player2.Id;
				text2 = player2.Name;
				permission.UpdateNickname(text4, text2);
			}
			if (permission.UserHasPermission(text2, text3))
			{
				player.Reply(lang.GetMessage("UserAlreadyHasPermission", this, player.Id), text4, text3);
			}
			else
			{
				permission.GrantUserPermission(text4, text3, null);
				player.Reply(lang.GetMessage("UserPermissionGranted", this, player.Id), $"{text2} ({text4})", text3);
			}
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageGrant", this, player.Id));
		}
	}

	[HookMethod("GroupCommand")]
	private void GroupCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (!player.IsAdmin && !player.HasPermission("oxide.group"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id), command);
			return;
		}
		if (args.Length < 2)
		{
			player.Reply(lang.GetMessage("CommandUsageGroup", this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageGroupParent", this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageGroupRemove", this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = args[1];
		string title = ((args.Length >= 3) ? args[2] : "");
		int rank = ((args.Length == 4) ? int.Parse(args[3]) : 0);
		if (text.Equals("add"))
		{
			if (permission.GroupExists(text2))
			{
				player.Reply(lang.GetMessage("GroupAlreadyExists", this, player.Id), text2);
			}
			else
			{
				permission.CreateGroup(text2, title, rank);
				player.Reply(lang.GetMessage("GroupCreated", this, player.Id), text2);
			}
		}
		else if (text.Equals("remove"))
		{
			if (!permission.GroupExists(text2))
			{
				player.Reply(lang.GetMessage("GroupNotFound", this, player.Id), text2);
			}
			else
			{
				permission.RemoveGroup(text2);
				player.Reply(lang.GetMessage("GroupDeleted", this, player.Id), text2);
			}
		}
		else if (text.Equals("set"))
		{
			if (!permission.GroupExists(text2))
			{
				player.Reply(lang.GetMessage("GroupNotFound", this, player.Id), text2);
				return;
			}
			permission.SetGroupTitle(text2, title);
			permission.SetGroupRank(text2, rank);
			player.Reply(lang.GetMessage("GroupChanged", this, player.Id), text2);
		}
		else if (text.Equals("parent"))
		{
			if (args.Length <= 2)
			{
				player.Reply(lang.GetMessage("CommandUsageGroupParent", this, player.Id));
				return;
			}
			if (!permission.GroupExists(text2))
			{
				player.Reply(lang.GetMessage("GroupNotFound", this, player.Id), text2);
				return;
			}
			string text3 = args[2];
			if (!string.IsNullOrEmpty(text3) && !permission.GroupExists(text3))
			{
				player.Reply(lang.GetMessage("GroupParentNotFound", this, player.Id), text3);
			}
			else if (permission.SetGroupParent(text2, text3))
			{
				player.Reply(lang.GetMessage("GroupParentChanged", this, player.Id), text2, text3);
			}
			else
			{
				player.Reply(lang.GetMessage("GroupParentNotChanged", this, player.Id), text2);
			}
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageGroup", this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageGroupParent", this, player.Id));
			player.Reply(lang.GetMessage("CommandUsageGroupRemove", this, player.Id));
		}
	}

	[HookMethod("LangCommand")]
	private void LangCommand(IPlayer player, string command, string[] args)
	{
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageLang", this, player.Id));
		}
		else if (player.Id != "server_console")
		{
			lang.SetLanguage(args[0], player.Id);
			player.Reply(lang.GetMessage("PlayerLanguage", this, player.Id), args[0]);
		}
		else
		{
			lang.SetServerLanguage(args[0]);
			player.Reply(lang.GetMessage("ServerLanguage", this, player.Id), lang.GetServerLanguage());
		}
	}

	[HookMethod("LoadCommand")]
	private void LoadCommand(IPlayer player, string command, string[] args)
	{
		if (!player.IsAdmin && !player.HasPermission("oxide.load"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id), command);
			return;
		}
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageLoad", this, player.Id));
			return;
		}
		if (args[0].Equals("*") || args[0].Equals("all"))
		{
			Interface.Oxide.LoadAllPlugins();
			return;
		}
		foreach (string value in args)
		{
			if (!string.IsNullOrEmpty(value))
			{
				Interface.Oxide.LoadPlugin(value);
				pluginManager.GetPlugin(value);
			}
		}
	}

	[HookMethod("PluginsCommand")]
	private void PluginsCommand(IPlayer player, string command, string[] args)
	{
		if (!player.IsAdmin && !player.HasPermission("oxide.plugins"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id), command);
			return;
		}
		Plugin[] array = (from pl in pluginManager.GetPlugins()
			where !pl.IsCorePlugin
			select pl).ToArray();
		HashSet<string> second = new HashSet<string>(array.Select((Plugin pl) => pl.Name));
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		foreach (PluginLoader pluginLoader in Interface.Oxide.GetPluginLoaders())
		{
			foreach (string item in pluginLoader.ScanDirectory(Interface.Oxide.PluginDirectory).Except(second))
			{
				dictionary[item] = (pluginLoader.PluginErrors.TryGetValue(item, out var value) ? value : "Unloaded");
			}
		}
		if (array.Length + dictionary.Count < 1)
		{
			player.Reply(lang.GetMessage("NoPluginsFound", this, player.Id));
			return;
		}
		string text = $"Listing {array.Length + dictionary.Count} plugins:";
		int num = 1;
		foreach (Plugin item2 in array.Where((Plugin p) => p.Filename != null))
		{
			text += $"\n  {num++:00} \"{item2.Title}\" ({item2.Version}) by {item2.Author} ({item2.TotalHookTime:0.00}s) - {item2.Filename.Basename()}";
		}
		foreach (string key in dictionary.Keys)
		{
			text += $"\n  {num++:00} {key} - {dictionary[key]}";
		}
		player.Reply(text);
	}

	[HookMethod("ReloadCommand")]
	private void ReloadCommand(IPlayer player, string command, string[] args)
	{
		if (!player.IsAdmin && !player.HasPermission("oxide.reload"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id), command);
			return;
		}
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageReload", this, player.Id));
			return;
		}
		if (args[0].Equals("*") || args[0].Equals("all"))
		{
			Interface.Oxide.ReloadAllPlugins();
			return;
		}
		foreach (string value in args)
		{
			if (!string.IsNullOrEmpty(value))
			{
				Interface.Oxide.ReloadPlugin(value);
			}
		}
	}

	[HookMethod("RevokeCommand")]
	private void RevokeCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (!player.IsAdmin && !player.HasPermission("oxide.revoke"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id), command);
			return;
		}
		if (args.Length < 3)
		{
			player.Reply(lang.GetMessage("CommandUsageRevoke", this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = args[1];
		string text3 = args[2];
		if (text.Equals("group"))
		{
			if (!permission.GroupExists(text2))
			{
				player.Reply(lang.GetMessage("GroupNotFound", this, player.Id), text2);
			}
			else if (!permission.GroupHasPermission(text2, text3))
			{
				player.Reply(lang.GetMessage("GroupDoesNotHavePermission", this, player.Id), text2, text3);
			}
			else
			{
				permission.RevokeGroupPermission(text2, text3);
				player.Reply(lang.GetMessage("GroupPermissionRevoked", this, player.Id), text2, text3);
			}
		}
		else if (text.Equals("user"))
		{
			IPlayer player2 = Covalence.PlayerManager.FindPlayer(text2);
			if (player2 == null && !permission.UserIdValid(text2))
			{
				player.Reply(lang.GetMessage("UserNotFound", this, player.Id), text2);
				return;
			}
			string text4 = text2;
			if (player2 != null)
			{
				text4 = player2.Id;
				text2 = player2.Name;
				permission.UpdateNickname(text4, text2);
			}
			if (!permission.UserHasPermission(text4, text3))
			{
				player.Reply(lang.GetMessage("UserDoesNotHavePermission", this, player.Id), text2, text3);
			}
			else
			{
				permission.RevokeUserPermission(text4, text3);
				player.Reply(lang.GetMessage("UserPermissionRevoked", this, player.Id), $"{text2} ({text4})", text3);
			}
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageRevoke", this, player.Id));
		}
	}

	[HookMethod("ShowCommand")]
	private void ShowCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (!player.IsAdmin && !player.HasPermission("oxide.show"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id), command);
			return;
		}
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageShow", this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = ((args.Length == 2) ? args[1] : string.Empty);
		if (text.Equals("perms"))
		{
			player.Reply(lang.GetMessage("Permissions", this, player.Id) + ":\n" + string.Join(", ", permission.GetPermissions()));
		}
		else if (text.Equals("perm"))
		{
			if (args.Length < 2)
			{
				player.Reply(lang.GetMessage("CommandUsageShow", this, player.Id));
				return;
			}
			if (string.IsNullOrEmpty(text2))
			{
				player.Reply(lang.GetMessage("CommandUsageShow", this, player.Id));
				return;
			}
			string[] permissionUsers = permission.GetPermissionUsers(text2);
			string[] permissionGroups = permission.GetPermissionGroups(text2);
			string text3 = string.Format("{0}:\n", string.Format(lang.GetMessage("PermissionUsers", this, player.Id), text2));
			text3 += ((permissionUsers.Length != 0) ? string.Join(", ", permissionUsers) : lang.GetMessage("NoPermissionUsers", this, player.Id));
			text3 += string.Format("\n\n{0}:\n", string.Format(lang.GetMessage("PermissionGroups", this, player.Id), text2));
			text3 += ((permissionGroups.Length != 0) ? string.Join(", ", permissionGroups) : lang.GetMessage("NoPermissionGroups", this, player.Id));
			player.Reply(text3);
		}
		else if (text.Equals("user"))
		{
			if (args.Length < 2)
			{
				player.Reply(lang.GetMessage("CommandUsageShow", this, player.Id));
				return;
			}
			if (string.IsNullOrEmpty(text2))
			{
				player.Reply(lang.GetMessage("CommandUsageShow", this, player.Id));
				return;
			}
			IPlayer player2 = Covalence.PlayerManager.FindPlayer(text2);
			if (player2 == null && !permission.UserIdValid(text2))
			{
				player.Reply(lang.GetMessage("UserNotFound", this, player.Id), text2);
				return;
			}
			string text4 = text2;
			if (player2 != null)
			{
				text4 = player2.Id;
				text2 = player2.Name;
				permission.UpdateNickname(text4, text2);
				text2 += $" ({text4})";
			}
			string[] userPermissions = permission.GetUserPermissions(text4);
			string[] userGroups = permission.GetUserGroups(text4);
			string text5 = string.Format("{0}:\n", string.Format(lang.GetMessage("UserPermissions", this, player.Id), text2));
			text5 += ((userPermissions.Length != 0) ? string.Join(", ", userPermissions) : lang.GetMessage("NoUserPermissions", this, player.Id));
			text5 += string.Format("\n\n{0}:\n", string.Format(lang.GetMessage("UserGroups", this, player.Id), text2));
			text5 += ((userGroups.Length != 0) ? string.Join(", ", userGroups) : lang.GetMessage("NoUserGroups", this, player.Id));
			player.Reply(text5);
		}
		else if (text.Equals("group"))
		{
			if (args.Length < 2)
			{
				player.Reply(lang.GetMessage("CommandUsageShow", this, player.Id));
				return;
			}
			if (string.IsNullOrEmpty(text2))
			{
				player.Reply(lang.GetMessage("CommandUsageShow", this, player.Id));
				return;
			}
			if (!permission.GroupExists(text2))
			{
				player.Reply(lang.GetMessage("GroupNotFound", this, player.Id), text2);
				return;
			}
			string[] usersInGroup = permission.GetUsersInGroup(text2);
			string[] groupPermissions = permission.GetGroupPermissions(text2);
			string text6 = string.Format("{0}:\n", string.Format(lang.GetMessage("GroupUsers", this, player.Id), text2));
			text6 += ((usersInGroup.Length != 0) ? string.Join(", ", usersInGroup) : lang.GetMessage("NoUsersInGroup", this, player.Id));
			text6 += string.Format("\n\n{0}:\n", string.Format(lang.GetMessage("GroupPermissions", this, player.Id), text2));
			text6 += ((groupPermissions.Length != 0) ? string.Join(", ", groupPermissions) : lang.GetMessage("NoGroupPermissions", this, player.Id));
			string groupParent = permission.GetGroupParent(text2);
			while (permission.GroupExists(groupParent))
			{
				text6 += string.Format("\n{0}:\n", string.Format(lang.GetMessage("ParentGroupPermissions", this, player.Id), groupParent));
				text6 += string.Join(", ", permission.GetGroupPermissions(groupParent));
				groupParent = permission.GetGroupParent(groupParent);
			}
			player.Reply(text6);
		}
		else if (text.Equals("groups"))
		{
			player.Reply(lang.GetMessage("Groups", this, player.Id) + ":\n" + string.Join(", ", permission.GetGroups()));
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageShow", this, player.Id));
		}
	}

	[HookMethod("UnloadCommand")]
	private void UnloadCommand(IPlayer player, string command, string[] args)
	{
		if (!player.IsAdmin && !player.HasPermission("oxide.unload"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id));
			return;
		}
		if (args.Length < 1)
		{
			player.Reply(lang.GetMessage("CommandUsageUnload", this, player.Id));
			return;
		}
		if (args[0].Equals("*") || args[0].Equals("all"))
		{
			Interface.Oxide.UnloadAllPlugins();
			return;
		}
		foreach (string value in args)
		{
			if (!string.IsNullOrEmpty(value))
			{
				Interface.Oxide.UnloadPlugin(value);
			}
		}
	}

	[HookMethod("UserGroupCommand")]
	private void UserGroupCommand(IPlayer player, string command, string[] args)
	{
		if (!PermissionsLoaded(player))
		{
			return;
		}
		if (!player.IsAdmin && !player.HasPermission("oxide.usergroup"))
		{
			player.Reply(lang.GetMessage("NotAllowed", this, player.Id), command);
			return;
		}
		if (args.Length < 3)
		{
			player.Reply(lang.GetMessage("CommandUsageUserGroup", this, player.Id));
			return;
		}
		string text = args[0];
		string text2 = args[1];
		string text3 = args[2];
		IPlayer player2 = Covalence.PlayerManager.FindPlayer(text2);
		if (player2 == null && !permission.UserIdValid(text2))
		{
			player.Reply(lang.GetMessage("UserNotFound", this, player.Id), text2);
			return;
		}
		string text4 = text2;
		if (player2 != null)
		{
			text4 = player2.Id;
			text2 = player2.Name;
			permission.UpdateNickname(text4, text2);
			text2 += $"({text4})";
		}
		if (!permission.GroupExists(text3))
		{
			player.Reply(lang.GetMessage("GroupNotFound", this, player.Id), text3);
		}
		else if (text.Equals("add"))
		{
			permission.AddUserGroup(text4, text3);
			player.Reply(lang.GetMessage("UserAddedToGroup", this, player.Id), text2, text3);
		}
		else if (text.Equals("remove"))
		{
			permission.RemoveUserGroup(text4, text3);
			player.Reply(lang.GetMessage("UserRemovedFromGroup", this, player.Id), text2, text3);
		}
		else
		{
			player.Reply(lang.GetMessage("CommandUsageUserGroup", this, player.Id));
		}
	}

	[HookMethod("VersionCommand")]
	private void VersionCommand(IPlayer player, string command, string[] args)
	{
		if (player.Id != "server_console")
		{
			string message = Covalence.FormatText("Server is running [#ffb658]Oxide {0}[/#] and [#ee715c]{1} {2}[/#]");
			player.Reply(message, OxideMod.Version, Covalence.GameName, Server.Version);
		}
		else
		{
			player.Reply($"Protocol: {Server.Protocol}\nBuild Date: {BuildInfo.Current.BuildDate}\n" + $"Unity Version: {UnityEngine.Application.unityVersion}\nChangeset: {BuildInfo.Current.Scm.ChangeId}\n" + $"Branch: {BuildInfo.Current.Scm.Branch}\nOxide Version: {OxideMod.Version}");
		}
	}

	public RustCore()
	{
		base.Title = "Rust";
		base.Author = "Oxide Team";
		Version assemblyVersion = RustExtension.AssemblyVersion;
		base.Version = new VersionNumber(assemblyVersion.Major, assemblyVersion.Minor, assemblyVersion.Build);
	}

	private bool PermissionsLoaded(IPlayer player)
	{
		if (permission.IsLoaded)
		{
			return true;
		}
		player.Reply(lang.GetMessage("PermissionsNotLoaded", this, player.Id), permission.LastException.Message);
		return false;
	}

	[HookMethod("Init")]
	private void Init()
	{
		RemoteLogger.SetTag("game", base.Title.ToLower());
		RemoteLogger.SetTag("game version", Server.Version);
		AddCovalenceCommand(new string[2] { "oxide.lang", "lang" }, "LangCommand");
		AddCovalenceCommand(new string[2] { "oxide.version", "version" }, "VersionCommand");
		AddCovalenceCommand(new string[2] { "oxide.plugins", "plugins" }, "PluginsCommand");
		AddCovalenceCommand(new string[2] { "oxide.load", "load" }, "LoadCommand");
		AddCovalenceCommand(new string[2] { "oxide.reload", "reload" }, "ReloadCommand");
		AddCovalenceCommand(new string[2] { "oxide.unload", "unload" }, "UnloadCommand");
		AddCovalenceCommand(new string[2] { "oxide.grant", "grant" }, "GrantCommand");
		AddCovalenceCommand(new string[2] { "oxide.group", "group" }, "GroupCommand");
		AddCovalenceCommand(new string[2] { "oxide.revoke", "revoke" }, "RevokeCommand");
		AddCovalenceCommand(new string[2] { "oxide.show", "show" }, "ShowCommand");
		AddCovalenceCommand(new string[2] { "oxide.usergroup", "usergroup" }, "UserGroupCommand");
		permission.RegisterPermission("oxide.plugins", this);
		permission.RegisterPermission("oxide.load", this);
		permission.RegisterPermission("oxide.reload", this);
		permission.RegisterPermission("oxide.unload", this);
		permission.RegisterPermission("oxide.grant", this);
		permission.RegisterPermission("oxide.group", this);
		permission.RegisterPermission("oxide.revoke", this);
		permission.RegisterPermission("oxide.show", this);
		permission.RegisterPermission("oxide.usergroup", this);
		lang.RegisterMessages(messages, this);
		if (!permission.IsLoaded)
		{
			return;
		}
		int num = 0;
		foreach (string defaultGroup in Interface.Oxide.Config.Options.DefaultGroups)
		{
			if (!permission.GroupExists(defaultGroup))
			{
				permission.CreateGroup(defaultGroup, defaultGroup, num++);
			}
		}
		permission.RegisterValidate((string s) => ulong.TryParse(s, out var result) && ((result == 0L) ? 1 : ((int)Math.Floor(Math.Log10(result) + 1.0))) >= 17);
		permission.CleanUp();
	}

	[HookMethod("OnPluginLoaded")]
	private void OnPluginLoaded(Plugin plugin)
	{
		if (serverInitialized)
		{
			plugin.CallHook("OnServerInitialized");
		}
	}

	[HookMethod("OnServerInitialized")]
	private void OnServerInitialized()
	{
		if (!serverInitialized)
		{
			if (Interface.Oxide.CheckConsole() && SingletonComponent<ServerConsole>.Instance != null)
			{
				SingletonComponent<ServerConsole>.Instance.enabled = false;
				UnityEngine.Object.Destroy(SingletonComponent<ServerConsole>.Instance);
				typeof(SingletonComponent<ServerConsole>).GetField("instance", BindingFlags.Static | BindingFlags.NonPublic)?.SetValue(null, null);
			}
			Oxide.Core.Analytics.Collect();
			RustExtension.ServerConsole();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools(that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
		}
	}

	[HookMethod("OnServerShutdown")]
	private void OnServerShutdown()
	{
		Interface.Oxide.OnShutdown();
	}

	private void ParseCommand(string argstr, out string command, out string[] args)
	{
		List<string> list = new List<string>();
		StringBuilder stringBuilder = new StringBuilder();
		bool flag = false;
		foreach (char c in argstr)
		{
			if (c == '"')
			{
				if (flag)
				{
					string text = stringBuilder.ToString().Trim();
					if (!string.IsNullOrEmpty(text))
					{
						list.Add(text);
					}
					stringBuilder.Clear();
					flag = false;
				}
				else
				{
					flag = true;
				}
			}
			else if (char.IsWhiteSpace(c) && !flag)
			{
				string text2 = stringBuilder.ToString().Trim();
				if (!string.IsNullOrEmpty(text2))
				{
					list.Add(text2);
				}
				stringBuilder.Clear();
			}
			else
			{
				stringBuilder.Append(c);
			}
		}
		if (stringBuilder.Length > 0)
		{
			string text3 = stringBuilder.ToString().Trim();
			if (!string.IsNullOrEmpty(text3))
			{
				list.Add(text3);
			}
		}
		if (list.Count == 0)
		{
			command = null;
			args = null;
		}
		else
		{
			command = list[0];
			list.RemoveAt(0);
			args = list.ToArray();
		}
	}

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg?.cmd == null)
		{
			return null;
		}
		if (Interface.Call("OnServerCommand", arg) != null)
		{
			return true;
		}
		string @string = arg.GetString(0);
		if (string.IsNullOrEmpty(@string))
		{
			return null;
		}
		BasePlayer basePlayer = arg.Connection?.player as BasePlayer;
		if (basePlayer == null)
		{
			return null;
		}
		string argstr = @string.TrimStart('/');
		ParseCommand(argstr, out var command, out var args);
		if (command == null)
		{
			return null;
		}
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		object obj = Interface.Call("OnPlayerCommand", arg);
		object obj2 = Interface.Call("OnUserCommand", iPlayer, command, args);
		if (obj != null || obj2 != null)
		{
			return true;
		}
		if (arg.cmd.FullName != "chat.say")
		{
			return null;
		}
		if (@string[0] != '/')
		{
			return null;
		}
		if (!Covalence.CommandSystem.HandleChatMessage(iPlayer, @string) && !cmdlib.HandleChatCommand(basePlayer, command, args))
		{
			if (!Interface.Oxide.Config.Options.Modded)
			{
				return null;
			}
			iPlayer.Reply(lang.GetMessage("UnknownCommand", this, iPlayer.Id), command);
			arg.ReplyWith(string.Empty);
			return true;
		}
		return null;
	}

	public static BasePlayer FindPlayer(string nameOrIdOrIp)
	{
		BasePlayer result = null;
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if (string.IsNullOrEmpty(activePlayer.UserIDString))
			{
				continue;
			}
			if (activePlayer.UserIDString.Equals(nameOrIdOrIp))
			{
				return activePlayer;
			}
			if (!string.IsNullOrEmpty(activePlayer.displayName))
			{
				if (activePlayer.displayName.Equals(nameOrIdOrIp, StringComparison.OrdinalIgnoreCase))
				{
					return activePlayer;
				}
				if (activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
				{
					result = activePlayer;
				}
				if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress.Equals(nameOrIdOrIp))
				{
					return activePlayer;
				}
			}
		}
		foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
		{
			if (string.IsNullOrEmpty(sleepingPlayer.UserIDString))
			{
				continue;
			}
			if (sleepingPlayer.UserIDString.Equals(nameOrIdOrIp))
			{
				return sleepingPlayer;
			}
			if (!string.IsNullOrEmpty(sleepingPlayer.displayName))
			{
				if (sleepingPlayer.displayName.Equals(nameOrIdOrIp, StringComparison.OrdinalIgnoreCase))
				{
					return sleepingPlayer;
				}
				if (sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
				{
					result = sleepingPlayer;
				}
			}
		}
		return result;
	}

	public static BasePlayer FindPlayerByName(string name)
	{
		BasePlayer result = null;
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if (!string.IsNullOrEmpty(activePlayer.displayName))
			{
				if (activePlayer.displayName.Equals(name, StringComparison.OrdinalIgnoreCase))
				{
					return activePlayer;
				}
				if (activePlayer.displayName.Contains(name, CompareOptions.OrdinalIgnoreCase))
				{
					result = activePlayer;
				}
			}
		}
		foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
		{
			if (!string.IsNullOrEmpty(sleepingPlayer.displayName))
			{
				if (sleepingPlayer.displayName.Equals(name, StringComparison.OrdinalIgnoreCase))
				{
					return sleepingPlayer;
				}
				if (sleepingPlayer.displayName.Contains(name, CompareOptions.OrdinalIgnoreCase))
				{
					result = sleepingPlayer;
				}
			}
		}
		return result;
	}

	public static BasePlayer FindPlayerById(ulong id)
	{
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if (activePlayer.userID == id)
			{
				return activePlayer;
			}
		}
		foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
		{
			if (sleepingPlayer.userID == id)
			{
				return sleepingPlayer;
			}
		}
		return null;
	}

	public static BasePlayer FindPlayerByIdString(string id)
	{
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if (!string.IsNullOrEmpty(activePlayer.UserIDString) && activePlayer.UserIDString.Equals(id))
			{
				return activePlayer;
			}
		}
		foreach (BasePlayer sleepingPlayer in BasePlayer.sleepingPlayerList)
		{
			if (!string.IsNullOrEmpty(sleepingPlayer.UserIDString) && sleepingPlayer.UserIDString.Equals(id))
			{
				return sleepingPlayer;
			}
		}
		return null;
	}

	[HookMethod("IOnDisableServerConsole")]
	private object IOnDisableServerConsole()
	{
		if (!ConsoleWindow.Check(force: true) || Interface.Oxide.CheckConsole(force: true))
		{
			return false;
		}
		return null;
	}

	[HookMethod("IOnEnableServerConsole")]
	private object IOnEnableServerConsole(ServerConsole serverConsole)
	{
		if (ConsoleWindow.Check(force: true) && !Interface.Oxide.CheckConsole(force: true))
		{
			return null;
		}
		serverConsole.enabled = false;
		UnityEngine.Object.Destroy(serverConsole);
		typeof(SingletonComponent<ServerConsole>).GetField("instance", BindingFlags.Static | BindingFlags.NonPublic)?.SetValue(null, null);
		return false;
	}

	[HookMethod("IOnRconCommand")]
	private object IOnRconCommand(IPAddress sender, string message)
	{
		if (string.IsNullOrEmpty(message))
		{
			return null;
		}
		RemoteMessage message2 = RemoteMessage.GetMessage(message);
		if (message2 == null)
		{
			return null;
		}
		string[] array = message2.Message.Split(' ');
		string text = array[0];
		if (Interface.Call("OnRconCommand", sender, text, (array.Length > 1) ? array.Skip(1).ToArray() : null) != null)
		{
			return true;
		}
		return null;
	}

	[HookMethod("IOnRconInitialize")]
	private object IOnRconInitialize()
	{
		if (!Interface.Oxide.Config.Rcon.Enabled)
		{
			return null;
		}
		return true;
	}

	[HookMethod("IOnRunCommandLine")]
	private object IOnRunCommandLine()
	{
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			ConsoleSystem.Option unrestricted = ConsoleSystem.Option.Unrestricted;
			unrestricted.PrintOutput = false;
			ConsoleSystem.Run(unrestricted, strCommand, text);
		}
		return false;
	}

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer player, HitInfo info)
	{
		if (!serverInitialized || player == null || info == null || player.IsDead() || isPlayerTakingDamage)
		{
			return null;
		}
		if (Interface.Call("OnEntityTakeDamage", player, info) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			player.OnAttacked(info);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

	[HookMethod("IOnBasePlayerHurt")]
	private object IOnBasePlayerHurt(BasePlayer player, HitInfo info)
	{
		if (!isPlayerTakingDamage)
		{
			return Interface.Call("OnEntityTakeDamage", player, info);
		}
		return null;
	}

	[HookMethod("IOnLootEntity")]
	private void IOnLootEntity(PlayerLoot source, BaseEntity entity)
	{
		Interface.Call("OnLootEntity", source.GetComponent<BasePlayer>(), entity);
	}

	[HookMethod("IOnLootItem")]
	private void IOnLootItem(PlayerLoot source, Item item)
	{
		Interface.Call("OnLootItem", source.GetComponent<BasePlayer>(), item);
	}

	[HookMethod("IOnLootPlayer")]
	private void IOnLootPlayer(PlayerLoot source, BasePlayer target)
	{
		Interface.Call("OnLootPlayer", source.GetComponent<BasePlayer>(), target);
	}

	[HookMethod("IOnPlayerAttack")]
	private object IOnPlayerAttack(BaseMelee melee, HitInfo info)
	{
		return Interface.Call("OnPlayerAttack", melee.GetOwnerPlayer(), info);
	}

	[HookMethod("IOnPlayerRevive")]
	private object IOnPlayerRevive(MedicalTool tool, BasePlayer target)
	{
		return Interface.Call("OnPlayerRevive", tool.GetOwnerPlayer(), target);
	}

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.Oxide.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.Oxide.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.Oxide.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.Oxide.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		int authLevel = connection.authLevel;
		string text2 = Regex.Replace(connection.ipaddress, ipPattern, "");
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj = Interface.Call("CanClientLogin", connection);
		object obj2 = Interface.Call("CanUserLogin", username, text, text2);
		object obj3 = obj ?? obj2;
		if (obj3 is string || (obj3 is bool && !(bool)obj3))
		{
			ConnectionAuth.Reject(connection, (obj3 is string) ? obj3.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj4 = Interface.Call("OnUserApprove", connection);
		object obj5 = Interface.Call("OnUserApproved", username, text, text2);
		return obj4 ?? obj5;
	}

	[HookMethod("IOnPlayerBanned")]
	private void IOnPlayerBanned(Connection connection)
	{
		string text = Regex.Replace(connection.ipaddress, ipPattern, "") ?? "0";
		string text2 = connection.authStatus ?? "Unknown";
		Interface.Oxide.CallHook("OnPlayerBanned", connection.username, connection.userid, text, text2);
		Interface.Oxide.CallHook("OnUserBanned", connection.username, connection.userid.ToString(), text, text2);
	}

	[HookMethod("OnPlayerChat")]
	private object OnPlayerChat(ConsoleSystem.Arg arg)
	{
		IPlayer iPlayer = (arg.Connection.player as BasePlayer).IPlayer;
		if (!string.IsNullOrEmpty(arg.GetString(0)))
		{
			return Interface.Call("OnUserChat", iPlayer, arg.GetString(0));
		}
		return null;
	}

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer player, string reason)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer != null)
		{
			Interface.Call("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(player);
	}

	[HookMethod("OnPlayerInit")]
	private void OnPlayerInit(BasePlayer player)
	{
		lang.SetLanguage(player.net.connection.info.GetString("global.language", "en"), player.UserIDString);
		Covalence.PlayerManager.PlayerConnected(player);
		IPlayer player2 = Covalence.PlayerManager.FindPlayerById(player.UserIDString);
		if (player2 != null)
		{
			player.IPlayer = player2;
			Interface.Call("OnUserConnected", player2);
		}
	}

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer player, string reason)
	{
		if (player.IPlayer != null)
		{
			Interface.Oxide.CallHook("OnUserKicked", player.IPlayer, reason);
		}
	}

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer player)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.Call("OnUserRespawn", iPlayer);
	}

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer player)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer != null)
		{
			Interface.Call("OnUserRespawned", iPlayer);
		}
	}

	[HookMethod("OnPlayerTick")]
	private object OnPlayerTick(BasePlayer player)
	{
		return Interface.Call("OnPlayerInput", player, player.serverInput);
	}

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo info)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.Call("OnEntityTakeDamage", entity, info);
		}
		return null;
	}

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.Call("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

	[HookMethod("IOnStructureDemolish")]
	private object IOnStructureDemolish(BuildingBlock block, BasePlayer player)
	{
		return Interface.Call("OnStructureDemolish", block, player, false);
	}

	[HookMethod("IOnStructureImmediateDemolish")]
	private object IOnStructureImmediateDemolish(BuildingBlock block, BasePlayer player)
	{
		return Interface.Call("OnStructureDemolish", block, player, true);
	}
}
