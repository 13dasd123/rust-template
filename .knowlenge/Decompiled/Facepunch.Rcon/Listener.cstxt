using System;
using System.Collections.Generic;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using Facepunch.Rcon;
using Facepunch.Rust.Profiling;
using Fleck;
using Oxide.Core;
using UnityEngine;

public class Listener
{
	public string Password;

	public int Port;

	public string Address;

	public string SslCertificate;

	public string SslCertificatePassword;

	public Action<IPAddress, int, string> OnMessage;

	private int nextClientId;

	private readonly Dictionary<int, RconConnection> clients = new Dictionary<int, RconConnection>();

	private readonly List<int> deadClients = new List<int>();

	private WebSocketServer server;

	public void Start()
	{
		Shutdown();
		bool num = !string.IsNullOrEmpty(SslCertificate) && !string.IsNullOrEmpty(SslCertificatePassword);
		IPAddress address = IPAddress.Any;
		string arg = (num ? "wss" : "ws");
		if (Address != null && !IPAddress.TryParse(Address, out address))
		{
			address = IPAddress.Any;
		}
		string location = $"{arg}://{address}:{Port}";
		server = new WebSocketServer(location);
		server.ListenerSocket.NoDelay = true;
		server.RestartAfterListenError = true;
		if (num)
		{
			X509Certificate2 certificate = new X509Certificate2(SslCertificate, SslCertificatePassword);
			server.Certificate = certificate;
		}
		string requiredPath = "/" + Password;
		server.Start(delegate(IWebSocketConnection socket)
		{
			IWebSocketConnection socket2 = socket;
			if (Interface.CallHook("OnRconConnection", socket.ConnectionInfo.ClientIpAddress) != null || socket2.ConnectionInfo.Path != requiredPath)
			{
				RconProfiler.OnFailedConnection(socket2, socket2.ConnectionInfo.Path);
				socket2.Close();
			}
			else
			{
				int id = Interlocked.Increment(ref nextClientId);
				IPAddress ipAddress = socket2.ConnectionInfo.ClientIpAddress;
				string ipString = ipAddress.ToString();
				int port = socket2.ConnectionInfo.ClientPort;
				RconProfiler.OnNewConnection(socket2, id);
				socket2.OnOpen = delegate
				{
					lock (clients)
					{
						clients.Add(id, new RconConnection(socket2, id));
						RconProfiler.UpdateClientCount(clients.Count);
					}
				};
				socket2.OnClose = delegate
				{
					lock (clients)
					{
						clients.Remove(id);
						RconProfiler.UpdateClientCount(clients.Count);
					}
				};
				socket2.OnMessage = delegate(string s)
				{
					if (Interface.CallHook("IOnRconMessage", socket2.ConnectionInfo.ClientIpAddress, s) == null)
					{
						lock (clients)
						{
							if (clients.TryGetValue(id, out var value))
							{
								value.Stats.RecievedMessages++;
							}
						}
						RconProfiler.OnRconMessage(ipString, port, id, s);
						OnMessage?.Invoke(ipAddress, id, s);
					}
				};
				socket2.OnError = delegate(Exception e)
				{
					Debug.Log("Rcon Error: " + e);
				};
			}
		});
	}

	public void Shutdown()
	{
		if (server != null)
		{
			server.Dispose();
			server = null;
		}
	}

	public void BroadcastMessage(string str)
	{
		if (server == null)
		{
			return;
		}
		lock (clients)
		{
			deadClients.Clear();
			foreach (KeyValuePair<int, RconConnection> client in clients)
			{
				if (client.Value.Socket.IsAvailable)
				{
					client.Value.Socket.Send(str);
					client.Value.Stats.BroadcastedMessages++;
				}
				else
				{
					deadClients.Add(client.Key);
				}
			}
			foreach (int deadClient in deadClients)
			{
				if (clients.TryGetValue(deadClient, out var value))
				{
					value.Socket.Close();
					clients.Remove(deadClient);
				}
			}
			RconProfiler.UpdateClientCount(clients.Count);
		}
	}

	public void SendMessage(int target, string str)
	{
		if (server == null)
		{
			return;
		}
		lock (clients)
		{
			if (clients.TryGetValue(target, out var value))
			{
				if (!value.Socket.IsAvailable)
				{
					value.Socket.Close();
					clients.Remove(target);
				}
				else
				{
					value.Socket.Send(str);
					value.Stats.SentMessages++;
					RconProfiler.UpdateClientCount(clients.Count);
				}
			}
		}
	}

	public IList<RconClientStats> GetClientStats()
	{
		List<RconClientStats> list = new List<RconClientStats>();
		lock (clients)
		{
			foreach (KeyValuePair<int, RconConnection> client in clients)
			{
				list.Add(client.Value.Stats);
			}
			return list;
		}
	}
}
