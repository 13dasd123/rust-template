using System;
using System.Collections.Generic;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using Fleck;
using Oxide.Core;
using UnityEngine;

public class Listener
{
	public string Password;

	public int Port;

	public string Address;

	public string SslCertificate;

	public string SslCertificatePassword;

	public Action<IPAddress, int, string> OnMessage;

	private int nextClientId;

	private readonly Dictionary<int, IWebSocketConnection> clients = new Dictionary<int, IWebSocketConnection>();

	private readonly List<int> deadClients = new List<int>();

	private WebSocketServer server;

	public void Start()
	{
		Shutdown();
		bool num = !string.IsNullOrEmpty(SslCertificate) && !string.IsNullOrEmpty(SslCertificatePassword);
		IPAddress address = IPAddress.Any;
		string arg = (num ? "wss" : "ws");
		if (Address != null && !IPAddress.TryParse(Address, out address))
		{
			address = IPAddress.Any;
		}
		string location = $"{arg}://{address}:{Port}";
		server = new WebSocketServer(location);
		server.ListenerSocket.NoDelay = true;
		server.RestartAfterListenError = true;
		if (num)
		{
			X509Certificate2 certificate = new X509Certificate2(SslCertificate, SslCertificatePassword);
			server.Certificate = certificate;
		}
		string requiredPath = "/" + Password;
		server.Start(delegate(IWebSocketConnection socket)
		{
			IWebSocketConnection socket2 = socket;
			if (Interface.CallHook("OnRconConnection", socket.ConnectionInfo.ClientIpAddress) != null || socket2.ConnectionInfo.Path != requiredPath)
			{
				socket2.Close();
			}
			else
			{
				int id = Interlocked.Increment(ref nextClientId);
				IPAddress ipAddress = socket2.ConnectionInfo.ClientIpAddress;
				socket2.OnOpen = delegate
				{
					lock (clients)
					{
						clients.Add(id, socket2);
					}
				};
				socket2.OnClose = delegate
				{
					lock (clients)
					{
						clients.Remove(id);
					}
				};
				socket2.OnMessage = delegate(string s)
				{
					if (Interface.CallHook("IOnRconCommand", socket2.ConnectionInfo.ClientIpAddress, s) == null)
					{
						OnMessage?.Invoke(ipAddress, id, s);
					}
				};
				socket2.OnError = delegate(Exception e)
				{
					Debug.Log("Rcon Error: " + e);
				};
			}
		});
	}

	public void Shutdown()
	{
		if (server != null)
		{
			server.Dispose();
			server = null;
		}
	}

	public void BroadcastMessage(string str)
	{
		if (server == null)
		{
			return;
		}
		lock (clients)
		{
			deadClients.Clear();
			foreach (KeyValuePair<int, IWebSocketConnection> client in clients)
			{
				if (client.Value.IsAvailable)
				{
					client.Value.Send(str);
				}
				else
				{
					deadClients.Add(client.Key);
				}
			}
			foreach (int deadClient in deadClients)
			{
				if (clients.TryGetValue(deadClient, out var value))
				{
					value.Close();
					clients.Remove(deadClient);
				}
			}
		}
	}

	public void SendMessage(int target, string str)
	{
		if (server == null)
		{
			return;
		}
		lock (clients)
		{
			if (clients.TryGetValue(target, out var value))
			{
				if (!value.IsAvailable)
				{
					value.Close();
					clients.Remove(target);
				}
				else
				{
					value.Send(str);
				}
			}
		}
	}
}
