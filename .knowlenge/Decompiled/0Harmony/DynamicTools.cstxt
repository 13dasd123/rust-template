using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using Harmony;
using Harmony.ILCopying;

public static class DynamicTools
{
	public static DynamicMethod CreateDynamicMethod(MethodBase original, string suffix)
	{
		if (original == null)
		{
			throw new ArgumentNullException("original cannot be null");
		}
		string text = original.Name + suffix;
		text = text.Replace("<>", "");
		ParameterInfo[] parameters = original.GetParameters();
		List<Type> list = parameters.Types().ToList();
		if (!original.IsStatic)
		{
			list.Insert(0, typeof(object));
		}
		Type[] parameterTypes = list.ToArray();
		Type returnedType = AccessTools.GetReturnedType(original);
		if (returnedType == null || returnedType.IsByRef)
		{
			return null;
		}
		DynamicMethod dynamicMethod;
		try
		{
			dynamicMethod = new DynamicMethod(text, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnedType, parameterTypes, original.DeclaringType, skipVisibility: true);
		}
		catch (Exception)
		{
			return null;
		}
		for (int i = 0; i < parameters.Length; i++)
		{
			dynamicMethod.DefineParameter(i + 1, parameters[i].Attributes, parameters[i].Name);
		}
		return dynamicMethod;
	}

	public static ILGenerator CreateSaveableMethod(MethodBase original, string suffix, out AssemblyBuilder assemblyBuilder, out TypeBuilder typeBuilder)
	{
		AssemblyName assemblyName = new AssemblyName("DebugAssembly");
		string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
		assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave, folderPath);
		ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name, assemblyName.Name + ".dll");
		typeBuilder = moduleBuilder.DefineType("Debug" + original.DeclaringType.Name, TypeAttributes.Public);
		if (original == null)
		{
			throw new ArgumentNullException("original cannot be null");
		}
		string text = original.Name + suffix;
		text = text.Replace("<>", "");
		ParameterInfo[] parameters = original.GetParameters();
		List<Type> list = parameters.Types().ToList();
		if (!original.IsStatic)
		{
			list.Insert(0, typeof(object));
		}
		Type[] parameterTypes = list.ToArray();
		MethodBuilder methodBuilder = typeBuilder.DefineMethod(text, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, AccessTools.GetReturnedType(original), parameterTypes);
		return methodBuilder.GetILGenerator();
	}

	public static void SaveMethod(AssemblyBuilder assemblyBuilder, TypeBuilder typeBuilder)
	{
		Type type = typeBuilder.CreateType();
		assemblyBuilder.Save("HarmonyDebugAssembly.dll");
	}

	public static LocalBuilder[] DeclareLocalVariables(MethodBase original, ILGenerator il, bool logOutput = true)
	{
		IList<LocalVariableInfo> list = original.GetMethodBody()?.LocalVariables;
		if (list == null)
		{
			return new LocalBuilder[0];
		}
		return list.Select(delegate(LocalVariableInfo lvi)
		{
			LocalBuilder localBuilder = il.DeclareLocal(lvi.LocalType, lvi.IsPinned);
			if (logOutput)
			{
				Emitter.LogLocalVariable(il, localBuilder);
			}
			return localBuilder;
		}).ToArray();
	}

	public static LocalBuilder DeclareLocalVariable(ILGenerator il, Type type)
	{
		if (type.IsByRef)
		{
			type = type.GetElementType();
		}
		if (AccessTools.IsClass(type))
		{
			LocalBuilder localBuilder = il.DeclareLocal(type);
			Emitter.LogLocalVariable(il, localBuilder);
			Emitter.Emit(il, OpCodes.Ldnull);
			Emitter.Emit(il, OpCodes.Stloc, localBuilder);
			return localBuilder;
		}
		if (AccessTools.IsStruct(type))
		{
			LocalBuilder localBuilder2 = il.DeclareLocal(type);
			Emitter.LogLocalVariable(il, localBuilder2);
			Emitter.Emit(il, OpCodes.Ldloca, localBuilder2);
			Emitter.Emit(il, OpCodes.Initobj, type);
			return localBuilder2;
		}
		if (AccessTools.IsValue(type))
		{
			LocalBuilder localBuilder3 = il.DeclareLocal(type);
			Emitter.LogLocalVariable(il, localBuilder3);
			if (type == typeof(float))
			{
				Emitter.Emit(il, OpCodes.Ldc_R4, 0f);
			}
			else if (type == typeof(double))
			{
				Emitter.Emit(il, OpCodes.Ldc_R8, 0.0);
			}
			else if (type == typeof(long))
			{
				Emitter.Emit(il, OpCodes.Ldc_I8, 0L);
			}
			else
			{
				Emitter.Emit(il, OpCodes.Ldc_I4, 0);
			}
			Emitter.Emit(il, OpCodes.Stloc, localBuilder3);
			return localBuilder3;
		}
		return null;
	}

	public static void PrepareDynamicMethod(DynamicMethod method)
	{
		BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.NonPublic;
		BindingFlags bindingAttr2 = BindingFlags.Static | BindingFlags.NonPublic;
		MethodInfo method2 = typeof(DynamicMethod).GetMethod("CreateDynMethod", bindingAttr);
		if (method2 != null)
		{
			method2.Invoke(method, new object[0]);
			return;
		}
		MethodInfo method3 = typeof(RuntimeHelpers).GetMethod("_CompileMethod", bindingAttr2);
		MethodInfo method4 = typeof(DynamicMethod).GetMethod("GetMethodDescriptor", bindingAttr);
		RuntimeMethodHandle runtimeMethodHandle = (RuntimeMethodHandle)method4.Invoke(method, new object[0]);
		MethodInfo method5 = typeof(RuntimeMethodHandle).GetMethod("GetMethodInfo", bindingAttr);
		if (method5 != null)
		{
			object obj = method5.Invoke(runtimeMethodHandle, new object[0]);
			try
			{
				method3.Invoke(null, new object[1] { obj });
				return;
			}
			catch (Exception)
			{
			}
		}
		if (method3.GetParameters()[0].ParameterType.IsAssignableFrom(runtimeMethodHandle.Value.GetType()))
		{
			method3.Invoke(null, new object[1] { runtimeMethodHandle.Value });
		}
		else if (method3.GetParameters()[0].ParameterType.IsAssignableFrom(runtimeMethodHandle.GetType()))
		{
			method3.Invoke(null, new object[1] { runtimeMethodHandle });
		}
	}
}
