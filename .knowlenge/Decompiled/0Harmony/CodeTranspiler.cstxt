using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Harmony;
using Harmony.ILCopying;

public class CodeTranspiler
{
	private IEnumerable<CodeInstruction> codeInstructions;

	private List<MethodInfo> transpilers = new List<MethodInfo>();

	private static readonly Dictionary<OpCode, OpCode> allJumpCodes = new Dictionary<OpCode, OpCode>
	{
		{
			OpCodes.Beq_S,
			OpCodes.Beq
		},
		{
			OpCodes.Bge_S,
			OpCodes.Bge
		},
		{
			OpCodes.Bge_Un_S,
			OpCodes.Bge_Un
		},
		{
			OpCodes.Bgt_S,
			OpCodes.Bgt
		},
		{
			OpCodes.Bgt_Un_S,
			OpCodes.Bgt_Un
		},
		{
			OpCodes.Ble_S,
			OpCodes.Ble
		},
		{
			OpCodes.Ble_Un_S,
			OpCodes.Ble_Un
		},
		{
			OpCodes.Blt_S,
			OpCodes.Blt
		},
		{
			OpCodes.Blt_Un_S,
			OpCodes.Blt_Un
		},
		{
			OpCodes.Bne_Un_S,
			OpCodes.Bne_Un
		},
		{
			OpCodes.Brfalse_S,
			OpCodes.Brfalse
		},
		{
			OpCodes.Brtrue_S,
			OpCodes.Brtrue
		},
		{
			OpCodes.Br_S,
			OpCodes.Br
		},
		{
			OpCodes.Leave_S,
			OpCodes.Leave
		}
	};

	public CodeTranspiler(List<ILInstruction> ilInstructions)
	{
		codeInstructions = ilInstructions.Select((ILInstruction ilInstruction) => ilInstruction.GetCodeInstruction()).ToList().AsEnumerable();
	}

	public void Add(MethodInfo transpiler)
	{
		transpilers.Add(transpiler);
	}

	[UpgradeToLatestVersion(1)]
	public static object ConvertInstruction(Type type, object op, out Dictionary<string, object> unassigned)
	{
		Dictionary<string, object> nonExisting = new Dictionary<string, object>();
		object result = AccessTools.MakeDeepCopy(op, type, delegate(string namePath, Traverse trvSrc, Traverse trvDest)
		{
			object value = trvSrc.GetValue();
			if (!trvDest.FieldExists())
			{
				nonExisting[namePath] = value;
				return (object)null;
			}
			return (namePath == "opcode") ? ((object)ReplaceShortJumps((OpCode)value)) : value;
		});
		unassigned = nonExisting;
		return result;
	}

	public static bool ShouldAddExceptionInfo(object op, int opIndex, List<object> originalInstructions, List<object> newInstructions, Dictionary<object, Dictionary<string, object>> unassignedValues)
	{
		int num = originalInstructions.IndexOf(op);
		if (num == -1)
		{
			return false;
		}
		Dictionary<string, object> unassigned = null;
		if (!unassignedValues.TryGetValue(op, out unassigned))
		{
			return false;
		}
		if (!unassigned.TryGetValue("blocks", out var blocksObject))
		{
			return false;
		}
		List<ExceptionBlock> blocks = blocksObject as List<ExceptionBlock>;
		int num2 = newInstructions.Count((object instr) => instr == op);
		if (num2 <= 1)
		{
			return true;
		}
		ExceptionBlock exceptionBlock = blocks.FirstOrDefault((ExceptionBlock block) => block.blockType != ExceptionBlockType.EndExceptionBlock);
		ExceptionBlock exceptionBlock2 = blocks.FirstOrDefault((ExceptionBlock block) => block.blockType == ExceptionBlockType.EndExceptionBlock);
		if (exceptionBlock != null && exceptionBlock2 == null)
		{
			object obj = originalInstructions.Skip(num + 1).FirstOrDefault(delegate(object instr)
			{
				if (!unassignedValues.TryGetValue(instr, out unassigned))
				{
					return false;
				}
				if (!unassigned.TryGetValue("blocks", out blocksObject))
				{
					return false;
				}
				blocks = blocksObject as List<ExceptionBlock>;
				return blocks.Count() > 0;
			});
			if (obj != null)
			{
				int num3 = num + 1;
				int num4 = num3 + originalInstructions.Skip(num3).ToList().IndexOf(obj) - 1;
				IEnumerable<object> first = originalInstructions.GetRange(num3, num4 - num3).Intersect(newInstructions);
				obj = newInstructions.Skip(opIndex + 1).FirstOrDefault(delegate(object instr)
				{
					if (!unassignedValues.TryGetValue(instr, out unassigned))
					{
						return false;
					}
					if (!unassigned.TryGetValue("blocks", out blocksObject))
					{
						return false;
					}
					blocks = blocksObject as List<ExceptionBlock>;
					return blocks.Count() > 0;
				});
				if (obj != null)
				{
					num3 = opIndex + 1;
					num4 = num3 + newInstructions.Skip(opIndex + 1).ToList().IndexOf(obj) - 1;
					List<object> range = newInstructions.GetRange(num3, num4 - num3);
					List<object> source = first.Except(range).ToList();
					return source.Count() == 0;
				}
			}
		}
		if (exceptionBlock == null && exceptionBlock2 != null)
		{
			object obj2 = originalInstructions.GetRange(0, num).LastOrDefault(delegate(object instr)
			{
				if (!unassignedValues.TryGetValue(instr, out unassigned))
				{
					return false;
				}
				if (!unassigned.TryGetValue("blocks", out blocksObject))
				{
					return false;
				}
				blocks = blocksObject as List<ExceptionBlock>;
				return blocks.Count() > 0;
			});
			if (obj2 != null)
			{
				int num5 = originalInstructions.GetRange(0, num).LastIndexOf(obj2);
				int num6 = num;
				IEnumerable<object> first2 = originalInstructions.GetRange(num5, num6 - num5).Intersect(newInstructions);
				obj2 = newInstructions.GetRange(0, opIndex).LastOrDefault(delegate(object instr)
				{
					if (!unassignedValues.TryGetValue(instr, out unassigned))
					{
						return false;
					}
					if (!unassigned.TryGetValue("blocks", out blocksObject))
					{
						return false;
					}
					blocks = blocksObject as List<ExceptionBlock>;
					return blocks.Count() > 0;
				});
				if (obj2 != null)
				{
					num5 = newInstructions.GetRange(0, opIndex).LastIndexOf(obj2);
					num6 = opIndex;
					List<object> range2 = newInstructions.GetRange(num5, num6 - num5);
					IEnumerable<object> source2 = first2.Except(range2);
					return source2.Count() == 0;
				}
			}
		}
		return true;
	}

	public static IEnumerable ConvertInstructionsAndUnassignedValues(Type type, IEnumerable enumerable, out Dictionary<object, Dictionary<string, object>> unassignedValues)
	{
		Assembly assembly = type.GetGenericTypeDefinition().Assembly;
		Type type2 = assembly.GetType(typeof(List<>).FullName);
		Type type3 = type.GetGenericArguments()[0];
		Type type4 = assembly.GetType(type2.MakeGenericType(type3).FullName);
		object obj = Activator.CreateInstance(type4);
		MethodInfo method = obj.GetType().GetMethod("Add");
		unassignedValues = new Dictionary<object, Dictionary<string, object>>();
		foreach (object item in enumerable)
		{
			Dictionary<string, object> unassigned;
			object obj2 = ConvertInstruction(type3, item, out unassigned);
			unassignedValues.Add(obj2, unassigned);
			method.Invoke(obj, new object[1] { obj2 });
		}
		return obj as IEnumerable;
	}

	[UpgradeToLatestVersion(1)]
	public static IEnumerable ConvertToOurInstructions(IEnumerable instructions, List<object> originalInstructions, Dictionary<object, Dictionary<string, object>> unassignedValues)
	{
		Type codeInstructionType = (from type in (from frame in new StackTrace().GetFrames()
				select frame.GetMethod()).OfType<MethodInfo>().Select(delegate(MethodInfo method)
			{
				Type returnType = method.ReturnType;
				if (!returnType.IsGenericType)
				{
					return (Type)null;
				}
				Type[] genericArguments = returnType.GetGenericArguments();
				if (genericArguments.Length != 1)
				{
					return (Type)null;
				}
				Type type2 = genericArguments[0];
				return (type2.FullName == typeof(CodeInstruction).FullName) ? type2 : null;
			})
			where type != null
			select type).First();
		List<object> newInstructions = instructions.Cast<object>().ToList();
		int index = -1;
		foreach (object op in newInstructions)
		{
			index++;
			object elementTo = AccessTools.MakeDeepCopy(op, codeInstructionType);
			if (unassignedValues.TryGetValue(op, out var fields))
			{
				bool addExceptionInfo = ShouldAddExceptionInfo(op, index, originalInstructions, newInstructions, unassignedValues);
				Traverse trv = Traverse.Create(elementTo);
				foreach (KeyValuePair<string, object> field in fields)
				{
					if (addExceptionInfo || field.Key != "blocks")
					{
						trv.Field(field.Key).SetValue(field.Value);
					}
				}
			}
			yield return elementTo;
			fields = null;
		}
	}

	public static IEnumerable ConvertToGeneralInstructions(MethodInfo transpiler, IEnumerable enumerable, out Dictionary<object, Dictionary<string, object>> unassignedValues)
	{
		Type type = (from p in transpiler.GetParameters()
			select p.ParameterType).FirstOrDefault((Type t) => t.IsGenericType && t.GetGenericTypeDefinition().Name.StartsWith("IEnumerable"));
		return ConvertInstructionsAndUnassignedValues(type, enumerable, out unassignedValues);
	}

	public static List<object> GetTranspilerCallParameters(ILGenerator generator, MethodInfo transpiler, MethodBase method, IEnumerable instructions)
	{
		List<object> parameter = new List<object>();
		(from param in transpiler.GetParameters()
			select param.ParameterType).Do(delegate(Type type)
		{
			if (type.IsAssignableFrom(typeof(ILGenerator)))
			{
				parameter.Add(generator);
			}
			else if (type.IsAssignableFrom(typeof(MethodBase)))
			{
				parameter.Add(method);
			}
			else
			{
				parameter.Add(instructions);
			}
		});
		return parameter;
	}

	public List<CodeInstruction> GetResult(ILGenerator generator, MethodBase method)
	{
		IEnumerable instructions = codeInstructions;
		transpilers.ForEach(delegate(MethodInfo transpiler)
		{
			instructions = ConvertToGeneralInstructions(transpiler, instructions, out var unassignedValues);
			List<object> list = new List<object>();
			list.AddRange(instructions.Cast<object>());
			List<object> transpilerCallParameters = GetTranspilerCallParameters(generator, transpiler, method, instructions);
			instructions = transpiler.Invoke(null, transpilerCallParameters.ToArray()) as IEnumerable;
			instructions = ConvertToOurInstructions(instructions, list, unassignedValues);
		});
		return instructions.Cast<CodeInstruction>().ToList();
	}

	private static OpCode ReplaceShortJumps(OpCode opcode)
	{
		foreach (KeyValuePair<OpCode, OpCode> allJumpCode in allJumpCodes)
		{
			if (opcode == allJumpCode.Key)
			{
				return allJumpCode.Value;
			}
		}
		return opcode;
	}
}
