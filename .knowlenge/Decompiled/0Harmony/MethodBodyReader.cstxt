using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using Harmony;
using Harmony.ILCopying;

public class MethodBodyReader
{
	private class ThisParameter : ParameterInfo
	{
		public ThisParameter(MethodBase method)
		{
			MemberImpl = method;
			ClassImpl = method.DeclaringType;
			NameImpl = "this";
			PositionImpl = -1;
		}
	}

	private readonly ILGenerator generator;

	private readonly MethodBase method;

	private readonly Module module;

	private readonly Type[] typeArguments;

	private readonly Type[] methodArguments;

	private readonly ByteBuffer ilBytes;

	private readonly ParameterInfo this_parameter;

	private readonly ParameterInfo[] parameters;

	private readonly IList<LocalVariableInfo> locals;

	private readonly IList<ExceptionHandlingClause> exceptions;

	private List<ILInstruction> ilInstructions;

	private LocalBuilder[] variables;

	private static Dictionary<OpCode, OpCode> shortJumps;

	private static readonly OpCode[] one_byte_opcodes;

	private static readonly OpCode[] two_bytes_opcodes;

	private static readonly Dictionary<Type, MethodInfo> emitMethods;

	public static List<ILInstruction> GetInstructions(ILGenerator generator, MethodBase method)
	{
		if (method == null)
		{
			throw new ArgumentNullException("Method cannot be null");
		}
		MethodBodyReader methodBodyReader = new MethodBodyReader(method, generator);
		methodBodyReader.DeclareVariables(null);
		methodBodyReader.ReadInstructions();
		return methodBodyReader.ilInstructions;
	}

	public MethodBodyReader(MethodBase method, ILGenerator generator)
	{
		this.generator = generator;
		this.method = method;
		module = method.Module;
		MethodBody methodBody = method.GetMethodBody();
		if (methodBody == null)
		{
			throw new ArgumentException("Method " + method.FullDescription() + " has no body");
		}
		byte[] iLAsByteArray = methodBody.GetILAsByteArray();
		if (iLAsByteArray == null)
		{
			throw new ArgumentException("Can not get IL bytes of method " + method.FullDescription());
		}
		ilBytes = new ByteBuffer(iLAsByteArray);
		ilInstructions = new List<ILInstruction>((iLAsByteArray.Length + 1) / 2);
		Type declaringType = method.DeclaringType;
		if (declaringType.IsGenericType)
		{
			try
			{
				typeArguments = declaringType.GetGenericArguments();
			}
			catch
			{
				typeArguments = null;
			}
		}
		if (method.IsGenericMethod)
		{
			try
			{
				methodArguments = method.GetGenericArguments();
			}
			catch
			{
				methodArguments = null;
			}
		}
		if (!method.IsStatic)
		{
			this_parameter = new ThisParameter(method);
		}
		parameters = method.GetParameters();
		locals = methodBody.LocalVariables;
		exceptions = methodBody.ExceptionHandlingClauses;
	}

	public void ReadInstructions()
	{
		while (ilBytes.position < ilBytes.buffer.Length)
		{
			int position = ilBytes.position;
			ILInstruction iLInstruction = new ILInstruction(ReadOpCode())
			{
				offset = position
			};
			ReadOperand(iLInstruction);
			ilInstructions.Add(iLInstruction);
		}
		ResolveBranches();
		ParseExceptions();
	}

	public void DeclareVariables(LocalBuilder[] existingVariables)
	{
		if (generator == null)
		{
			return;
		}
		if (existingVariables != null)
		{
			variables = existingVariables;
			return;
		}
		variables = locals.Select((LocalVariableInfo lvi) => generator.DeclareLocal(lvi.LocalType, lvi.IsPinned)).ToArray();
	}

	private void ResolveBranches()
	{
		foreach (ILInstruction ilInstruction in ilInstructions)
		{
			switch (ilInstruction.opcode.OperandType)
			{
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				ilInstruction.operand = GetInstruction((int)ilInstruction.operand, isEndOfInstruction: false);
				break;
			case OperandType.InlineSwitch:
			{
				int[] array = (int[])ilInstruction.operand;
				ILInstruction[] array2 = new ILInstruction[array.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array2[i] = GetInstruction(array[i], isEndOfInstruction: false);
				}
				ilInstruction.operand = array2;
				break;
			}
			}
		}
	}

	private void ParseExceptions()
	{
		foreach (ExceptionHandlingClause exception in exceptions)
		{
			int tryOffset = exception.TryOffset;
			int num = exception.TryOffset + exception.TryLength - 1;
			int handlerOffset = exception.HandlerOffset;
			int offset = exception.HandlerOffset + exception.HandlerLength - 1;
			ILInstruction instruction = GetInstruction(tryOffset, isEndOfInstruction: false);
			instruction.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginExceptionBlock, null));
			ILInstruction instruction2 = GetInstruction(offset, isEndOfInstruction: true);
			instruction2.blocks.Add(new ExceptionBlock(ExceptionBlockType.EndExceptionBlock, null));
			switch (exception.Flags)
			{
			case ExceptionHandlingClauseOptions.Filter:
			{
				ILInstruction instruction6 = GetInstruction(exception.FilterOffset, isEndOfInstruction: false);
				instruction6.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginExceptFilterBlock, null));
				break;
			}
			case ExceptionHandlingClauseOptions.Finally:
			{
				ILInstruction instruction5 = GetInstruction(handlerOffset, isEndOfInstruction: false);
				instruction5.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginFinallyBlock, null));
				break;
			}
			case ExceptionHandlingClauseOptions.Clause:
			{
				ILInstruction instruction4 = GetInstruction(handlerOffset, isEndOfInstruction: false);
				instruction4.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginCatchBlock, exception.CatchType));
				break;
			}
			case ExceptionHandlingClauseOptions.Fault:
			{
				ILInstruction instruction3 = GetInstruction(handlerOffset, isEndOfInstruction: false);
				instruction3.blocks.Add(new ExceptionBlock(ExceptionBlockType.BeginFaultBlock, null));
				break;
			}
			}
		}
	}

	public void FinalizeILCodes(List<MethodInfo> transpilers, List<Label> endLabels, List<ExceptionBlock> endBlocks)
	{
		if (generator == null)
		{
			return;
		}
		foreach (ILInstruction ilInstruction in ilInstructions)
		{
			switch (ilInstruction.opcode.OperandType)
			{
			case OperandType.InlineSwitch:
				if (ilInstruction.operand is ILInstruction[] array)
				{
					List<Label> list = new List<Label>();
					ILInstruction[] array2 = array;
					foreach (ILInstruction iLInstruction2 in array2)
					{
						Label item = generator.DefineLabel();
						iLInstruction2.labels.Add(item);
						list.Add(item);
					}
					ilInstruction.argument = list.ToArray();
				}
				break;
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				if (ilInstruction.operand is ILInstruction iLInstruction)
				{
					Label label2 = generator.DefineLabel();
					iLInstruction.labels.Add(label2);
					ilInstruction.argument = label2;
				}
				break;
			}
		}
		CodeTranspiler codeTranspiler = new CodeTranspiler(ilInstructions);
		transpilers.Do(delegate(MethodInfo transpiler)
		{
			codeTranspiler.Add(transpiler);
		});
		List<CodeInstruction> result = codeTranspiler.GetResult(generator, method);
		while (true)
		{
			CodeInstruction codeInstruction2 = result.LastOrDefault();
			if (codeInstruction2 == null || codeInstruction2.opcode != OpCodes.Ret)
			{
				break;
			}
			endLabels.AddRange(codeInstruction2.labels);
			result.RemoveAt(result.Count - 1);
		}
		int idx = 0;
		result.Do(delegate(CodeInstruction codeInstruction)
		{
			codeInstruction.labels.Do(delegate(Label label)
			{
				Emitter.MarkLabel(generator, label);
			});
			codeInstruction.blocks.Do(delegate(ExceptionBlock block)
			{
				Emitter.MarkBlockBefore(generator, block, out var _);
			});
			OpCode opCode = codeInstruction.opcode;
			object obj = codeInstruction.operand;
			if (opCode == OpCodes.Ret)
			{
				Label label4 = generator.DefineLabel();
				opCode = OpCodes.Br;
				obj = label4;
				endLabels.Add(label4);
			}
			if (shortJumps.TryGetValue(opCode, out var value))
			{
				opCode = value;
			}
			if (true)
			{
				switch (opCode.OperandType)
				{
				case OperandType.InlineNone:
					Emitter.Emit(generator, opCode);
					break;
				case OperandType.InlineSig:
					if (obj == null)
					{
						throw new Exception("Wrong null argument: " + codeInstruction);
					}
					if (!(obj is int))
					{
						throw new Exception(string.Concat("Wrong Emit argument type ", obj.GetType(), " in ", codeInstruction));
					}
					Emitter.Emit(generator, opCode, (int)obj);
					break;
				default:
				{
					if (obj == null)
					{
						throw new Exception("Wrong null argument: " + codeInstruction);
					}
					MethodInfo methodInfo = EmitMethodForType(obj.GetType());
					if (methodInfo == null)
					{
						throw new Exception(string.Concat("Unknown Emit argument type ", obj.GetType(), " in ", codeInstruction));
					}
					if (HarmonyInstance.DEBUG)
					{
						FileLog.LogBuffered(string.Concat(Emitter.CodePos(generator), opCode, " ", Emitter.FormatArgument(obj)));
					}
					methodInfo.Invoke(generator, new object[2] { opCode, obj });
					break;
				}
				}
			}
			codeInstruction.blocks.Do(delegate(ExceptionBlock block)
			{
				Emitter.MarkBlockAfter(generator, block);
			});
			idx++;
		});
	}

	private static void GetMemberInfoValue(MemberInfo info, out object result)
	{
		result = null;
		switch (info.MemberType)
		{
		case MemberTypes.Constructor:
			result = (ConstructorInfo)info;
			break;
		case MemberTypes.Event:
			result = (EventInfo)info;
			break;
		case MemberTypes.Field:
			result = (FieldInfo)info;
			break;
		case MemberTypes.Method:
			result = (MethodInfo)info;
			break;
		case MemberTypes.TypeInfo:
		case MemberTypes.NestedType:
			result = (Type)info;
			break;
		case MemberTypes.Property:
			result = (PropertyInfo)info;
			break;
		}
	}

	private void ReadOperand(ILInstruction instruction)
	{
		switch (instruction.opcode.OperandType)
		{
		case OperandType.InlineNone:
			instruction.argument = null;
			break;
		case OperandType.InlineSwitch:
		{
			int num2 = ilBytes.ReadInt32();
			int num3 = ilBytes.position + 4 * num2;
			int[] array = new int[num2];
			for (int i = 0; i < num2; i++)
			{
				array[i] = ilBytes.ReadInt32() + num3;
			}
			instruction.operand = array;
			break;
		}
		case OperandType.ShortInlineBrTarget:
		{
			sbyte b2 = (sbyte)ilBytes.ReadByte();
			instruction.operand = b2 + ilBytes.position;
			break;
		}
		case OperandType.InlineBrTarget:
		{
			int num4 = ilBytes.ReadInt32();
			instruction.operand = num4 + ilBytes.position;
			break;
		}
		case OperandType.ShortInlineI:
			if (instruction.opcode == OpCodes.Ldc_I4_S)
			{
				sbyte b4 = (sbyte)ilBytes.ReadByte();
				instruction.operand = b4;
				instruction.argument = (sbyte)instruction.operand;
			}
			else
			{
				byte b5 = ilBytes.ReadByte();
				instruction.operand = b5;
				instruction.argument = (byte)instruction.operand;
			}
			break;
		case OperandType.InlineI:
		{
			int num8 = ilBytes.ReadInt32();
			instruction.operand = num8;
			instruction.argument = (int)instruction.operand;
			break;
		}
		case OperandType.ShortInlineR:
		{
			float num6 = ilBytes.ReadSingle();
			instruction.operand = num6;
			instruction.argument = (float)instruction.operand;
			break;
		}
		case OperandType.InlineR:
		{
			double num5 = ilBytes.ReadDouble();
			instruction.operand = num5;
			instruction.argument = (double)instruction.operand;
			break;
		}
		case OperandType.InlineI8:
		{
			long num7 = ilBytes.ReadInt64();
			instruction.operand = num7;
			instruction.argument = (long)instruction.operand;
			break;
		}
		case OperandType.InlineSig:
		{
			int metadataToken = ilBytes.ReadInt32();
			byte[] source = (byte[])(instruction.argument = (instruction.operand = module.ResolveSignature(metadataToken)));
			Debugger.Log(0, "TEST", "METHOD " + method.FullDescription() + "\n");
			Debugger.Log(0, "TEST", "Signature = " + source.Select((byte b) => $"0x{b:x02}").Aggregate((string a, string b) => a + " " + b) + "\n");
			Debugger.Break();
			break;
		}
		case OperandType.InlineString:
		{
			int metadataToken6 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveString(metadataToken6);
			instruction.argument = (string)instruction.operand;
			break;
		}
		case OperandType.InlineTok:
		{
			int metadataToken5 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveMember(metadataToken5, typeArguments, methodArguments);
			GetMemberInfoValue((MemberInfo)instruction.operand, out instruction.argument);
			break;
		}
		case OperandType.InlineType:
		{
			int metadataToken4 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveType(metadataToken4, typeArguments, methodArguments);
			instruction.argument = (Type)instruction.operand;
			break;
		}
		case OperandType.InlineMethod:
		{
			int metadataToken3 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveMethod(metadataToken3, typeArguments, methodArguments);
			if (instruction.operand is ConstructorInfo)
			{
				instruction.argument = (ConstructorInfo)instruction.operand;
			}
			else
			{
				instruction.argument = (MethodInfo)instruction.operand;
			}
			break;
		}
		case OperandType.InlineField:
		{
			int metadataToken2 = ilBytes.ReadInt32();
			instruction.operand = module.ResolveField(metadataToken2, typeArguments, methodArguments);
			instruction.argument = (FieldInfo)instruction.operand;
			break;
		}
		case OperandType.ShortInlineVar:
		{
			byte b3 = ilBytes.ReadByte();
			if (TargetsLocalVariable(instruction.opcode))
			{
				LocalVariableInfo localVariable2 = GetLocalVariable(b3);
				if (localVariable2 == null)
				{
					instruction.argument = b3;
					break;
				}
				instruction.operand = localVariable2;
				instruction.argument = variables[localVariable2.LocalIndex];
			}
			else
			{
				instruction.operand = GetParameter(b3);
				instruction.argument = b3;
			}
			break;
		}
		case OperandType.InlineVar:
		{
			short num = ilBytes.ReadInt16();
			if (TargetsLocalVariable(instruction.opcode))
			{
				LocalVariableInfo localVariable = GetLocalVariable(num);
				if (localVariable == null)
				{
					instruction.argument = num;
					break;
				}
				instruction.operand = localVariable;
				instruction.argument = variables[localVariable.LocalIndex];
			}
			else
			{
				instruction.operand = GetParameter(num);
				instruction.argument = num;
			}
			break;
		}
		default:
			throw new NotSupportedException();
		}
	}

	private ILInstruction GetInstruction(int offset, bool isEndOfInstruction)
	{
		int num = ilInstructions.Count - 1;
		if (offset < 0 || offset > ilInstructions[num].offset)
		{
			throw new Exception("Instruction offset " + offset + " is outside valid range 0 - " + ilInstructions[num].offset);
		}
		int num2 = 0;
		int num3 = num;
		while (num2 <= num3)
		{
			int num4 = num2 + (num3 - num2) / 2;
			ILInstruction iLInstruction = ilInstructions[num4];
			if (isEndOfInstruction)
			{
				if (offset == iLInstruction.offset + iLInstruction.GetSize() - 1)
				{
					return iLInstruction;
				}
			}
			else if (offset == iLInstruction.offset)
			{
				return iLInstruction;
			}
			if (offset < iLInstruction.offset)
			{
				num3 = num4 - 1;
			}
			else
			{
				num2 = num4 + 1;
			}
		}
		throw new Exception("Cannot find instruction for " + offset.ToString("X4"));
	}

	private static bool TargetsLocalVariable(OpCode opcode)
	{
		return opcode.Name.Contains("loc");
	}

	private LocalVariableInfo GetLocalVariable(int index)
	{
		return locals?[index];
	}

	private ParameterInfo GetParameter(int index)
	{
		if (index == 0)
		{
			return this_parameter;
		}
		return parameters[index - 1];
	}

	private OpCode ReadOpCode()
	{
		byte b = ilBytes.ReadByte();
		return (b != 254) ? one_byte_opcodes[b] : two_bytes_opcodes[ilBytes.ReadByte()];
	}

	private MethodInfo EmitMethodForType(Type type)
	{
		foreach (KeyValuePair<Type, MethodInfo> emitMethod in emitMethods)
		{
			if (emitMethod.Key == type)
			{
				return emitMethod.Value;
			}
		}
		foreach (KeyValuePair<Type, MethodInfo> emitMethod2 in emitMethods)
		{
			if (emitMethod2.Key.IsAssignableFrom(type))
			{
				return emitMethod2.Value;
			}
		}
		return null;
	}

	[MethodImpl(MethodImplOptions.Synchronized)]
	static MethodBodyReader()
	{
		shortJumps = new Dictionary<OpCode, OpCode>
		{
			{
				OpCodes.Leave_S,
				OpCodes.Leave
			},
			{
				OpCodes.Brfalse_S,
				OpCodes.Brfalse
			},
			{
				OpCodes.Brtrue_S,
				OpCodes.Brtrue
			},
			{
				OpCodes.Beq_S,
				OpCodes.Beq
			},
			{
				OpCodes.Bge_S,
				OpCodes.Bge
			},
			{
				OpCodes.Bgt_S,
				OpCodes.Bgt
			},
			{
				OpCodes.Ble_S,
				OpCodes.Ble
			},
			{
				OpCodes.Blt_S,
				OpCodes.Blt
			},
			{
				OpCodes.Bne_Un_S,
				OpCodes.Bne_Un
			},
			{
				OpCodes.Bge_Un_S,
				OpCodes.Bge_Un
			},
			{
				OpCodes.Bgt_Un_S,
				OpCodes.Bgt_Un
			},
			{
				OpCodes.Ble_Un_S,
				OpCodes.Ble_Un
			},
			{
				OpCodes.Br_S,
				OpCodes.Br
			},
			{
				OpCodes.Blt_Un_S,
				OpCodes.Blt_Un
			}
		};
		one_byte_opcodes = new OpCode[225];
		two_bytes_opcodes = new OpCode[31];
		FieldInfo[] fields = typeof(OpCodes).GetFields(BindingFlags.Static | BindingFlags.Public);
		FieldInfo[] array = fields;
		foreach (FieldInfo fieldInfo in array)
		{
			OpCode opCode = (OpCode)fieldInfo.GetValue(null);
			if (opCode.OpCodeType != OpCodeType.Nternal)
			{
				if (opCode.Size == 1)
				{
					one_byte_opcodes[opCode.Value] = opCode;
				}
				else
				{
					two_bytes_opcodes[opCode.Value & 0xFF] = opCode;
				}
			}
		}
		emitMethods = new Dictionary<Type, MethodInfo>();
		typeof(ILGenerator).GetMethods().ToList().Do(delegate(MethodInfo method)
		{
			if (!(method.Name != "Emit"))
			{
				ParameterInfo[] array2 = method.GetParameters();
				if (array2.Length == 2)
				{
					Type[] array3 = array2.Select((ParameterInfo p) => p.ParameterType).ToArray();
					if (!(array3[0] != typeof(OpCode)))
					{
						emitMethods[array3[1]] = method;
					}
				}
			}
		});
	}
}
