using System;
using System.IO;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using Harmony;

public static class PatchInfoSerialization
{
	private class Binder : SerializationBinder
	{
		public override Type BindToType(string assemblyName, string typeName)
		{
			Type[] array = new Type[3]
			{
				typeof(PatchInfo),
				typeof(Patch[]),
				typeof(Patch)
			};
			Type[] array2 = array;
			foreach (Type type in array2)
			{
				if (typeName == type.FullName)
				{
					return type;
				}
			}
			return Type.GetType($"{typeName}, {assemblyName}");
		}
	}

	public static byte[] Serialize(this PatchInfo patchInfo)
	{
		using MemoryStream memoryStream = new MemoryStream();
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		binaryFormatter.Serialize(memoryStream, patchInfo);
		return memoryStream.GetBuffer();
	}

	public static PatchInfo Deserialize(byte[] bytes)
	{
		BinaryFormatter binaryFormatter = new BinaryFormatter
		{
			Binder = new Binder()
		};
		MemoryStream serializationStream = new MemoryStream(bytes);
		return (PatchInfo)binaryFormatter.Deserialize(serializationStream);
	}

	public static int PriorityComparer(object obj, int index, int priority, string[] before, string[] after)
	{
		Traverse traverse = Traverse.Create(obj);
		string value = traverse.Field("owner").GetValue<string>();
		int value2 = traverse.Field("priority").GetValue<int>();
		int value3 = traverse.Field("index").GetValue<int>();
		if (before != null && Array.IndexOf(before, value) > -1)
		{
			return -1;
		}
		if (after != null && Array.IndexOf(after, value) > -1)
		{
			return 1;
		}
		if (priority != value2)
		{
			return -priority.CompareTo(value2);
		}
		return index.CompareTo(value3);
	}
}
