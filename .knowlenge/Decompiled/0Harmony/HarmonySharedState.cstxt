using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Harmony;

public static class HarmonySharedState
{
	private static readonly string name = "HarmonySharedState";

	internal static readonly int internalVersion = 100;

	internal static int actualVersion = -1;

	private static Dictionary<MethodBase, byte[]> GetState()
	{
		lock (name)
		{
			Assembly assembly = SharedStateAssembly();
			if (assembly == null)
			{
				AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName(name), AssemblyBuilderAccess.Run);
				ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(name);
				TypeAttributes attr = TypeAttributes.Public | TypeAttributes.Abstract | TypeAttributes.Sealed;
				TypeBuilder typeBuilder = moduleBuilder.DefineType(name, attr);
				typeBuilder.DefineField("state", typeof(Dictionary<MethodBase, byte[]>), FieldAttributes.Public | FieldAttributes.Static);
				typeBuilder.DefineField("version", typeof(int), FieldAttributes.Public | FieldAttributes.Static).SetConstant(internalVersion);
				typeBuilder.CreateType();
				assembly = SharedStateAssembly();
				if (assembly == null)
				{
					throw new Exception("Cannot find or create harmony shared state");
				}
			}
			FieldInfo field = assembly.GetType(name).GetField("version");
			if (field == null)
			{
				throw new Exception("Cannot find harmony state version field");
			}
			actualVersion = (int)field.GetValue(null);
			FieldInfo field2 = assembly.GetType(name).GetField("state");
			if (field2 == null)
			{
				throw new Exception("Cannot find harmony state field");
			}
			if (field2.GetValue(null) == null)
			{
				field2.SetValue(null, new Dictionary<MethodBase, byte[]>());
			}
			return (Dictionary<MethodBase, byte[]>)field2.GetValue(null);
		}
	}

	private static Assembly SharedStateAssembly()
	{
		return AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault((Assembly a) => a.GetName().Name.Contains(name));
	}

	internal static PatchInfo GetPatchInfo(MethodBase method)
	{
		byte[] valueSafe = GetState().GetValueSafe(method);
		if (valueSafe == null)
		{
			return null;
		}
		return PatchInfoSerialization.Deserialize(valueSafe);
	}

	internal static IEnumerable<MethodBase> GetPatchedMethods()
	{
		return GetState().Keys.AsEnumerable();
	}

	internal static void UpdatePatchInfo(MethodBase method, PatchInfo patchInfo)
	{
		GetState()[method] = patchInfo.Serialize();
	}
}
