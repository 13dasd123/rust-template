using System;
using System.Reflection;
using System.Reflection.Emit;
using Harmony;

public class FastAccess
{
	public static InstantiationHandler CreateInstantiationHandler(Type type)
	{
		ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[0], null);
		if (constructor == null)
		{
			throw new ApplicationException($"The type {type} must declare an empty constructor (the constructor may be private, internal, protected, protected internal, or public).");
		}
		DynamicMethod dynamicMethod = new DynamicMethod("InstantiateObject_" + type.Name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, typeof(object), null, type, skipVisibility: true);
		ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
		iLGenerator.Emit(OpCodes.Newobj, constructor);
		iLGenerator.Emit(OpCodes.Ret);
		return (InstantiationHandler)dynamicMethod.CreateDelegate(typeof(InstantiationHandler));
	}

	public static GetterHandler CreateGetterHandler(PropertyInfo propertyInfo)
	{
		MethodInfo getMethod = propertyInfo.GetGetMethod(nonPublic: true);
		DynamicMethod dynamicMethod = CreateGetDynamicMethod(propertyInfo.DeclaringType);
		ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Call, getMethod);
		BoxIfNeeded(getMethod.ReturnType, iLGenerator);
		iLGenerator.Emit(OpCodes.Ret);
		return (GetterHandler)dynamicMethod.CreateDelegate(typeof(GetterHandler));
	}

	public static GetterHandler CreateGetterHandler(FieldInfo fieldInfo)
	{
		DynamicMethod dynamicMethod = CreateGetDynamicMethod(fieldInfo.DeclaringType);
		ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Ldfld, fieldInfo);
		BoxIfNeeded(fieldInfo.FieldType, iLGenerator);
		iLGenerator.Emit(OpCodes.Ret);
		return (GetterHandler)dynamicMethod.CreateDelegate(typeof(GetterHandler));
	}

	public static GetterHandler CreateFieldGetter(Type type, params string[] names)
	{
		foreach (string name in names)
		{
			if (AccessTools.Field(typeof(ILGenerator), name) != null)
			{
				return CreateGetterHandler(AccessTools.Field(type, name));
			}
			if (AccessTools.Property(typeof(ILGenerator), name) != null)
			{
				return CreateGetterHandler(AccessTools.Property(type, name));
			}
		}
		return null;
	}

	public static SetterHandler CreateSetterHandler(PropertyInfo propertyInfo)
	{
		MethodInfo setMethod = propertyInfo.GetSetMethod(nonPublic: true);
		DynamicMethod dynamicMethod = CreateSetDynamicMethod(propertyInfo.DeclaringType);
		ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Ldarg_1);
		UnboxIfNeeded(setMethod.GetParameters()[0].ParameterType, iLGenerator);
		iLGenerator.Emit(OpCodes.Call, setMethod);
		iLGenerator.Emit(OpCodes.Ret);
		return (SetterHandler)dynamicMethod.CreateDelegate(typeof(SetterHandler));
	}

	public static SetterHandler CreateSetterHandler(FieldInfo fieldInfo)
	{
		DynamicMethod dynamicMethod = CreateSetDynamicMethod(fieldInfo.DeclaringType);
		ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Ldarg_1);
		UnboxIfNeeded(fieldInfo.FieldType, iLGenerator);
		iLGenerator.Emit(OpCodes.Stfld, fieldInfo);
		iLGenerator.Emit(OpCodes.Ret);
		return (SetterHandler)dynamicMethod.CreateDelegate(typeof(SetterHandler));
	}

	private static DynamicMethod CreateGetDynamicMethod(Type type)
	{
		return new DynamicMethod("DynamicGet_" + type.Name, typeof(object), new Type[1] { typeof(object) }, type, skipVisibility: true);
	}

	private static DynamicMethod CreateSetDynamicMethod(Type type)
	{
		return new DynamicMethod("DynamicSet_" + type.Name, typeof(void), new Type[2]
		{
			typeof(object),
			typeof(object)
		}, type, skipVisibility: true);
	}

	private static void BoxIfNeeded(Type type, ILGenerator generator)
	{
		if (type.IsValueType)
		{
			generator.Emit(OpCodes.Box, type);
		}
	}

	private static void UnboxIfNeeded(Type type, ILGenerator generator)
	{
		if (type.IsValueType)
		{
			generator.Emit(OpCodes.Unbox_Any, type);
		}
	}
}
