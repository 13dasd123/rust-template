using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.Serialization;
using Harmony;

public static class AccessTools
{
	public delegate ref U FieldRef<T, U>(T obj);

	public static BindingFlags all = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetField | BindingFlags.SetField | BindingFlags.GetProperty | BindingFlags.SetProperty;

	public static Type TypeByName(string name)
	{
		Type type = Type.GetType(name, throwOnError: false);
		if (type == null)
		{
			type = AppDomain.CurrentDomain.GetAssemblies().SelectMany((Assembly x) => x.GetTypes()).FirstOrDefault((Type x) => x.FullName == name);
		}
		if (type == null)
		{
			type = AppDomain.CurrentDomain.GetAssemblies().SelectMany((Assembly x) => x.GetTypes()).FirstOrDefault((Type x) => x.Name == name);
		}
		return type;
	}

	public static T FindIncludingBaseTypes<T>(Type type, Func<Type, T> action)
	{
		while (true)
		{
			T val = action(type);
			if (val != null)
			{
				return val;
			}
			if (type == typeof(object))
			{
				break;
			}
			type = type.BaseType;
		}
		return default(T);
	}

	public static T FindIncludingInnerTypes<T>(Type type, Func<Type, T> action)
	{
		T val = action(type);
		if (val != null)
		{
			return val;
		}
		Type[] nestedTypes = type.GetNestedTypes(all);
		foreach (Type type2 in nestedTypes)
		{
			val = FindIncludingInnerTypes(type2, action);
			if (val != null)
			{
				break;
			}
		}
		return val;
	}

	public static FieldInfo Field(Type type, string name)
	{
		if (type == null || name == null)
		{
			return null;
		}
		return FindIncludingBaseTypes(type, (Type t) => t.GetField(name, all));
	}

	public static FieldInfo Field(Type type, int idx)
	{
		return GetDeclaredFields(type).ElementAtOrDefault(idx);
	}

	public static PropertyInfo DeclaredProperty(Type type, string name)
	{
		if (type == null || name == null)
		{
			return null;
		}
		return type.GetProperty(name, all);
	}

	public static PropertyInfo Property(Type type, string name)
	{
		if (type == null || name == null)
		{
			return null;
		}
		return FindIncludingBaseTypes(type, (Type t) => t.GetProperty(name, all));
	}

	public static MethodInfo DeclaredMethod(Type type, string name, Type[] parameters = null, Type[] generics = null)
	{
		if (type == null || name == null)
		{
			return null;
		}
		ParameterModifier[] modifiers = new ParameterModifier[0];
		MethodInfo methodInfo = ((parameters != null) ? type.GetMethod(name, all, null, parameters, modifiers) : type.GetMethod(name, all));
		if (methodInfo == null)
		{
			return null;
		}
		if (generics != null)
		{
			methodInfo = methodInfo.MakeGenericMethod(generics);
		}
		return methodInfo;
	}

	public static MethodInfo Method(Type type, string name, Type[] parameters = null, Type[] generics = null)
	{
		if (type == null || name == null)
		{
			return null;
		}
		ParameterModifier[] modifiers = new ParameterModifier[0];
		MethodInfo methodInfo;
		if (parameters == null)
		{
			try
			{
				methodInfo = FindIncludingBaseTypes(type, (Type t) => t.GetMethod(name, all));
			}
			catch (AmbiguousMatchException)
			{
				methodInfo = FindIncludingBaseTypes(type, (Type t) => t.GetMethod(name, all, null, new Type[0], modifiers));
			}
		}
		else
		{
			methodInfo = FindIncludingBaseTypes(type, (Type t) => t.GetMethod(name, all, null, parameters, modifiers));
		}
		if (methodInfo == null)
		{
			return null;
		}
		if (generics != null)
		{
			methodInfo = methodInfo.MakeGenericMethod(generics);
		}
		return methodInfo;
	}

	public static MethodInfo Method(string typeColonMethodname, Type[] parameters = null, Type[] generics = null)
	{
		if (typeColonMethodname == null)
		{
			return null;
		}
		string[] array = typeColonMethodname.Split(':');
		if (array.Length != 2)
		{
			throw new ArgumentException("Method must be specified as 'Namespace.Type1.Type2:MethodName", "typeColonMethodname");
		}
		Type type = TypeByName(array[0]);
		return Method(type, array[1], parameters, generics);
	}

	public static List<string> GetMethodNames(Type type)
	{
		if (type == null)
		{
			return new List<string>();
		}
		return (from m in type.GetMethods(all)
			select m.Name).ToList();
	}

	public static List<string> GetMethodNames(object instance)
	{
		if (instance == null)
		{
			return new List<string>();
		}
		return GetMethodNames(instance.GetType());
	}

	public static ConstructorInfo DeclaredConstructor(Type type, Type[] parameters = null)
	{
		if (type == null)
		{
			return null;
		}
		if (parameters == null)
		{
			parameters = new Type[0];
		}
		return type.GetConstructor(all, null, parameters, new ParameterModifier[0]);
	}

	public static ConstructorInfo Constructor(Type type, Type[] parameters = null)
	{
		if (type == null)
		{
			return null;
		}
		if (parameters == null)
		{
			parameters = new Type[0];
		}
		return FindIncludingBaseTypes(type, (Type t) => t.GetConstructor(all, null, parameters, new ParameterModifier[0]));
	}

	public static List<ConstructorInfo> GetDeclaredConstructors(Type type)
	{
		return (from method in type.GetConstructors(all)
			where method.DeclaringType == type
			select method).ToList();
	}

	public static List<MethodInfo> GetDeclaredMethods(Type type)
	{
		return (from method in type.GetMethods(all)
			where method.DeclaringType == type
			select method).ToList();
	}

	public static List<PropertyInfo> GetDeclaredProperties(Type type)
	{
		return (from property in type.GetProperties(all)
			where property.DeclaringType == type
			select property).ToList();
	}

	public static List<FieldInfo> GetDeclaredFields(Type type)
	{
		return (from field in type.GetFields(all)
			where field.DeclaringType == type
			select field).ToList();
	}

	public static Type GetReturnedType(MethodBase method)
	{
		ConstructorInfo constructorInfo = method as ConstructorInfo;
		if (constructorInfo != null)
		{
			return typeof(void);
		}
		return ((MethodInfo)method).ReturnType;
	}

	public static Type Inner(Type type, string name)
	{
		if (type == null || name == null)
		{
			return null;
		}
		return FindIncludingBaseTypes(type, (Type t) => t.GetNestedType(name, all));
	}

	public static Type FirstInner(Type type, Func<Type, bool> predicate)
	{
		if (type == null || predicate == null)
		{
			return null;
		}
		return type.GetNestedTypes(all).FirstOrDefault((Type subType) => predicate(subType));
	}

	public static MethodInfo FirstMethod(Type type, Func<MethodInfo, bool> predicate)
	{
		if (type == null || predicate == null)
		{
			return null;
		}
		return type.GetMethods(all).FirstOrDefault((MethodInfo method) => predicate(method));
	}

	public static ConstructorInfo FirstConstructor(Type type, Func<ConstructorInfo, bool> predicate)
	{
		if (type == null || predicate == null)
		{
			return null;
		}
		return type.GetConstructors(all).FirstOrDefault((ConstructorInfo constructor) => predicate(constructor));
	}

	public static PropertyInfo FirstProperty(Type type, Func<PropertyInfo, bool> predicate)
	{
		if (type == null || predicate == null)
		{
			return null;
		}
		return type.GetProperties(all).FirstOrDefault((PropertyInfo property) => predicate(property));
	}

	public static Type[] GetTypes(object[] parameters)
	{
		if (parameters == null)
		{
			return new Type[0];
		}
		return parameters.Select((object p) => (p == null) ? typeof(object) : p.GetType()).ToArray();
	}

	public static List<string> GetFieldNames(Type type)
	{
		if (type == null)
		{
			return new List<string>();
		}
		return (from f in type.GetFields(all)
			select f.Name).ToList();
	}

	public static List<string> GetFieldNames(object instance)
	{
		if (instance == null)
		{
			return new List<string>();
		}
		return GetFieldNames(instance.GetType());
	}

	public static List<string> GetPropertyNames(Type type)
	{
		if (type == null)
		{
			return new List<string>();
		}
		return (from f in type.GetProperties(all)
			select f.Name).ToList();
	}

	public static List<string> GetPropertyNames(object instance)
	{
		if (instance == null)
		{
			return new List<string>();
		}
		return GetPropertyNames(instance.GetType());
	}

	public static FieldRef<T, U> FieldRefAccess<T, U>(string fieldName)
	{
		FieldInfo field = typeof(T).GetField(fieldName, BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic);
		if (field == null)
		{
			throw new MissingFieldException(typeof(T).Name, fieldName);
		}
		string name = "__refget_" + typeof(T).Name + "_fi_" + field.Name;
		DynamicMethod dynamicMethod = new DynamicMethod(name, typeof(U), new Type[1] { typeof(T) }, typeof(T), skipVisibility: true);
		Traverse traverse = Traverse.Create(dynamicMethod);
		traverse.Field("returnType").SetValue(typeof(U).MakeByRefType());
		traverse.Field("m_returnType").SetValue(typeof(U).MakeByRefType());
		ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
		iLGenerator.Emit(OpCodes.Ldarg_0);
		iLGenerator.Emit(OpCodes.Ldflda, field);
		iLGenerator.Emit(OpCodes.Ret);
		return (FieldRef<T, U>)dynamicMethod.CreateDelegate(typeof(FieldRef<T, U>));
	}

	public static ref U FieldRefAccess<T, U>(T instance, string fieldName)
	{
		return ref FieldRefAccess<T, U>(fieldName)(instance);
	}

	public static void ThrowMissingMemberException(Type type, params string[] names)
	{
		string text = string.Join(",", GetFieldNames(type).ToArray());
		string text2 = string.Join(",", GetPropertyNames(type).ToArray());
		throw new MissingMemberException(string.Join(",", names) + "; available fields: " + text + "; available properties: " + text2);
	}

	public static object GetDefaultValue(Type type)
	{
		if (type == null)
		{
			return null;
		}
		if (type == typeof(void))
		{
			return null;
		}
		if (type.IsValueType)
		{
			return Activator.CreateInstance(type);
		}
		return null;
	}

	public static object CreateInstance(Type type)
	{
		if (type == null)
		{
			throw new NullReferenceException("Cannot create instance for NULL type");
		}
		ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public, null, CallingConventions.Any, new Type[0], null);
		if (constructor != null)
		{
			return Activator.CreateInstance(type);
		}
		return FormatterServices.GetUninitializedObject(type);
	}

	public static object MakeDeepCopy(object source, Type resultType, Func<string, Traverse, Traverse, object> processor = null, string pathRoot = "")
	{
		if (source == null)
		{
			return null;
		}
		Type type = source.GetType();
		if (type.IsPrimitive)
		{
			return source;
		}
		if (type.IsEnum)
		{
			return Enum.ToObject(resultType, (int)source);
		}
		if (type.IsGenericType && resultType.IsGenericType)
		{
			MethodInfo methodInfo = FirstMethod(resultType, (MethodInfo m) => m.Name == "Add" && m.GetParameters().Count() == 1);
			if (methodInfo != null)
			{
				object obj = Activator.CreateInstance(resultType);
				FastInvokeHandler handler = MethodInvoker.GetHandler(methodInfo);
				Type resultType2 = resultType.GetGenericArguments()[0];
				int num = 0;
				foreach (object item in source as IEnumerable)
				{
					string text = num++.ToString();
					string pathRoot2 = ((pathRoot.Length > 0) ? (pathRoot + "." + text) : text);
					object obj2 = MakeDeepCopy(item, resultType2, processor, pathRoot2);
					handler(obj, new object[1] { obj2 });
				}
				return obj;
			}
		}
		if (type.IsArray && resultType.IsArray)
		{
			Type elementType = resultType.GetElementType();
			int length = ((Array)source).Length;
			object[] array = Activator.CreateInstance(resultType, length) as object[];
			object[] array2 = source as object[];
			for (int i = 0; i < length; i++)
			{
				string text2 = i.ToString();
				string pathRoot3 = ((pathRoot.Length > 0) ? (pathRoot + "." + text2) : text2);
				array[i] = MakeDeepCopy(array2[i], elementType, processor, pathRoot3);
			}
			return array;
		}
		string @namespace = type.Namespace;
		if (@namespace == "System" || (@namespace != null && @namespace.StartsWith("System.")))
		{
			return source;
		}
		object obj3 = CreateInstance(resultType);
		Traverse.IterateFields(source, obj3, delegate(string name, Traverse src, Traverse dst)
		{
			string text3 = ((pathRoot.Length > 0) ? (pathRoot + "." + name) : name);
			object source2 = ((processor != null) ? processor(text3, src, dst) : src.GetValue());
			dst.SetValue(MakeDeepCopy(source2, dst.GetValueType(), processor, text3));
		});
		return obj3;
	}

	public static void MakeDeepCopy<T>(object source, out T result, Func<string, Traverse, Traverse, object> processor = null, string pathRoot = "")
	{
		result = (T)MakeDeepCopy(source, typeof(T), processor, pathRoot);
	}

	public static bool IsStruct(Type type)
	{
		return type.IsValueType && !IsValue(type) && !IsVoid(type);
	}

	public static bool IsClass(Type type)
	{
		return !type.IsValueType;
	}

	public static bool IsValue(Type type)
	{
		return type.IsPrimitive || type.IsEnum;
	}

	public static bool IsVoid(Type type)
	{
		return type == typeof(void);
	}
}
