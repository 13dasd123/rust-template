using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Harmony;
using Harmony.ILCopying;

public static class PatchFunctions
{
	public static void AddPrefix(PatchInfo patchInfo, string owner, HarmonyMethod info)
	{
		if (info != null && !(info.method == null))
		{
			int priority = ((info.prioritiy == -1) ? 400 : info.prioritiy);
			string[] before = info.before ?? new string[0];
			string[] after = info.after ?? new string[0];
			patchInfo.AddPrefix(info.method, owner, priority, before, after);
		}
	}

	public static void RemovePrefix(PatchInfo patchInfo, string owner)
	{
		patchInfo.RemovePrefix(owner);
	}

	public static void AddPostfix(PatchInfo patchInfo, string owner, HarmonyMethod info)
	{
		if (info != null && !(info.method == null))
		{
			int priority = ((info.prioritiy == -1) ? 400 : info.prioritiy);
			string[] before = info.before ?? new string[0];
			string[] after = info.after ?? new string[0];
			patchInfo.AddPostfix(info.method, owner, priority, before, after);
		}
	}

	public static void RemovePostfix(PatchInfo patchInfo, string owner)
	{
		patchInfo.RemovePostfix(owner);
	}

	public static void AddTranspiler(PatchInfo patchInfo, string owner, HarmonyMethod info)
	{
		if (info != null && !(info.method == null))
		{
			int priority = ((info.prioritiy == -1) ? 400 : info.prioritiy);
			string[] before = info.before ?? new string[0];
			string[] after = info.after ?? new string[0];
			patchInfo.AddTranspiler(info.method, owner, priority, before, after);
		}
	}

	public static void RemoveTranspiler(PatchInfo patchInfo, string owner)
	{
		patchInfo.RemoveTranspiler(owner);
	}

	public static void RemovePatch(PatchInfo patchInfo, MethodInfo patch)
	{
		patchInfo.RemovePatch(patch);
	}

	public static List<ILInstruction> GetInstructions(ILGenerator generator, MethodBase method)
	{
		return MethodBodyReader.GetInstructions(generator, method);
	}

	public static List<MethodInfo> GetSortedPatchMethods(MethodBase original, Patch[] patches)
	{
		return (from p in patches
			where p.patch != null
			orderby p
			select p.GetMethod(original)).ToList();
	}

	public static DynamicMethod UpdateWrapper(MethodBase original, PatchInfo patchInfo, string instanceID)
	{
		List<MethodInfo> sortedPatchMethods = GetSortedPatchMethods(original, patchInfo.prefixes);
		List<MethodInfo> sortedPatchMethods2 = GetSortedPatchMethods(original, patchInfo.postfixes);
		List<MethodInfo> sortedPatchMethods3 = GetSortedPatchMethods(original, patchInfo.transpilers);
		DynamicMethod dynamicMethod = MethodPatcher.CreatePatchedMethod(original, instanceID, sortedPatchMethods, sortedPatchMethods2, sortedPatchMethods3);
		if (dynamicMethod == null)
		{
			throw new MissingMethodException("Cannot create dynamic replacement for " + original.FullDescription());
		}
		string text = Memory.DetourMethod(original, dynamicMethod);
		if (text != null)
		{
			throw new FormatException("Method " + original.FullDescription() + " cannot be patched. Reason: " + text);
		}
		PatchTools.RememberObject(original, dynamicMethod);
		return dynamicMethod;
	}
}
