using System;
using System.Reflection;
using System.Reflection.Emit;
using Harmony;

public class MethodInvoker
{
	public static FastInvokeHandler GetHandler(DynamicMethod methodInfo, Module module)
	{
		return Handler(methodInfo, module);
	}

	public static FastInvokeHandler GetHandler(MethodInfo methodInfo)
	{
		return Handler(methodInfo, methodInfo.DeclaringType.Module);
	}

	private unsafe static FastInvokeHandler Handler(MethodInfo methodInfo, Module module, bool directBoxValueAccess = false)
	{
		DynamicMethod dynamicMethod = new DynamicMethod("FastInvoke_" + methodInfo.Name + "_" + (directBoxValueAccess ? "direct" : "indirect"), typeof(object), new Type[2]
		{
			typeof(object),
			typeof(object[])
		}, module, skipVisibility: true);
		ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
		if (!methodInfo.IsStatic)
		{
			iLGenerator.Emit(OpCodes.Ldarg_0);
			EmitUnboxIfNeeded(iLGenerator, methodInfo.DeclaringType);
		}
		bool flag = true;
		ParameterInfo[] parameters = methodInfo.GetParameters();
		for (int i = 0; i < parameters.Length; i++)
		{
			Type type = parameters[i].ParameterType;
			bool isByRef = type.IsByRef;
			if (isByRef)
			{
				type = type.GetElementType();
			}
			bool isValueType = type.IsValueType;
			if (isByRef && isValueType && !directBoxValueAccess)
			{
				iLGenerator.Emit(OpCodes.Ldarg_1);
				EmitFastInt(iLGenerator, i);
			}
			iLGenerator.Emit(OpCodes.Ldarg_1);
			EmitFastInt(iLGenerator, i);
			if (isByRef && !isValueType)
			{
				iLGenerator.Emit(OpCodes.Ldelema, typeof(object));
				continue;
			}
			iLGenerator.Emit(OpCodes.Ldelem_Ref);
			if (!isValueType)
			{
				continue;
			}
			if (!isByRef || !directBoxValueAccess)
			{
				iLGenerator.Emit(OpCodes.Unbox_Any, type);
				if (isByRef)
				{
					iLGenerator.Emit(OpCodes.Box, type);
					iLGenerator.Emit(OpCodes.Dup);
					iLGenerator.Emit(OpCodes.Unbox, type);
					if (flag)
					{
						flag = false;
						iLGenerator.DeclareLocal(typeof(void*), pinned: true);
					}
					iLGenerator.Emit(OpCodes.Stloc_0);
					iLGenerator.Emit(OpCodes.Stelem_Ref);
					iLGenerator.Emit(OpCodes.Ldloc_0);
				}
			}
			else
			{
				iLGenerator.Emit(OpCodes.Unbox, type);
			}
		}
		if (methodInfo.IsStatic)
		{
			iLGenerator.EmitCall(OpCodes.Call, methodInfo, null);
		}
		else
		{
			iLGenerator.EmitCall(OpCodes.Callvirt, methodInfo, null);
		}
		if (methodInfo.ReturnType == typeof(void))
		{
			iLGenerator.Emit(OpCodes.Ldnull);
		}
		else
		{
			EmitBoxIfNeeded(iLGenerator, methodInfo.ReturnType);
		}
		iLGenerator.Emit(OpCodes.Ret);
		return (FastInvokeHandler)dynamicMethod.CreateDelegate(typeof(FastInvokeHandler));
	}

	private static void EmitCastToReference(ILGenerator il, Type type)
	{
		if (type.IsValueType)
		{
			il.Emit(OpCodes.Unbox_Any, type);
		}
		else
		{
			il.Emit(OpCodes.Castclass, type);
		}
	}

	private static void EmitUnboxIfNeeded(ILGenerator il, Type type)
	{
		if (type.IsValueType)
		{
			il.Emit(OpCodes.Unbox_Any, type);
		}
	}

	private static void EmitBoxIfNeeded(ILGenerator il, Type type)
	{
		if (type.IsValueType)
		{
			il.Emit(OpCodes.Box, type);
		}
	}

	private static void EmitFastInt(ILGenerator il, int value)
	{
		switch (value)
		{
		case -1:
			il.Emit(OpCodes.Ldc_I4_M1);
			return;
		case 0:
			il.Emit(OpCodes.Ldc_I4_0);
			return;
		case 1:
			il.Emit(OpCodes.Ldc_I4_1);
			return;
		case 2:
			il.Emit(OpCodes.Ldc_I4_2);
			return;
		case 3:
			il.Emit(OpCodes.Ldc_I4_3);
			return;
		case 4:
			il.Emit(OpCodes.Ldc_I4_4);
			return;
		case 5:
			il.Emit(OpCodes.Ldc_I4_5);
			return;
		case 6:
			il.Emit(OpCodes.Ldc_I4_6);
			return;
		case 7:
			il.Emit(OpCodes.Ldc_I4_7);
			return;
		case 8:
			il.Emit(OpCodes.Ldc_I4_8);
			return;
		}
		if (value > -129 && value < 128)
		{
			il.Emit(OpCodes.Ldc_I4_S, (sbyte)value);
		}
		else
		{
			il.Emit(OpCodes.Ldc_I4, value);
		}
	}
}
