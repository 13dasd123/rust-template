using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Harmony;

[Serializable]
public class Patch : IComparable
{
	public readonly int index;

	public readonly string owner;

	public readonly int priority;

	public readonly string[] before;

	public readonly string[] after;

	public readonly MethodInfo patch;

	public Patch(MethodInfo patch, int index, string owner, int priority, string[] before, string[] after)
	{
		if (patch is DynamicMethod)
		{
			throw new Exception("Cannot directly reference dynamic method \"" + patch.FullDescription() + "\" in Harmony. Use a factory method instead that will return the dynamic method.");
		}
		this.index = index;
		this.owner = owner;
		this.priority = priority;
		this.before = before;
		this.after = after;
		this.patch = patch;
	}

	public MethodInfo GetMethod(MethodBase original)
	{
		if (patch.ReturnType != typeof(DynamicMethod))
		{
			return patch;
		}
		if (!patch.IsStatic)
		{
			return patch;
		}
		ParameterInfo[] parameters = patch.GetParameters();
		if (parameters.Count() != 1)
		{
			return patch;
		}
		if (parameters[0].ParameterType != typeof(MethodBase))
		{
			return patch;
		}
		return patch.Invoke(null, new object[1] { original }) as DynamicMethod;
	}

	public override bool Equals(object obj)
	{
		return obj != null && obj is Patch && patch == ((Patch)obj).patch;
	}

	public int CompareTo(object obj)
	{
		return PatchInfoSerialization.PriorityComparer(obj, index, priority, before, after);
	}

	public override int GetHashCode()
	{
		return patch.GetHashCode();
	}
}
