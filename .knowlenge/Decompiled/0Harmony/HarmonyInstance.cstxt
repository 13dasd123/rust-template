using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using Harmony;
using Harmony.Tools;

public class HarmonyInstance
{
	private readonly string id;

	public static bool DEBUG = false;

	private static bool selfPatchingDone = false;

	public string Id => id;

	private HarmonyInstance(string id)
	{
		if (DEBUG)
		{
			Assembly assembly = typeof(HarmonyInstance).Assembly;
			Version version = assembly.GetName().Version;
			string text = assembly.Location;
			if (text == null || text == "")
			{
				text = new Uri(assembly.CodeBase).LocalPath;
			}
			FileLog.Log(string.Concat("### Harmony id=", id, ", version=", version, ", location=", text));
			MethodBase outsideCaller = GetOutsideCaller();
			Assembly assembly2 = outsideCaller.DeclaringType.Assembly;
			text = assembly2.Location;
			if (text == null || text == "")
			{
				text = new Uri(assembly2.CodeBase).LocalPath;
			}
			FileLog.Log("### Started from " + outsideCaller.FullDescription() + ", location " + text);
			FileLog.Log("### At " + DateTime.Now.ToString("yyyy-MM-dd hh.mm.ss"));
		}
		this.id = id;
		if (!selfPatchingDone)
		{
			selfPatchingDone = true;
			SelfPatching.PatchOldHarmonyMethods();
		}
	}

	public static HarmonyInstance Create(string id)
	{
		if (id == null)
		{
			throw new Exception("id cannot be null");
		}
		return new HarmonyInstance(id);
	}

	private MethodBase GetOutsideCaller()
	{
		StackTrace stackTrace = new StackTrace(fNeedFileInfo: true);
		StackFrame[] frames = stackTrace.GetFrames();
		foreach (StackFrame stackFrame in frames)
		{
			MethodBase method = stackFrame.GetMethod();
			if (method.DeclaringType.Namespace != typeof(HarmonyInstance).Namespace)
			{
				return method;
			}
		}
		throw new Exception("Unexpected end of stack trace");
	}

	public void PatchAll()
	{
		MethodBase method = new StackTrace().GetFrame(1).GetMethod();
		Assembly assembly = method.ReflectedType.Assembly;
		PatchAll(assembly);
	}

	public void PatchAll(Assembly assembly)
	{
		assembly.GetTypes().Do(delegate(Type type)
		{
			List<HarmonyMethod> harmonyMethods = type.GetHarmonyMethods();
			if (harmonyMethods != null && harmonyMethods.Count() > 0)
			{
				HarmonyMethod attributes = HarmonyMethod.Merge(harmonyMethods);
				PatchProcessor patchProcessor = new PatchProcessor(this, type, attributes);
				patchProcessor.Patch();
			}
		});
	}

	public DynamicMethod Patch(MethodBase original, HarmonyMethod prefix = null, HarmonyMethod postfix = null, HarmonyMethod transpiler = null)
	{
		PatchProcessor patchProcessor = new PatchProcessor(this, new List<MethodBase> { original }, prefix, postfix, transpiler);
		return patchProcessor.Patch().FirstOrDefault();
	}

	public void UnpatchAll(string harmonyID = null)
	{
		List<MethodBase> list = GetPatchedMethods().ToList();
		foreach (MethodBase original in list)
		{
			Patches patchInfo2 = GetPatchInfo(original);
			patchInfo2.Prefixes.DoIf(IDCheck, delegate(Patch patchInfo)
			{
				Unpatch(original, patchInfo.patch);
			});
			patchInfo2.Postfixes.DoIf(IDCheck, delegate(Patch patchInfo)
			{
				Unpatch(original, patchInfo.patch);
			});
			patchInfo2.Transpilers.DoIf(IDCheck, delegate(Patch patchInfo)
			{
				Unpatch(original, patchInfo.patch);
			});
		}
		bool IDCheck(Patch patchInfo)
		{
			return harmonyID == null || patchInfo.owner == harmonyID;
		}
	}

	public void Unpatch(MethodBase original, HarmonyPatchType type, string harmonyID = null)
	{
		PatchProcessor patchProcessor = new PatchProcessor(this, new List<MethodBase> { original });
		patchProcessor.Unpatch(type, harmonyID);
	}

	public void Unpatch(MethodBase original, MethodInfo patch)
	{
		PatchProcessor patchProcessor = new PatchProcessor(this, new List<MethodBase> { original });
		patchProcessor.Unpatch(patch);
	}

	public bool HasAnyPatches(string harmonyID)
	{
		return (from original in GetPatchedMethods()
			select GetPatchInfo(original)).Any((Patches info) => info.Owners.Contains(harmonyID));
	}

	public Patches GetPatchInfo(MethodBase method)
	{
		return PatchProcessor.GetPatchInfo(method);
	}

	public IEnumerable<MethodBase> GetPatchedMethods()
	{
		return HarmonySharedState.GetPatchedMethods();
	}

	public Dictionary<string, Version> VersionInfo(out Version currentVersion)
	{
		currentVersion = typeof(HarmonyInstance).Assembly.GetName().Version;
		Dictionary<string, Assembly> assemblies = new Dictionary<string, Assembly>();
		GetPatchedMethods().Do(delegate(MethodBase method)
		{
			PatchInfo patchInfo = HarmonySharedState.GetPatchInfo(method);
			patchInfo.prefixes.Do(delegate(Patch fix)
			{
				assemblies[fix.owner] = fix.patch.DeclaringType.Assembly;
			});
			patchInfo.postfixes.Do(delegate(Patch fix)
			{
				assemblies[fix.owner] = fix.patch.DeclaringType.Assembly;
			});
			patchInfo.transpilers.Do(delegate(Patch fix)
			{
				assemblies[fix.owner] = fix.patch.DeclaringType.Assembly;
			});
		});
		Dictionary<string, Version> result = new Dictionary<string, Version>();
		assemblies.Do(delegate(KeyValuePair<string, Assembly> info)
		{
			AssemblyName assemblyName = info.Value.GetReferencedAssemblies().FirstOrDefault((AssemblyName a) => a.FullName.StartsWith("0Harmony, Version"));
			if (assemblyName != null)
			{
				result[info.Key] = assemblyName.Version;
			}
		});
		return result;
	}
}
