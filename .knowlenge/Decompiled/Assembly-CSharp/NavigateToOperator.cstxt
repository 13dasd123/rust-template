using System.Collections.Generic;
using Apex.Serialization;
using Rust.Ai;
using UnityEngine;

public class NavigateToOperator : BaseAction
{
	public enum OperatorType
	{
		EnemyLoc,
		RandomLoc,
		Spawn,
		FoodLoc,
		FleeEnemy,
		FleeHurtDir
	}

	[ApexSerialization]
	public OperatorType Operator;

	public override void DoExecute(BaseContext c)
	{
		if (c.GetFact(BaseNpc.Facts.CanNotMove) == 1)
		{
			c.AIAgent.StopMoving();
		}
		else if (c.AIAgent.IsNavRunning() && !c.AIAgent.GetNavAgent.pathPending)
		{
			switch (Operator)
			{
			case OperatorType.EnemyLoc:
				NavigateToEnemy(c);
				break;
			case OperatorType.RandomLoc:
				NavigateToRandomLoc(c);
				break;
			case OperatorType.Spawn:
				NavigateToSpawn(c);
				break;
			case OperatorType.FoodLoc:
				NavigateToFood(c);
				break;
			case OperatorType.FleeEnemy:
				FleeEnemy(c);
				break;
			case OperatorType.FleeHurtDir:
				FleeHurtDir(c);
				break;
			}
		}
	}

	public static void NavigateToEnemy(BaseContext c)
	{
		if (c.GetFact(BaseNpc.Facts.HasEnemy) > 0 && c.AIAgent.IsNavRunning())
		{
			c.AIAgent.GetNavAgent.destination = c.EnemyPosition;
		}
	}

	public static void NavigateToRandomLoc(BaseContext c)
	{
		if (IsRoamReady.Evaluate(c) && c.AIAgent.IsNavRunning() && NavigateInDirOfBestSample(c, NavPointSampler.SampleCount.Eight, 4f, NavPointSampler.SampleFeatures.DiscourageSharpTurns, c.AIAgent.GetStats.MinRoamRange, c.AIAgent.GetStats.MaxRoamRange))
		{
			float num = c.AIAgent.GetStats.MaxRoamDelay - c.AIAgent.GetStats.MinRoamDelay;
			float num2 = Random.value * num;
			float time = num2 / num;
			float num3 = c.AIAgent.GetStats.RoamDelayDistribution.Evaluate(time);
			float num4 = num3 * num;
			c.NextRoamTime = Time.realtimeSinceStartup + c.AIAgent.GetStats.MinRoamDelay + num4;
		}
	}

	public static void NavigateToSpawn(BaseContext c)
	{
		if (c.AIAgent.IsNavRunning())
		{
			c.AIAgent.GetNavAgent.destination = c.AIAgent.GuardPosition;
		}
	}

	public static void NavigateToFood(BaseContext c)
	{
		if (c.AIAgent.FoodTarget != null && !c.AIAgent.FoodTarget.IsDestroyed && c.AIAgent.FoodTarget.transform != null && c.GetFact(BaseNpc.Facts.FoodRange) < 2 && c.AIAgent.IsNavRunning())
		{
			c.AIAgent.GetNavAgent.destination = c.AIAgent.FoodTarget.ServerPosition;
		}
	}

	public static void FleeEnemy(BaseContext c)
	{
		if (c.AIAgent.IsNavRunning() && NavigateInDirOfBestSample(c, NavPointSampler.SampleCount.Eight, 4f, NavPointSampler.SampleFeatures.RetreatFromTarget, c.AIAgent.GetStats.MinFleeRange, c.AIAgent.GetStats.MaxFleeRange))
		{
			c.SetFact(BaseNpc.Facts.IsFleeing, 1);
		}
	}

	public static void FleeHurtDir(BaseContext c)
	{
		if (c.AIAgent.IsNavRunning() && NavigateInDirOfBestSample(c, NavPointSampler.SampleCount.Eight, 4f, NavPointSampler.SampleFeatures.RetreatFromDirection, c.AIAgent.GetStats.MinFleeRange, c.AIAgent.GetStats.MaxFleeRange))
		{
			c.SetFact(BaseNpc.Facts.IsFleeing, 1);
		}
	}

	private static bool NavigateInDirOfBestSample(BaseContext c, NavPointSampler.SampleCount sampleCount, float radius, NavPointSampler.SampleFeatures features, float minRange, float maxRange)
	{
		List<NavPointSample> list = c.AIAgent.RequestNavPointSamplesInCircle(sampleCount, radius, features);
		if (list == null)
		{
			return false;
		}
		foreach (NavPointSample item in list)
		{
			Vector3 normalized = (item.Position - c.Position).normalized;
			Vector3 pos = c.Position + (normalized * minRange + normalized * ((maxRange - minRange) * Random.value));
			NavPointSample navPointSample = NavPointSampler.SamplePoint(pos, new NavPointSampler.SampleScoreParams
			{
				WaterMaxDepth = c.AIAgent.GetStats.MaxWaterDepth,
				Agent = c.AIAgent,
				Features = features
			});
			if (Mathf.Approximately(navPointSample.Score, 0f))
			{
				continue;
			}
			pos = navPointSample.Position;
			c.AIAgent.GetNavAgent.destination = pos;
			return true;
		}
		return false;
	}
}
