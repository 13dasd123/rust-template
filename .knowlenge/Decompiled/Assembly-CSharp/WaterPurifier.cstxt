using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class WaterPurifier : LiquidContainer
{
	public static class WaterPurifierFlags
	{
		public const Flags Boiling = Flags.Reserved1;
	}

	public GameObjectRef storagePrefab;

	public Transform storagePrefabAnchor;

	public ItemDefinition freshWater;

	public int waterToProcessPerMinute = 120;

	public int freshWaterRatio = 4;

	public LiquidContainer waterStorage;

	public float dirtyWaterProcssed;

	public float pendingFreshWater;

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Rust.Application.isLoadingSave)
		{
			SpawnStorageEnt();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SpawnStorageEnt();
	}

	public void SpawnStorageEnt()
	{
		waterStorage = GameManager.server.CreateEntity(storagePrefab.resourcePath, storagePrefabAnchor.localPosition, storagePrefabAnchor.localRotation) as LiquidContainer;
		waterStorage.SetParent(GetParentEntity());
		waterStorage.Spawn();
	}

	internal override void OnParentRemoved()
	{
		Kill(DestroyMode.Gib);
	}

	public override void OnKilled(HitInfo info)
	{
		base.OnKilled(info);
		waterStorage.Kill();
	}

	public void ParentTemperatureUpdate(float temp)
	{
	}

	public void CheckCoolDown()
	{
		if (!GetParentEntity() || !GetParentEntity().IsOn() || !HasDirtyWater())
		{
			SetFlag(Flags.Reserved1, b: false);
			CancelInvoke(CheckCoolDown);
		}
	}

	public bool HasDirtyWater()
	{
		Item slot = inventory.GetSlot(0);
		return slot != null && slot.info.itemType == ItemContainer.ContentsType.Liquid && slot.amount > 0;
	}

	public void Cook(float timeCooked)
	{
		if (waterStorage == null)
		{
			return;
		}
		bool flag = HasDirtyWater();
		if (!IsBoiling() && flag)
		{
			InvokeRepeating(CheckCoolDown, 2f, 2f);
			SetFlag(Flags.Reserved1, b: true);
		}
		if (!IsBoiling() || !flag)
		{
			return;
		}
		float num = timeCooked * ((float)waterToProcessPerMinute / 60f);
		dirtyWaterProcssed += num;
		pendingFreshWater += num / (float)freshWaterRatio;
		if (dirtyWaterProcssed >= 1f)
		{
			int num2 = Mathf.FloorToInt(dirtyWaterProcssed);
			Item slot = inventory.GetSlot(0);
			slot.UseItem(num2);
			dirtyWaterProcssed -= num2;
			SendNetworkUpdate();
		}
		if (!(pendingFreshWater >= 1f))
		{
			return;
		}
		int num3 = Mathf.FloorToInt(pendingFreshWater);
		pendingFreshWater -= num3;
		Item slot2 = waterStorage.inventory.GetSlot(0);
		if (slot2 != null && slot2.info != freshWater)
		{
			slot2.RemoveFromContainer();
			slot2.Remove();
		}
		if (slot2 == null)
		{
			Item item = ItemManager.Create(freshWater, num3, 0uL);
			if (!item.MoveToContainer(waterStorage.inventory))
			{
				item.Remove();
			}
		}
		else
		{
			slot2.amount += num3;
			slot2.amount = Mathf.Clamp(slot2.amount, 0, waterStorage.maxStackSize);
			waterStorage.inventory.MarkDirty();
		}
		waterStorage.SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk && waterStorage != null)
		{
			info.msg.miningQuarry = Pool.Get<ProtoBuf.MiningQuarry>();
			info.msg.miningQuarry.extractor = Pool.Get<ResourceExtractor>();
			info.msg.miningQuarry.extractor.outputContents = waterStorage.inventory.Save();
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			SetFlag(Flags.On, b: false);
			if (info.msg.miningQuarry != null && waterStorage != null)
			{
				waterStorage.inventory.Load(info.msg.miningQuarry.extractor.outputContents);
			}
		}
	}

	public bool IsBoiling()
	{
		return HasFlag(Flags.Reserved1);
	}
}
