using System;
using ConVar;
using Facepunch;
using Facepunch.Math;
using ProtoBuf;
using UnityEngine;

public class WipeTimer : BaseEntity
{
	public enum WipeFrequency
	{
		Monthly,
		Weekly,
		BiWeekly
	}

	[ServerVar(Help = "0=sun,1=mon,2=tues,3=wed,4=thur,5=fri,6=sat")]
	public static int wipeDayOfWeek = 4;

	[ServerVar(Help = "Which hour to wipe? 14.5 = 2:30pm")]
	public static float wipeHourOfDay = 14f;

	[ServerVar(Help = "Unix timestamp (seconds) for the upcoming wipe. Overrides all other convars if set to a time in the future.")]
	public static long wipeUnixTimestampOverride = 0L;

	public bool useWipeDayOverride;

	public DayOfWeek wipeDayOfWeekOverride = DayOfWeek.Thursday;

	[ServerVar(Name = "days_to_add_test")]
	public static int daysToAddTest = 0;

	[ServerVar(Name = "hours_to_add_test")]
	public static float hoursToAddTest = 0f;

	public bool isWeekly;

	public bool isBiWeekly;

	public bool isMonthly = true;

	public bool isOverride;

	public static WipeTimer serverinstance;

	public static WipeTimer clientinstance;

	private string oldTags = "";

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			serverinstance = this;
		}
		if (base.isClient)
		{
			clientinstance = this;
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			serverinstance = null;
		}
		if (base.isClient)
		{
			clientinstance = null;
		}
		base.DestroyShared();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		RecalculateWipeFrequency();
		InvokeRepeating(TryAndUpdate, 1f, 4f);
	}

	public void RecalculateWipeFrequency()
	{
		string tags = Server.tags;
		if (tags.Contains("monthly"))
		{
			isMonthly = true;
			isWeekly = false;
			isBiWeekly = false;
		}
		else if (tags.Contains("biweekly"))
		{
			isMonthly = false;
			isWeekly = false;
			isBiWeekly = true;
		}
		else if (tags.Contains("weekly"))
		{
			isMonthly = false;
			isWeekly = true;
			isBiWeekly = false;
		}
		else
		{
			isMonthly = true;
		}
	}

	public void TryAndUpdate()
	{
		if (Server.tags != oldTags)
		{
			RecalculateWipeFrequency();
			oldTags = Server.tags;
		}
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk && info.msg.landmine == null)
		{
			info.msg.landmine = Facepunch.Pool.Get<ProtoBuf.Landmine>();
			info.msg.landmine.triggeredID = (ulong)GetTicksUntilWipe();
		}
	}

	public TimeSpan GetTimeSpanUntilWipe()
	{
		DateTime dateTime = DateTime.Now.AddDays(daysToAddTest).AddHours(hoursToAddTest);
		return GetWipeTime(dateTime) - dateTime;
	}

	public long GetTicksUntilWipe()
	{
		return GetTimeSpanUntilWipe().Ticks;
	}

	[ContextMenu("PrintWipe")]
	public void PrintWipe()
	{
		DateTime dateTime = DateTime.Now.AddDays(daysToAddTest).AddHours(hoursToAddTest);
		DateTime wipeTime = GetWipeTime(dateTime);
		TimeSpan timeSpan = wipeTime - dateTime;
		Debug.Log("Test Time " + dateTime.ToString());
		Debug.Log("Time until wipe :" + timeSpan.Days + " days, " + timeSpan.Hours + " hours, " + timeSpan.Minutes + " minutes, " + timeSpan.Seconds + " seconds.");
		Debug.Log("Calculated Wipe time static " + wipeTime.Month + "month," + wipeTime.Day + " days, " + wipeTime.Hour + " hours, " + wipeTime.Minute + " minutes, " + wipeTime.Second + " seconds.");
		Debug.Log("Wipe time : " + wipeTime.ToString());
		long ticks = timeSpan.Ticks;
		Debug.Log("ticks is :" + ticks);
	}

	public static int ConvertWeekday(DayOfWeek weekday)
	{
		return weekday switch
		{
			DayOfWeek.Tuesday => 2, 
			DayOfWeek.Wednesday => 3, 
			DayOfWeek.Thursday => 4, 
			DayOfWeek.Friday => 5, 
			DayOfWeek.Saturday => 6, 
			DayOfWeek.Sunday => 7, 
			_ => 1, 
		};
	}

	public DateTime GetWipeTime(DateTime nowTime)
	{
		if (wipeUnixTimestampOverride > 0 && wipeUnixTimestampOverride > Epoch.Current)
		{
			return Epoch.ToDateTime(wipeUnixTimestampOverride);
		}
		return GetWipeTime(nowTime, useWipeDayOverride ? wipeDayOfWeekOverride : ((DayOfWeek)wipeDayOfWeek), wipeHourOfDay, (!isMonthly) ? (isWeekly ? WipeFrequency.Weekly : WipeFrequency.BiWeekly) : WipeFrequency.Monthly);
	}

	private static DateTime GetWipeTime(DateTime nowTime, DayOfWeek wipeDay, float wipeHour, WipeFrequency freq)
	{
		int num = ConvertWeekday(wipeDay);
		DateTime dateTime = new DateTime(nowTime.Year, 1, 1).AddHours(Mathf.FloorToInt(wipeHour));
		dateTime = dateTime.AddMinutes((wipeHour - (float)dateTime.Hour) * 60f).AddMonths(nowTime.Month - 1);
		int num2 = ConvertWeekday(nowTime.DayOfWeek);
		int num3 = 0;
		num3 = ((num2 > num) ? (7 - (num2 - num)) : ((num2 < num) ? (num - num2) : ((nowTime.Hour > dateTime.Hour && nowTime.Minute >= dateTime.Minute) ? 7 : 0)));
		switch (freq)
		{
		case WipeFrequency.Weekly:
			dateTime = dateTime.AddDays(nowTime.Day - 1).AddDays(num3);
			break;
		case WipeFrequency.BiWeekly:
			dateTime = dateTime.AddDays(nowTime.Day - 1).AddDays(num3 + 7);
			break;
		case WipeFrequency.Monthly:
		{
			if (num2 < num && nowTime.Day <= num)
			{
				int num4 = num - num2;
				dateTime = dateTime.AddDays(nowTime.Day - 1).AddDays(num4);
				break;
			}
			dateTime = dateTime.AddMonths(1);
			int num5 = ConvertWeekday(dateTime.DayOfWeek);
			int num6 = 0;
			if (num5 > num)
			{
				num6 = 7 - (num5 - num);
			}
			else if (num5 < num)
			{
				num6 = num - num5;
			}
			dateTime = dateTime.AddDays(num6);
			break;
		}
		}
		return dateTime;
	}
}
