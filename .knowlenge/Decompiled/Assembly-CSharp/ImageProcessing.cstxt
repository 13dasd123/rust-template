using System;
using System.Collections.Generic;
using UnityEngine;

public static class ImageProcessing
{
	public static void GaussianBlur2D(float[,] data)
	{
		GaussianBlur2D(data, 1);
	}

	public static void GaussianBlur2D(float[,] data, int iterations)
	{
		int length = data.GetLength(0);
		int length2 = data.GetLength(1);
		float[,] a = data;
		float[,] b = new float[length, length2];
		for (int i = 0; i < iterations; i++)
		{
			for (int j = 0; j < length; j++)
			{
				int num = Mathf.Max(0, j - 1);
				int num2 = Mathf.Min(length - 1, j + 1);
				for (int k = 0; k < length2; k++)
				{
					int num3 = Mathf.Max(0, k - 1);
					int num4 = Mathf.Min(length2 - 1, k + 1);
					float num5 = a[j, k] * 4f + a[j, num3] + a[j, num4] + a[num, k] + a[num2, k];
					b[j, k] = num5 * 0.125f;
				}
			}
			GenericsUtil.Swap(ref a, ref b);
		}
		if (a != data)
		{
			Buffer.BlockCopy(a, 0, data, 0, data.Length * 4);
		}
	}

	public static void GaussianBlur2D(float[,,] data)
	{
		GaussianBlur2D(data, 1);
	}

	public static void GaussianBlur2D(float[,,] data, int iterations)
	{
		int len1 = data.GetLength(0);
		int len2 = data.GetLength(1);
		int len3 = data.GetLength(2);
		float[,,] src = data;
		float[,,] dst = new float[len1, len2, len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[x, j, k] * 4f + src[x, num3, k] + src[x, num4, k] + src[num, j, k] + src[num2, j, k];
						dst[x, j, k] = num5 * 0.125f;
					}
				}
			});
			GenericsUtil.Swap(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[,] data)
	{
		Average2D(data, 1);
	}

	public static void Average2D(float[,] data, int iterations)
	{
		int len1 = data.GetLength(0);
		int len2 = data.GetLength(1);
		float[,] src = data;
		float[,] dst = new float[len1, len2];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					float num5 = src[x, j] + src[x, num3] + src[x, num4] + src[num, j] + src[num2, j];
					dst[x, j] = num5 * 0.2f;
				}
			});
			GenericsUtil.Swap(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[,,] data)
	{
		Average2D(data, 1);
	}

	public static void Average2D(float[,,] data, int iterations)
	{
		int len1 = data.GetLength(0);
		int len2 = data.GetLength(1);
		int len3 = data.GetLength(2);
		float[,,] src = data;
		float[,,] dst = new float[len1, len2, len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[x, j, k] + src[x, num3, k] + src[x, num4, k] + src[num, j, k] + src[num2, j, k];
						dst[x, j, k] = num5 * 0.2f;
					}
				}
			});
			GenericsUtil.Swap(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Upsample2D(float[,] src, float[,] dst)
	{
		int srclen1 = src.GetLength(0);
		int srclen2 = src.GetLength(1);
		int length = dst.GetLength(0);
		int length2 = dst.GetLength(1);
		if (2 * srclen1 != length || 2 * srclen2 != length2)
		{
			return;
		}
		Parallel.For(0, srclen1, delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				float num5 = src[x, i] * 6f;
				float num6 = num5 + src[num, i] + src[x, num3];
				dst[2 * x, 2 * i] = num6 * 0.125f;
				float num7 = num5 + src[num2, i] + src[x, num3];
				dst[2 * x + 1, 2 * i] = num7 * 0.125f;
				float num8 = num5 + src[num, i] + src[x, num4];
				dst[2 * x, 2 * i + 1] = num8 * 0.125f;
				float num9 = num5 + src[num2, i] + src[x, num4];
				dst[2 * x + 1, 2 * i + 1] = num9 * 0.125f;
			}
		});
	}

	public static void Upsample2D(float[,,] src, float[,,] dst)
	{
		int srclen1 = src.GetLength(0);
		int srclen2 = src.GetLength(1);
		int srclen3 = src.GetLength(2);
		int length = dst.GetLength(0);
		int length2 = dst.GetLength(1);
		int length3 = src.GetLength(2);
		if (2 * srclen1 != length || 2 * srclen2 != length2 || srclen3 != length3)
		{
			return;
		}
		Parallel.For(0, srclen1, delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				for (int j = 0; j < srclen3; j++)
				{
					float num5 = src[x, i, j] * 6f;
					float num6 = num5 + src[num, i, j] + src[x, num3, j];
					dst[2 * x, 2 * i, j] = num6 * 0.125f;
					float num7 = num5 + src[num2, i, j] + src[x, num3, j];
					dst[2 * x + 1, 2 * i, j] = num7 * 0.125f;
					float num8 = num5 + src[num, i, j] + src[x, num4, j];
					dst[2 * x, 2 * i + 1, j] = num8 * 0.125f;
					float num9 = num5 + src[num2, i, j] + src[x, num4, j];
					dst[2 * x + 1, 2 * i + 1, j] = num9 * 0.125f;
				}
			}
		});
	}

	public static void Dilate2D(int[,] src, int srcmask, int radius, Action<int, int> action)
	{
		int dx = src.GetLength(0);
		int dy = src.GetLength(1);
		Parallel.For(0, dx, delegate(int x)
		{
			MaxQueue maxQueue = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				maxQueue.Push(src[x, i] & srcmask);
			}
			for (int j = 0; j < dy; j++)
			{
				if (j > radius)
				{
					maxQueue.Pop();
				}
				if (j < dy - radius)
				{
					maxQueue.Push(src[x, j + radius] & srcmask);
				}
				if (maxQueue.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, dy, delegate(int y)
		{
			MaxQueue maxQueue2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				maxQueue2.Push(src[k, y] & srcmask);
			}
			for (int l = 0; l < dx; l++)
			{
				if (l > radius)
				{
					maxQueue2.Pop();
				}
				if (l < dx - radius)
				{
					maxQueue2.Push(src[l + radius, y] & srcmask);
				}
				if (maxQueue2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void FloodFill2D(int x, int y, int[,] data, int mask_any, int mask_not, Func<int, int> action)
	{
		int length = data.GetLength(0);
		int length2 = data.GetLength(1);
		Stack<KeyValuePair<int, int>> stack = new Stack<KeyValuePair<int, int>>();
		stack.Push(new KeyValuePair<int, int>(x, y));
		while (stack.Count > 0)
		{
			KeyValuePair<int, int> keyValuePair = stack.Pop();
			x = keyValuePair.Key;
			y = keyValuePair.Value;
			int num;
			for (num = y; num >= 0; num--)
			{
				int num2 = data[x, num];
				if ((data[x, num] & mask_any) == 0 || (data[x, num] & mask_not) != 0)
				{
					break;
				}
			}
			num++;
			bool flag;
			bool flag2 = (flag = false);
			for (; num < length2; num++)
			{
				int num3 = data[x, num];
				if ((data[x, num] & mask_any) == 0 || (data[x, num] & mask_not) != 0)
				{
					break;
				}
				data[x, num] = action(data[x, num]);
				if (x > 0)
				{
					int num4 = data[x - 1, num];
					bool flag3 = (num4 & mask_any) != 0 && (num4 & mask_not) == 0;
					if (!flag2 && flag3)
					{
						stack.Push(new KeyValuePair<int, int>(x - 1, num));
						flag2 = true;
					}
					else if (flag2 && !flag3)
					{
						flag2 = false;
					}
				}
				if (x < length - 1)
				{
					int num5 = data[x + 1, num];
					bool flag4 = (num5 & mask_any) != 0 && (num5 & mask_not) == 0;
					if (!flag && flag4)
					{
						stack.Push(new KeyValuePair<int, int>(x + 1, num));
						flag = true;
					}
					else if (flag && !flag4)
					{
						flag = false;
					}
				}
			}
		}
	}
}
