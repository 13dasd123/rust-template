using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class Memory
{
	public struct SeenInfo
	{
		public BaseEntity Entity;

		public Vector3 Position;

		public float Timestamp;

		public float Danger;
	}

	public List<BaseEntity> Visible = new List<BaseEntity>();

	public List<SeenInfo> All = new List<SeenInfo>();

	public void Update(BaseEntity ent, float danger = 0f)
	{
		for (int i = 0; i < All.Count; i++)
		{
			if (All[i].Entity == ent)
			{
				SeenInfo value = All[i];
				value.Position = ent.transform.position;
				value.Timestamp = Mathf.Max(Time.realtimeSinceStartup, value.Timestamp);
				value.Danger += danger;
				All[i] = value;
				return;
			}
		}
		All.Add(new SeenInfo
		{
			Entity = ent,
			Position = ent.transform.position,
			Timestamp = Time.realtimeSinceStartup,
			Danger = danger
		});
		Visible.Add(ent);
	}

	public void AddDanger(Vector3 position, float amount)
	{
		for (int i = 0; i < All.Count; i++)
		{
			if (Mathf.Approximately(All[i].Position.x, position.x) && Mathf.Approximately(All[i].Position.y, position.y) && Mathf.Approximately(All[i].Position.z, position.z))
			{
				SeenInfo value = All[i];
				value.Danger = amount;
				All[i] = value;
				return;
			}
		}
		All.Add(new SeenInfo
		{
			Position = position,
			Timestamp = Time.realtimeSinceStartup,
			Danger = amount
		});
	}

	public SeenInfo GetInfo(BaseEntity entity)
	{
		foreach (SeenInfo item in All)
		{
			if (item.Entity == entity)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	internal void Forget(float secondsOld)
	{
		for (int i = 0; i < All.Count; i++)
		{
			if (Time.realtimeSinceStartup - All[i].Timestamp > secondsOld)
			{
				if (All[i].Entity != null)
				{
					Visible.Remove(All[i].Entity);
				}
				All.RemoveAt(i);
				i--;
			}
		}
	}
}
