using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class DynamicNavMesh : SingletonComponent<DynamicNavMesh>, IServerComponent
{
	[Tooltip("TODO: Replace with actual agent type id on the NavMeshAgent when we upgrade to 5.6.1 or above.")]
	public int NavMeshAgentTypeIndex;

	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private Stopwatch BuildTimer = new Stopwatch();

	public bool IsBuilding
	{
		get
		{
			if (BuildingOperation == null)
			{
				return false;
			}
			return true;
		}
	}

	private void OnEnable()
	{
		if (AiManager.nav_grid)
		{
			base.enabled = false;
			return;
		}
		NavMeshData = new NavMeshData(0);
		sources = new List<NavMeshBuildSource>();
		InvokeRepeating(FinishBuildingNavmesh, 0f, 1f);
	}

	private void OnDisable()
	{
		if (!AiManager.nav_grid)
		{
			CancelInvoke(FinishBuildingNavmesh);
			NavMeshDataInstance.Remove();
		}
	}

	[ContextMenu("Update Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		if (!IsBuilding && !AiManager.nav_disable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			List<NavMeshBuildMarkup> markups = new List<NavMeshBuildMarkup>();
			NavMeshBuilder.CollectSources(Bounds, LayerMask, NavMeshCollectGeometry, 0, markups, sources);
			UnityEngine.Debug.Log("Starting Navmesh Build with " + sources.Count + " sources");
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			settingsByIndex.overrideVoxelSize = true;
			settingsByIndex.voxelSize *= 2f;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				UnityEngine.Debug.LogWarning("Calling UpdateNavMesh took " + num);
			}
		}
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (IsBuilding || AiManager.nav_disable)
		{
			yield break;
		}
		UpdateNavMeshAsync();
		if (!AiManager.nav_wait)
		{
			UnityEngine.Debug.Log("nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (BuildingOperation != null)
		{
			int pctDone = (int)(BuildingOperation.progress * 100f);
			if (lastPct != pctDone)
			{
				UnityEngine.Debug.LogFormat("{0}%", pctDone);
				lastPct = pctDone;
			}
			Thread.Sleep(250);
			FinishBuildingNavmesh();
			yield return null;
		}
	}

	public void FinishBuildingNavmesh()
	{
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!NavMeshDataInstance.valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			UnityEngine.Debug.Log($"Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}
