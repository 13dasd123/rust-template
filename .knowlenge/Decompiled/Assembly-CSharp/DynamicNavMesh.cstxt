using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class DynamicNavMesh : SingletonComponent<DynamicNavMesh>, IServerComponent
{
	public int NavMeshAgentTypeIndex;

	[Tooltip("The default area associated with the NavMeshAgent index.")]
	public string DefaultAreaName = "Walkable";

	public int AsyncTerrainNavMeshBakeCellSize = 80;

	public int AsyncTerrainNavMeshBakeCellHeight = 100;

	public Bounds Bounds;

	public NavMeshData NavMeshData;

	public NavMeshDataInstance NavMeshDataInstance;

	public LayerMask LayerMask;

	public NavMeshCollectGeometry NavMeshCollectGeometry;

	private List<AsyncTerrainNavMeshBake> terrainBakes;

	private List<NavMeshBuildSource> sources;

	private AsyncOperation BuildingOperation;

	private bool HasBuildOperationStarted;

	private Stopwatch BuildTimer = new Stopwatch();

	private int defaultArea;

	private int agentTypeId;

	public bool IsBuilding
	{
		get
		{
			if (!HasBuildOperationStarted || BuildingOperation != null)
			{
				return true;
			}
			return false;
		}
	}

	private void OnEnable()
	{
		agentTypeId = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex).agentTypeID;
		NavMeshData = new NavMeshData(agentTypeId);
		sources = new List<NavMeshBuildSource>();
		terrainBakes = new List<AsyncTerrainNavMeshBake>();
		defaultArea = NavMesh.GetAreaFromName(DefaultAreaName);
		InvokeRepeating(FinishBuildingNavmesh, 0f, 1f);
	}

	private void OnDisable()
	{
		if (!Rust.Application.isQuitting)
		{
			CancelInvoke(FinishBuildingNavmesh);
			NavMeshDataInstance.Remove();
		}
	}

	[ContextMenu("Update Nav Mesh")]
	public void UpdateNavMeshAsync()
	{
		if (!HasBuildOperationStarted && !AiManager.nav_disable)
		{
			float realtimeSinceStartup = Time.realtimeSinceStartup;
			UnityEngine.Debug.Log("Starting Navmesh Build with " + sources.Count + " sources");
			NavMeshBuildSettings settingsByIndex = NavMesh.GetSettingsByIndex(NavMeshAgentTypeIndex);
			settingsByIndex.overrideVoxelSize = true;
			settingsByIndex.voxelSize *= 2f;
			BuildingOperation = NavMeshBuilder.UpdateNavMeshDataAsync(NavMeshData, settingsByIndex, sources, Bounds);
			BuildTimer.Reset();
			BuildTimer.Start();
			HasBuildOperationStarted = true;
			float num = Time.realtimeSinceStartup - realtimeSinceStartup;
			if (num > 0.1f)
			{
				UnityEngine.Debug.LogWarning("Calling UpdateNavMesh took " + num);
			}
		}
	}

	private IEnumerator CollectSourcesAsync(Action callback)
	{
		float time = Time.realtimeSinceStartup;
		UnityEngine.Debug.Log("Starting Navmesh Source Collecting.");
		List<NavMeshBuildMarkup> markups = new List<NavMeshBuildMarkup>();
		NavMeshBuilder.CollectSources(Bounds, LayerMask, NavMeshCollectGeometry, defaultArea, markups, sources);
		if (TerrainMeta.HeightMap != null)
		{
			for (float x = 0f - Bounds.extents.x; x < Bounds.extents.x; x += (float)AsyncTerrainNavMeshBakeCellSize)
			{
				for (float z = 0f - Bounds.extents.z; z < Bounds.extents.z; z += (float)AsyncTerrainNavMeshBakeCellSize)
				{
					AsyncTerrainNavMeshBake terrainSource = new AsyncTerrainNavMeshBake(new Vector3(x, 0f, z), AsyncTerrainNavMeshBakeCellSize, AsyncTerrainNavMeshBakeCellHeight, normal: false, alpha: true);
					yield return terrainSource;
					terrainBakes.Add(terrainSource);
					sources.Add(terrainSource.CreateNavMeshBuildSource(addSourceObject: true));
				}
			}
		}
		AppendModifierVolumes(ref sources);
		float num = Time.realtimeSinceStartup - time;
		if (num > 0.1f)
		{
			UnityEngine.Debug.LogWarning("Calling CollectSourcesAsync took " + num);
		}
		callback?.Invoke();
	}

	public IEnumerator UpdateNavMeshAndWait()
	{
		if (HasBuildOperationStarted || AiManager.nav_disable)
		{
			yield break;
		}
		HasBuildOperationStarted = false;
		Bounds.size = TerrainMeta.Size;
		NavMesh.pathfindingIterationsPerFrame = AiManager.pathfindingIterationsPerFrame;
		if (AiManager.nav_wait)
		{
			yield return CollectSourcesAsync(UpdateNavMeshAsync);
		}
		else
		{
			StartCoroutine(CollectSourcesAsync(UpdateNavMeshAsync));
		}
		if (!AiManager.nav_wait)
		{
			UnityEngine.Debug.Log("nav_wait is false, so we're not waiting for the navmesh to finish generating. This might cause your server to sputter while it's generating.");
			yield break;
		}
		int lastPct = 0;
		while (!HasBuildOperationStarted)
		{
			Thread.Sleep(250);
			yield return null;
		}
		while (BuildingOperation != null)
		{
			int num = (int)(BuildingOperation.progress * 100f);
			if (lastPct != num)
			{
				UnityEngine.Debug.LogFormat("{0}%", num);
				lastPct = num;
			}
			Thread.Sleep(250);
			FinishBuildingNavmesh();
			yield return null;
		}
	}

	private void AppendModifierVolumes(ref List<NavMeshBuildSource> sources)
	{
		foreach (NavMeshModifierVolume activeModifier in NavMeshModifierVolume.activeModifiers)
		{
			if (((int)LayerMask & (1 << activeModifier.gameObject.layer)) != 0 && activeModifier.AffectsAgentType(agentTypeId))
			{
				Vector3 pos = activeModifier.transform.TransformPoint(activeModifier.center);
				Vector3 lossyScale = activeModifier.transform.lossyScale;
				Vector3 size = new Vector3(activeModifier.size.x * Mathf.Abs(lossyScale.x), activeModifier.size.y * Mathf.Abs(lossyScale.y), activeModifier.size.z * Mathf.Abs(lossyScale.z));
				NavMeshBuildSource item = default(NavMeshBuildSource);
				item.shape = NavMeshBuildSourceShape.ModifierBox;
				item.transform = Matrix4x4.TRS(pos, activeModifier.transform.rotation, Vector3.one);
				item.size = size;
				item.area = activeModifier.area;
				sources.Add(item);
			}
		}
	}

	public void FinishBuildingNavmesh()
	{
		if (BuildingOperation != null && BuildingOperation.isDone)
		{
			if (!NavMeshDataInstance.valid)
			{
				NavMeshDataInstance = NavMesh.AddNavMeshData(NavMeshData);
			}
			UnityEngine.Debug.Log($"Navmesh Build took {BuildTimer.Elapsed.TotalSeconds:0.00} seconds");
			BuildingOperation = null;
		}
	}
}
