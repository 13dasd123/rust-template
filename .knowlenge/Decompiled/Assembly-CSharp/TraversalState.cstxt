using UnityEngine;
using UnityEngine.AI;

public class TraversalState : BasicAIState
{
	private Vector3 desiredDestination;

	public bool finished;

	private AITraversalArea area;

	private bool isTraversing;

	private bool waiting;

	public override float GetWeight()
	{
		if (finished)
		{
			return 0f;
		}
		AITraversalArea traversalArea = GetEntity().GetTraversalArea();
		if (isTraversing || waiting)
		{
			return 10000f;
		}
		if (GetEntity().IsInTraversalArea())
		{
			NavMeshPath path = GetEntity().NavAgent.path;
			bool flag = false;
			bool flag2 = false;
			Vector3[] corners = path.corners;
			foreach (Vector3 vector in corners)
			{
				if (Vector3.Distance(vector, traversalArea.entryPoint1.position) <= 2f)
				{
					flag = true;
				}
				else if (Vector3.Distance(vector, traversalArea.entryPoint2.position) <= 2f)
				{
					flag2 = true;
				}
				if (traversalArea.movementArea.Contains(vector))
				{
					return 10000f;
				}
				if (flag && flag2)
				{
					return 10000f;
				}
			}
		}
		return 0f;
	}

	public override void StateEnter()
	{
		base.StateEnter();
		GetEntity().SetDesiredSpeed(HumanNPC.SpeedType.Walk);
		finished = false;
		isTraversing = false;
		waiting = false;
		desiredDestination = GetEntity().finalDestination;
		area = GetEntity().GetTraversalArea();
		if ((bool)area && area.CanTraverse(GetEntity()))
		{
			area.SetBusyFor(2f);
		}
	}

	public override void StateThink(float delta)
	{
		base.StateThink(delta);
		if ((bool)area)
		{
			if (isTraversing)
			{
				area.SetBusyFor(delta * 2f);
			}
			else if (area.CanTraverse(GetEntity()))
			{
				waiting = false;
				isTraversing = true;
				AITraversalWaitPoint entryPointNear = area.GetEntryPointNear(area.GetFarthestEntry(GetEntity().transform.position).position);
				if ((bool)entryPointNear)
				{
					entryPointNear.Occupy(delta * 2f);
				}
				Vector3 destination = ((entryPointNear == null) ? desiredDestination : entryPointNear.transform.position);
				GetEntity().SetDestination(destination);
				area.SetBusyFor(delta * 2f);
			}
			else
			{
				AITraversalWaitPoint entryPointNear2 = area.GetEntryPointNear(GetEntity().transform.position);
				if ((bool)entryPointNear2)
				{
					entryPointNear2.Occupy();
					GetEntity().SetStationaryAimPoint(area.GetClosestEntry(GetEntity().transform.position).position);
				}
				Vector3 destination2 = ((entryPointNear2 == null) ? GetEntity().transform.position : entryPointNear2.transform.position);
				GetEntity().SetDestination(destination2);
				waiting = true;
				isTraversing = false;
			}
		}
		if (isTraversing && Vector3.Distance(GetEntity().transform.position, GetEntity().finalDestination) < 0.25f)
		{
			finished = true;
			isTraversing = false;
			waiting = false;
		}
	}

	public override bool CanInterrupt()
	{
		return true;
	}

	public override void StateLeave()
	{
		base.StateLeave();
		finished = false;
		area = null;
		isTraversing = false;
		waiting = false;
		GetEntity().SetDestination(desiredDestination);
	}
}
