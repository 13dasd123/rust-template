using System;
using Rust.Ai.Gen2;
using UnityEngine;

[Serializable]
[SoftRequireComponent(typeof(RootMotionPlayer))]
public class State_EatFood : FSMStateBase
{
	[SerializeField]
	protected AnimationClip Animation;

	[SerializeField]
	public float DamageToCorpsesPerLoop = 2.5f;

	private SenseComponent sense;

	private bool isAnimationPlaying;

	public override EFSMStateStatus OnStateEnter()
	{
		if (sense == null)
		{
			sense = Owner.GetComponent<SenseComponent>();
		}
		if (!sense.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		Vector3 forward = food.transform.position - Owner.transform.position;
		forward.y = 0f;
		Owner.transform.rotation = Quaternion.LookRotation(forward);
		PlayAnimation();
		return base.OnStateEnter();
	}

	private void PlayAnimation()
	{
		isAnimationPlaying = true;
		Owner.GetComponent<RootMotionPlayer>().PlayServer(Animation, OnAnimationEnd);
	}

	private void OnAnimationEnd()
	{
		isAnimationPlaying = false;
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		if (!sense.FindFood(out var food))
		{
			return EFSMStateStatus.Failure;
		}
		if (isAnimationPlaying)
		{
			return base.OnStateUpdate(deltaTime);
		}
		if (food is BaseCorpse baseCorpse)
		{
			baseCorpse.Hurt(DamageToCorpsesPerLoop);
			if (baseCorpse.IsDead())
			{
				sense.ClearTarget();
				return EFSMStateStatus.Success;
			}
			PlayAnimation();
		}
		else if (food is DroppedItem droppedItem)
		{
			droppedItem.item.amount = Mathf.FloorToInt((float)droppedItem.item.amount * 0.5f);
			if (droppedItem.item.amount <= 0)
			{
				droppedItem.DestroyItem();
				droppedItem.Kill();
				sense.ClearTarget();
				return EFSMStateStatus.Success;
			}
			droppedItem.item.MarkDirty();
			PlayAnimation();
		}
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		Owner.GetComponent<RootMotionPlayer>().StopServer();
	}
}
