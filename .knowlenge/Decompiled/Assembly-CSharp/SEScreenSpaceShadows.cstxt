using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Sonic Ether/SE Screen-Space Shadows")]
[RequireComponent(typeof(Camera))]
public class SEScreenSpaceShadows : MonoBehaviour
{
	private CommandBuffer blendShadowsCommandBuffer;

	private CommandBuffer renderShadowsCommandBuffer;

	private Camera attachedCamera;

	public Light sun;

	private Material material;

	private object initChecker;

	private bool sunInitialized;

	private int temporalJitterCounter;

	[Range(0f, 1f)]
	public float blendStrength = 1f;

	[Range(0f, 1f)]
	public float accumulation = 0.9f;

	[Range(0.1f, 5f)]
	public float lengthFade = 0.7f;

	[Range(0.01f, 5f)]
	public float range = 0.7f;

	[Range(0f, 1f)]
	public float zThickness = 0.1f;

	[Range(2f, 92f)]
	public int samples = 32;

	[Range(0.5f, 4f)]
	public float nearSampleQuality = 1.5f;

	[Range(0f, 1f)]
	public float traceBias = 0.03f;

	public bool stochasticSampling = true;

	public bool leverageTemporalAA;

	public bool bilateralBlur = true;

	[Range(1f, 2f)]
	public int blurPasses = 1;

	[Range(0.01f, 0.5f)]
	public float blurDepthTolerance = 0.1f;

	private bool previousBilateralBlurSetting;

	private int previousBlurPassesSetting = 1;

	private Texture2D noBlendTex;

	private void AddCommandBufferClean(Light light, CommandBuffer commandBuffer, LightEvent lightEvent)
	{
		bool flag = false;
		CommandBuffer[] commandBuffers = light.GetCommandBuffers(lightEvent);
		CommandBuffer[] array = commandBuffers;
		foreach (CommandBuffer commandBuffer2 in array)
		{
			if (commandBuffer2.name == commandBuffer.name)
			{
				flag = true;
			}
		}
		if (!flag)
		{
			light.AddCommandBuffer(lightEvent, commandBuffer);
		}
	}

	private void AddCommandBufferClean(Camera camera, CommandBuffer commandBuffer, CameraEvent cameraEvent)
	{
		bool flag = false;
		CommandBuffer[] commandBuffers = camera.GetCommandBuffers(cameraEvent);
		CommandBuffer[] array = commandBuffers;
		foreach (CommandBuffer commandBuffer2 in array)
		{
			if (commandBuffer2.name == commandBuffer.name)
			{
				flag = true;
			}
		}
		if (!flag)
		{
			camera.AddCommandBuffer(cameraEvent, commandBuffer);
		}
	}

	private void RemoveCommandBuffer(Light light, CommandBuffer commandBuffer, LightEvent lightEvent)
	{
		CommandBuffer[] commandBuffers = light.GetCommandBuffers(lightEvent);
		List<CommandBuffer> list = new List<CommandBuffer>();
		CommandBuffer[] array = commandBuffers;
		foreach (CommandBuffer commandBuffer2 in array)
		{
			if (commandBuffer2.name != commandBuffer.name)
			{
				list.Add(commandBuffer2);
			}
		}
		light.RemoveCommandBuffers(lightEvent);
		foreach (CommandBuffer item in list)
		{
			light.AddCommandBuffer(lightEvent, item);
		}
	}

	private void RemoveCommandBuffer(Camera camera, CommandBuffer commandBuffer, CameraEvent cameraEvent)
	{
		CommandBuffer[] commandBuffers = camera.GetCommandBuffers(cameraEvent);
		List<CommandBuffer> list = new List<CommandBuffer>();
		CommandBuffer[] array = commandBuffers;
		foreach (CommandBuffer commandBuffer2 in array)
		{
			if (commandBuffer2.name != commandBuffer.name)
			{
				list.Add(commandBuffer2);
			}
		}
		camera.RemoveCommandBuffers(cameraEvent);
		foreach (CommandBuffer item in list)
		{
			camera.AddCommandBuffer(cameraEvent, item);
		}
	}

	private void RemoveCommandBuffers()
	{
		RemoveCommandBuffer(attachedCamera, renderShadowsCommandBuffer, CameraEvent.BeforeLighting);
		if (sun != null)
		{
			RemoveCommandBuffer(sun, blendShadowsCommandBuffer, LightEvent.AfterScreenspaceMask);
		}
	}

	public bool GetCompatibleRenderPath()
	{
		if ((bool)attachedCamera)
		{
			return attachedCamera.actualRenderingPath == RenderingPath.DeferredShading;
		}
		Camera component = GetComponent<Camera>();
		return component.actualRenderingPath == RenderingPath.DeferredShading;
	}

	private void Init()
	{
		if (initChecker != null)
		{
			return;
		}
		if (!attachedCamera)
		{
			attachedCamera = GetComponent<Camera>();
			attachedCamera.depthTextureMode |= DepthTextureMode.Depth;
		}
		if (!GetCompatibleRenderPath())
		{
			initChecker = null;
			return;
		}
		material = new Material(Shader.Find("Hidden/SEScreenSpaceShadows"));
		sunInitialized = false;
		blendShadowsCommandBuffer = new CommandBuffer
		{
			name = "SE Screen Space Shadows: Blend"
		};
		blendShadowsCommandBuffer.Blit(BuiltinRenderTextureType.None, BuiltinRenderTextureType.CurrentActive, material, 0);
		renderShadowsCommandBuffer = new CommandBuffer
		{
			name = "SE Screen Space Shadows: Render"
		};
		int num = Shader.PropertyToID("SEScreenShadowBuffer0");
		int num2 = Shader.PropertyToID("SEScreenShadowBuffer1");
		int num3 = Shader.PropertyToID("DepthSource");
		renderShadowsCommandBuffer.GetTemporaryRT(num, -1, -1, 0, FilterMode.Bilinear, RenderTextureFormat.R8);
		if (bilateralBlur)
		{
			renderShadowsCommandBuffer.GetTemporaryRT(num2, -1, -1, 0, FilterMode.Bilinear, RenderTextureFormat.R8);
		}
		renderShadowsCommandBuffer.GetTemporaryRT(num3, -1, -1, 0, FilterMode.Point, RenderTextureFormat.RFloat);
		renderShadowsCommandBuffer.Blit(num, num3, material, 2);
		renderShadowsCommandBuffer.Blit(num3, num, material, 1);
		if (bilateralBlur)
		{
			for (int i = 0; i < blurPasses; i++)
			{
				renderShadowsCommandBuffer.SetGlobalVector("SESSSBlurKernel", new Vector2(0f, 1f));
				renderShadowsCommandBuffer.Blit(num, num2, material, 3);
				renderShadowsCommandBuffer.SetGlobalVector("SESSSBlurKernel", new Vector2(1f, 0f));
				renderShadowsCommandBuffer.Blit(num2, num, material, 3);
			}
		}
		renderShadowsCommandBuffer.SetGlobalTexture("SEScreenSpaceShadowsTexture", num);
		AddCommandBufferClean(attachedCamera, renderShadowsCommandBuffer, CameraEvent.BeforeLighting);
		noBlendTex = new Texture2D(1, 1, TextureFormat.ARGB32, mipmap: false);
		noBlendTex.SetPixel(0, 0, Color.white);
		noBlendTex.Apply();
		initChecker = new object();
	}

	private void OnEnable()
	{
		Init();
	}

	private void OnDisable()
	{
		RemoveCommandBuffers();
		initChecker = null;
	}

	private void OnPreRender()
	{
		Init();
		if (initChecker != null)
		{
			if (sun != null && !sunInitialized)
			{
				AddCommandBufferClean(sun, blendShadowsCommandBuffer, LightEvent.AfterScreenspaceMask);
				sunInitialized = true;
			}
			if (leverageTemporalAA)
			{
				temporalJitterCounter = (temporalJitterCounter + 1) % 8;
			}
			if (previousBilateralBlurSetting != bilateralBlur || previousBlurPassesSetting != blurPasses)
			{
				RemoveCommandBuffers();
				initChecker = null;
				Init();
			}
			previousBilateralBlurSetting = bilateralBlur;
			previousBlurPassesSetting = blurPasses;
			if (sunInitialized)
			{
				material.SetMatrix("ProjectionMatrix", attachedCamera.projectionMatrix);
				material.SetMatrix("ProjectionMatrixInverse", attachedCamera.projectionMatrix.inverse);
				material.SetVector("SunlightVector", base.transform.InverseTransformDirection(sun.transform.forward));
				material.SetVector("ScreenRes", new Vector4(attachedCamera.pixelWidth, attachedCamera.pixelHeight, 1f / (float)attachedCamera.pixelWidth, 1f / (float)attachedCamera.pixelHeight));
				material.SetFloat("BlendStrength", blendStrength);
				material.SetFloat("Accumulation", accumulation);
				material.SetFloat("Range", range);
				material.SetFloat("ZThickness", zThickness);
				material.SetInt("Samples", samples);
				material.SetFloat("NearQualityCutoff", 1f / nearSampleQuality);
				material.SetFloat("TraceBias", traceBias);
				material.SetFloat("StochasticSampling", (!stochasticSampling) ? 0f : 1f);
				material.SetInt("TJitter", temporalJitterCounter);
				material.SetFloat("LengthFade", lengthFade);
				material.SetFloat("BlurDepthTolerance", blurDepthTolerance);
			}
		}
	}

	private void OnPostRender()
	{
		Shader.SetGlobalTexture("SEScreenSpaceShadowsTexture", noBlendTex);
	}
}
