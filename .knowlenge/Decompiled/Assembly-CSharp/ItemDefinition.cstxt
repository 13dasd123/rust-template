using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Steamworks;
using Rust;
using UnityEngine;

public class ItemDefinition : MonoBehaviour
{
	[Serializable]
	public struct Condition
	{
		[Serializable]
		public class WorldSpawnCondition
		{
			public float fractionMin = 1f;

			public float fractionMax = 1f;
		}

		public bool enabled;

		[Tooltip("The maximum condition this item type can have, new items will start with this value")]
		public float max;

		[Tooltip("If false then item will destroy when condition reaches 0")]
		public bool repairable;

		[Tooltip("If true, never lose max condition when repaired")]
		public bool maintainMaxCondition;

		public WorldSpawnCondition foundCondition;
	}

	[Flags]
	public enum Flag
	{
		NoDropping = 1,
		NotStraightToBelt = 2
	}

	public enum AmountType
	{
		Count,
		Millilitre,
		Feet,
		Genetics
	}

	[Header("Item")]
	[ReadOnly]
	public int itemid;

	[Tooltip("The shortname should be unique. A hash will be generated from it to identify the item type. If this name changes at any point it will make all saves incompatible")]
	public string shortname;

	[Header("Appearance")]
	public Translate.Phrase displayName;

	public Translate.Phrase displayDescription;

	public Sprite iconSprite;

	public ItemCategory category;

	public ItemSelectionPanel selectionPanel;

	[Header("Containment")]
	public int maxDraggable;

	public ItemContainer.ContentsType itemType = ItemContainer.ContentsType.Generic;

	public AmountType amountType;

	[InspectorFlags]
	public ItemSlot occupySlots = ItemSlot.None;

	public int stackable;

	public bool quickDespawn;

	[Header("Spawn Tables")]
	public Rarity rarity;

	public bool spawnAsBlueprint;

	[Header("Sounds")]
	public SoundDefinition inventorySelectSound;

	public SoundDefinition inventoryGrabSound;

	public SoundDefinition inventoryDropSound;

	public SoundDefinition physImpactSoundDef;

	public Condition condition;

	[Header("Misc")]
	public bool hidden;

	[InspectorFlags]
	public Flag flags;

	[Tooltip("User can craft this item on any server if they have this steam item")]
	public SteamInventoryItem steamItem;

	[Tooltip("Can only craft this item if the parent is craftable (tech tree)")]
	public ItemDefinition Parent;

	public GameObjectRef worldModelPrefab;

	[NonSerialized]
	public ItemMod[] itemMods;

	public BaseEntity.TraitFlag Traits;

	[NonSerialized]
	public ItemSkinDirectory.Skin[] skins;

	[NonSerialized]
	private Inventory.Definition[] _skins2;

	[Tooltip("Panel to show in the inventory menu when selected")]
	public GameObject panel;

	[NonSerialized]
	public ItemDefinition[] Children = new ItemDefinition[0];

	public Inventory.Definition[] skins2
	{
		get
		{
			if (_skins2 != null)
			{
				return _skins2;
			}
			if (Global.SteamServer != null && Global.SteamServer.Inventory.Definitions != null)
			{
				string prefabname = base.name;
				_skins2 = Global.SteamServer.Inventory.Definitions.Where((Inventory.Definition x) => (x.GetStringProperty("itemshortname") == shortname || x.GetStringProperty("itemshortname") == prefabname) && !string.IsNullOrEmpty(x.GetStringProperty("workshopdownload"))).ToArray();
			}
			return _skins2;
		}
	}

	public ItemBlueprint Blueprint => GetComponent<ItemBlueprint>();

	public bool isWearable { get; private set; }

	public bool isHoldable { get; private set; }

	public bool isUsable { get; private set; }

	public bool HasSkins
	{
		get
		{
			if (skins2 != null && skins2.Length > 0)
			{
				return true;
			}
			if (skins != null && skins.Length > 0)
			{
				return true;
			}
			return false;
		}
	}

	public bool CraftableWithSkin { get; private set; }

	public bool HasFlag(Flag f)
	{
		return (flags & f) == f;
	}

	public void Initialize(List<ItemDefinition> itemList)
	{
		if (itemMods != null)
		{
			Debug.LogError("Item Definition Initializing twice: " + base.name);
		}
		skins = ItemSkinDirectory.ForItem(this);
		itemMods = GetComponentsInChildren<ItemMod>(includeInactive: true);
		ItemMod[] array = itemMods;
		foreach (ItemMod itemMod in array)
		{
			itemMod.ModInit();
		}
		Children = itemList.Where((ItemDefinition x) => x.Parent == this).ToArray();
		isWearable = GetComponent<ItemModWearable>() != null;
		isHoldable = GetComponent<ItemModEntity>() != null;
		isUsable = GetComponent<ItemModEntity>() != null || GetComponent<ItemModConsume>() != null;
	}
}
