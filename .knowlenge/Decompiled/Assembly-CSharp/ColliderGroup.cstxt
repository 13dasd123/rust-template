using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ColliderGroup : Pool.IPooled
{
	public bool Invalidated;

	public bool NeedsRefresh;

	public bool Processing;

	public bool Preserving;

	public ListHashSet<ColliderBatch> Colliders = new ListHashSet<ColliderBatch>();

	public List<ColliderBatch> TempColliders = new List<ColliderBatch>();

	public List<MeshColliderBatch> Batches = new List<MeshColliderBatch>();

	public List<MeshColliderBatch> TempBatches = new List<MeshColliderBatch>();

	public List<MeshColliderInstance> TempInstances = new List<MeshColliderInstance>();

	private ColliderGrid grid;

	private ColliderCell cell;

	private ColliderKey key;

	private Action updateData;

	private Action refreshBatches;

	public float Size => grid.CellSize;

	public Vector3 Position => cell.position;

	public int Count => Colliders.Count;

	public void Initialize(ColliderGrid grid, ColliderCell cell, ColliderKey key)
	{
		this.grid = grid;
		this.cell = cell;
		this.key = key;
	}

	public void EnterPool()
	{
		Invalidated = false;
		NeedsRefresh = false;
		Processing = false;
		Preserving = false;
		Colliders.Clear();
		TempColliders.Clear();
		Batches.Clear();
		TempBatches.Clear();
		TempInstances.Clear();
		grid = null;
		cell = null;
		key = default(ColliderKey);
	}

	public void LeavePool()
	{
	}

	public void Add(ColliderBatch collider)
	{
		Colliders.Add(collider);
		NeedsRefresh = true;
	}

	public void Remove(ColliderBatch collider)
	{
		Colliders.Remove(collider);
		NeedsRefresh = true;
	}

	public void Invalidate()
	{
		if (!Invalidated)
		{
			for (int i = 0; i < Batches.Count; i++)
			{
				Batches[i].Invalidate();
			}
			Invalidated = true;
		}
		cell.interrupt = true;
	}

	public void Add(MeshColliderInstance instance)
	{
		TempInstances.Add(instance);
	}

	public void UpdateData()
	{
		TempInstances.Clear();
		for (int i = 0; i < TempColliders.Count; i++)
		{
			if (cell.interrupt)
			{
				break;
			}
			TempColliders[i].AddBatch(this);
		}
	}

	public void CreateBatches()
	{
		if (TempInstances.Count == 0)
		{
			return;
		}
		MeshColliderBatch meshColliderBatch = CreateBatch();
		for (int i = 0; i < TempInstances.Count; i++)
		{
			MeshColliderInstance instance = TempInstances[i];
			if (meshColliderBatch.AvailableVertices < instance.mesh.vertexCount)
			{
				meshColliderBatch = CreateBatch();
			}
			meshColliderBatch.Add(instance);
		}
		TempInstances.Clear();
	}

	public void RefreshBatches()
	{
		for (int i = 0; i < TempBatches.Count; i++)
		{
			if (cell.interrupt)
			{
				break;
			}
			TempBatches[i].Refresh();
		}
	}

	public void ApplyBatches()
	{
		for (int i = 0; i < TempBatches.Count; i++)
		{
			if (cell.interrupt)
			{
				break;
			}
			TempBatches[i].Apply();
		}
	}

	public void DisplayBatches()
	{
		for (int i = 0; i < TempBatches.Count; i++)
		{
			if (cell.interrupt)
			{
				break;
			}
			TempBatches[i].Display();
		}
	}

	public IEnumerator UpdateDataAsync()
	{
		if (updateData == null)
		{
			updateData = UpdateData;
		}
		return Parallel.Coroutine(updateData);
	}

	public IEnumerator RefreshBatchesAsync()
	{
		if (refreshBatches == null)
		{
			refreshBatches = RefreshBatches;
		}
		return Parallel.Coroutine(refreshBatches);
	}

	public void Start()
	{
		if (NeedsRefresh)
		{
			Processing = true;
			TempColliders.Clear();
			TempColliders.AddRange(Colliders.Values);
			NeedsRefresh = false;
		}
		else
		{
			Preserving = true;
		}
	}

	public void End()
	{
		if (Processing)
		{
			if (!cell.interrupt)
			{
				Clear();
				for (int i = 0; i < TempBatches.Count; i++)
				{
					TempBatches[i].Free();
				}
				List<MeshColliderBatch> batches = Batches;
				Batches = TempBatches;
				TempBatches = batches;
				Invalidated = false;
			}
			else
			{
				Cancel();
			}
			TempColliders.Clear();
			Processing = false;
		}
		else
		{
			Preserving = false;
		}
	}

	public void Clear()
	{
		for (int i = 0; i < Batches.Count; i++)
		{
			grid.RecycleInstance(Batches[i]);
		}
		Batches.Clear();
	}

	public void Cancel()
	{
		for (int i = 0; i < TempBatches.Count; i++)
		{
			grid.RecycleInstance(TempBatches[i]);
		}
		TempBatches.Clear();
	}

	public int MeshCount()
	{
		int num = 0;
		for (int i = 0; i < Batches.Count; i++)
		{
			num += Batches[i].Count;
		}
		return num;
	}

	public int BatchedMeshCount()
	{
		int num = 0;
		for (int i = 0; i < Batches.Count; i++)
		{
			num += Batches[i].BatchedCount;
		}
		return num;
	}

	public MeshColliderBatch CreateBatch()
	{
		MeshColliderBatch meshColliderBatch = grid.CreateInstance();
		meshColliderBatch.Setup(cell.position, key.layer, key.material);
		meshColliderBatch.Alloc();
		TempBatches.Add(meshColliderBatch);
		return meshColliderBatch;
	}
}
