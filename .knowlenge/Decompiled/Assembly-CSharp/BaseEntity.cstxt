#define UNITY_ASSERTIONS
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Network;
using ProtoBuf;
using Rust;
using Rust.Ai;
using Spatial;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseEntity : BaseNetworkable
{
	public class Menu : Attribute
	{
		[Serializable]
		public struct Option
		{
			public Translate.Phrase name;

			public Translate.Phrase description;

			public Sprite icon;

			public int order;
		}

		public class Description : Attribute
		{
			public string token;

			public string english;

			public Description(string t, string e)
			{
				token = t;
				english = e;
			}
		}

		public class Icon : Attribute
		{
			public string icon;

			public Icon(string i)
			{
				icon = i;
			}
		}

		public class ShowIf : Attribute
		{
			public string functionName;

			public ShowIf(string testFunc)
			{
				functionName = testFunc;
			}
		}

		public string TitleToken;

		public string TitleEnglish;

		public string UseVariable;

		public int Order;

		public string ProxyFunction;

		public float Time;

		public string OnStart;

		public string OnProgress;

		public Menu()
		{
		}

		public Menu(string menuTitleToken, string menuTitleEnglish)
		{
			TitleToken = menuTitleToken;
			TitleEnglish = menuTitleEnglish;
		}
	}

	[Serializable]
	public struct MovementModify
	{
		public float drag;
	}

	public enum GiveItemReason
	{
		Generic,
		ResourceHarvested,
		PickedUp,
		Crafted
	}

	[Flags]
	public enum Flags
	{
		Placeholder = 1,
		On = 2,
		OnFire = 4,
		Open = 8,
		Locked = 0x10,
		Debugging = 0x20,
		Disabled = 0x40,
		Reserved1 = 0x80,
		Reserved2 = 0x100,
		Reserved3 = 0x200,
		Reserved4 = 0x400,
		Reserved5 = 0x800,
		Broken = 0x1000,
		Busy = 0x2000,
		Reserved6 = 0x4000,
		Reserved7 = 0x8000,
		Reserved8 = 0x10000
	}

	public static class Query
	{
		public class EntityTree
		{
			private Grid<BaseEntity> Grid;

			private Grid<BasePlayer> PlayerGrid;

			public EntityTree(float worldSize)
			{
				Grid = new Grid<BaseEntity>(32, worldSize);
				PlayerGrid = new Grid<BasePlayer>(32, worldSize);
			}

			public void Add(BaseEntity ent)
			{
				Vector3 localPosition = ent.transform.localPosition;
				Grid.Add(ent, localPosition.x, localPosition.z);
			}

			public void AddPlayer(BasePlayer player)
			{
				Vector3 localPosition = player.transform.localPosition;
				PlayerGrid.Add(player, localPosition.x, localPosition.z);
			}

			public void Remove(BaseEntity ent, bool isPlayer = false)
			{
				Grid.Remove(ent);
				if (isPlayer)
				{
					BasePlayer basePlayer = ent as BasePlayer;
					if (basePlayer != null)
					{
						PlayerGrid.Remove(basePlayer);
					}
				}
			}

			public void RemovePlayer(BasePlayer player)
			{
				PlayerGrid.Remove(player);
			}

			public void Move(BaseEntity ent)
			{
				Vector3 localPosition = ent.transform.localPosition;
				Grid.Move(ent, localPosition.x, localPosition.z);
				BasePlayer basePlayer = ent as BasePlayer;
				if (basePlayer != null)
				{
					MovePlayer(basePlayer);
				}
			}

			public void MovePlayer(BasePlayer player)
			{
				Vector3 localPosition = player.transform.localPosition;
				PlayerGrid.Move(player, localPosition.x, localPosition.z);
			}

			public int GetInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
			{
				return Grid.Query(position.x, position.z, distance, results, filter);
			}

			public int GetPlayersInSphere(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
			{
				return PlayerGrid.Query(position.x, position.z, distance, results, filter);
			}
		}

		public static EntityTree Server;
	}

	public class RPC_Shared : Attribute
	{
	}

	public struct RPCMessage
	{
		public Connection connection;

		public BasePlayer player;

		public Read read;
	}

	public class RPC_Server : RPC_Shared
	{
		public abstract class Conditional : Attribute
		{
			public virtual string GetArgs()
			{
				return null;
			}
		}

		public class MaxDistance : Conditional
		{
			private float maximumDistance;

			public MaxDistance(float maxDist)
			{
				maximumDistance = maxDist;
			}

			public override string GetArgs()
			{
				return maximumDistance.ToString("0.00f");
			}

			public static bool Test(string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				return ent.Distance(player.eyes.position) <= maximumDistance;
			}
		}

		public class IsVisible : Conditional
		{
			private float maximumDistance;

			public IsVisible(float maxDist)
			{
				maximumDistance = maxDist;
			}

			public override string GetArgs()
			{
				return maximumDistance.ToString("0.00f");
			}

			public static bool Test(string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				return ent.IsVisible(player.eyes.HeadRay(), maximumDistance) || ent.IsVisible(player.eyes.position);
			}
		}

		public class FromOwner : Conditional
		{
			public static bool Test(string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				return true;
			}
		}

		public class IsActiveItem : Conditional
		{
			public static bool Test(string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				Item activeItem = player.GetActiveItem();
				if (activeItem == null)
				{
					return false;
				}
				if (activeItem.GetHeldEntity() != ent)
				{
					return false;
				}
				return true;
			}
		}
	}

	public enum Signal
	{
		Attack,
		Alt_Attack,
		DryFire,
		Reload,
		Deploy,
		Flinch_Head,
		Flinch_Chest,
		Flinch_Stomach,
		Flinch_RearHead,
		Flinch_RearTorso,
		Throw,
		Relax,
		Gesture,
		PhysImpact,
		Eat,
		Startled
	}

	public enum Slot
	{
		Lock,
		FireMod,
		UpperModifier,
		MiddleModifier,
		LowerModifier,
		CenterDecoration,
		Count
	}

	[Flags]
	public enum TraitFlag
	{
		None = 0,
		Alive = 1,
		Animal = 2,
		Human = 4,
		Interesting = 8,
		Food = 0x10,
		Meat = 0x20,
		Water = 0x20
	}

	public static class Util
	{
		public static BaseEntity[] FindTargets(string strFilter, bool onlyPlayers)
		{
			return (from x in BaseNetworkable.serverEntities.Where(delegate(BaseNetworkable x)
				{
					if (x is BasePlayer)
					{
						BasePlayer basePlayer = x as BasePlayer;
						if (string.IsNullOrEmpty(strFilter))
						{
							return true;
						}
						if (strFilter == "!alive" && basePlayer.IsAlive())
						{
							return true;
						}
						if (strFilter == "!sleeping" && basePlayer.IsSleeping())
						{
							return true;
						}
						if (strFilter[0] != '!' && !StringEx.Contains(basePlayer.displayName, strFilter, CompareOptions.IgnoreCase) && !basePlayer.UserIDString.Contains(strFilter))
						{
							return false;
						}
						return true;
					}
					if (onlyPlayers)
					{
						return false;
					}
					if (string.IsNullOrEmpty(strFilter))
					{
						return false;
					}
					return x.ShortPrefabName.Contains(strFilter) ? true : false;
				})
				select x as BaseEntity).ToArray();
		}
	}

	[Header("BaseEntity")]
	public Bounds bounds;

	public GameObjectRef impactEffect;

	public bool enableSaving = true;

	public bool syncPosition;

	public Model model;

	[InspectorFlags]
	public Flags flags;

	[NonSerialized]
	public uint parentBone;

	[NonSerialized]
	public ulong skinID;

	private EntityComponentBase[] _components;

	[NonSerialized]
	public string _name;

	private static Queue<BaseEntity> globalBroadcastQueue = new Queue<BaseEntity>();

	private static uint globalBroadcastProtocol = 0u;

	private uint broadcastProtocol;

	private List<EntityLink> links = new List<EntityLink>();

	private bool linkedToNeighbours;

	[NonSerialized]
	public EntityRef parentEntity;

	private Spawnable _spawnable;

	public static HashSet<BaseEntity> saveList = new HashSet<BaseEntity>();

	[NonSerialized]
	public BaseEntity creatorEntity;

	private int doneMovingWithoutARigidBodyCheck = 1;

	private bool isCallingUpdateNetworkGroup;

	private EntityRef[] entitySlots = new EntityRef[6];

	protected List<TriggerBase> triggers;

	protected bool isVisible = true;

	protected bool isAnimatorVisible = true;

	protected bool isShadowVisible = true;

	protected OccludeeSphere localOccludee = new OccludeeSphere(-1);

	public EntityComponentBase[] Components => _components ?? (_components = GetComponentsInChildren<EntityComponentBase>(includeInactive: true));

	public ulong OwnerID { get; set; }

	protected virtual float PositionTickRate => 0.1f;

	public virtual Vector3 ServerPosition
	{
		get
		{
			return base.transform.localPosition;
		}
		set
		{
			if (!(base.transform.localPosition == value))
			{
				base.transform.localPosition = value;
				base.transform.hasChanged = true;
			}
		}
	}

	public virtual Quaternion ServerRotation
	{
		get
		{
			return base.transform.localRotation;
		}
		set
		{
			if (!(base.transform.localRotation == value))
			{
				base.transform.localRotation = value;
				base.transform.hasChanged = true;
			}
		}
	}

	public float radiationLevel
	{
		get
		{
			if (triggers == null)
			{
				return 0f;
			}
			float num = 0f;
			for (int i = 0; i < triggers.Count; i++)
			{
				TriggerRadiation triggerRadiation = triggers[i] as TriggerRadiation;
				if (!(triggerRadiation == null))
				{
					num = Mathf.Max(num, triggerRadiation.GetRadiation(GetNetworkPosition(), RadiationProtection()));
				}
			}
			return num;
		}
	}

	public float currentTemperature
	{
		get
		{
			float num = Climate.GetTemperature(base.transform.position);
			if (triggers == null)
			{
				return num;
			}
			for (int i = 0; i < triggers.Count; i++)
			{
				TriggerTemperature triggerTemperature = triggers[i] as TriggerTemperature;
				if (!(triggerTemperature == null))
				{
					num = triggerTemperature.WorkoutTemperature(GetNetworkPosition(), num);
				}
			}
			return num;
		}
	}

	public virtual TraitFlag Traits => TraitFlag.None;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("BaseEntity.OnRpcMessage"))
		{
			if (rpc == 555001694 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - BroadcastSignalFromClient "));
				}
				using (TimeWarning.New("BroadcastSignalFromClient"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.FromOwner.Test("BroadcastSignalFromClient", this, player))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BroadcastSignalFromClient(msg2);
						}
					}
					catch (Exception exception)
					{
						player.Kick("RPC Error in BroadcastSignalFromClient");
						Debug.LogException(exception);
					}
				}
				return true;
			}
			if (rpc == 2257057967u && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - SV_RequestFile "));
				}
				using (TimeWarning.New("SV_RequestFile"))
				{
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SV_RequestFile(msg3);
						}
					}
					catch (Exception exception2)
					{
						player.Kick("RPC Error in SV_RequestFile");
						Debug.LogException(exception2);
					}
				}
				return true;
			}
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		throw new NotImplementedException();
	}

	protected void ReceiveCollisionMessages(bool b)
	{
		if (b)
		{
			base.gameObject.transform.GetOrAddComponent<EntityCollisionMessage>();
		}
		else
		{
			UnityEngine.TransformEx.RemoveComponent<EntityCollisionMessage>(base.gameObject.transform);
		}
	}

	public virtual BasePlayer ToPlayer()
	{
		return null;
	}

	public override void InitShared()
	{
		base.InitShared();
		InitEntityLinks();
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		FreeEntityLinks();
	}

	public override void ResetState()
	{
		base.ResetState();
		parentBone = 0u;
		OwnerID = 0uL;
		flags = (Flags)0;
		parentEntity = default(EntityRef);
		_spawnable = null;
	}

	public OBB WorldSpaceBounds()
	{
		return new OBB(GetEstimatedWorldPosition(), base.transform.lossyScale, GetEstimatedWorldRotation(), bounds);
	}

	public Vector3 PivotPoint()
	{
		return GetEstimatedWorldPosition();
	}

	public Vector3 CenterPoint()
	{
		return WorldSpaceBounds().position;
	}

	public Vector3 ClosestPoint(Vector3 position)
	{
		return WorldSpaceBounds().ClosestPoint(position);
	}

	public float Distance(Vector3 position)
	{
		return (ClosestPoint(position) - position).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		return (ClosestPoint(position) - position).sqrMagnitude;
	}

	public float Distance(BaseEntity other)
	{
		return Distance(other.GetEstimatedWorldPosition());
	}

	public float SqrDistance(BaseEntity other)
	{
		return SqrDistance(other.GetEstimatedWorldPosition());
	}

	public float Distance2D(Vector3 position)
	{
		return (ClosestPoint(position) - position).Magnitude2D();
	}

	public float SqrDistance2D(Vector3 position)
	{
		return (ClosestPoint(position) - position).SqrMagnitude2D();
	}

	public float Distance2D(BaseEntity other)
	{
		return Distance(other.GetEstimatedWorldPosition());
	}

	public float SqrDistance2D(BaseEntity other)
	{
		return SqrDistance(other.GetEstimatedWorldPosition());
	}

	public bool IsVisible(Ray ray, float maxDistance)
	{
		if (ray.origin.IsNaNOrInfinity())
		{
			return false;
		}
		if (ray.direction.IsNaNOrInfinity())
		{
			return false;
		}
		if (ray.direction == Vector3.zero)
		{
			return false;
		}
		if (!WorldSpaceBounds().Trace(ray, out var hit, maxDistance))
		{
			return false;
		}
		if (UnityEngine.Physics.Raycast(ray, out var hitInfo, maxDistance, 1075904513))
		{
			if (RaycastHitEx.GetEntity(hitInfo) == this)
			{
				return true;
			}
			if (hitInfo.distance <= hit.distance)
			{
				return false;
			}
		}
		return true;
	}

	public bool IsVisible(Vector3 position, Vector3 target)
	{
		Vector3 vector = target - position;
		float magnitude = vector.magnitude;
		if (magnitude < Mathf.Epsilon)
		{
			return true;
		}
		Vector3 vector2 = vector / magnitude;
		Vector3 vector3 = vector2 * Mathf.Min(magnitude, 0.01f);
		return IsVisible(new Ray(position + vector3, vector2), magnitude);
	}

	public bool IsVisible(Vector3 position)
	{
		return IsVisible(position, CenterPoint()) || IsVisible(position, ClosestPoint(position));
	}

	public bool IsOlderThan(BaseEntity other)
	{
		if (other == null)
		{
			return true;
		}
		uint num = ((net != null) ? net.ID : 0u);
		uint num2 = ((other.net != null) ? other.net.ID : 0u);
		return num < num2;
	}

	public virtual bool IsOutside()
	{
		OBB oBB = WorldSpaceBounds();
		Vector3 position = oBB.position + oBB.up * oBB.extents.y;
		return IsOutside(position);
	}

	public bool IsOutside(Vector3 position)
	{
		return !UnityEngine.Physics.Raycast(position, Vector3.up, 100f, 1101070337);
	}

	public float WaterFactor()
	{
		return WaterLevel.Factor(WorldSpaceBounds().ToBounds());
	}

	public virtual float Health()
	{
		return 0f;
	}

	public virtual float MaxHealth()
	{
		return 0f;
	}

	public virtual float MaxVelocity()
	{
		return 0f;
	}

	public virtual float BoundsPadding()
	{
		return 0.1f;
	}

	public virtual float PenetrationResistance(HitInfo info)
	{
		return 1f;
	}

	public virtual GameObjectRef GetImpactEffect(HitInfo info)
	{
		return impactEffect;
	}

	public virtual void OnAttacked(HitInfo info)
	{
	}

	public virtual Item GetItem()
	{
		return null;
	}

	public virtual Item GetItem(uint itemId)
	{
		return null;
	}

	public virtual void GiveItem(Item item, GiveItemReason reason = GiveItemReason.Generic)
	{
		item.Remove();
	}

	public virtual bool CanBeLooted(BasePlayer player)
	{
		return true;
	}

	public virtual BaseEntity GetEntity()
	{
		return this;
	}

	public override string ToString()
	{
		if (_name == null)
		{
			if (base.isServer)
			{
				_name = string.Format("{1}[{0}]", (net != null) ? net.ID : 0u, base.ShortPrefabName);
			}
			else
			{
				_name = base.ShortPrefabName;
			}
		}
		return _name;
	}

	public virtual string Categorize()
	{
		return "entity";
	}

	public void Log(string str)
	{
		if (base.isClient)
		{
			Debug.Log("<color=#ffa>[" + ToString() + "] " + str + "</color>", base.gameObject);
		}
		else
		{
			Debug.Log("<color=#aff>[" + ToString() + "] " + str + "</color>", base.gameObject);
		}
	}

	public void SetModel(Model mdl)
	{
		if (!(model == mdl))
		{
			model = mdl;
		}
	}

	public void SwitchToFastPhysics()
	{
		Rigidbody component = base.gameObject.GetComponent<Rigidbody>();
		if ((bool)component)
		{
			component.collisionDetectionMode = CollisionDetectionMode.Discrete;
		}
	}

	public virtual bool ShouldBlockProjectiles()
	{
		return true;
	}

	public virtual void DebugServer(int rep, float time)
	{
		DebugText(base.transform.position + Vector3.up * 1f, $"{((net != null) ? net.ID : 0u)}: {base.name}\n{DebugText()}", Color.white, time);
	}

	public virtual string DebugText()
	{
		return string.Empty;
	}

	public void OnDebugStart()
	{
		EntityDebug entityDebug = base.gameObject.GetComponent<EntityDebug>();
		if (entityDebug == null)
		{
			entityDebug = base.gameObject.AddComponent<EntityDebug>();
		}
		entityDebug.enabled = true;
	}

	protected void DebugText(Vector3 pos, string str, Color color, float time)
	{
		if (base.isServer)
		{
			ConsoleNetwork.BroadcastToAllClients("ddraw.text", time, color, pos, str);
		}
	}

	public bool HasFlag(Flags f)
	{
		return (flags & f) == f;
	}

	public bool ParentHasFlag(Flags f)
	{
		BaseEntity baseEntity = GetParentEntity();
		if (baseEntity == null)
		{
			return false;
		}
		return baseEntity.HasFlag(f);
	}

	public void SetFlag(Flags f, bool b, bool recursive = false)
	{
		Flags old = flags;
		if (b)
		{
			if (HasFlag(f))
			{
				return;
			}
			flags |= f;
		}
		else
		{
			if (!HasFlag(f))
			{
				return;
			}
			flags &= ~f;
		}
		OnFlagsChanged(old, flags);
		SendNetworkUpdate();
		if (recursive && children != null)
		{
			for (int i = 0; i < children.Count; i++)
			{
				children[i].SetFlag(f, b, recursive: true);
			}
		}
	}

	public bool IsOn()
	{
		return HasFlag(Flags.On);
	}

	public bool IsOpen()
	{
		return HasFlag(Flags.Open);
	}

	public bool IsOnFire()
	{
		return HasFlag(Flags.OnFire);
	}

	public bool IsLocked()
	{
		return HasFlag(Flags.Locked);
	}

	public override bool IsDebugging()
	{
		return HasFlag(Flags.Debugging);
	}

	public bool IsDisabled()
	{
		return HasFlag(Flags.Disabled) || ParentHasFlag(Flags.Disabled);
	}

	public bool IsBroken()
	{
		return HasFlag(Flags.Broken);
	}

	public bool IsBusy()
	{
		return HasFlag(Flags.Busy);
	}

	public override string GetLogColor()
	{
		if (base.isServer)
		{
			return "cyan";
		}
		return "yellow";
	}

	public virtual void OnFlagsChanged(Flags old, Flags next)
	{
		if (IsDebugging() && (old & Flags.Debugging) != (next & Flags.Debugging))
		{
			OnDebugStart();
		}
	}

	public bool IsOccupied(Socket_Base socket)
	{
		return FindLink(socket)?.IsOccupied() ?? false;
	}

	public bool IsOccupied(string socketName)
	{
		return FindLink(socketName)?.IsOccupied() ?? false;
	}

	public EntityLink FindLink(Socket_Base socket)
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			if (entityLinks[i].socket == socket)
			{
				return entityLinks[i];
			}
		}
		return null;
	}

	public EntityLink FindLink(string socketName)
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			if (entityLinks[i].socket.socketName == socketName)
			{
				return entityLinks[i];
			}
		}
		return null;
	}

	public T FindLinkedEntity<T>() where T : BaseEntity
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				EntityLink entityLink2 = entityLink.connections[j];
				if (entityLink2.owner is T)
				{
					return entityLink2.owner as T;
				}
			}
		}
		return (T)null;
	}

	public void EntityLinkMessage<T>(Action<T> action) where T : BaseEntity
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				EntityLink entityLink2 = entityLink.connections[j];
				if (entityLink2.owner is T)
				{
					action(entityLink2.owner as T);
				}
			}
		}
	}

	public void EntityLinkBroadcast<T>(Action<T> action) where T : BaseEntity
	{
		globalBroadcastProtocol++;
		globalBroadcastQueue.Clear();
		broadcastProtocol = globalBroadcastProtocol;
		globalBroadcastQueue.Enqueue(this);
		if (this is T)
		{
			action(this as T);
		}
		while (globalBroadcastQueue.Count > 0)
		{
			BaseEntity baseEntity = globalBroadcastQueue.Dequeue();
			List<EntityLink> entityLinks = baseEntity.GetEntityLinks();
			for (int i = 0; i < entityLinks.Count; i++)
			{
				EntityLink entityLink = entityLinks[i];
				for (int j = 0; j < entityLink.connections.Count; j++)
				{
					BaseEntity owner = entityLink.connections[j].owner;
					if (owner.broadcastProtocol != globalBroadcastProtocol)
					{
						owner.broadcastProtocol = globalBroadcastProtocol;
						globalBroadcastQueue.Enqueue(owner);
						if (owner is T)
						{
							action(owner as T);
						}
					}
				}
			}
		}
	}

	public void EntityLinkBroadcast()
	{
		globalBroadcastProtocol++;
		globalBroadcastQueue.Clear();
		broadcastProtocol = globalBroadcastProtocol;
		globalBroadcastQueue.Enqueue(this);
		while (globalBroadcastQueue.Count > 0)
		{
			BaseEntity baseEntity = globalBroadcastQueue.Dequeue();
			List<EntityLink> entityLinks = baseEntity.GetEntityLinks();
			for (int i = 0; i < entityLinks.Count; i++)
			{
				EntityLink entityLink = entityLinks[i];
				for (int j = 0; j < entityLink.connections.Count; j++)
				{
					BaseEntity owner = entityLink.connections[j].owner;
					if (owner.broadcastProtocol != globalBroadcastProtocol)
					{
						owner.broadcastProtocol = globalBroadcastProtocol;
						globalBroadcastQueue.Enqueue(owner);
					}
				}
			}
		}
	}

	public bool ReceivedEntityLinkBroadcast()
	{
		return broadcastProtocol == globalBroadcastProtocol;
	}

	public List<EntityLink> GetEntityLinks(bool linkToNeighbours = true)
	{
		if (Rust.Application.isLoadingSave)
		{
			return links;
		}
		if (!linkedToNeighbours && linkToNeighbours)
		{
			LinkToNeighbours();
		}
		return links;
	}

	private void LinkToEntity(BaseEntity other)
	{
		if (this == other || links.Count == 0 || other.links.Count == 0)
		{
			return;
		}
		using (TimeWarning.New("LinkToEntity"))
		{
			for (int i = 0; i < links.Count; i++)
			{
				EntityLink entityLink = links[i];
				for (int j = 0; j < other.links.Count; j++)
				{
					EntityLink entityLink2 = other.links[j];
					if (entityLink.CanConnect(entityLink2))
					{
						if (!entityLink.Contains(entityLink2))
						{
							entityLink.Add(entityLink2);
						}
						if (!entityLink2.Contains(entityLink))
						{
							entityLink2.Add(entityLink);
						}
					}
				}
			}
		}
	}

	private void LinkToNeighbours()
	{
		if (links.Count == 0)
		{
			return;
		}
		linkedToNeighbours = true;
		using (TimeWarning.New("LinkToNeighbours"))
		{
			List<BaseEntity> obj = Facepunch.Pool.GetList<BaseEntity>();
			OBB oBB = WorldSpaceBounds();
			Vis.Entities(oBB.position, oBB.extents.magnitude + 1f, obj);
			for (int i = 0; i < obj.Count; i++)
			{
				BaseEntity baseEntity = obj[i];
				if (baseEntity.isServer == base.isServer)
				{
					LinkToEntity(baseEntity);
				}
			}
			Facepunch.Pool.FreeList(ref obj);
		}
	}

	private void InitEntityLinks()
	{
		using (TimeWarning.New("InitEntityLinks"))
		{
			if (base.isServer)
			{
				links.AddLinks(this, PrefabAttribute.server.FindAll<Socket_Base>(prefabID));
			}
		}
	}

	private void FreeEntityLinks()
	{
		links.FreeLinks();
		linkedToNeighbours = false;
	}

	public void RefreshEntityLinks()
	{
		links.ClearLinks();
		LinkToNeighbours();
	}

	[RPC_Server]
	public void SV_RequestFile(RPCMessage msg)
	{
		uint num = msg.read.UInt32();
		FileStorage.Type type = (FileStorage.Type)msg.read.UInt8();
		string funcName = StringPool.Get(msg.read.UInt32());
		byte[] array = FileStorage.server.Get(num, type, net.ID);
		if (array != null)
		{
			ClientRPCEx(new SendInfo(msg.connection)
			{
				channel = 2,
				method = SendMethod.Reliable
			}, null, funcName, num, (uint)array.Length, array);
		}
	}

	public BaseEntity GetParentEntity()
	{
		return parentEntity.Get(base.isServer);
	}

	public void SetParent(BaseEntity entity, string strBone)
	{
		SetParent(entity, (!string.IsNullOrEmpty(strBone)) ? StringPool.Get(strBone) : 0u);
	}

	public bool HasChild(BaseEntity c)
	{
		if (c == this)
		{
			return true;
		}
		BaseEntity baseEntity = c.GetParentEntity();
		if (baseEntity != null)
		{
			return HasChild(baseEntity);
		}
		return false;
	}

	public bool HasParent()
	{
		return parentEntity.IsValid(base.isServer);
	}

	public void SetParent(BaseEntity entity, uint boneID = 0u)
	{
		if (entity != null)
		{
			if (entity == this)
			{
				Debug.LogError("Trying to parent to self " + this, base.gameObject);
				return;
			}
			if (HasChild(entity))
			{
				Debug.LogError("Trying to parent to child " + this, base.gameObject);
				return;
			}
		}
		LogEntry(LogEntryType.Hierarchy, 2, "SetParent {0} {1}", entity, boneID);
		BaseEntity baseEntity = GetParentEntity();
		if ((bool)baseEntity)
		{
			baseEntity.RemoveChild(this);
		}
		if (base.limitNetworking && baseEntity != null && baseEntity != entity)
		{
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if (basePlayer.IsValid())
			{
				DestroyOnClient(basePlayer.net.connection);
			}
		}
		if (entity == null)
		{
			if (parentEntity.IsValid(base.isServer))
			{
				parentEntity.Set(null);
				base.transform.SetParent(null, worldPositionStays: false);
				parentBone = 0u;
				UpdateNetworkGroup();
				SendNetworkUpdate();
				SendChildrenNetworkUpdate();
			}
		}
		else
		{
			Debug.Assert(entity.isServer, "SetParent - child should be a SERVER entity");
			Debug.Assert(entity.net != null, "Setting parent to entity that hasn't spawned yet! (net is null)");
			Debug.Assert(entity.net.ID != 0, "Setting parent to entity that hasn't spawned yet! (id = 0)");
			entity.AddChild(this);
			parentEntity.Set(entity);
			base.transform.SetParent(entity.transform, worldPositionStays: false);
			parentBone = boneID;
			UpdateNetworkGroup();
			SendNetworkUpdate();
			SendChildrenNetworkUpdate();
		}
	}

	private void DestroyOnClient(Connection connection)
	{
		if (children != null)
		{
			foreach (BaseEntity child in children)
			{
				child.DestroyOnClient(connection);
			}
		}
		if (Network.Net.sv.IsConnected() && Network.Net.sv.write.Start())
		{
			Network.Net.sv.write.PacketID(Message.Type.EntityDestroy);
			Network.Net.sv.write.EntityID(net.ID);
			Network.Net.sv.write.UInt8(0);
			Network.Net.sv.write.Send(new SendInfo(connection));
			LogEntry(LogEntryType.Network, 2, "EntityDestroy");
		}
	}

	private void SendChildrenNetworkUpdate()
	{
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.UpdateNetworkGroup();
			child.SendNetworkUpdate();
		}
	}

	public virtual void ParentBecoming(BaseEntity ent)
	{
		Log("ParentBecoming Missed " + ent);
	}

	public Vector3 GetEstimatedWorldPosition()
	{
		return base.transform.position;
	}

	public Quaternion GetEstimatedWorldRotation()
	{
		return base.transform.rotation;
	}

	public virtual BuildingPrivlidge GetBuildingPrivilege()
	{
		return GetBuildingPrivilege(WorldSpaceBounds());
	}

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
	{
		BuildingBlock other = null;
		BuildingPrivlidge result = null;
		List<BuildingBlock> obj = Facepunch.Pool.GetList<BuildingBlock>();
		Vis.Entities(obb.position, 16f + obb.extents.magnitude, obj, 2097152);
		for (int i = 0; i < obj.Count; i++)
		{
			BuildingBlock buildingBlock = obj[i];
			if (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) > 16f)
			{
				continue;
			}
			BuildingManager.Building building = buildingBlock.GetBuilding();
			if (building != null)
			{
				BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
				if (!(dominatingBuildingPrivilege == null))
				{
					other = buildingBlock;
					result = dominatingBuildingPrivilege;
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj);
		return result;
	}

	public void SV_RPCMessage(uint nameID, Message message)
	{
		Assert.IsTrue(base.isServer, "Should be server!");
		BasePlayer basePlayer = NetworkPacketEx.Player(message);
		if (!basePlayer.IsValid())
		{
			if (ConVar.Global.developer > 0)
			{
				Debug.Log("SV_RPCMessage: From invalid player " + basePlayer);
			}
		}
		else if (basePlayer.isStalled)
		{
			if (ConVar.Global.developer > 0)
			{
				Debug.Log("SV_RPCMessage: player is stalled " + basePlayer);
			}
		}
		else if (!OnRpcMessage(basePlayer, nameID, message))
		{
			for (int i = 0; i < Components.Length && !Components[i].OnRpcMessage(basePlayer, nameID, message); i++)
			{
			}
		}
	}

	public void ClientRPCPlayer<T1, T2, T3, T4, T5>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		if (Network.Net.sv.IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1, arg2, arg3, arg4, arg5);
		}
	}

	public void ClientRPCPlayer<T1, T2, T3, T4>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		if (Network.Net.sv.IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1, arg2, arg3, arg4);
		}
	}

	public void ClientRPCPlayer<T1, T2, T3>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3)
	{
		if (Network.Net.sv.IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1, arg2, arg3);
		}
	}

	public void ClientRPCPlayer<T1, T2>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2)
	{
		if (Network.Net.sv.IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1, arg2);
		}
	}

	public void ClientRPCPlayer<T1>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1)
	{
		if (Network.Net.sv.IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1);
		}
	}

	public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName)
	{
		if (Network.Net.sv.IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName);
		}
	}

	public void ClientRPC<T1, T2, T3, T4, T5>(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		if (Network.Net.sv.IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1, arg2, arg3, arg4, arg5);
		}
	}

	public void ClientRPC<T1, T2, T3, T4>(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		if (Network.Net.sv.IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1, arg2, arg3, arg4);
		}
	}

	public void ClientRPC<T1, T2, T3>(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
	{
		if (Network.Net.sv.IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1, arg2, arg3);
		}
	}

	public void ClientRPC<T1, T2>(Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
	{
		if (Network.Net.sv.IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1, arg2);
		}
	}

	public void ClientRPC<T1>(Connection sourceConnection, string funcName, T1 arg1)
	{
		if (Network.Net.sv.IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1);
		}
	}

	public void ClientRPC(Connection sourceConnection, string funcName)
	{
		if (Network.Net.sv.IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName);
		}
	}

	public void ClientRPCEx<T1, T2, T3, T4, T5>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		if (Network.Net.sv.IsConnected() && net != null && ClientRPCStart(sourceConnection, funcName))
		{
			ClientRPCWrite(arg1);
			ClientRPCWrite(arg2);
			ClientRPCWrite(arg3);
			ClientRPCWrite(arg4);
			ClientRPCWrite(arg5);
			ClientRPCSend(sendInfo);
		}
	}

	public void ClientRPCEx<T1, T2, T3, T4>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		if (Network.Net.sv.IsConnected() && net != null && ClientRPCStart(sourceConnection, funcName))
		{
			ClientRPCWrite(arg1);
			ClientRPCWrite(arg2);
			ClientRPCWrite(arg3);
			ClientRPCWrite(arg4);
			ClientRPCSend(sendInfo);
		}
	}

	public void ClientRPCEx<T1, T2, T3>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
	{
		if (Network.Net.sv.IsConnected() && net != null && ClientRPCStart(sourceConnection, funcName))
		{
			ClientRPCWrite(arg1);
			ClientRPCWrite(arg2);
			ClientRPCWrite(arg3);
			ClientRPCSend(sendInfo);
		}
	}

	public void ClientRPCEx<T1, T2>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
	{
		if (Network.Net.sv.IsConnected() && net != null && ClientRPCStart(sourceConnection, funcName))
		{
			ClientRPCWrite(arg1);
			ClientRPCWrite(arg2);
			ClientRPCSend(sendInfo);
		}
	}

	public void ClientRPCEx<T1>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1)
	{
		if (Network.Net.sv.IsConnected() && net != null && ClientRPCStart(sourceConnection, funcName))
		{
			ClientRPCWrite(arg1);
			ClientRPCSend(sendInfo);
		}
	}

	public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName)
	{
		if (Network.Net.sv.IsConnected() && net != null && ClientRPCStart(sourceConnection, funcName))
		{
			ClientRPCSend(sendInfo);
		}
	}

	private bool ClientRPCStart(Connection sourceConnection, string funcName)
	{
		if (Network.Net.sv.write.Start())
		{
			Network.Net.sv.write.PacketID(Message.Type.RPCMessage);
			Network.Net.sv.write.UInt32(net.ID);
			Network.Net.sv.write.UInt32(StringPool.Get(funcName));
			Network.Net.sv.write.UInt64(sourceConnection?.userid ?? 0);
			return true;
		}
		return false;
	}

	private void ClientRPCWrite<T>(T arg)
	{
		NetworkWriteEx.WriteObject(Network.Net.sv.write, arg);
	}

	private void ClientRPCSend(SendInfo sendInfo)
	{
		Network.Net.sv.write.Send(sendInfo);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseEntity = Facepunch.Pool.Get<ProtoBuf.BaseEntity>();
		if (info.forDisk)
		{
			info.msg.baseEntity.pos = base.transform.localPosition;
			info.msg.baseEntity.rot = base.transform.localRotation.eulerAngles;
		}
		else
		{
			info.msg.baseEntity.pos = GetNetworkPosition();
			info.msg.baseEntity.rot = GetNetworkRotation();
		}
		info.msg.baseEntity.flags = (int)flags;
		info.msg.baseEntity.skinid = skinID;
		if (parentEntity.IsValid(base.isServer))
		{
			info.msg.parent = Facepunch.Pool.Get<ParentInfo>();
			info.msg.parent.uid = parentEntity.uid;
			info.msg.parent.bone = parentBone;
		}
		if (HasAnySlot())
		{
			info.msg.entitySlots = Facepunch.Pool.Get<EntitySlots>();
			info.msg.entitySlots.slotLock = entitySlots[0].uid;
			info.msg.entitySlots.slotFireMod = entitySlots[1].uid;
			info.msg.entitySlots.slotUpperModification = entitySlots[2].uid;
			info.msg.entitySlots.centerDecoration = entitySlots[5].uid;
		}
		if (info.forDisk && (bool)_spawnable)
		{
			_spawnable.Save(info);
		}
		if (OwnerID != 0 && (info.forDisk || ShouldNetworkOwnerInfo()))
		{
			info.msg.ownerInfo = Facepunch.Pool.Get<OwnerInfo>();
			info.msg.ownerInfo.steamid = OwnerID;
		}
	}

	public virtual bool ShouldNetworkOwnerInfo()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseEntity != null)
		{
			ProtoBuf.BaseEntity baseEntity = info.msg.baseEntity;
			Flags old = flags;
			flags = (Flags)baseEntity.flags;
			OnFlagsChanged(old, flags);
			OnSkinChanged(skinID, info.msg.baseEntity.skinid);
			if (info.fromDisk)
			{
				if (baseEntity.pos.IsNaNOrInfinity())
				{
					Debug.LogWarning(ToString() + " has broken position - " + baseEntity.pos);
					baseEntity.pos = Vector3.zero;
				}
				base.transform.localPosition = baseEntity.pos;
				base.transform.localRotation = Quaternion.Euler(baseEntity.rot);
			}
		}
		if (info.msg.entitySlots != null)
		{
			entitySlots[0].uid = info.msg.entitySlots.slotLock;
			entitySlots[1].uid = info.msg.entitySlots.slotFireMod;
			entitySlots[2].uid = info.msg.entitySlots.slotUpperModification;
			entitySlots[5].uid = info.msg.entitySlots.centerDecoration;
		}
		if (info.msg.parent != null)
		{
			if (base.isServer)
			{
				BaseEntity entity = BaseNetworkable.serverEntities.Find(info.msg.parent.uid) as BaseEntity;
				SetParent(entity);
			}
			parentEntity.uid = info.msg.parent.uid;
			parentBone = info.msg.parent.bone;
		}
		else
		{
			parentEntity.uid = 0u;
			parentBone = 0u;
		}
		if (info.msg.ownerInfo != null)
		{
			OwnerID = info.msg.ownerInfo.steamid;
		}
		if ((bool)_spawnable)
		{
			_spawnable.Load(info);
		}
	}

	public override void ServerInit()
	{
		_spawnable = GetComponent<Spawnable>();
		base.ServerInit();
		if (enableSaving)
		{
			Assert.IsTrue(!saveList.Contains(this), "Already in save list - server Init being called twice?");
			saveList.Add(this);
		}
		if (flags != 0)
		{
			OnFlagsChanged((Flags)0, flags);
		}
		if (syncPosition && PositionTickRate >= 0f)
		{
			InvokeRandomized(NetworkPositionTick, PositionTickRate, PositionTickRate - PositionTickRate * 0.05f, PositionTickRate * 0.05f);
		}
		Query.Server.Add(this);
	}

	public virtual void OnSensation(Sensation sensation)
	{
	}

	protected void NetworkPositionTick()
	{
		if (base.transform.hasChanged)
		{
			TransformChanged();
			base.transform.hasChanged = false;
		}
	}

	private void TransformChanged()
	{
		if (Query.Server != null)
		{
			Query.Server.Move(this);
		}
		if (net == null)
		{
			return;
		}
		InvalidateNetworkCache();
		if (!globalBroadcast && !ValidBounds.Test(base.transform.position))
		{
			OnInvalidPosition();
		}
		else if (syncPosition)
		{
			if (!isCallingUpdateNetworkGroup)
			{
				Invoke(UpdateNetworkGroup, 5f);
				isCallingUpdateNetworkGroup = true;
			}
			SendNetworkUpdate_Position();
			OnPositionalNetworkUpdate();
		}
	}

	public virtual void OnPositionalNetworkUpdate()
	{
	}

	public void DoMovingWithoutARigidBodyCheck()
	{
		if (doneMovingWithoutARigidBodyCheck <= 10)
		{
			doneMovingWithoutARigidBodyCheck++;
			if (doneMovingWithoutARigidBodyCheck >= 10 && !(GetComponent<Collider>() == null) && GetComponent<Rigidbody>() == null)
			{
				Debug.LogWarning(string.Concat("Entity moving without a rigid body! (", base.gameObject, ")"), this);
			}
		}
	}

	public void SpawnAsMapEntity()
	{
		if (net == null && !base.IsDestroyed)
		{
			Spawn();
		}
	}

	internal override void DoServerDestroy()
	{
		CancelInvoke(NetworkPositionTick);
		saveList.Remove(this);
		RemoveFromTriggers();
		if (children != null)
		{
			BaseEntity[] array = children.ToArray();
			foreach (BaseEntity baseEntity in array)
			{
				baseEntity.OnParentRemoved();
			}
		}
		SetParent(null);
		Query.Server.Remove(this);
		base.DoServerDestroy();
	}

	internal virtual void OnParentRemoved()
	{
		Kill();
	}

	public virtual void OnInvalidPosition()
	{
		Debug.Log(string.Concat("Invalid Position: ", this, " ", base.transform.position, " (destroying)"));
		Kill();
	}

	public BaseCorpse DropCorpse(string strCorpsePrefab)
	{
		Assert.IsTrue(base.isServer, "DropCorpse called on client!");
		if (!ConVar.Server.corpses)
		{
			return null;
		}
		if (string.IsNullOrEmpty(strCorpsePrefab))
		{
			return null;
		}
		BaseCorpse baseCorpse = GameManager.server.CreateEntity(strCorpsePrefab) as BaseCorpse;
		if (baseCorpse == null)
		{
			Debug.LogWarning(string.Concat("Error creating corpse: ", base.gameObject, " - ", strCorpsePrefab));
			return null;
		}
		baseCorpse.InitCorpse(this);
		return baseCorpse;
	}

	public override void UpdateNetworkGroup()
	{
		isCallingUpdateNetworkGroup = false;
		if (net == null || Network.Net.sv == null || Network.Net.sv.visibility == null)
		{
			return;
		}
		using (TimeWarning.New("UpdateNetworkGroup"))
		{
			if (globalBroadcast)
			{
				if (net.SwitchGroup(BaseNetworkable.GlobalNetworkGroup))
				{
					SendNetworkGroupChange();
				}
			}
			else if (parentEntity.IsSet())
			{
				BaseEntity baseEntity = GetParentEntity();
				if (!baseEntity.IsValid())
				{
					Debug.LogWarning("UpdateNetworkGroup: Missing parent entity " + parentEntity.uid);
					Invoke(UpdateNetworkGroup, 2f);
					isCallingUpdateNetworkGroup = true;
				}
				else if (baseEntity != null)
				{
					if (net.SwitchGroup(baseEntity.net.group))
					{
						SendNetworkGroupChange();
					}
				}
				else
				{
					Debug.LogWarning(string.Concat(base.gameObject, ": has parent id - but couldn't find parent! ", parentEntity));
				}
			}
			else
			{
				base.UpdateNetworkGroup();
			}
		}
	}

	public virtual void Eat(BaseNpc baseNpc, float timeSpent)
	{
		baseNpc.AddCalories(100f);
	}

	public virtual void OnDeployed(BaseEntity parent)
	{
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		if (player == this)
		{
			return true;
		}
		BaseEntity baseEntity = GetParentEntity();
		if (base.limitNetworking)
		{
			if (baseEntity == null)
			{
				return false;
			}
			if (baseEntity != player)
			{
				return false;
			}
		}
		if (baseEntity != null)
		{
			return baseEntity.ShouldNetworkTo(player);
		}
		return base.ShouldNetworkTo(player);
	}

	public virtual void AttackerInfo(PlayerLifeStory.DeathInfo info)
	{
		info.attackerName = base.ShortPrefabName;
		info.attackerSteamID = 0uL;
		info.inflictorName = string.Empty;
	}

	public virtual void Push(Vector3 velocity)
	{
		SetVelocity(velocity);
	}

	public virtual void SetVelocity(Vector3 velocity)
	{
		Rigidbody component = GetComponent<Rigidbody>();
		if ((bool)component)
		{
			component.velocity = velocity;
		}
	}

	public virtual void SetAngularVelocity(Vector3 velocity)
	{
		Rigidbody component = GetComponent<Rigidbody>();
		if ((bool)component)
		{
			component.angularVelocity = velocity;
		}
	}

	public virtual Vector3 GetDropPosition()
	{
		return base.transform.position;
	}

	public virtual Vector3 GetDropVelocity()
	{
		return Vector3.up;
	}

	public virtual bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		return true;
	}

	public virtual float RadiationProtection()
	{
		return 0f;
	}

	public virtual float RadiationExposureFraction()
	{
		return 1f;
	}

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void BroadcastSignalFromClient(RPCMessage msg)
	{
		Signal signal = (Signal)msg.read.Int32();
		string arg = msg.read.String();
		SignalBroadcast(signal, arg, msg.connection);
	}

	public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)
	{
		if (net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers)
			{
				method = SendMethod.Unreliable,
				priority = Priority.Immediate
			}, sourceConnection, "SignalFromServerEx", (int)signal, arg);
		}
	}

	public void SignalBroadcast(Signal signal, Connection sourceConnection = null)
	{
		if (net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers)
			{
				method = SendMethod.Unreliable,
				priority = Priority.Immediate
			}, sourceConnection, "SignalFromServer", (int)signal);
		}
	}

	private void OnSkinChanged(ulong oldSkinID, ulong newSkinID)
	{
		if (oldSkinID != newSkinID)
		{
			skinID = newSkinID;
		}
	}

	public bool HasAnySlot()
	{
		for (int i = 0; i < entitySlots.Length; i++)
		{
			if (entitySlots[i].IsValid(base.isServer))
			{
				return true;
			}
		}
		return false;
	}

	public BaseEntity GetSlot(Slot slot)
	{
		return entitySlots[(int)slot].Get(base.isServer);
	}

	public string GetSlotAnchorName(Slot slot)
	{
		return slot.ToString().ToLower();
	}

	public void SetSlot(Slot slot, BaseEntity ent)
	{
		entitySlots[(int)slot].Set(ent);
		SendNetworkUpdate();
	}

	public virtual bool HasSlot(Slot slot)
	{
		return false;
	}

	public bool HasTrait(TraitFlag f)
	{
		return (Traits & f) == f;
	}

	public bool HasAnyTrait(TraitFlag f)
	{
		return (Traits & f) != 0;
	}

	public virtual bool EnterTrigger(TriggerBase trigger)
	{
		if (triggers == null)
		{
			triggers = Facepunch.Pool.Get<List<TriggerBase>>();
		}
		triggers.Add(trigger);
		return true;
	}

	public virtual void LeaveTrigger(TriggerBase trigger)
	{
		if (triggers != null)
		{
			triggers.Remove(trigger);
			if (triggers.Count == 0)
			{
				Facepunch.Pool.FreeList(ref triggers);
			}
		}
	}

	public void RemoveFromTriggers()
	{
		if (triggers == null)
		{
			return;
		}
		using (TimeWarning.New("RemoveFromTriggers"))
		{
			TriggerBase[] array = triggers.ToArray();
			foreach (TriggerBase triggerBase in array)
			{
				if ((bool)triggerBase)
				{
					triggerBase.RemoveEntity(this);
				}
			}
			if (triggers != null && triggers.Count == 0)
			{
				Facepunch.Pool.FreeList(ref triggers);
			}
		}
	}

	public T FindTrigger<T>() where T : TriggerBase
	{
		if (triggers == null)
		{
			return (T)null;
		}
		foreach (TriggerBase trigger in triggers)
		{
			if (trigger as T == null)
			{
				continue;
			}
			return trigger as T;
		}
		return (T)null;
	}
}
