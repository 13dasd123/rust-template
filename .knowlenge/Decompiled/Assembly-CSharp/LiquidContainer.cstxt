#define UNITY_ASSERTIONS
using System;
using ConVar;
using Network;
using UnityEngine;
using UnityEngine.Assertions;

public class LiquidContainer : StorageContainer, ISplashable
{
	public ItemDefinition defaultLiquid;

	public int startingAmount;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("LiquidContainer.OnRpcMessage"))
		{
			if (rpc == 2457800725u && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - SVDrink "));
				}
				using (TimeWarning.New("SVDrink"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("SVDrink", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							SVDrink(rpc2);
						}
					}
					catch (Exception exception)
					{
						player.Kick("RPC Error in SVDrink");
						Debug.LogException(exception);
					}
				}
				return true;
			}
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (startingAmount > 0)
		{
			inventory.AddItem(defaultLiquid, startingAmount);
		}
	}

	protected void UpdateOnFlag()
	{
		SetFlag(Flags.On, inventory.itemList.Count > 0 && inventory.itemList[0].amount > 0);
	}

	protected override void OnInventoryDirty()
	{
		UpdateOnFlag();
	}

	public virtual void OpenTap(float duration)
	{
		if (!HasFlag(Flags.Reserved5))
		{
			SetFlag(Flags.Reserved5, b: true);
			Invoke(ShutTap, duration);
			SendNetworkUpdateImmediate();
		}
	}

	public virtual void ShutTap()
	{
		SetFlag(Flags.Reserved5, b: false);
		SendNetworkUpdateImmediate();
	}

	public bool HasLiquidItem()
	{
		return GetLiquidItem() != null;
	}

	public Item GetLiquidItem()
	{
		return (inventory.itemList.Count != 0) ? inventory.itemList[0] : null;
	}

	public bool wantsSplash(ItemDefinition splashType, int amount)
	{
		return !HasLiquidItem() || (GetLiquidItem().info == splashType && GetLiquidItem().amount < maxStackSize);
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		int num = 0;
		if (HasLiquidItem())
		{
			Item item = GetLiquidItem();
			int amount2 = item.amount;
			ItemDefinition itemDefinition = WaterResource.Merge(splashType, item.info);
			if (item.info != itemDefinition)
			{
				item.Remove();
				item = ItemManager.Create(itemDefinition, amount2, 0uL);
				if (!item.MoveToContainer(inventory))
				{
					item.Remove();
					return 0;
				}
			}
			num = Mathf.Min(maxStackSize - amount2, amount);
			item.amount += num;
		}
		else
		{
			num = Mathf.Min(amount, maxStackSize);
			Item item2 = ItemManager.Create(splashType, num, 0uL);
			if (item2 != null && !item2.MoveToContainer(inventory))
			{
				item2.Remove();
			}
		}
		return num;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void SVDrink(RPCMessage rpc)
	{
		if (!rpc.player.metabolism.CanConsume())
		{
			return;
		}
		foreach (Item item in inventory.itemList)
		{
			ItemModConsume component = item.info.GetComponent<ItemModConsume>();
			if (component == null || !component.CanDoAction(item, rpc.player))
			{
				continue;
			}
			component.DoAction(item, rpc.player);
			break;
		}
	}

	public override bool SupportsPooling()
	{
		return true;
	}
}
