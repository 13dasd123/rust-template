using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Network;
using Network.Visibility;
using Rust;
using UnityEngine;
using UnityEngine.Profiling;

[Factory("global")]
public class Global : ConsoleSystem
{
	private static int _developer;

	[ServerVar]
	[ClientVar]
	public static int maxthreads = 8;

	[ServerVar(Saved = true)]
	[ClientVar(Saved = true)]
	public static int perf;

	[ClientVar(ClientInfo = true, Saved = true, Help = "If you're an admin this will enable god mode")]
	public static bool god;

	[ClientVar(ClientInfo = true, Saved = true, Help = "If enabled you will be networked when you're spectating. This means that you will hear audio chat, but also means that cheaters will potentially be able to detect you watching them.")]
	public static bool specnet;

	[ServerVar]
	[ClientVar]
	public static bool timewarning
	{
		get
		{
			return TimeWarning.Enabled;
		}
		set
		{
			TimeWarning.Enabled = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static int developer
	{
		get
		{
			return _developer;
		}
		set
		{
			_developer = value;
		}
	}

	[ServerVar]
	public static void restart(Arg args)
	{
		ServerMgr.RestartServer(args.GetString(1, string.Empty), args.GetInt(0, 300));
	}

	[ClientVar]
	[ServerVar]
	public static void quit(Arg args)
	{
		SingletonComponent<ServerMgr>.Instance.Shutdown();
		Rust.Application.isQuitting = true;
		Network.Net.sv.Stop("quit");
		Process.GetCurrentProcess().Kill();
		UnityEngine.Debug.Log("Quitting");
		Rust.Application.Quit();
	}

	[ServerVar]
	public static void report(Arg args)
	{
		ServerPerformance.DoReport();
	}

	[ServerVar]
	[ClientVar]
	public static void objects(Arg args)
	{
		UnityEngine.Object[] array = UnityEngine.Object.FindObjectsOfType<UnityEngine.Object>();
		string text = string.Empty;
		Dictionary<Type, int> dictionary = new Dictionary<Type, int>();
		Dictionary<Type, long> dictionary2 = new Dictionary<Type, long>();
		UnityEngine.Object[] array2 = array;
		foreach (UnityEngine.Object @object in array2)
		{
			int runtimeMemorySize = Profiler.GetRuntimeMemorySize(@object);
			if (dictionary.ContainsKey(@object.GetType()))
			{
				dictionary[@object.GetType()]++;
			}
			else
			{
				dictionary.Add(@object.GetType(), 1);
			}
			if (dictionary2.ContainsKey(@object.GetType()))
			{
				dictionary2[@object.GetType()] += runtimeMemorySize;
			}
			else
			{
				dictionary2.Add(@object.GetType(), runtimeMemorySize);
			}
		}
		IOrderedEnumerable<KeyValuePair<Type, long>> orderedEnumerable = dictionary2.OrderByDescending((KeyValuePair<Type, long> x) => x.Value);
		foreach (KeyValuePair<Type, long> item in orderedEnumerable)
		{
			string text2 = text;
			text = string.Concat(text2, dictionary[item.Key].ToString().PadLeft(10), " ", item.Value.FormatBytes().PadLeft(15), "\t", item.Key, "\n");
		}
		args.ReplyWith(text);
	}

	[ServerVar]
	[ClientVar]
	public static void textures(Arg args)
	{
		Texture[] array = UnityEngine.Object.FindObjectsOfType<Texture>();
		string text = string.Empty;
		Texture[] array2 = array;
		foreach (Texture texture in array2)
		{
			string text2 = Profiler.GetRuntimeMemorySize(texture).FormatBytes();
			string text3 = text;
			text = text3 + texture.ToString().PadRight(30) + texture.name.PadRight(30) + text2 + "\n";
		}
		args.ReplyWith(text);
	}

	[ServerVar]
	[ClientVar]
	public static void colliders(Arg args)
	{
		int num = (from x in UnityEngine.Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).Count();
		int num2 = (from x in UnityEngine.Object.FindObjectsOfType<Collider>()
			where !x.enabled
			select x).Count();
		string strValue = num + " colliders enabled, " + num2 + " disabled";
		args.ReplyWith(strValue);
	}

	[ServerVar]
	[ClientVar]
	public static void error(Arg args)
	{
		GameObject gameObject = null;
		gameObject.transform.position = Vector3.zero;
	}

	[ServerVar]
	[ClientVar]
	public static void queue(Arg args)
	{
		string empty = string.Empty;
		empty = empty + "stabilityCheckQueue:\t\t" + StabilityEntity.stabilityCheckQueue.Info() + "\n";
		empty = empty + "updateSurroundingsQueue:\t" + StabilityEntity.updateSurroundingsQueue.Info() + "\n";
		args.ReplyWith(empty);
	}

	[ServerUserVar]
	public static void setinfo(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer)
		{
			string @string = args.GetString(0, null);
			string string2 = args.GetString(1, null);
			if (@string != null && string2 != null)
			{
				basePlayer.SetInfo(@string, string2);
			}
		}
	}

	[ServerVar]
	public static void sleep(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer && !basePlayer.IsSleeping() && !basePlayer.IsSpectating() && !basePlayer.IsDead())
		{
			basePlayer.StartSleeping();
		}
	}

	[ServerUserVar]
	public static void kill(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer && !basePlayer.IsSpectating() && !basePlayer.IsDead())
		{
			if (basePlayer.CanSuicide())
			{
				basePlayer.MarkSuicide();
				basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
			}
			else
			{
				basePlayer.ConsoleMessage("You can't suicide again so quickly, wait a while");
			}
		}
	}

	[ServerUserVar]
	public static void respawn(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if (!basePlayer)
		{
			return;
		}
		if (!basePlayer.IsDead() && !basePlayer.IsSpectating())
		{
			if (developer > 0)
			{
				UnityEngine.Debug.LogWarning(string.Concat(basePlayer, " wanted to respawn but isn't dead or spectating"));
			}
			basePlayer.SendNetworkUpdate();
		}
		else
		{
			basePlayer.Respawn();
		}
	}

	[ServerVar]
	public static void injure(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer && !basePlayer.IsDead())
		{
			basePlayer.StartWounded();
		}
	}

	[ServerVar]
	public static void spectate(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer)
		{
			if (!basePlayer.IsDead())
			{
				basePlayer.DieInstantly();
			}
			string @string = args.GetString(0, string.Empty);
			if (basePlayer.IsDead())
			{
				basePlayer.StartSpectating();
				basePlayer.UpdateSpectateTarget(@string);
			}
		}
	}

	[ServerUserVar]
	public static void respawn_sleepingbag(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer && basePlayer.IsDead())
		{
			uint uInt = args.GetUInt(0);
			if (uInt == 0)
			{
				args.ReplyWith("Missing sleeping bag ID");
			}
			else if (!SleepingBag.SpawnPlayer(basePlayer, uInt))
			{
				args.ReplyWith("Couldn't spawn in sleeping bag!");
			}
		}
	}

	[ServerUserVar]
	public static void respawn_sleepingbag_remove(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer)
		{
			uint uInt = args.GetUInt(0);
			if (uInt == 0)
			{
				args.ReplyWith("Missing sleeping bag ID");
			}
			else
			{
				SleepingBag.DestroyBag(basePlayer, uInt);
			}
		}
	}

	[ServerUserVar]
	public static void status_sv(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer)
		{
			args.ReplyWith(basePlayer.GetDebugStatus());
		}
	}

	[ClientVar]
	public static void status_cl(Arg args)
	{
	}

	[ServerVar]
	public static void teleport(Arg args)
	{
		if (args.HasArgs(2))
		{
			BasePlayer player = ArgEx.GetPlayer(args, 0);
			if ((bool)player && player.IsAlive())
			{
				BasePlayer playerOrSleeper = ArgEx.GetPlayerOrSleeper(args, 1);
				if ((bool)playerOrSleeper && playerOrSleeper.IsAlive())
				{
					player.Teleport(playerOrSleeper);
				}
			}
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer && basePlayer.IsAlive())
		{
			BasePlayer playerOrSleeper2 = ArgEx.GetPlayerOrSleeper(args, 0);
			if ((bool)playerOrSleeper2 && playerOrSleeper2.IsAlive())
			{
				basePlayer.Teleport(playerOrSleeper2);
			}
		}
	}

	[ServerVar]
	public static void teleport2me(Arg args)
	{
		BasePlayer player = ArgEx.GetPlayer(args, 0);
		if ((bool)player && player.IsAlive())
		{
			BasePlayer basePlayer = ArgEx.Player(args);
			if ((bool)basePlayer && basePlayer.IsAlive())
			{
				player.Teleport(basePlayer);
			}
		}
	}

	[ServerVar]
	public static void teleportany(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer && basePlayer.IsAlive())
		{
			basePlayer.Teleport(args.GetString(0, string.Empty), playersOnly: false);
		}
	}

	[ServerVar]
	public static void teleportpos(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer && basePlayer.IsAlive())
		{
			basePlayer.Teleport(args.GetVector3(0, Vector3.zero));
		}
	}

	[ServerVar]
	[ClientVar]
	public static void free(Arg args)
	{
		ConVar.Pool.clear_prefabs(args);
		ConVar.Pool.clear_assets(args);
		ConVar.Pool.clear_memory(args);
		ConVar.GC.collect();
		ConVar.GC.unload();
	}

	[ServerVar(ServerUser = true)]
	[ClientVar]
	public static void version(Arg arg)
	{
		arg.ReplyWith($"Protocol: {Protocol.printable}\nBuild Date: {BuildInfo.Current.BuildDate}\nUnity Version: {UnityEngine.Application.unityVersion}\nChangeset: {BuildInfo.Current.Scm.ChangeId}\nBranch: {BuildInfo.Current.Scm.Branch}");
	}

	[ServerVar]
	[ClientVar]
	public static void sysinfo(Arg arg)
	{
		arg.ReplyWith(SystemInfoGeneralText.currentInfo);
	}

	[ServerVar]
	[ClientVar]
	public static void sysuid(Arg arg)
	{
		arg.ReplyWith(SystemInfo.deviceUniqueIdentifier);
	}

	[ServerVar]
	public static void breakitem(Arg args)
	{
		BasePlayer basePlayer = ArgEx.Player(args);
		if ((bool)basePlayer)
		{
			Item activeItem = basePlayer.GetActiveItem();
			activeItem?.LoseCondition(activeItem.condition);
		}
	}

	[ServerVar]
	[ClientVar]
	public static void subscriptions(Arg arg)
	{
		TextTable textTable = new TextTable();
		textTable.AddColumn("realm");
		textTable.AddColumn("group");
		BasePlayer basePlayer = ArgEx.Player(arg);
		if ((bool)basePlayer)
		{
			foreach (Group item in basePlayer.net.subscriber.subscribed)
			{
				textTable.AddRow("sv", item.ID.ToString());
			}
		}
		arg.ReplyWith(textTable.ToString());
	}
}
