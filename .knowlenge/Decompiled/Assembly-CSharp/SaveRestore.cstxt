#define UNITY_ASSERTIONS
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class SaveRestore : SingletonComponent<SaveRestore>
{
	[CompilerGenerated]
	private sealed class <DoAutomatedSave>c__Iterator2 : IEnumerator, IDisposable, IEnumerator<object>
	{
		internal string <folder>__0;

		internal bool AndWait;

		internal SaveRestore $this;

		internal object $current;

		internal bool $disposing;

		internal int $PC;

		object IEnumerator<object>.Current
		{
			[DebuggerHidden]
			get
			{
				return $current;
			}
		}

		object IEnumerator.Current
		{
			[DebuggerHidden]
			get
			{
				return $current;
			}
		}

		[DebuggerHidden]
		public <DoAutomatedSave>c__Iterator2()
		{
		}

		public bool MoveNext()
		{
			uint num = (uint)$PC;
			$PC = -1;
			switch (num)
			{
			case 0u:
				IsSaving = true;
				<folder>__0 = ConVar.Server.rootFolder;
				if (!AndWait)
				{
					$current = CoroutineEx.waitForEndOfFrame;
					if (!$disposing)
					{
						$PC = 1;
					}
					break;
				}
				goto case 1u;
			case 1u:
				if (AndWait)
				{
					IEnumerator enumerator = Save(<folder>__0 + "/" + SaveFileName, AndWait);
					while (enumerator.MoveNext())
					{
					}
					goto case 2u;
				}
				$current = $this.StartCoroutine(Save(<folder>__0 + "/" + SaveFileName, AndWait));
				if (!$disposing)
				{
					$PC = 2;
				}
				break;
			case 2u:
				if (!AndWait)
				{
					$current = CoroutineEx.waitForEndOfFrame;
					if (!$disposing)
					{
						$PC = 3;
					}
					break;
				}
				goto case 3u;
			case 3u:
				UnityEngine.Debug.Log("Saving complete");
				IsSaving = false;
				$PC = -1;
				goto default;
			default:
				return false;
			}
			return true;
		}

		[DebuggerHidden]
		public void Dispose()
		{
			$disposing = true;
			$PC = -1;
		}

		[DebuggerHidden]
		public void Reset()
		{
			throw new NotSupportedException();
		}
	}

	public static bool IsSaving = false;

	public bool timedSave = true;

	public int timedSavePause;

	public static DateTime SaveCreatedTime;

	private static MemoryStream SaveBuffer = new MemoryStream(33554432);

	public static string SaveFileName => World.FileName + ".sav";

	public static IEnumerator Save(string strFilename, bool AndWait = false)
	{
		if (Rust.Application.isQuitting)
		{
			yield break;
		}
		Stopwatch timerSerialize = new Stopwatch();
		Stopwatch timerWrite = new Stopwatch();
		Stopwatch timerDisk = new Stopwatch();
		Stopwatch timerTotal = new Stopwatch();
		int iEnts = 0;
		Stopwatch sw = Stopwatch.StartNew();
		BaseEntity[] array = BaseEntity.saveList.ToArray();
		foreach (BaseEntity entity in array)
		{
			if (entity == null || !entity.IsValid())
			{
				continue;
			}
			try
			{
				entity.GetSaveCache();
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogException(exception);
			}
			if (sw.Elapsed.TotalMilliseconds > 5.0)
			{
				if (!AndWait)
				{
					yield return CoroutineEx.waitForEndOfFrame;
				}
				sw.Reset();
				sw.Start();
			}
		}
		SaveBuffer.Position = 0L;
		SaveBuffer.SetLength(0L);
		timerTotal.Start();
		using (TimeWarning timeWarning = TimeWarning.New("Save", 100L))
		{
			BinaryWriter writer = new BinaryWriter(SaveBuffer);
			writer.Write((sbyte)83);
			writer.Write((sbyte)65);
			writer.Write((sbyte)86);
			writer.Write((sbyte)82);
			writer.Write((sbyte)68);
			writer.Write(Epoch.FromDateTime(SaveCreatedTime));
			writer.Write(156u);
			BaseNetworkable.SaveInfo saveinfo = new BaseNetworkable.SaveInfo
			{
				forDisk = true
			};
			if (!AndWait)
			{
				yield return CoroutineEx.waitForEndOfFrame;
			}
			foreach (BaseEntity save in BaseEntity.saveList)
			{
				if (save == null || save.IsDestroyed)
				{
					UnityEngine.Debug.LogWarning("Entity is NULL but is still in saveList - not destroyed properly? " + save, save);
					continue;
				}
				MemoryStream memoryStream = null;
				try
				{
					timerSerialize.Start();
					memoryStream = save.GetSaveCache();
					timerSerialize.Stop();
				}
				catch (Exception exception2)
				{
					UnityEngine.Debug.LogException(exception2);
				}
				if (memoryStream == null || memoryStream.Length <= 0)
				{
					UnityEngine.Debug.LogWarningFormat("Skipping saving entity {0} - because {1}", save, (memoryStream != null) ? "savecache is 0" : "savecache is null");
				}
				else
				{
					timerWrite.Start();
					writer.Write((uint)memoryStream.Length);
					writer.Write(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
					timerWrite.Stop();
					iEnts++;
				}
			}
		}
		timerTotal.Stop();
		if (!AndWait)
		{
			yield return CoroutineEx.waitForEndOfFrame;
		}
		timerDisk.Start();
		try
		{
			if (File.Exists(strFilename + ".new"))
			{
				File.Delete(strFilename + ".new");
			}
			try
			{
				File.WriteAllBytes(strFilename + ".new", SaveBuffer.ToArray());
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogWarning("Couldn't write save file! We got an exception: " + ex);
				if (File.Exists(strFilename + ".new"))
				{
					File.Delete(strFilename + ".new");
				}
			}
			if (File.Exists(strFilename))
			{
				File.Delete(strFilename);
			}
			File.Move(strFilename + ".new", strFilename);
		}
		catch (Exception ex2)
		{
			UnityEngine.Debug.LogWarning("Error when saving to disk: " + ex2);
		}
		timerDisk.Stop();
		UnityEngine.Debug.LogFormat("Saved {0} ents, serialization({1}), write({2}), disk({3}) totalstall({4}).", iEnts.ToString("N0"), timerSerialize.Elapsed.TotalSeconds.ToString("0.00"), timerWrite.Elapsed.TotalSeconds.ToString("0.00"), timerDisk.Elapsed.TotalSeconds.ToString("0.00"), timerTotal.Elapsed.TotalSeconds.ToString("0.00"));
	}

	private void Start()
	{
		StartCoroutine(SaveRegularly());
	}

	private IEnumerator SaveRegularly()
	{
		while (true)
		{
			yield return CoroutineEx.waitForSeconds(ConVar.Server.saveinterval);
			if (timedSave && timedSavePause <= 0)
			{
				yield return StartCoroutine(DoAutomatedSave());
			}
		}
	}

	[DebuggerHidden]
	private IEnumerator DoAutomatedSave(bool AndWait = false)
	{
		Interface.CallHook("OnServerSave", null);
		<DoAutomatedSave>c__Iterator2 <DoAutomatedSave>c__Iterator = new <DoAutomatedSave>c__Iterator2();
		<DoAutomatedSave>c__Iterator.AndWait = AndWait;
		<DoAutomatedSave>c__Iterator.$this = this;
		return <DoAutomatedSave>c__Iterator;
	}

	public static bool Save(bool AndWait)
	{
		if (SingletonComponent<SaveRestore>.Instance == null)
		{
			return false;
		}
		if (IsSaving)
		{
			return false;
		}
		IEnumerator enumerator = SingletonComponent<SaveRestore>.Instance.DoAutomatedSave(AndWait: true);
		while (enumerator.MoveNext())
		{
		}
		return true;
	}

	internal static void ClearMapEntities()
	{
		BaseEntity[] array = UnityEngine.Object.FindObjectsOfType<BaseEntity>();
		if (array.Length <= 0)
		{
			return;
		}
		DebugEx.Log("Destroying " + array.Length + " old entities", StackTraceLogType.None);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log("\t" + (i + 1) + " / " + array.Length, StackTraceLogType.None);
			}
		}
		ItemManager.Heartbeat();
		DebugEx.Log("\tdone.", StackTraceLogType.None);
	}

	public static bool Load(string strFilename = "", bool allowOutOfDateSaves = false)
	{
		SaveCreatedTime = DateTime.UtcNow;
		try
		{
			if (strFilename == string.Empty)
			{
				strFilename = ConVar.Server.rootFolder + "/" + SaveFileName;
			}
			if (!File.Exists(strFilename))
			{
				if (!File.Exists("TestSaves/" + strFilename))
				{
					UnityEngine.Debug.LogWarning("Couldn't load " + strFilename + " - file doesn't exist");
					Interface.CallHook("OnNewSave", strFilename);
					return false;
				}
				strFilename = "TestSaves/" + strFilename;
			}
			Dictionary<BaseEntity, ProtoBuf.Entity> dictionary = new Dictionary<BaseEntity, ProtoBuf.Entity>();
			using (FileStream fileStream = File.OpenRead(strFilename))
			{
				using BinaryReader binaryReader = new BinaryReader(fileStream);
				SaveCreatedTime = File.GetCreationTime(strFilename);
				if (binaryReader.ReadSByte() != 83 || binaryReader.ReadSByte() != 65 || binaryReader.ReadSByte() != 86 || binaryReader.ReadSByte() != 82)
				{
					UnityEngine.Debug.LogWarning("Invalid save (missing header)");
					return false;
				}
				if (binaryReader.PeekChar() == 68)
				{
					binaryReader.ReadChar();
					SaveCreatedTime = Epoch.ToDateTime(binaryReader.ReadInt32());
				}
				if (binaryReader.ReadUInt32() != 156)
				{
					if (allowOutOfDateSaves)
					{
						UnityEngine.Debug.LogWarning("This save is from an older (possibly incompatible) version!");
					}
					else
					{
						UnityEngine.Debug.LogWarning("This save is from an older version. It might not load properly.");
					}
				}
				ClearMapEntities();
				Assert.IsTrue(BaseEntity.saveList.Count == 0, "BaseEntity.saveList isn't empty!");
				Network.Net.sv.Reset();
				Rust.Application.isLoadingSave = true;
				HashSet<uint> hashSet = new HashSet<uint>();
				while (fileStream.Position < fileStream.Length)
				{
					RCon.Update();
					uint length = binaryReader.ReadUInt32();
					ProtoBuf.Entity entData = ProtoBuf.Entity.DeserializeLength(fileStream, (int)length);
					if (entData.basePlayer != null && dictionary.Any((KeyValuePair<BaseEntity, ProtoBuf.Entity> x) => x.Value.basePlayer != null && x.Value.basePlayer.userid == entData.basePlayer.userid))
					{
						UnityEngine.Debug.LogWarning("Skipping entity " + entData.baseNetworkable.uid + " - it's a player " + entData.basePlayer.userid + " who is in the save multiple times");
						continue;
					}
					if (entData.baseNetworkable.uid != 0 && hashSet.Contains(entData.baseNetworkable.uid))
					{
						UnityEngine.Debug.LogWarning("Skipping entity " + entData.baseNetworkable.uid + " " + StringPool.Get(entData.baseNetworkable.prefabID) + " - uid is used multiple times");
						continue;
					}
					if (entData.baseNetworkable.uid != 0)
					{
						hashSet.Add(entData.baseNetworkable.uid);
					}
					BaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entData.baseNetworkable.prefabID), entData.baseEntity.pos, Quaternion.Euler(entData.baseEntity.rot));
					if ((bool)baseEntity)
					{
						baseEntity.InitLoad(entData.baseNetworkable.uid);
						dictionary.Add(baseEntity, entData);
					}
				}
			}
			DebugEx.Log("Spawning " + dictionary.Count + " entities", StackTraceLogType.None);
			object obj = Interface.CallHook("OnSaveLoad", dictionary);
			if (obj is bool)
			{
				return (bool)obj;
			}
			BaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);
			info.fromDisk = true;
			Stopwatch stopwatch = Stopwatch.StartNew();
			int num = 0;
			foreach (KeyValuePair<BaseEntity, ProtoBuf.Entity> item in dictionary)
			{
				BaseEntity key = item.Key;
				if (key == null)
				{
					continue;
				}
				RCon.Update();
				info.msg = item.Value;
				key.Spawn();
				key.Load(info);
				if (key.IsValid())
				{
					key.PostServerLoad();
					num++;
					if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
					{
						stopwatch.Reset();
						stopwatch.Start();
						DebugEx.Log("\t" + num + " / " + dictionary.Count, StackTraceLogType.None);
					}
				}
			}
			DebugEx.Log("\tdone.", StackTraceLogType.None);
			if ((bool)SingletonComponent<SpawnHandler>.Instance)
			{
				DebugEx.Log("Enforcing SpawnPopulation Limits", StackTraceLogType.None);
				SingletonComponent<SpawnHandler>.Instance.EnforceLimits();
				DebugEx.Log("\tdone.", StackTraceLogType.None);
			}
			Rust.Application.isLoadingSave = false;
			return true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogWarning("Error loading save (" + strFilename + "): " + ex.Message);
			return false;
		}
	}

	public static void GetSaveCache()
	{
		BaseEntity[] array = BaseEntity.saveList.ToArray();
		if (array.Length <= 0)
		{
			return;
		}
		DebugEx.Log("Initializing " + array.Length + " entity save caches", StackTraceLogType.None);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			BaseEntity baseEntity = array[i];
			if (baseEntity.IsValid())
			{
				baseEntity.GetSaveCache();
				if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
				{
					stopwatch.Reset();
					stopwatch.Start();
					DebugEx.Log("\t" + (i + 1) + " / " + array.Length, StackTraceLogType.None);
				}
			}
		}
		DebugEx.Log("\tdone.", StackTraceLogType.None);
	}

	public static void InitializeEntityLinks()
	{
		BaseEntity[] array = (from x in BaseNetworkable.serverEntities
			where x is BaseEntity
			select x as BaseEntity).ToArray();
		if (array.Length <= 0)
		{
			return;
		}
		DebugEx.Log("Initializing " + array.Length + " entity links", StackTraceLogType.None);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].RefreshEntityLinks();
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log("\t" + (i + 1) + " / " + array.Length, StackTraceLogType.None);
			}
		}
		DebugEx.Log("\tdone.", StackTraceLogType.None);
	}

	public static void InitializeEntitySupports()
	{
		if (!ConVar.Server.stability)
		{
			return;
		}
		StabilityEntity[] array = (from x in BaseNetworkable.serverEntities
			where x is StabilityEntity
			select x as StabilityEntity).ToArray();
		if (array.Length <= 0)
		{
			return;
		}
		DebugEx.Log("Initializing " + array.Length + " stability supports", StackTraceLogType.None);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].InitializeSupports();
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log("\t" + (i + 1) + " / " + array.Length, StackTraceLogType.None);
			}
		}
		DebugEx.Log("\tdone.", StackTraceLogType.None);
	}

	public static void InitializeEntityConditionals()
	{
		BuildingBlock[] array = (from x in BaseNetworkable.serverEntities
			where x is BuildingBlock
			select x as BuildingBlock).ToArray();
		if (array.Length <= 0)
		{
			return;
		}
		DebugEx.Log("Initializing " + array.Length + " conditional models", StackTraceLogType.None);
		Stopwatch stopwatch = Stopwatch.StartNew();
		for (int i = 0; i < array.Length; i++)
		{
			RCon.Update();
			array[i].UpdateSkin(force: true);
			if (stopwatch.Elapsed.TotalMilliseconds > 2000.0)
			{
				stopwatch.Reset();
				stopwatch.Start();
				DebugEx.Log("\t" + (i + 1) + " / " + array.Length, StackTraceLogType.None);
			}
		}
		DebugEx.Log("\tdone.", StackTraceLogType.None);
	}
}
