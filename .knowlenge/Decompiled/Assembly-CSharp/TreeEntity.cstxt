using System;
using Network;
using UnityEngine;

public class TreeEntity : ResourceEntity
{
	public GameObjectRef prefab;

	public bool hasBonusGame = true;

	public GameObjectRef bonusHitEffect;

	public GameObjectRef bonusHitSound;

	public Collider serverCollider;

	public Collider clientCollider;

	public SoundDefinition smallCrackSoundDef;

	public SoundDefinition medCrackSoundDef;

	private float lastAttackDamage;

	[NonSerialized]
	protected BaseEntity xMarker;

	private int currentBonusLevel;

	private float lastDirection = -1f;

	private float lastHitTime;

	protected Transform treeBaseRef;

	protected Vector3 oldInstancePos = Vector3.zero;

	protected Quaternion oldInstanceRot = Quaternion.identity;

	protected float lastTreeFallTickTime;

	protected float fallStartTime = -1f;

	[Header("Falling")]
	public bool fallOnKilled = true;

	public float fallDuration = 1.5f;

	public GameObjectRef fallStartSound;

	public GameObjectRef fallImpactSound;

	public GameObjectRef fallImpactParticles;

	public SoundDefinition fallLeavesLoopDef;

	private Sound fallLeavesLoop;

	private SoundModulation.Modulator fallLeavesGainMod;

	private float impactSoundCheckHeight;

	[NonSerialized]
	private Vector3 hitDirection;

	[NonSerialized]
	private Vector3 rotateDirection;

	[NonSerialized]
	private Vector3 fallDirection;

	[NonSerialized]
	public bool[] usedHeights = new bool[20];

	public bool impactSoundPlayed;

	[NonSerialized]
	public float treeDistanceUponFalling;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("TreeEntity.OnRpcMessage"))
		{
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			CleanupMarker();
		}
	}

	public override float BoundsPadding()
	{
		return 1f;
	}

	public override bool SupportsPooling()
	{
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		lastDirection = ((UnityEngine.Random.Range(0, 2) != 0) ? 1 : (-1));
	}

	public bool DidHitMarker(HitInfo info)
	{
		if (xMarker == null)
		{
			return false;
		}
		Vector3 lhs = Vector3Ex.Direction2D(base.transform.position, xMarker.GetEstimatedWorldPosition());
		Vector3 attackNormal = info.attackNormal;
		Vector3 vector = Vector3Ex.Direction2D(base.transform.position, info.HitPositionWorld);
		float num = Mathf.Abs(info.HitPositionWorld.y - xMarker.GetEstimatedWorldPosition().y);
		if ((double)Vector3.Dot(lhs, attackNormal) >= 0.3 && Vector3.Distance(xMarker.GetEstimatedWorldPosition(), info.HitPositionWorld) <= 0.2f)
		{
			return true;
		}
		return false;
	}

	public void StartBonusGame()
	{
		if (IsInvoking(StopBonusGame))
		{
			CancelInvoke(StopBonusGame);
		}
		Invoke(StopBonusGame, 60f);
	}

	public void StopBonusGame()
	{
		CleanupMarker();
		lastHitTime = 0f;
		currentBonusLevel = 0;
	}

	public bool BonusActive()
	{
		return xMarker != null;
	}

	public override void OnAttacked(HitInfo info)
	{
		bool canGather = info.CanGather;
		float num = Time.time - lastHitTime;
		lastHitTime = Time.time;
		if (!hasBonusGame || !canGather || info.Initiator == null || (BonusActive() && !DidHitMarker(info)))
		{
			base.OnAttacked(info);
			return;
		}
		if (xMarker != null && !info.DidGather && info.gatherScale > 0f)
		{
			xMarker.ClientRPC(null, "MarkerHit", currentBonusLevel);
			currentBonusLevel++;
			info.gatherScale = 1f + Mathf.Clamp((float)currentBonusLevel * 0.125f, 0f, 1f);
		}
		Vector3 aimFrom = ((!(xMarker != null)) ? info.HitPositionWorld : xMarker.GetEstimatedWorldPosition());
		CleanupMarker();
		Vector3 vector = Vector3Ex.Direction2D(base.transform.position, aimFrom);
		Vector3 vector2 = vector;
		Vector3 vector3 = Vector3.Cross(vector2, Vector3.up);
		float num2 = lastDirection;
		float t = UnityEngine.Random.Range(0.5f, 0.5f);
		Vector3 vector4 = Vector3.Lerp(-vector2, vector3 * num2, t);
		Vector3 position = base.transform.InverseTransformDirection(vector4.normalized) * 2.5f;
		position = base.transform.InverseTransformPoint(GetCollider().ClosestPoint(base.transform.TransformPoint(position)));
		Vector3 aimFrom2 = base.transform.TransformPoint(position);
		position.y = base.transform.InverseTransformPoint(info.HitPositionWorld).y;
		Vector3 vector5 = base.transform.InverseTransformPoint(info.Initiator.CenterPoint());
		float min = Mathf.Max(0.75f, vector5.y);
		float max = vector5.y + 0.5f;
		position.y = Mathf.Clamp(position.y + UnityEngine.Random.Range(0.1f, 0.2f) * ((UnityEngine.Random.Range(0, 2) != 0) ? 1f : (-1f)), min, max);
		Vector3 vector6 = Vector3Ex.Direction2D(base.transform.position, aimFrom2);
		Vector3 vector7 = vector6;
		vector6 = base.transform.InverseTransformDirection(vector6);
		Quaternion quaternion = QuaternionEx.LookRotationNormal(-vector6, Vector3.zero);
		position = base.transform.TransformPoint(position);
		quaternion = QuaternionEx.LookRotationNormal(-vector7, Vector3.zero);
		xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking.prefab", position, quaternion);
		xMarker.Spawn();
		if (num > 5f)
		{
			StartBonusGame();
		}
		base.OnAttacked(info);
		if (health > 0f)
		{
			lastAttackDamage = info.damageTypes.Total();
			int num3 = Mathf.CeilToInt(health / lastAttackDamage);
			if (num3 < 2)
			{
				ClientRPC(null, "CrackSound", 1);
			}
			else if (num3 < 5)
			{
				ClientRPC(null, "CrackSound", 0);
			}
		}
	}

	public void CleanupMarker()
	{
		if ((bool)xMarker)
		{
			xMarker.Kill();
		}
		xMarker = null;
	}

	public Collider GetCollider()
	{
		if (base.isServer)
		{
			return (!(serverCollider == null)) ? serverCollider : GetComponentInChildren<CapsuleCollider>();
		}
		return (!(clientCollider == null)) ? clientCollider : GetComponent<Collider>();
	}

	public override void OnKilled(HitInfo info)
	{
		if (isKilled)
		{
			return;
		}
		isKilled = true;
		CleanupMarker();
		if (fallOnKilled)
		{
			Collider collider = GetCollider();
			if ((bool)collider)
			{
				collider.enabled = false;
			}
			ClientRPC(null, "TreeFall", info.attackNormal);
			Invoke(DelayedKill, fallDuration + 1f);
		}
		else
		{
			DelayedKill();
		}
	}

	public void DelayedKill()
	{
		Kill();
	}
}
