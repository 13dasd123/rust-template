using System;
using ConVar;
using Network;
using UnityEngine;

public class TreeEntity : ResourceEntity, IPrefabPreProcess
{
	public static ListHashSet<TreeEntity> activeTreeList = new ListHashSet<TreeEntity>();

	public GameObjectRef prefab;

	public bool hasBonusGame = true;

	public GameObjectRef bonusHitEffect;

	public GameObjectRef bonusHitSound;

	public Collider serverCollider;

	public Collider clientCollider;

	public TreeMarkerData MarkerData;

	public SoundDefinition smallCrackSoundDef;

	public SoundDefinition medCrackSoundDef;

	private float lastAttackDamage;

	[NonSerialized]
	public BaseEntity xMarker;

	private int currentBonusLevel;

	private float lastDirection = -1f;

	private float lastHitTime;

	private int lastHitMarkerIndex = -1;

	[Header("Falling")]
	public bool fallOnKilled = true;

	public float fallDuration = 1.5f;

	public GameObjectRef fallStartSound;

	public GameObjectRef fallImpactSound;

	public GameObjectRef fallImpactParticles;

	public SoundDefinition fallLeavesLoopDef;

	[NonSerialized]
	public bool[] usedHeights = new bool[20];

	public bool impactSoundPlayed;

	[NonSerialized]
	public float treeDistanceUponFalling;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("TreeEntity.OnRpcMessage"))
		{
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override float BoundsPadding()
	{
		return 1f;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		lastDirection = ((UnityEngine.Random.Range(0, 2) != 0) ? 1 : (-1));
		activeTreeList.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		activeTreeList.Remove(this);
		CleanupMarker();
		TreeManager.OnTreeDestroyed(this);
	}

	public bool DidHitMarker(HitInfo info)
	{
		if (xMarker == null)
		{
			return false;
		}
		if (MarkerData != null)
		{
			if (new Bounds(xMarker.transform.position, Vector3.one * 0.2f).Contains(info.HitPositionWorld))
			{
				return true;
			}
		}
		else
		{
			Vector3 lhs = Vector3Ex.Direction2D(base.transform.position, xMarker.transform.position);
			if (MarkerData != null)
			{
				lhs = xMarker.transform.forward;
			}
			Vector3 attackNormal = info.attackNormal;
			float num = Vector3.Dot(lhs, attackNormal);
			float num2 = Vector3.Distance(xMarker.transform.position, info.HitPositionWorld);
			if (num >= 0.3f && num2 <= 0.2f)
			{
				return true;
			}
		}
		return false;
	}

	public void StartBonusGame()
	{
		if (IsInvoking(StopBonusGame))
		{
			CancelInvoke(StopBonusGame);
		}
		Invoke(StopBonusGame, 60f);
	}

	public void StopBonusGame()
	{
		CleanupMarker();
		lastHitTime = 0f;
		currentBonusLevel = 0;
	}

	public bool BonusActive()
	{
		return xMarker != null;
	}

	public override void OnAttacked(HitInfo info)
	{
		bool canGather = info.CanGather;
		float num = UnityEngine.Time.time - lastHitTime;
		lastHitTime = UnityEngine.Time.time;
		if (!hasBonusGame || !canGather || info.Initiator == null || (BonusActive() && !DidHitMarker(info)))
		{
			base.OnAttacked(info);
			return;
		}
		if (xMarker != null && !info.DidGather && info.gatherScale > 0f)
		{
			xMarker.ClientRPC(null, "MarkerHit", currentBonusLevel);
			currentBonusLevel++;
			info.gatherScale = 1f + Mathf.Clamp((float)currentBonusLevel * 0.125f, 0f, 1f);
		}
		Vector3 aimFrom = ((xMarker != null) ? xMarker.transform.position : info.HitPositionWorld);
		CleanupMarker();
		Vector3 vector = Vector3Ex.Direction2D(base.transform.position, aimFrom);
		Vector3 vector2 = Vector3.Cross(vector, Vector3.up);
		float num2 = lastDirection;
		float num3 = UnityEngine.Random.Range(0.5f, 0.5f);
		if (MarkerData != null)
		{
			num3 += UnityEngine.Random.Range(0f, 0.25f);
		}
		Vector3 vector3 = Vector3.Lerp(-vector, vector2 * num2, num3);
		Vector3 position = base.transform.InverseTransformDirection(vector3.normalized) * 2.5f;
		position = base.transform.InverseTransformPoint(GetCollider().ClosestPoint(base.transform.TransformPoint(position)));
		Vector3 aimFrom2 = base.transform.TransformPoint(position);
		position.y = base.transform.InverseTransformPoint(info.HitPositionWorld).y;
		Vector3 vector4 = base.transform.InverseTransformPoint(info.Initiator.CenterPoint());
		float min = Mathf.Max(0.75f, vector4.y);
		float max = vector4.y + 0.5f;
		position.y = Mathf.Clamp(position.y + UnityEngine.Random.Range(0.1f, 0.2f) * ((UnityEngine.Random.Range(0, 2) == 0) ? (-1f) : 1f), min, max);
		Vector3 vector5 = Vector3Ex.Direction2D(base.transform.position, aimFrom2);
		Vector3 vector6 = vector5;
		vector5 = base.transform.InverseTransformDirection(vector5);
		Quaternion quaternion = QuaternionEx.LookRotationNormal(-vector5, Vector3.zero);
		position = base.transform.TransformPoint(position);
		quaternion = QuaternionEx.LookRotationNormal(-vector6, Vector3.zero);
		position = GetCollider().ClosestPoint(position);
		if (MarkerData != null)
		{
			position = MarkerData.ClampToClosestPointInLocalSpace(base.transform.InverseTransformPoint(position) + UnityEngine.Random.insideUnitSphere * 0.25f, lastHitMarkerIndex, out var normal, out lastHitMarkerIndex);
			position = base.transform.TransformPoint(position);
			quaternion = QuaternionEx.LookRotationNormal(base.transform.TransformDirection(normal));
		}
		else
		{
			quaternion = QuaternionEx.LookRotationNormal(-Vector3Ex.Direction(new Line(GetCollider().transform.TransformPoint(new Vector3(0f, 10f, 0f)), GetCollider().transform.TransformPoint(new Vector3(0f, -10f, 0f))).ClosestPoint(position), position));
		}
		if (MarkerData != null)
		{
			xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking_nospherecast.prefab", position, quaternion);
		}
		else
		{
			xMarker = GameManager.server.CreateEntity("assets/content/nature/treesprefabs/trees/effects/tree_marking.prefab", position, quaternion);
		}
		xMarker.Spawn();
		if (num > 5f)
		{
			StartBonusGame();
		}
		base.OnAttacked(info);
		if (health > 0f)
		{
			lastAttackDamage = info.damageTypes.Total();
			int num4 = Mathf.CeilToInt(health / lastAttackDamage);
			if (num4 < 2)
			{
				ClientRPC(null, "CrackSound", 1);
			}
			else if (num4 < 5)
			{
				ClientRPC(null, "CrackSound", 0);
			}
		}
	}

	public void CleanupMarker()
	{
		if ((bool)xMarker)
		{
			xMarker.Kill();
		}
		xMarker = null;
	}

	public Collider GetCollider()
	{
		if (base.isServer)
		{
			if (!(serverCollider == null))
			{
				return serverCollider;
			}
			return GetComponentInChildren<CapsuleCollider>();
		}
		if (!(clientCollider == null))
		{
			return clientCollider;
		}
		return GetComponent<Collider>();
	}

	public override void OnKilled(HitInfo info)
	{
		if (isKilled)
		{
			return;
		}
		isKilled = true;
		CleanupMarker();
		if (fallOnKilled)
		{
			Collider collider = GetCollider();
			if ((bool)collider)
			{
				collider.enabled = false;
			}
			ClientRPC(null, "TreeFall", info.attackNormal);
			Invoke(DelayedKill, fallDuration + 1f);
		}
		else
		{
			DelayedKill();
		}
	}

	public void DelayedKill()
	{
		Kill();
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (serverside)
		{
			globalBroadcast = ConVar.Tree.global_broadcast;
		}
	}
}
