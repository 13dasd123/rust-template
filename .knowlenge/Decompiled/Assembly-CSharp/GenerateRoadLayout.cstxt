using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRoadLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public TerrainPathConnect target;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;

		public TerrainPathConnect origin;

		public TerrainPathConnect target;
	}

	public const float Width = 10f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 8f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = -0f;

	public const float TerrainOffset = -0.5f;

	private const int MaxDepth = 100000;

	public override void Process(uint seed)
	{
		List<PathList> list = new List<PathList>();
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		List<MonumentInfo> monuments = TerrainMeta.Path.Monuments;
		if (monuments.Count == 0)
		{
			return;
		}
		int num = Mathf.NextPowerOfTwo((int)((float)World.Size / 10f));
		int[,] array = new int[num, num];
		float radius = 5f;
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				int num2 = SeedRandom.Range(ref seed, 100, 500);
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int num3 = 2295686;
				int num4 = 49152;
				if (slope > 20f || (topology & num3) != 0)
				{
					array[i, j] = int.MaxValue;
				}
				else if ((topology & num4) != 0)
				{
					array[i, j] = 2500;
				}
				else
				{
					array[i, j] = 1 + (int)(slope * slope * 10f) + num2;
				}
			}
		}
		PathFinder pathFinder = new PathFinder(array);
		List<PathSegment> list2 = new List<PathSegment>();
		List<PathNode> list3 = new List<PathNode>();
		List<PathNode> list4 = new List<PathNode>();
		List<PathFinder.Point> list5 = new List<PathFinder.Point>();
		List<PathFinder.Point> list6 = new List<PathFinder.Point>();
		List<PathFinder.Point> list7 = new List<PathFinder.Point>();
		foreach (MonumentInfo item in monuments)
		{
			bool flag = list3.Count == 0;
			foreach (TerrainPathConnect target2 in item.GetTargets(InfrastructureType.Road))
			{
				PathFinder.Point point = target2.GetPoint(num);
				PathFinder.Node node = pathFinder.FindClosestWalkable(point, 100000);
				if (node != null)
				{
					PathNode pathNode = new PathNode();
					pathNode.monument = item;
					pathNode.target = target2;
					pathNode.node = node;
					if (flag)
					{
						list3.Add(pathNode);
					}
					else
					{
						list4.Add(pathNode);
					}
				}
			}
		}
		while (list4.Count != 0)
		{
			list6.Clear();
			list7.Clear();
			list6.AddRange(list3.Select((PathNode x) => x.node.point));
			list6.AddRange(list5);
			list7.AddRange(list4.Select((PathNode x) => x.node.point));
			PathFinder.Node node2 = pathFinder.FindPathUndirected(list6, list7, 100000);
			if (node2 == null)
			{
				PathNode copy = list4[0];
				list3.AddRange(list4.Where((PathNode x) => x.monument == copy.monument));
				list4.RemoveAll((PathNode x) => x.monument == copy.monument);
				continue;
			}
			PathSegment segment = new PathSegment();
			for (PathFinder.Node node3 = node2; node3 != null; node3 = node3.next)
			{
				if (node3 == node2)
				{
					segment.start = node3;
				}
				if (node3.next == null)
				{
					segment.end = node3;
				}
			}
			list2.Add(segment);
			PathNode copy2 = list4.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
			list3.AddRange(list4.Where((PathNode x) => x.monument == copy2.monument));
			list4.RemoveAll((PathNode x) => x.monument == copy2.monument);
			int num5 = 1;
			for (PathFinder.Node node4 = node2; node4 != null; node4 = node4.next)
			{
				if (num5 % 8 == 0)
				{
					list5.Add(node4.point);
				}
				num5++;
			}
		}
		foreach (PathNode target in list3)
		{
			PathSegment pathSegment = list2.Find((PathSegment x) => x.start.point == target.node.point || x.end.point == target.node.point);
			if (pathSegment != null)
			{
				if (pathSegment.start.point == target.node.point)
				{
					PathFinder.Node node5 = target.node;
					PathFinder.Node start = pathFinder.Reverse(target.node);
					node5.next = pathSegment.start;
					pathSegment.start = start;
					pathSegment.origin = target.target;
				}
				else if (pathSegment.end.point == target.node.point)
				{
					pathSegment.end.next = target.node;
					pathSegment.end = pathFinder.FindEnd(target.node);
					pathSegment.target = target.target;
				}
			}
		}
		List<Vector3> list8 = new List<Vector3>();
		foreach (PathSegment item2 in list2)
		{
			bool start2 = false;
			bool end = false;
			for (PathFinder.Node node6 = item2.start; node6 != null; node6 = node6.next)
			{
				float normX2 = ((float)node6.point.x + 0.5f) / (float)num;
				float normZ2 = ((float)node6.point.y + 0.5f) / (float)num;
				if (item2.start == node6 && item2.origin != null)
				{
					start2 = true;
					normX2 = TerrainMeta.NormalizeX(item2.origin.transform.position.x);
					normZ2 = TerrainMeta.NormalizeZ(item2.origin.transform.position.z);
				}
				else if (item2.end == node6 && item2.target != null)
				{
					end = true;
					normX2 = TerrainMeta.NormalizeX(item2.target.transform.position.x);
					normZ2 = TerrainMeta.NormalizeZ(item2.target.transform.position.z);
				}
				float x2 = TerrainMeta.DenormalizeX(normX2);
				float z = TerrainMeta.DenormalizeZ(normZ2);
				float y = Mathf.Max(heightMap.GetHeight(normX2, normZ2), 1f);
				list8.Add(new Vector3(x2, y, z));
			}
			if (list8.Count != 0)
			{
				if (list8.Count >= 2)
				{
					PathList pathList = new PathList("Road " + list.Count, list8.ToArray());
					pathList.Width = 10f;
					pathList.InnerPadding = 1f;
					pathList.OuterPadding = 1f;
					pathList.InnerFade = 1f;
					pathList.OuterFade = 8f;
					pathList.RandomScale = 0.75f;
					pathList.MeshOffset = -0f;
					pathList.TerrainOffset = -0.5f;
					pathList.Topology = 2048;
					pathList.Splat = 128;
					pathList.Start = start2;
					pathList.End = end;
					list.Add(pathList);
				}
				list8.Clear();
			}
		}
		foreach (PathList item3 in list)
		{
			item3.Path.Smoothen(2);
		}
		TerrainMeta.Path.Roads.AddRange(list);
	}
}
