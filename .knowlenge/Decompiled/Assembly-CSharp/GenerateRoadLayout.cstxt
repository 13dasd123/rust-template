using System.Collections.Generic;
using UnityEngine;

public class GenerateRoadLayout : ProceduralComponent
{
	public const float DefaultWidth = 12f;

	public const float DefaultOffset = -1.5f;

	public const float DefaultPadding = 5f;

	public const float DefaultFade = 10f;

	public float Width = 12f;

	public float Offset = -1.5f;

	public float Padding = 5f;

	public float Fade = 10f;

	public override void Process(uint seed)
	{
		List<PathList> roads = new List<PathList>();
		List<PathList> bridges = new List<PathList>();
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		List<TerrainPathConnect> targets = TerrainMeta.Path.GetTargets(InfrastructureType.Road);
		if (targets.Count == 0)
		{
			return;
		}
		int num = Mathf.NextPowerOfTwo((int)((float)World.Size / Width));
		float normfac = 1f / (float)(num - 1);
		List<PathFinder.Point> points = new List<PathFinder.Point>();
		foreach (TerrainPathConnect item3 in targets)
		{
			Vector3 position = item3.transform.position;
			float num2 = TerrainMeta.NormalizeX(position.x);
			float num3 = TerrainMeta.NormalizeZ(position.z);
			PathFinder.Point point = default(PathFinder.Point);
			point.x = Mathf.Clamp((int)(num2 * (float)num), 0, num - 1);
			point.y = Mathf.Clamp((int)(num3 * (float)num), 0, num - 1);
			PathFinder.Point item = point;
			points.Add(item);
		}
		int[,] costmap = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = (float)i * normfac;
			for (int k = 0; k < num; k++)
			{
				float normX = (float)k * normfac;
				int num4 = SeedRandom.Range(ref seed, 0, 500);
				float slope = heightmap.GetSlope(normX, normZ);
				int topology = topomap.GetTopology(normX, normZ);
				if (slope > 20f || (topology & 0x30386) != 0)
				{
					costmap[i, k] = int.MaxValue;
				}
				else if ((topology & 0xC000) != 0)
				{
					costmap[i, k] = 2500;
				}
				else
				{
					costmap[i, k] = 1 + (int)(slope * slope * 10f) + num4;
				}
			}
		}
		PathFinder.Node[,] pathMatrix = new PathFinder.Node[points.Count, points.Count];
		Parallel.For(0, points.Count, delegate(int j)
		{
			PathFinder pathFinder = new PathFinder(costmap);
			for (int l = 0; l < points.Count; l++)
			{
				if (l != j)
				{
					PathFinder.Node node = pathFinder.FindPath(points[j], points[l], 25000);
					if (node != null)
					{
						pathMatrix[j, l] = node;
					}
				}
			}
		});
		SpanningTree<PathFinder.Node> spanningTree = new SpanningTree<PathFinder.Node>();
		for (int m = 0; m < points.Count; m++)
		{
			spanningTree.AddNode();
		}
		for (int n = 0; n < points.Count; n++)
		{
			for (int num5 = 0; num5 < points.Count; num5++)
			{
				PathFinder.Node node2 = pathMatrix[n, num5];
				if (node2 != null)
				{
					spanningTree.AddEdge(n, num5, node2.cost, node2);
				}
			}
		}
		spanningTree.CalculateMin();
		bool[,] pathmap = new bool[num, num];
		List<Vector3> road = new List<Vector3>();
		List<Vector3> bridge = new List<Vector3>();
		List<Vector3> temp = new List<Vector3>();
		spanningTree.ForEach(delegate(PathFinder.Node first)
		{
			bool flag = false;
			PathList pathList = null;
			PathList pathList2 = null;
			PathList pathList3 = null;
			PathList pathList4 = null;
			for (PathFinder.Node node3 = first; node3 != null; node3 = node3.next)
			{
				float num6 = (float)node3.point.x * normfac;
				float num7 = (float)node3.point.y * normfac;
				float height = heightmap.GetHeight01(num6, num7);
				Vector3 item2 = TerrainMeta.Denormalize(new Vector3(num6, height, num7));
				int topology2 = topomap.GetTopology(num6, num7);
				if ((topology2 & 0x400) != 0)
				{
					if (temp.Count != 0)
					{
						if (bridge.Count != 0)
						{
							bridge.AddRange(temp);
						}
						else
						{
							road.AddRange(temp);
						}
						temp.Clear();
					}
					if (road.Count != 0)
					{
						if (road.Count >= 2)
						{
							PathList pathList5 = new PathList("Road " + roads.Count, road.ToArray(), Width, Offset, Padding, Fade, 2048, 1);
							roads.Add(pathList5);
							if (pathList == null)
							{
								pathList = pathList5;
							}
							pathList2 = pathList5;
						}
						road.Clear();
					}
					if (bridge.Count != 0)
					{
						if (bridge.Count >= 2)
						{
							PathList pathList6 = new PathList("Bridge " + bridges.Count, bridge.ToArray(), Width, Offset, Padding, Fade, 8192);
							bridges.Add(pathList6);
							if (pathList3 == null)
							{
								pathList3 = pathList6;
							}
							pathList4 = pathList6;
						}
						bridge.Clear();
					}
				}
				else if ((topology2 & 0x14080) != 0)
				{
					if (temp.Count != 0)
					{
						bridge.AddRange(temp);
						temp.Clear();
					}
					bridge.Add(item2);
					if (road.Count != 0)
					{
						if (road.Count >= 2)
						{
							PathList pathList7 = new PathList("Road " + roads.Count, road.ToArray(), Width, Offset, Padding, Fade, 2048, 1);
							roads.Add(pathList7);
							if (pathList == null)
							{
								pathList = pathList7;
							}
							pathList2 = pathList7;
						}
						road.Clear();
					}
				}
				else if ((topology2 & 0x28100) != 0)
				{
					temp.Add(item2);
				}
				else
				{
					if (temp.Count != 0)
					{
						if (bridge.Count != 0)
						{
							bridge.AddRange(temp);
						}
						else
						{
							road.AddRange(temp);
						}
						temp.Clear();
					}
					road.Add(item2);
					if (bridge.Count != 0)
					{
						if (bridge.Count >= 2)
						{
							PathList pathList8 = new PathList("Bridge " + bridges.Count, bridge.ToArray(), Width, Offset, Padding, Fade, 8192);
							bridges.Add(pathList8);
							if (pathList3 == null)
							{
								pathList3 = pathList8;
							}
							pathList4 = pathList8;
						}
						bridge.Clear();
					}
				}
				if (pathmap[node3.point.y, node3.point.x])
				{
					if ((topology2 & 0x400) == 0)
					{
						flag = true;
					}
					break;
				}
				pathmap[node3.point.y, node3.point.x] = true;
			}
			if (temp.Count != 0)
			{
				if (bridge.Count != 0)
				{
					bridge.AddRange(temp);
				}
				else
				{
					road.AddRange(temp);
				}
				temp.Clear();
			}
			if (road.Count != 0)
			{
				if (road.Count >= 2)
				{
					PathList pathList9 = new PathList("Road " + roads.Count, road.ToArray(), Width, Offset, Padding, Fade, 2048, 1);
					roads.Add(pathList9);
					if (pathList == null)
					{
						pathList = pathList9;
					}
					pathList2 = pathList9;
				}
				road.Clear();
			}
			if (bridge.Count != 0)
			{
				if (bridge.Count >= 2)
				{
					PathList pathList10 = new PathList("Bridge " + bridges.Count, bridge.ToArray(), Width, Offset, Padding, Fade, 8192);
					bridges.Add(pathList10);
					if (pathList3 == null)
					{
						pathList3 = pathList10;
					}
					pathList4 = pathList10;
				}
				bridge.Clear();
			}
			if (flag)
			{
				pathList2 = null;
				pathList4 = null;
			}
			if (pathList != null)
			{
				pathList.Start = true;
			}
			if (pathList2 != null)
			{
				pathList2.End = true;
			}
			if (pathList3 != null)
			{
				pathList3.Start = true;
			}
			if (pathList4 != null)
			{
				pathList4.End = true;
			}
		});
		foreach (PathList item4 in roads)
		{
			item4.Path.Smoothen(2);
		}
		TerrainMeta.Path.Roads.AddRange(roads);
		TerrainMeta.Path.Bridges.AddRange(bridges);
		roads = TerrainMeta.Path.Roads;
		bridges = TerrainMeta.Path.Bridges;
		foreach (PathList item5 in roads)
		{
			item5.Scaling = 0.75f;
		}
		foreach (PathList item6 in roads)
		{
			item6.Path.RecalculateTangents();
		}
		foreach (PathList item7 in bridges)
		{
			item7.Path.RecalculateTangents();
		}
		heightmap.Push();
		foreach (PathList item8 in roads)
		{
			item8.AdjustTerrainHeight();
			item8.AdjustTerrainTexture();
			item8.AdjustTerrainTopology();
		}
		foreach (PathList item9 in bridges)
		{
			item9.AdjustTerrainHeight();
			item9.AdjustTerrainTopology();
		}
		heightmap.Pop();
		int[,] map = topomap.dst;
		float fac = 1f / (float)(topomap.res - 1);
		ImageProcessing.Dilate2D(map, 6144, 6, delegate(int x, int y)
		{
			if ((map[x, y] & 0x31) != 0)
			{
				map[x, y] |= 4096;
			}
			float normX2 = (float)x * fac;
			float normZ2 = (float)y * fac;
			if (heightmap.GetSlope(normX2, normZ2) > 40f)
			{
				map[x, y] |= 2;
			}
		});
	}
}
