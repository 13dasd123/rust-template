using System.Collections.Generic;
using UnityEngine;

public class GeneratePowerlineLayout : ProceduralComponent
{
	public override void Process(uint seed)
	{
		List<PathList> powerlines = new List<PathList>();
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		List<TerrainPathConnect> targets = TerrainMeta.Path.GetTargets(InfrastructureType.Power);
		if (targets.Count == 0)
		{
			return;
		}
		int num = Mathf.NextPowerOfTwo((int)(World.Size / 10));
		float normfac = 1f / (float)(num - 1);
		List<PathFinder.Point> points = new List<PathFinder.Point>();
		foreach (TerrainPathConnect item3 in targets)
		{
			Vector3 position = item3.transform.position;
			float num2 = TerrainMeta.NormalizeX(position.x);
			float num3 = TerrainMeta.NormalizeZ(position.z);
			PathFinder.Point point = default(PathFinder.Point);
			point.x = Mathf.Clamp((int)(num2 * (float)num), 0, num - 1);
			point.y = Mathf.Clamp((int)(num3 * (float)num), 0, num - 1);
			PathFinder.Point item = point;
			points.Add(item);
		}
		int[,] costmap = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = (float)i * normfac;
			for (int k = 0; k < num; k++)
			{
				float normX = (float)k * normfac;
				float slope = heightmap.GetSlope(normX, normZ);
				int topology = topomap.GetTopology(normX, normZ);
				if ((topology & 0x30186) != 0)
				{
					costmap[i, k] = int.MaxValue;
				}
				else if ((topology & 0xD800) != 0)
				{
					costmap[i, k] = 2500;
				}
				else if ((topology & 0x200) != 0)
				{
					costmap[i, k] = 1000;
				}
				else
				{
					costmap[i, k] = 1 + (int)(slope * slope);
				}
			}
		}
		PathFinder.Node[,] pathMatrix = new PathFinder.Node[points.Count, points.Count];
		Parallel.For(0, points.Count, delegate(int j)
		{
			PathFinder pathFinder = new PathFinder(costmap);
			for (int l = 0; l < points.Count; l++)
			{
				if (l != j)
				{
					PathFinder.Node node = pathFinder.FindPath(points[j], points[l], 25000);
					if (node != null)
					{
						pathMatrix[j, l] = node;
					}
				}
			}
		});
		SpanningTree<PathFinder.Node> spanningTree = new SpanningTree<PathFinder.Node>();
		for (int m = 0; m < points.Count; m++)
		{
			spanningTree.AddNode();
		}
		for (int n = 0; n < points.Count; n++)
		{
			for (int num4 = 0; num4 < points.Count; num4++)
			{
				PathFinder.Node node2 = pathMatrix[n, num4];
				if (node2 != null)
				{
					spanningTree.AddEdge(n, num4, node2.cost, node2);
				}
			}
		}
		spanningTree.CalculateMin();
		bool[,] pathmap = new bool[num, num];
		List<Vector3> powerline = new List<Vector3>();
		spanningTree.ForEach(delegate(PathFinder.Node first)
		{
			bool flag = false;
			PathList pathList = null;
			PathList pathList2 = null;
			for (PathFinder.Node node3 = first; node3 != null; node3 = node3.next)
			{
				float num5 = (float)node3.point.x * normfac;
				float num6 = (float)node3.point.y * normfac;
				float height = heightmap.GetHeight01(num5, num6);
				Vector3 item2 = TerrainMeta.Denormalize(new Vector3(num5, height, num6));
				int topology2 = topomap.GetTopology(num5, num6);
				if ((topology2 & 0x400) != 0)
				{
					if (powerline.Count != 0)
					{
						if (powerline.Count >= 8)
						{
							PathList pathList3 = new PathList("Powerline " + powerlines.Count, powerline.ToArray());
							powerlines.Add(pathList3);
							if (pathList == null)
							{
								pathList = pathList3;
							}
							pathList2 = pathList3;
						}
						powerline.Clear();
					}
				}
				else
				{
					powerline.Add(item2);
				}
				if (pathmap[node3.point.y, node3.point.x])
				{
					if ((topology2 & 0x400) == 0)
					{
						flag = true;
					}
					break;
				}
				pathmap[node3.point.y, node3.point.x] = true;
			}
			if (powerline.Count != 0)
			{
				if (powerline.Count >= 8)
				{
					PathList pathList4 = new PathList("Powerline " + powerlines.Count, powerline.ToArray());
					powerlines.Add(pathList4);
					if (pathList == null)
					{
						pathList = pathList4;
					}
					pathList2 = pathList4;
				}
				powerline.Clear();
			}
			if (flag)
			{
				pathList2 = null;
			}
			if (pathList != null)
			{
				pathList.Start = true;
			}
			if (pathList2 != null)
			{
				pathList2.End = true;
			}
		});
		TerrainMeta.Path.Powerlines.AddRange(powerlines);
		powerlines = TerrainMeta.Path.Powerlines;
		foreach (PathList item4 in powerlines)
		{
			item4.Path.RecalculateTangents();
		}
	}
}
