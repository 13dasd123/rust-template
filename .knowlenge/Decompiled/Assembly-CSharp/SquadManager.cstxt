using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai;
using UnityEngine;

public class SquadManager : FacepunchBehaviour
{
	public enum ActionCallbackEnum
	{
		FleeExplosion,
		TakeCover,
		Aggro,
		Chatter,
		Death,
		RespondDeath,
		RespondOk,
		Reload
	}

	public GameObjectRef FleeExplosionEffect;

	public GameObjectRef TakeCoverEffect;

	public GameObjectRef AggroEffect;

	public GameObjectRef ChatterEffect;

	public GameObjectRef DeathEffect;

	public GameObjectRef RespondDeathEffect;

	public GameObjectRef RespondOkEffect;

	public GameObjectRef ReloadEffect;

	private readonly float[] ActionCallbackTimers = new float[Enum.GetValues(typeof(ActionCallbackEnum)).Length];

	public List<SquadMember> SquadlessMembers = new List<SquadMember>();

	public List<Squad> Squads = new List<Squad>();

	public List<Squad> DisbandingSquads = new List<Squad>();

	[ReadOnly]
	public bool IsTicking;

	public Transform CoverPointGroup;

	public Transform PatrolPointGroup;

	private List<PathInterestNode> patrolPoints;

	[ServerVar(Help = "squad_tick_rate defines how often we tick a squad to manage its members. (default: 0.5)")]
	public static float squad_tick_rate = 0.5f;

	[ServerVar(Help = "squad_radius defines the max distance from the squad center a unit can be to be considered a member. (default: 15)")]
	public static float squad_radius = 15f;

	[ServerVar(Help = "squad_min_delay_individual_speak defines the minimum interval between each time a single individual is allowed to speak. (default: 5)")]
	public static float squad_min_delay_individual_speak = 5f;

	[ServerVar(Help = "squad_min_delay_topic_speak defines the minimum interval between each time a topic is allowed to be spoken about. (default: 11)")]
	public static float squad_min_delay_topic_speak = 11f;

	[ServerVar(Help = "If squad_disable is set to true then squads won't spawn.. which means there will not spawn any scientists. (default: true)")]
	public static bool squad_disable = true;

	[ServerVar(Help = "squad_max_population_military_tunnels defines the size of the squad population at military tunnels. (default: 10)")]
	public static int squad_max_population_military_tunnels = 10;

	[ServerVar(Help = "squad_spawn_per_tick_max_military_tunnels defines how many can maximum spawn at once at military tunnels. (default: 4)")]
	public static int squad_spawn_per_tick_max_military_tunnels = 4;

	[ServerVar(Help = "squad_spawn_per_tick_min_military_tunnels defineshow many will minimum spawn at once at military tunnels. (default: 2)")]
	public static int squad_spawn_per_tick_min_military_tunnels = 2;

	[ServerVar(Help = "squad_respawn_delay_max_military_tunnels defines the maximum delay between spawn ticks at military tunnels. (default: 480)")]
	public static float squad_respawn_delay_max_military_tunnels = 480f;

	[ServerVar(Help = "squad_respawn_delay_min_military_tunnels defines the minimum delay between spawn ticks at military tunnels. (default: 240)")]
	public static float squad_respawn_delay_min_military_tunnels = 240f;

	[ServerVar(Help = "If squad_try_spawn_intelligently is set to true then squads will try to prevent spawning right next to players.")]
	public static bool squad_try_spawn_intelligently = true;

	[ServerVar(Help = "squad_valid_aim_cone defines how close their aim needs to be on target in order to fire. (default: 5)")]
	public static float squad_valid_aim_cone = 0.8f;

	[ServerVar(Help = "squad_cover_compromised_cooldown defines how long a cover point is marked as compromised before it's cleared again for selection. (default: 10)")]
	public static float squad_cover_compromised_cooldown = 10f;

	[ServerVar(Help = "If squad_cover_use_path_distance is set to true then squads will look at the distance between the cover point and their target using the path between the two, rather than the straight-line distance.")]
	public static bool squad_cover_use_path_distance = true;

	[ServerVar(Help = "squad_cover_path_vs_straight_dist_max_diff defines what the maximum difference between straight-line distance and path distance can be when evaluating cover points. (default: 2)")]
	public static float squad_cover_path_vs_straight_dist_max_diff = 2f;

	[ServerVar(Help = "squad_door_trigger_size defines the size of the trigger box on doors that opens the door as NPCs walk close to it (default: 1.5)")]
	public static float squad_door_trigger_size = 1.5f;

	public void Tick()
	{
		if (!IsTicking)
		{
			IsTicking = true;
		}
		foreach (Squad squad in Squads)
		{
			if (squad.Members.Count == 0)
			{
				continue;
			}
			foreach (Squad squad2 in Squads)
			{
				if (squad == squad2 || squad2.Members.Count == 0 || !squad.Bounds.Intersects(squad2.Bounds))
				{
					continue;
				}
				foreach (SquadMember member in squad2.Members)
				{
					if (!(member.Entity == null) && member.Entity.enabled && !member.Entity.IsDestroyed)
					{
						squad.Members.Add(member);
					}
				}
				squad2.Members.Clear();
				DisbandingSquads.Add(squad2);
			}
		}
		foreach (Squad squad3 in Squads)
		{
			squad3.Tick();
			foreach (SquadMember member2 in squad3.Members)
			{
				if (!(member2.Entity == null) && member2.Entity.enabled && !member2.Entity.IsDestroyed && Vector3.Distance(squad3.Position, member2.transform.position) > squad_radius)
				{
					squad3.PendingRemoval.Add(member2);
				}
			}
		}
		foreach (Squad squad4 in Squads)
		{
			foreach (SquadMember item in squad4.PendingRemoval)
			{
				LeaveSquad(squad4, item);
			}
			squad4.PendingRemoval.Clear();
		}
		foreach (Squad disbandingSquad in DisbandingSquads)
		{
			if (disbandingSquad.Members.Count == 0)
			{
				DisbandSquad(disbandingSquad);
			}
		}
		DisbandingSquads.Clear();
		if (SquadlessMembers.Count > 0)
		{
			List<SquadMember> obj = null;
			foreach (SquadMember squadlessMember in SquadlessMembers)
			{
				if (squadlessMember.Entity == null || !squadlessMember.Entity.enabled || squadlessMember.Entity.IsDestroyed)
				{
					continue;
				}
				foreach (Squad squad5 in Squads)
				{
					if (Vector3.Distance(squad5.Position, squadlessMember.transform.position) <= squad_radius)
					{
						EnterSquad(squad5, squadlessMember);
						if (obj == null)
						{
							obj = Pool.GetList<SquadMember>();
						}
						obj.Add(squadlessMember);
					}
				}
			}
			if (obj != null)
			{
				foreach (SquadMember item2 in obj)
				{
					SquadlessMembers.Remove(item2);
				}
				Pool.FreeList(ref obj);
			}
		}
		foreach (Squad squad6 in Squads)
		{
			squad6.UpdateNearbyEnemies();
		}
	}

	public void Add(SquadMember member)
	{
		foreach (Squad squad2 in Squads)
		{
			if (Vector3.Distance(squad2.Position, member.transform.position) <= squad_radius)
			{
				EnterSquad(squad2, member);
				return;
			}
		}
		Squad squad = Pool.Get<Squad>();
		squad.Manager = this;
		EnterSquad(squad, member);
		Squads.Add(squad);
		if (!IsTicking)
		{
			IsTicking = true;
			InvokeRandomized(Tick, 0f, squad_tick_rate, 0.1f);
		}
	}

	public void Remove(SquadMember member)
	{
		if (member.Squad != null)
		{
			LeaveSquad(member.Squad, member);
		}
	}

	private void EnterSquad(Squad squad, SquadMember member)
	{
		squad.Members.Add(member);
		squad.Tick();
		member.Squad = squad;
	}

	private void LeaveSquad(Squad squad, SquadMember member)
	{
		squad.Members.Remove(member);
		if (squad.Members.Count > 0)
		{
			squad.Tick();
		}
		else
		{
			DisbandingSquads.Add(squad);
		}
		if (!(member.Entity == null) && member.Entity.enabled && !member.Entity.IsDestroyed)
		{
			member.Squad = null;
			SquadlessMembers.Add(member);
		}
	}

	private void DisbandSquad(Squad squad)
	{
		Squads.Remove(squad);
		squad.Manager = null;
		Pool.Free(ref squad);
		if (Squads.Count == 0 && IsTicking)
		{
			IsTicking = false;
			CancelInvoke(Tick);
		}
	}

	public Squad GetSquadClosestToPoint(Vector3 point, out float distSqr)
	{
		distSqr = float.MaxValue;
		Squad result = null;
		foreach (Squad squad in Squads)
		{
			float sqrMagnitude = (point - squad.Position).sqrMagnitude;
			if (sqrMagnitude < distSqr)
			{
				distSqr = sqrMagnitude;
				result = squad;
			}
		}
		return result;
	}

	public void OnActionCallback(ActionCallbackEnum callback, Squad squad, SquadMember member)
	{
		if (squad == null || member.Entity == null || !member.Entity.enabled || member.Entity.IsDestroyed || ActionCallbackTimers[(int)callback] > Time.realtimeSinceStartup)
		{
			return;
		}
		ActionCallbackTimers[(int)callback] = Time.realtimeSinceStartup + squad_min_delay_topic_speak;
		switch (callback)
		{
		case ActionCallbackEnum.FleeExplosion:
			if (FleeExplosionEffect.isValid)
			{
				Effect.server.Run(FleeExplosionEffect.resourcePath, member.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
			}
			break;
		case ActionCallbackEnum.TakeCover:
			if (TakeCoverEffect.isValid)
			{
				Effect.server.Run(TakeCoverEffect.resourcePath, member.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
			}
			break;
		case ActionCallbackEnum.Aggro:
			if (AggroEffect.isValid)
			{
				Effect.server.Run(AggroEffect.resourcePath, member.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				StartCoroutine(RespondOk(squad, member, 1.5f + UnityEngine.Random.value * 2f));
			}
			break;
		case ActionCallbackEnum.Chatter:
			if (ChatterEffect.isValid)
			{
				Effect.server.Run(ChatterEffect.resourcePath, member.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				StartCoroutine(RespondChatter(squad, member, 3f + UnityEngine.Random.value * 2f));
			}
			break;
		case ActionCallbackEnum.Death:
			if (DeathEffect.isValid)
			{
				Effect.server.Run(DeathEffect.resourcePath, member.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				StartCoroutine(RespondDeath(squad, member, 1.5f + UnityEngine.Random.value * 1f));
			}
			break;
		case ActionCallbackEnum.RespondDeath:
			if (RespondDeathEffect.isValid)
			{
				Effect.server.Run(RespondDeathEffect.resourcePath, member.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
			}
			break;
		case ActionCallbackEnum.RespondOk:
			if (RespondOkEffect.isValid)
			{
				Effect.server.Run(RespondOkEffect.resourcePath, member.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
			}
			break;
		case ActionCallbackEnum.Reload:
			if (ReloadEffect.isValid)
			{
				Effect.server.Run(ReloadEffect.resourcePath, member.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
			}
			break;
		}
	}

	public IEnumerator RespondOk(Squad squad, SquadMember member, float delay)
	{
		yield return CoroutineEx.waitForSeconds(delay);
		if (squad.Members.Count <= 1)
		{
			yield break;
		}
		foreach (SquadMember member2 in squad.Members)
		{
			if (member2 == member || member2.Entity == null || !member2.Entity.enabled || member2.Entity.IsDestroyed)
			{
				continue;
			}
			OnActionCallback(ActionCallbackEnum.RespondOk, squad, member2);
			break;
		}
	}

	public IEnumerator RespondDeath(Squad squad, SquadMember member, float delay)
	{
		yield return CoroutineEx.waitForSeconds(delay);
		if (squad.Members.Count <= 1)
		{
			yield break;
		}
		foreach (SquadMember member2 in squad.Members)
		{
			if (member2 == member || member2.Entity == null || !member2.Entity.enabled || member2.Entity.IsDestroyed)
			{
				continue;
			}
			OnActionCallback(ActionCallbackEnum.RespondDeath, squad, member2);
			break;
		}
	}

	public IEnumerator RespondChatter(Squad squad, SquadMember member, float delay)
	{
		float returnChance = 0.5f;
		if (UnityEngine.Random.value > returnChance)
		{
			yield break;
		}
		yield return CoroutineEx.waitForSeconds(delay);
		if (squad.Members.Count <= 1)
		{
			yield break;
		}
		foreach (SquadMember member2 in squad.Members)
		{
			if (member2 == member || member2.Entity == null || !member2.Entity.enabled || member2.Entity.IsDestroyed)
			{
				continue;
			}
			if (ChatterEffect.isValid && UnityEngine.Random.value < 0.75f)
			{
				Effect.server.Run(ChatterEffect.resourcePath, member2.Entity, StringPool.Get("head"), Vector3.zero, Vector3.zero);
			}
			else
			{
				OnActionCallback(ActionCallbackEnum.RespondOk, squad, member2);
			}
			break;
		}
	}

	public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f)
	{
		if (PatrolPointGroup == null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(PatrolPointGroup.GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		foreach (PathInterestNode patrolPoint in patrolPoints)
		{
			float sqrMagnitude = (patrolPoint.transform.position - from).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				return patrolPoint;
			}
		}
		return null;
	}

	public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f)
	{
		if (PatrolPointGroup == null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(PatrolPointGroup.GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		for (int i = 0; i < 20; i++)
		{
			PathInterestNode pathInterestNode = patrolPoints[UnityEngine.Random.Range(0, patrolPoints.Count)];
			float sqrMagnitude = (pathInterestNode.transform.position - from).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				return pathInterestNode;
			}
		}
		return null;
	}
}
