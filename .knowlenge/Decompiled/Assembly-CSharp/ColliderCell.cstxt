using System.Collections;
using ConVar;
using Facepunch;
using UnityEngine;

public class ColliderCell
{
	public Vector3 position;

	public ColliderGrid grid;

	public bool interrupt;

	private ListDictionary<ColliderKey, ColliderGroup> batches = new ListDictionary<ColliderKey, ColliderGroup>();

	public ColliderCell(ColliderGrid grid, Vector3 position)
	{
		this.grid = grid;
		this.position = position;
	}

	public bool NeedsRefresh()
	{
		BufferList<ColliderGroup> values = batches.Values;
		for (int i = 0; i < values.Count; i++)
		{
			if (values[i].NeedsRefresh)
			{
				return true;
			}
		}
		return false;
	}

	public int MeshCount()
	{
		int num = 0;
		BufferList<ColliderGroup> values = batches.Values;
		for (int i = 0; i < values.Count; i++)
		{
			num += values[i].MeshCount();
		}
		return num;
	}

	public int BatchedMeshCount()
	{
		int num = 0;
		BufferList<ColliderGroup> values = batches.Values;
		for (int i = 0; i < values.Count; i++)
		{
			num += values[i].BatchedMeshCount();
		}
		return num;
	}

	public void Refresh()
	{
		interrupt = false;
		BufferList<ColliderGroup> values = batches.Values;
		for (int i = 0; i < values.Count; i++)
		{
			ColliderGroup grp = values[i];
			if (grp.Processing)
			{
				continue;
			}
			if (grp.Count > 0)
			{
				grp.Start();
				if (grp.Processing)
				{
					grp.UpdateData();
					grp.CreateBatches();
					grp.RefreshBatches();
					grp.ApplyBatches();
					grp.DisplayBatches();
				}
				grp.End();
			}
			else
			{
				grp.Clear();
				DestroyColliderGroup(ref grp);
				batches.RemoveAt(i--);
			}
		}
	}

	public IEnumerator RefreshAsync()
	{
		interrupt = false;
		BufferList<ColliderGroup> batchGroups = batches.Values;
		for (int i = 0; i < batchGroups.Count; i++)
		{
			ColliderGroup colliderGroup = batchGroups[i];
			if (colliderGroup.Count > 0)
			{
				colliderGroup.Start();
			}
		}
		for (int j = 0; j < batchGroups.Count; j++)
		{
			if (interrupt)
			{
				break;
			}
			ColliderGroup batchGroup = batchGroups[j];
			if (!batchGroup.Processing)
			{
				continue;
			}
			if (Batching.collider_threading)
			{
				IEnumerator enumerator = batchGroup.UpdateDataAsync();
				while (enumerator.MoveNext())
				{
					yield return enumerator.Current;
				}
				grid.ResetTimeout();
				continue;
			}
			batchGroup.UpdateData();
			if (grid.NeedsTimeout)
			{
				yield return CoroutineEx.waitForEndOfFrame;
				grid.ResetTimeout();
			}
		}
		for (int k = 0; k < batchGroups.Count; k++)
		{
			if (interrupt)
			{
				break;
			}
			ColliderGroup batchGroup2 = batchGroups[k];
			if (batchGroup2.Processing)
			{
				batchGroup2.CreateBatches();
				if (grid.NeedsTimeout)
				{
					yield return CoroutineEx.waitForEndOfFrame;
					grid.ResetTimeout();
				}
			}
		}
		for (int l = 0; l < batchGroups.Count; l++)
		{
			if (interrupt)
			{
				break;
			}
			ColliderGroup batchGroup3 = batchGroups[l];
			if (!batchGroup3.Processing)
			{
				continue;
			}
			if (Batching.collider_threading)
			{
				IEnumerator enumerator2 = batchGroup3.RefreshBatchesAsync();
				while (enumerator2.MoveNext())
				{
					yield return enumerator2.Current;
				}
				grid.ResetTimeout();
				continue;
			}
			batchGroup3.RefreshBatches();
			if (grid.NeedsTimeout)
			{
				yield return CoroutineEx.waitForEndOfFrame;
				grid.ResetTimeout();
			}
		}
		for (int m = 0; m < batchGroups.Count; m++)
		{
			if (interrupt)
			{
				break;
			}
			ColliderGroup batchGroup4 = batchGroups[m];
			if (!batchGroup4.Processing)
			{
				continue;
			}
			for (int n = 0; n < batchGroup4.TempBatches.Count; n++)
			{
				if (interrupt)
				{
					break;
				}
				batchGroup4.TempBatches[n].Apply();
				if (grid.NeedsTimeout)
				{
					yield return CoroutineEx.waitForEndOfFrame;
					grid.ResetTimeout();
				}
			}
		}
		for (int num = 0; num < batchGroups.Count; num++)
		{
			if (interrupt)
			{
				break;
			}
			ColliderGroup colliderGroup2 = batchGroups[num];
			if (colliderGroup2.Processing)
			{
				colliderGroup2.DisplayBatches();
			}
		}
		for (int num2 = 0; num2 < batchGroups.Count; num2++)
		{
			ColliderGroup grp = batchGroups[num2];
			if (grp.Processing || grp.Preserving)
			{
				grp.End();
			}
			else if (grp.Count == 0 && !interrupt)
			{
				grp.Clear();
				DestroyColliderGroup(ref grp);
				batches.RemoveAt(num2--);
			}
		}
	}

	public ColliderGroup FindBatchGroup(ColliderBatch collider)
	{
		ColliderKey key = new ColliderKey(collider);
		if (!batches.TryGetValue(key, out var val))
		{
			val = CreateColliderGroup(grid, this, key);
			batches.Add(key, val);
		}
		return val;
	}

	private ColliderGroup CreateColliderGroup(ColliderGrid grid, ColliderCell cell, ColliderKey key)
	{
		ColliderGroup colliderGroup = Facepunch.Pool.Get<ColliderGroup>();
		colliderGroup.Initialize(grid, cell, key);
		return colliderGroup;
	}

	private void DestroyColliderGroup(ref ColliderGroup grp)
	{
		Facepunch.Pool.Free(ref grp);
	}
}
