using System;

public class PathFinder
{
	public struct Point
	{
		public int x;

		public int y;

		public Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		public static Point operator +(Point a, Point b)
		{
			return new Point(a.x + b.x, a.y + b.y);
		}

		public static Point operator -(Point a, Point b)
		{
			return new Point(a.x - b.x, a.y - b.y);
		}

		public static Point operator *(Point p, int i)
		{
			return new Point(p.x * i, p.y * i);
		}

		public static Point operator /(Point p, int i)
		{
			return new Point(p.x / i, p.y / i);
		}
	}

	public class Node : IMinHeapNode<Node>, ILinkedListNode<Node>
	{
		public Point point;

		public int cost;

		public int heuristic;

		public Node next { get; set; }

		public Node child { get; set; }

		public int order => cost + heuristic;

		public Node(Point point, int cost, int heuristic, Node next = null)
		{
			this.point = point;
			this.cost = cost;
			this.heuristic = heuristic;
			this.next = next;
		}
	}

	private int[,] costmap;

	private bool[,] visited;

	private Point[] neighbors;

	private static Point[] mooreNeighbors = new Point[8]
	{
		new Point(-1, 1),
		new Point(0, 1),
		new Point(1, 1),
		new Point(-1, 0),
		new Point(1, 0),
		new Point(-1, -1),
		new Point(0, -1),
		new Point(1, -1)
	};

	private static Point[] neumannNeighbors = new Point[4]
	{
		new Point(0, 1),
		new Point(-1, 0),
		new Point(1, 0),
		new Point(0, -1)
	};

	public PathFinder(int[,] costmap, bool diagonals = true)
	{
		this.costmap = costmap;
		neighbors = ((!diagonals) ? neumannNeighbors : mooreNeighbors);
	}

	public Node FindPath(Point start, Point end, int depth = int.MaxValue)
	{
		return FindPathReversed(end, start, depth);
	}

	private Node FindPathReversed(Point start, Point end, int depth = int.MaxValue)
	{
		if (visited == null)
		{
			visited = new bool[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		start = FindClosestWalkable(start, end);
		end = FindClosestWalkable(end, start);
		IntrusiveMinHeap<Node> intrusiveMinHeap = default(IntrusiveMinHeap<Node>);
		int cost = costmap[start.y, start.x];
		int heuristic = Heuristic(start, end);
		Node item = new Node(start, cost, heuristic);
		intrusiveMinHeap.Add(item);
		visited[start.y, start.x] = true;
		while (!intrusiveMinHeap.Empty && depth-- > 0)
		{
			Node node = intrusiveMinHeap.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x >= num && point.x <= num2 && point.y >= num3 && point.y <= num4)
				{
					int num5 = costmap[point.y, point.x];
					if (num5 != int.MaxValue && !visited[point.y, point.x])
					{
						visited[point.y, point.x] = true;
						int cost2 = node.cost + num5;
						int heuristic2 = Heuristic(point, end);
						Node item2 = new Node(point, cost2, heuristic2, node);
						intrusiveMinHeap.Add(item2);
					}
				}
			}
		}
		return null;
	}

	public Point FindClosestWalkable(Point start, Point end)
	{
		int num = Heuristic(start, end);
		while (costmap[start.y, start.x] == int.MaxValue)
		{
			Point point = start;
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point2 = point + neighbors[i];
				int num2 = Heuristic(point2, end);
				if (num2 < num)
				{
					start = point2;
					num = num2;
				}
			}
			if (point.x == start.x && point.y == start.y)
			{
				break;
			}
		}
		return start;
	}

	public int Heuristic(Point a, Point b)
	{
		return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
	}
}
