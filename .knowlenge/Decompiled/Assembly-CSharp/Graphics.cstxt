using Rust.Workshop;
using UnityEngine;

[Factory("graphics")]
public class Graphics : ConsoleSystem
{
	private const float MinShadowDistance = 50f;

	private const float MaxShadowDistance2Split = 200f;

	private const float MaxShadowDistance4Split = 1000f;

	private static float _shadowdistance = 1000f;

	[ClientVar(Saved = true)]
	public static int shadowmode = 2;

	[ClientVar(Saved = true)]
	public static int shadowlights = 1;

	[ClientVar(Saved = true)]
	public static bool contactshadows;

	[ClientVar(Saved = true)]
	public static float drawdistance = 2500f;

	private static float _fov = 75f;

	[ClientVar]
	public static bool hud = true;

	[ClientVar(Saved = true)]
	public static bool chat = true;

	[ClientVar(Saved = true)]
	public static bool branding = true;

	[ClientVar(Saved = true)]
	public static bool dof;

	[ClientVar(Saved = true)]
	public static float dof_aper = 12f;

	[ClientVar(Saved = true)]
	public static float dof_blur = 1f;

	private static float _uiscale = 1f;

	private static int _anisotropic = 1;

	private static int _parallax;

	private static bool _lso;

	[ClientVar(Help = "The currently selected quality level")]
	public static int quality
	{
		get
		{
			return QualitySettings.GetQualityLevel();
		}
		set
		{
			QualitySettings.SetQualityLevel(value, applyExpensiveChanges: true);
		}
	}

	[ClientVar(Saved = true)]
	public static float shadowdistance
	{
		get
		{
			return _shadowdistance;
		}
		set
		{
			_shadowdistance = value;
			QualitySettings.shadowDistance = EnforceShadowDistanceBounds(_shadowdistance);
		}
	}

	[ClientVar(Saved = true)]
	public static int shadowcascades
	{
		get
		{
			return QualitySettings.shadowCascades;
		}
		set
		{
			QualitySettings.shadowCascades = value;
			QualitySettings.shadowDistance = EnforceShadowDistanceBounds(shadowdistance);
		}
	}

	[ClientVar(Saved = true)]
	public static float fov
	{
		get
		{
			return _fov;
		}
		set
		{
			_fov = Mathf.Clamp(value, 60f, 90f);
		}
	}

	[ClientVar]
	public static float lodbias
	{
		get
		{
			return QualitySettings.lodBias;
		}
		set
		{
			QualitySettings.lodBias = Mathf.Clamp(value, 0.25f, 5f);
		}
	}

	[ClientVar(Saved = true)]
	public static int shaderlod
	{
		get
		{
			return Shader.globalMaximumLOD;
		}
		set
		{
			Shader.globalMaximumLOD = Mathf.Clamp(value, 100, 600);
		}
	}

	[ClientVar(Saved = true)]
	public static float uiscale
	{
		get
		{
			return _uiscale;
		}
		set
		{
			_uiscale = Mathf.Clamp(value, 0.5f, 1f);
		}
	}

	[ClientVar(Saved = true)]
	public static int af
	{
		get
		{
			return _anisotropic;
		}
		set
		{
			value = Mathf.Clamp(value, 1, 16);
			Texture.SetGlobalAnisotropicFilteringLimits(1, value);
			if (value <= 1)
			{
				Texture.anisotropicFiltering = AnisotropicFiltering.Disable;
			}
			if (value > 1)
			{
				Texture.anisotropicFiltering = AnisotropicFiltering.Enable;
			}
			_anisotropic = value;
		}
	}

	[ClientVar(Saved = true)]
	public static int parallax
	{
		get
		{
			return _parallax;
		}
		set
		{
			switch (value)
			{
			default:
				Shader.DisableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.DisableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			case 1:
				Shader.EnableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.DisableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			case 2:
				Shader.DisableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.EnableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			}
			_parallax = value;
		}
	}

	[ClientVar(Saved = true)]
	public static bool lso
	{
		get
		{
			return _lso;
		}
		set
		{
			_lso = value;
		}
	}

	[ClientVar]
	public static bool itemskins
	{
		get
		{
			return Rust.Workshop.WorkshopSkin.AllowApply;
		}
		set
		{
			Rust.Workshop.WorkshopSkin.AllowApply = value;
		}
	}

	[ClientVar]
	public static bool itemskincache
	{
		get
		{
			return Skin.Cache;
		}
		set
		{
			Skin.Cache = value;
		}
	}

	public static float EnforceShadowDistanceBounds(float distance)
	{
		distance = ((QualitySettings.shadowCascades == 1) ? Mathf.Clamp(distance, 50f, 50f) : ((QualitySettings.shadowCascades != 2) ? Mathf.Clamp(distance, 50f, 1000f) : Mathf.Clamp(distance, 50f, 200f)));
		return distance;
	}
}
