using UnityEngine;

public static class WaterLevel
{
	public static float Factor(Bounds bounds)
	{
		if (!TerrainMeta.WaterMap)
		{
			return 0f;
		}
		if (!TerrainMeta.WaterMap.isInitialized)
		{
			return 0f;
		}
		if (Water.Collision == null)
		{
			return 0f;
		}
		if (Water.Collision.GetIgnore(bounds))
		{
			return 0f;
		}
		if (bounds.size == Vector3.zero)
		{
			bounds.size = new Vector3(0.1f, 0.1f, 0.1f);
		}
		float height = TerrainMeta.WaterMap.GetHeight(bounds.center);
		float a = Mathf.InverseLerp(bounds.min.y, bounds.max.y, height);
		float b = Mathf.InverseLerp(bounds.min.y, bounds.max.y, 0f);
		if (TerrainCheck(bounds.max))
		{
			a = 0f;
		}
		return Mathf.Max(a, b);
	}

	public static bool Test(Vector3 vPos, bool skipGetIgnore = false)
	{
		return GetWaterDepth(vPos, skipGetIgnore) > 0f;
	}

	public static float GetWaterDepth(Vector3 vPos, bool skipGetIgnore = false)
	{
		if (!TerrainMeta.WaterMap)
		{
			return 0f;
		}
		if (!TerrainMeta.WaterMap.isInitialized)
		{
			return 0f;
		}
		if (Water.Collision == null)
		{
			return 0f;
		}
		if (!skipGetIgnore && Water.Collision.GetIgnore(vPos))
		{
			return 0f;
		}
		using (TimeWarning.New("WaterLevel.GetWaterDepth"))
		{
			float num = TerrainMeta.WaterMap.GetHeight(vPos) - vPos.y;
			if (num < 0f)
			{
				return 0f;
			}
			if (TerrainCheck(vPos))
			{
				return 0f;
			}
			return num;
		}
	}

	private static bool TerrainCheck(Vector3 pos)
	{
		return pos.y > 0f && pos.y < TerrainMeta.HeightMap.GetHeight(pos) - 1f;
	}
}
