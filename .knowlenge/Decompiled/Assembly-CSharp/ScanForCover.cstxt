using Apex.AI;
using Apex.Serialization;
using Rust.Ai;
using UnityEngine;

[FriendlyName("Scan for Cover", "Scanning for cover volumes and the cover points within the relevant ones.")]
public sealed class ScanForCover : BaseAction
{
	[ApexSerialization]
	public float MaxDistanceToCover = 15f;

	[ApexSerialization]
	public float CoverArcThreshold = -0.75f;

	public override void DoExecute(BaseContext ctx)
	{
		if (SingletonComponent<AiManager>.Instance == null || !SingletonComponent<AiManager>.Instance.enabled || !SingletonComponent<AiManager>.Instance.UseCover || ctx.AIAgent.AttackTarget == null || !(ctx is NPCHumanContext nPCHumanContext))
		{
			return;
		}
		if (nPCHumanContext.sampledCoverPoints.Count > 0)
		{
			nPCHumanContext.sampledCoverPoints.Clear();
			nPCHumanContext.sampledCoverPointTypes.Clear();
		}
		if (!(nPCHumanContext.AIAgent.AttackTarget is BasePlayer))
		{
			return;
		}
		if (nPCHumanContext.CurrentCoverVolume == null || !nPCHumanContext.CurrentCoverVolume.Contains(nPCHumanContext.Position))
		{
			nPCHumanContext.CurrentCoverVolume = SingletonComponent<AiManager>.Instance.GetCoverVolumeContaining(nPCHumanContext.Position);
			if (nPCHumanContext.CurrentCoverVolume == null)
			{
				nPCHumanContext.CurrentCoverVolume = AiManager.CreateNewCoverVolume(nPCHumanContext.Position, null);
			}
		}
		if (!(nPCHumanContext.CurrentCoverVolume != null))
		{
			return;
		}
		foreach (CoverPoint coverPoint in nPCHumanContext.CurrentCoverVolume.CoverPoints)
		{
			if (coverPoint.IsReserved)
			{
				continue;
			}
			Vector3 position = coverPoint.Position;
			float sqrMagnitude = (nPCHumanContext.Position - position).sqrMagnitude;
			if (!(sqrMagnitude > MaxDistanceToCover))
			{
				Vector3 normalized = (position - nPCHumanContext.AIAgent.AttackTargetMemory.Position).normalized;
				if (ProvidesCoverFromDirection(coverPoint, normalized, CoverArcThreshold))
				{
					nPCHumanContext.sampledCoverPointTypes.Add(coverPoint.NormalCoverType);
					nPCHumanContext.sampledCoverPoints.Add(coverPoint);
				}
			}
		}
	}

	public static bool ProvidesCoverFromDirection(CoverPoint cp, Vector3 directionTowardCover, float arcThreshold)
	{
		float num = Vector3.Dot(cp.Normal, directionTowardCover);
		if (num < arcThreshold)
		{
			return true;
		}
		return false;
	}
}
