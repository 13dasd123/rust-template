using System;
using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "LAM_DirectionalMovement", menuName = "FImpossible Creations/Legs Animator/Module - 360 Movement Animation", order = 2)]
public class LAM_DirectionalMovement : LegsAnimatorControlModuleBase
{
	[Serializable]
	public class AnglesSetup
	{
		public Vector3 AnglesOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips rotations on reaching 45 angle movement")]
		public Vector3 AnglesOn45 = new Vector3(-10f, 14f, -5f);

		[Tooltip(" Hips rotations on reaching 90 angle movement")]
		public Vector3 AnglesOn90 = new Vector3(-7f, 40f, -3f);

		[Tooltip(" Hips rotations on reaching 135 angle movement")]
		public Vector3 AnglesOn135 = new Vector3(-8f, -25f, -4f);

		[Tooltip(" Hips rotations on reaching 180 angle movement")]
		public Vector3 AnglesOn180 = new Vector3(-20f, 0f, 0f);

		[Space(8f)]
		public Vector3 HipsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips position offset on reaching 45 angle movement")]
		public Vector3 HipsOffsetOn45 = new Vector3(-0.05f, 0f, -0.05f);

		[Tooltip(" Hips position offset on reaching 90 angle movement")]
		public Vector3 HipsOffsetOn90 = new Vector3(-0.1f, 0f, 0.05f);

		[Tooltip(" Hips position offset on reaching 135 angle movement")]
		public Vector3 HipsOffsetOn135 = new Vector3(-0.1f, 0f, 0.1f);

		[Tooltip(" Hips position offset on reaching 180 angle movement")]
		public Vector3 HipsOffsetOn180 = new Vector3(0f, 0.05f, 0.2f);

		[Space(8f)]
		public Vector3 IKsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Foot IK position offset on reaching 45 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn45 = new Vector3(0f, 0f, -0.04f);

		[Tooltip(" Foot IK position offset on reaching 90 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn90 = new Vector3(0f, 0f, -0.08f);

		[Tooltip(" Foot IK position offset on reaching 135 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn135 = new Vector3(0f, 0f, 0.08f);

		[Tooltip(" Foot IK position offset on reaching 180 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn180 = new Vector3(0f, 0f, 0f);
	}

	private class LegRedirectHelper
	{
		private LAM_DirectionalMovement parent;

		private LegsAnimator.Leg leg;

		internal LegRedirectHelper oppositeHelper;

		private Vector3 computedPosLocal = Vector3.zero;

		private Quaternion _footRedirCache = Quaternion.identity;

		private LegsAnimator LA => parent.LA;

		public Vector3 LastComputedWorldSpaceLegPos { get; private set; }

		public LegRedirectHelper(LAM_DirectionalMovement parent, LegsAnimator.Leg leg)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			this.parent = parent;
			this.leg = leg;
			LastComputedWorldSpaceLegPos = leg.BoneEnd.position;
			computedPosLocal = leg.Owner.ToRootLocalSpace(LastComputedWorldSpaceLegPos);
		}

		public Vector3 ComputeIKOffset(Vector3 localPos, float smoother = 1f)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_027a: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			float @float = parent._play_TrDur.GetFloat();
			Vector3 val = parent._calc_LocalRotDir * localPos;
			float num = Vector3.Magnitude(val - computedPosLocal);
			float num2 = num / leg.Owner.ScaleReferenceNoScale;
			float num3 = 0f;
			if (num > 0.2f)
			{
				num3 = Mathf.InverseLerp(0.2f, 1f, num);
				num3 *= 0.1f;
				if (@float < 0.1f)
				{
					num3 *= @float / 0.1f;
				}
			}
			if (parent._calc_toNegativeXProgress > 0f)
			{
				Vector3 val2 = localPos;
				val2.x *= -1f;
				Vector3 val3 = parent._calc_LocalRotDir * val2;
				val = Vector3.Lerp(val, val3, parent._calc_toNegativeXProgress);
			}
			float num4 = 0f;
			if (!(smoother >= 3f))
			{
				if (smoother > 0f)
				{
					if (num2 < 0.1f / smoother)
					{
						computedPosLocal = val;
					}
					else
					{
						num4 = Mathf.InverseLerp(1.5f * smoother, 0.1f / smoother, num2) * 6f;
					}
					num4 = Mathf.Max(0f, num4);
				}
				else
				{
					computedPosLocal = val;
				}
			}
			computedPosLocal = Vector3.Lerp(computedPosLocal, val, LA.DeltaTime * (Mathf.Lerp(20f, 4f, (parent._calc_angleDiffFactor * @float + num3) * 1.5f) + num4));
			computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, val.y, 0.5f);
			if (parent._var_raiseLimit > 0f)
			{
				float c_AnimatedAnkleFlatHeight = leg.C_AnimatedAnkleFlatHeight;
				float num5 = 0f;
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorR);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorL);
				}
				if (parent._calc_toNegativeXProgress > 0f)
				{
					num5 = Mathf.Lerp(num5, 1f, parent._calc_toNegativeXProgress);
				}
				computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, c_AnimatedAnkleFlatHeight, num5 * parent._var_raiseLimit);
			}
			LastComputedWorldSpaceLegPos = LA.RootToWorldSpace(computedPosLocal);
			return computedPosLocal;
		}

		internal Quaternion FootRedirectSmoother(Quaternion target)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			_footRedirCache = Quaternion.Lerp(_footRedirCache, target, parent._calc_deltaSpeedSlow);
			return _footRedirCache;
		}
	}

	private LegsAnimator.LegsAnimatorCustomModuleHelper _useHelper;

	private LegsAnimator.Variable _play_HipsRedir;

	private LegsAnimator.Variable _play_FeetRedir;

	private LegsAnimator.Variable _play_KneesRedir;

	private LegsAnimator.Variable _play_TrDur;

	private LegsAnimator.Variable _play_LimitRaise;

	private LegsAnimator.Variable _play_FixFeet;

	private LegsAnimator.Variable _play_AdjustStretch;

	private LegsAnimator.Variable _play_RestoreSpine;

	private LegsAnimator.Variable _play_Smoother;

	private LegsAnimator.Variable _play_reAdj;

	private LegsAnimator.Variable _play_offInAir;

	private int _hash_xDir = -1;

	private int _hash_zDir = -1;

	private Vector3 _calc_WorldDir = Vector3.zero;

	private Vector3 _calc_LocalDir = Vector3.zero;

	private Quaternion _calc_LocalRotDir = Quaternion.identity;

	private float _localTargetAngle;

	private float _wrappedAngle;

	private float _smoothedWrappedAngle;

	private float _calc_smoothedTargetAngle;

	private float _calc_angleDiffFactor;

	private float _calc_toNegativeXProgress;

	internal float _calc_backAngleOff;

	private float _calc_sideFactorL;

	private float _calc_sideFactorR;

	internal float _calc_sideFactor;

	private float _calc_deltaSpeed;

	private float _calc_deltaSpeedSlow;

	private float _var_raiseLimit;

	private float _var_fixFeet;

	private Vector3 _calc_hipsPositionOffsets = Vector3.zero;

	private Vector3 _calc_hipsRotationOffsets = Vector3.zero;

	private Vector3 _calc_hipsStretchOffset = Vector3.zero;

	private Vector3 _sd_hipsStretchOff = Vector3.zero;

	private Vector3 _calc_ikOff = Vector3.zero;

	private List<LegRedirectHelper> legRedirectHelpers;

	[NonSerialized]
	public Transform SpineBone;

	[NonSerialized]
	public Vector3 User_MultiplyHipsOffsets = Vector3.one;

	[FPD_Header("Angles setup to drive procedural animation", 6f, 4f, 2)]
	public AnglesSetup Animation360Angles;

	[NonSerialized]
	public float User_StretchRotatorAnglePower = 30f;

	[NonSerialized]
	public float User_StretchPositionMultiplier = 1f;

	private float _mainBlend = 1f;

	private bool _wasUpdated;

	private Vector3 overridingDirection = Vector3.zero;

	private bool useOverridingDirection;

	[NonSerialized]
	public float overrideDirectionFadeSpeed = 6f;

	private float overrideDirectionBlend;

	private float _calc_lStretch;

	private float _calc_rStretch;

	private LegsAnimator.Variable HipsRedirVar => _useHelper.RequestVariable("Redirect Hips", 0.8f);

	private LegsAnimator.Variable FeetRedirVar => _useHelper.RequestVariable("Redirect Feet", 0.8f);

	private LegsAnimator.Variable KneesRedirVar => _useHelper.RequestVariable("Redirect Knees", 0.4f);

	private LegsAnimator.Variable TrDurationVar => _useHelper.RequestVariable("Transitions Duration", 0.25f);

	private LegsAnimator.Variable LimitRaiseVar => _useHelper.RequestVariable("Limit Leg Raise", 0.1f);

	private LegsAnimator.Variable FixFeetVar => _useHelper.RequestVariable("Fix Backward Feet", 1f);

	private LegsAnimator.Variable AdjustStretchVar => _useHelper.RequestVariable("Adjust Stretched", 0.2f);

	private LegsAnimator.Variable RestoreSpineVar => _useHelper.RequestVariable("Restore Spine", 0.5f);

	private LegsAnimator.Variable ExtraSmootherVar => _useHelper.RequestVariable("Extra Smoother", 0f);

	private LegsAnimator.Variable ReAdjVar => _useHelper.RequestVariable("Re-adjust with hips offset", false);

	private LegsAnimator.Variable FadeOffInAirVar => _useHelper.RequestVariable("Disable When Jumping", false);

	private LegsAnimator.Variable XDirAnimVarVar => _useHelper.RequestVariable("Animator World X Dir", "");

	private LegsAnimator.Variable ZDirAnimVarVar => _useHelper.RequestVariable("Animator World Z Dir", "");

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_useHelper = helper;
		_play_HipsRedir = HipsRedirVar;
		_play_TrDur = TrDurationVar;
		_play_LimitRaise = LimitRaiseVar;
		_play_FeetRedir = FeetRedirVar;
		_play_KneesRedir = KneesRedirVar;
		_play_FixFeet = FixFeetVar;
		_play_AdjustStretch = AdjustStretchVar;
		_play_RestoreSpine = RestoreSpineVar;
		_play_Smoother = ExtraSmootherVar;
		_play_offInAir = FadeOffInAirVar;
		_play_reAdj = ReAdjVar;
		_wasUpdated = false;
		legRedirectHelpers = new List<LegRedirectHelper>();
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegRedirectHelper item = new LegRedirectHelper(this, base.LA.Legs[i]);
			legRedirectHelpers.Add(item);
		}
		for (int j = 0; j < base.LA.Legs.Count; j++)
		{
			if (base.LA.Legs[j].OppositeLegIndex >= 0)
			{
				legRedirectHelpers[j].oppositeHelper = legRedirectHelpers[base.LA.Legs[j].OppositeLegIndex];
			}
		}
		if ((Object)(object)SpineBone == (Object)null && base.LA.Hips.childCount > 0)
		{
			if (base.LA.Hips.childCount == 1)
			{
				SpineBone = base.LA.Hips.GetChild(0);
			}
			else
			{
				for (int k = 0; k < base.LA.Hips.childCount; k++)
				{
					if (((Object)base.LA.Hips.GetChild(k)).name.ToLower().Contains("spin"))
					{
						SpineBone = base.LA.Hips.GetChild(k);
						break;
					}
				}
				if ((Object)(object)SpineBone == (Object)null)
				{
					SpineBone = base.LA.Hips.GetChild(0);
				}
			}
		}
		if (Object.op_Implicit((Object)(object)base.LA.Mecanim))
		{
			LegsAnimator.Variable xDirAnimVarVar = XDirAnimVarVar;
			if (!string.IsNullOrWhiteSpace(xDirAnimVarVar.GetString()))
			{
				_hash_xDir = Animator.StringToHash(xDirAnimVarVar.GetString());
				LegsAnimator.Variable zDirAnimVarVar = ZDirAnimVarVar;
				_hash_zDir = Animator.StringToHash(zDirAnimVarVar.GetString());
			}
		}
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a3: Unknown result type (might be due to invalid IL or missing references)
		_mainBlend = base.LA._MainBlend * base.ModuleBlend;
		if (_play_offInAir.GetBool())
		{
			_mainBlend *= base.LA.IsGroundedBlend;
		}
		float @float = _play_TrDur.GetFloat();
		if (_mainBlend < 0.001f)
		{
			return;
		}
		if (useOverridingDirection)
		{
			if (overrideDirectionFadeSpeed < 0.0001f)
			{
				overrideDirectionBlend = 1f;
			}
			else
			{
				overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 1f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
			}
		}
		else if (overrideDirectionFadeSpeed < 0.0001f)
		{
			overrideDirectionBlend = 0f;
		}
		else
		{
			overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 0f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
		}
		Vector3 calc_WorldDir;
		if (_hash_zDir != -1)
		{
			Vector3 val = new Vector3(base.LA.Mecanim.GetFloat(_hash_xDir), 0f, base.LA.Mecanim.GetFloat(_hash_zDir));
			calc_WorldDir = ((Vector3)(ref val)).normalized;
		}
		else
		{
			calc_WorldDir = base.LA.DesiredMovementDirection;
			calc_WorldDir.y = 0f;
			if (((Vector3)(ref calc_WorldDir)).magnitude < 0.1f)
			{
				calc_WorldDir = Vector3.zero;
			}
		}
		_calc_WorldDir = calc_WorldDir;
		if (overrideDirectionBlend > 0.0001f)
		{
			if (overrideDirectionBlend >= 1f)
			{
				_calc_WorldDir = overridingDirection;
			}
			else
			{
				_calc_WorldDir = Vector3.Slerp(_calc_WorldDir, overridingDirection, overrideDirectionBlend);
			}
		}
		_calc_LocalDir = base.LA.ToRootLocalSpaceVec(_calc_WorldDir);
		_var_raiseLimit = _play_LimitRaise.GetFloat();
		_var_fixFeet = _play_FixFeet.GetFloat();
		if (((Vector3)(ref _calc_LocalDir)).sqrMagnitude < 1E-05f)
		{
			_localTargetAngle = 0f;
		}
		_localTargetAngle = FEngineering.GetAngleRad(_calc_LocalDir.x, _calc_LocalDir.z);
		float num = ((!(@float <= 0f)) ? (3f * Mathf.Lerp(5f, 0.5f, @float / 0.6f)) : 1000f);
		_calc_deltaSpeed = base.LA.DeltaTime * num;
		_calc_deltaSpeedSlow = base.LA.DeltaTime * (num * 0.6f);
		_calc_smoothedTargetAngle = Mathf.LerpAngle(_calc_smoothedTargetAngle, _localTargetAngle, _calc_deltaSpeedSlow);
		_calc_angleDiffFactor = Mathf.InverseLerp(0.0001f, 0.25f, Mathf.Abs((_localTargetAngle - _calc_smoothedTargetAngle) / MathF.PI));
		_localTargetAngle *= 57.29578f;
		_wrappedAngle = FormatAngleToPM180(_localTargetAngle);
		_smoothedWrappedAngle = Mathf.LerpAngle(_smoothedWrappedAngle, _wrappedAngle, _calc_deltaSpeed * 1.25f);
		_smoothedWrappedAngle = FormatAngleToPM180(_smoothedWrappedAngle);
		if (_smoothedWrappedAngle < -179.9f && _wrappedAngle > 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		if (_smoothedWrappedAngle > 179.9f && _wrappedAngle < 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		float wrappedAngle = _wrappedAngle;
		float num2 = ((!(_wrappedAngle < 90f)) ? Mathf.InverseLerp(180f, 90f, wrappedAngle) : Mathf.InverseLerp(0f, 90f, wrappedAngle));
		_calc_sideFactorR = Mathf.Lerp(_calc_sideFactorR, num2, _calc_deltaSpeed * 2f);
		num2 = ((!(_wrappedAngle > -90f)) ? Mathf.InverseLerp(-180f, -90f, wrappedAngle) : Mathf.InverseLerp(0f, -90f, wrappedAngle));
		_calc_sideFactorL = Mathf.Lerp(_calc_sideFactorL, num2, _calc_deltaSpeed * 2f);
		if (_wrappedAngle < 0f)
		{
			_calc_sideFactor = _calc_sideFactorL;
		}
		else
		{
			_calc_sideFactor = _calc_sideFactorR;
		}
		_calc_toNegativeXProgress = 0f;
		float wrappedAngle2 = _wrappedAngle;
		if (wrappedAngle2 < -90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(-90f, -135f, wrappedAngle2);
		}
		else if (wrappedAngle2 > 90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(90f, 135f, wrappedAngle2);
		}
		_calc_LocalRotDir = Quaternion.Euler(0f, _localTargetAngle, 0f);
		_wasUpdated = true;
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if (!_wasUpdated)
		{
			return;
		}
		float smoother = _play_Smoother.GetFloat() + 1f;
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			Vector3 animatorEndBonePos = leg._AnimatorEndBonePos;
			Vector3 localPos = base.LA.ToRootLocalSpace(animatorEndBonePos);
			LegRedirectHelper legRedirectHelper = legRedirectHelpers[leg.PlaymodeIndex];
			legRedirectHelper.ComputeIKOffset(localPos, smoother);
			Vector3 val = legRedirectHelper.LastComputedWorldSpaceLegPos;
			if (_mainBlend < 1f)
			{
				val = Vector3.LerpUnclamped(animatorEndBonePos, val, _mainBlend);
			}
			Vector3 calc_ikOff = _calc_ikOff;
			if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Left)
			{
				calc_ikOff.x = 0f - calc_ikOff.x;
			}
			else if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Right)
			{
				calc_ikOff.z = 0f - calc_ikOff.z;
			}
			calc_ikOff = base.LA.RootToWorldSpaceVec(calc_ikOff);
			val += calc_ikOff;
			leg.OverrideAnimatorAnklePosition(val);
		}
	}

	public void OverrideMoveDirection(Vector3? direction)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!direction.HasValue)
		{
			useOverridingDirection = false;
			return;
		}
		useOverridingDirection = true;
		overridingDirection = direction.Value;
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06de: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0724: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_074c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0751: Unknown result type (might be due to invalid IL or missing references)
		//IL_0756: Unknown result type (might be due to invalid IL or missing references)
		//IL_0758: Unknown result type (might be due to invalid IL or missing references)
		//IL_0777: Unknown result type (might be due to invalid IL or missing references)
		//IL_077c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0781: Unknown result type (might be due to invalid IL or missing references)
		//IL_0786: Unknown result type (might be due to invalid IL or missing references)
		//IL_0788: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_0819: Unknown result type (might be due to invalid IL or missing references)
		//IL_0820: Unknown result type (might be due to invalid IL or missing references)
		//IL_0822: Unknown result type (might be due to invalid IL or missing references)
		//IL_0854: Unknown result type (might be due to invalid IL or missing references)
		//IL_0859: Unknown result type (might be due to invalid IL or missing references)
		//IL_0865: Unknown result type (might be due to invalid IL or missing references)
		//IL_086f: Unknown result type (might be due to invalid IL or missing references)
		//IL_087f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0884: Unknown result type (might be due to invalid IL or missing references)
		//IL_088f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0894: Unknown result type (might be due to invalid IL or missing references)
		//IL_089d: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_080d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_045c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0470: Unknown result type (might be due to invalid IL or missing references)
		//IL_0484: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_0525: Unknown result type (might be due to invalid IL or missing references)
		//IL_0539: Unknown result type (might be due to invalid IL or missing references)
		//IL_058e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0596: Unknown result type (might be due to invalid IL or missing references)
		//IL_0598: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0563: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_0907: Unknown result type (might be due to invalid IL or missing references)
		if (!_wasUpdated)
		{
			return;
		}
		float @float = _play_HipsRedir.GetFloat();
		float float2 = _play_FeetRedir.GetFloat();
		float float3 = _play_KneesRedir.GetFloat();
		float float4 = _play_AdjustStretch.GetFloat();
		float num = Mathf.Abs(_wrappedAngle);
		float num2 = Mathf.InverseLerp(0f, 45f, num);
		float wrappedAngle = _wrappedAngle;
		float num3 = wrappedAngle;
		if (float2 > 0f)
		{
			if (wrappedAngle < -90f)
			{
				num3 = ((!(wrappedAngle > -135f)) ? Mathf.Lerp(40f, 0f, Mathf.InverseLerp(-135f, -180f, wrappedAngle)) : Mathf.Lerp(-90f, 40f, Mathf.InverseLerp(-90f, -135f, wrappedAngle)));
			}
			else if (wrappedAngle > 90f)
			{
				num3 = ((!(wrappedAngle < 135f)) ? Mathf.Lerp(-40f, 0f, Mathf.InverseLerp(135f, 180f, wrappedAngle)) : Mathf.Lerp(90f, -40f, Mathf.InverseLerp(90f, 135f, wrappedAngle)));
			}
		}
		Vector3 val = Vector3.zero;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		num6 = ((!(num > 135f)) ? Mathf.InverseLerp(90f, 135f, num) : Mathf.InverseLerp(180f, 135f, num));
		num6 = Mathf.Lerp(1f, -0.5f, num6);
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			if (float2 > 0f)
			{
				float num7 = num3;
				float num8 = 1f - float2;
				num8 = num8 * num8 * num8;
				Quaternion target = Quaternion.AngleAxis(num7 * (1f - num8) * 0.8f * _mainBlend, base.LA.BaseTransform.up);
				target = legRedirectHelpers[i].FootRedirectSmoother(target);
				leg.OverrideFinalIKRot(target * leg.GetFinalIKRot());
			}
			if (float3 > 0f)
			{
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorR) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorL) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
			}
			else
			{
				leg.IKProcessor.StartBoneRotationOffset = Quaternion.identity;
			}
			if (!(float4 > 0.01f))
			{
				continue;
			}
			float stretchValue = leg.IKProcessor.GetStretchValue(legRedirectHelpers[i].LastComputedWorldSpaceLegPos);
			if (stretchValue > 0.9f)
			{
				float num9 = Mathf.InverseLerp(0.9f, 1.125f, stretchValue);
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num4 += num9;
				}
				else
				{
					num5 += num9;
				}
				Vector3 vec = leg._PreviousFinalIKPos - base.LA.BaseTransform.position;
				vec = base.LA.ToRootLocalSpaceVec(vec);
				vec.y *= -0.8f;
				vec = base.LA.RootToWorldSpaceVec(vec);
				val += vec * (num9 * 1f);
			}
		}
		Vector3 val2 = Animation360Angles.AnglesOn0;
		Vector3 val3 = Animation360Angles.HipsOffsetOn0;
		Vector3 val4 = Animation360Angles.IKsOffsetOn0;
		if (num > 0f)
		{
			if (num < 90f)
			{
				float t = InverseLerpDoubleSide(0f, 45f, num, 90f);
				LerpIt(ref val2, Animation360Angles.AnglesOn45, t);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn45, t);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn45, t);
			}
			if (num > 45f && num < 135f)
			{
				float t2 = InverseLerpDoubleSide(45f, 90f, num, 135f);
				LerpIt(ref val2, Animation360Angles.AnglesOn90, t2);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn90, t2);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn90, t2);
			}
			if (num > 90f)
			{
				float t3 = InverseLerpDoubleSide(90f, 135f, num, 180f);
				LerpIt(ref val2, Animation360Angles.AnglesOn135, t3);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn135, t3);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn135, t3);
			}
			if (num > 135f)
			{
				float t4 = Mathf.InverseLerp(135f, 180f, num);
				LerpIt(ref val2, Animation360Angles.AnglesOn180, t4);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn180, t4);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn180, t4);
			}
			if (_wrappedAngle < 0f)
			{
				val2.y = 0f - val2.y;
				val2.z = 0f - val2.z;
				val3.x = 0f - val3.x;
				val4.z = 0f - val4.z;
			}
			val2 *= @float;
			val3 *= 0.7f * @float;
			val2 = Vector3.Scale(val2, User_MultiplyHipsOffsets);
		}
		val4 *= @float * _mainBlend * base.LA.ScaleReference;
		_calc_ikOff = val4;
		float num10 = 0.25f + float4 * 0.75f;
		_calc_lStretch = Mathf.Lerp(_calc_lStretch, num4, _calc_deltaSpeed);
		_calc_rStretch = Mathf.Lerp(_calc_rStretch, num5, _calc_deltaSpeed);
		val2.y -= _calc_lStretch * User_StretchRotatorAnglePower * @float * num10;
		val2.y += _calc_rStretch * User_StretchRotatorAnglePower * @float * num10;
		_calc_hipsRotationOffsets.x = Mathf.LerpAngle(_calc_hipsRotationOffsets.x, val2.x, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.y = Mathf.LerpAngle(_calc_hipsRotationOffsets.y, val2.y, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.z = Mathf.LerpAngle(_calc_hipsRotationOffsets.z, val2.z, _calc_deltaSpeed);
		_calc_hipsPositionOffsets = Vector3.Lerp(_calc_hipsPositionOffsets, val3, _calc_deltaSpeed);
		val3 *= User_StretchPositionMultiplier;
		Quaternion val5 = Quaternion.identity;
		float num11 = _play_RestoreSpine.GetFloat();
		if ((Object)(object)SpineBone != (Object)null)
		{
			val5 = SpineBone.rotation;
		}
		else
		{
			num11 = 0f;
		}
		Quaternion val6 = Quaternion.AngleAxis(_calc_hipsRotationOffsets.y * _mainBlend, base.LA.BaseTransform.up);
		val6 *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.z * _mainBlend, base.LA.BaseTransform.forward);
		val6 *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.x * _mainBlend, base.LA.BaseTransform.right);
		base.LA.Hips.rotation = val6 * base.LA.Hips.rotation;
		if (num11 > 0f)
		{
			SpineBone.rotation = Quaternion.Slerp(SpineBone.rotation, val5, Mathf.Lerp(1f, num11, _mainBlend));
		}
		_calc_hipsStretchOffset = Vector3.SmoothDamp(_calc_hipsStretchOffset, num2 * val, ref _sd_hipsStretchOff, 0.2f + 0.3f * _play_TrDur.GetFloat(), 100000f, base.LA.DeltaTime);
		Vector3 val7 = base.LA.RootToWorldSpaceVec(_calc_hipsPositionOffsets * 0.5f * base.LA.ScaleReference) * _mainBlend;
		LegsAnimator lA = base.LA;
		lA._Hips_Modules_ExtraWOffset += val7 + _calc_hipsStretchOffset * float4 * _mainBlend;
		if (_play_reAdj.GetBool())
		{
			for (int j = 0; j < base.LA.Legs.Count; j++)
			{
				base.LA.Legs[j].OverrideFinalIKPos(base.LA.Legs[j].GetFinalIKPos() - val7);
			}
		}
	}

	public override void OnPostLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (!(_mainBlend < 0.001f) && _wasUpdated && _var_fixFeet > 0f)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				LegsAnimator.Leg leg = base.LA.Legs[i];
				Quaternion rotation = leg.IKProcessor.EndIKBone.transform.rotation;
				Quaternion val = leg.IKProcessor.EndIKBone.transform.parent.rotation * leg.IKProcessor.EndIKBone.InitialLocalRotation;
				val = Quaternion.LerpUnclamped(rotation, val, (1f - leg.A_AligningHelperBlend) * _var_fixFeet * base.LA.IsMovingBlend * _calc_toNegativeXProgress);
				leg.IKProcessor.EndIKBone.transform.rotation = val;
			}
		}
	}

	public static float FormatAngleToPM180(float angle)
	{
		float num = angle % 360f;
		if (num > 180f)
		{
			num -= 360f;
		}
		if (num < -180f)
		{
			num += 360f;
		}
		return num;
	}

	private static float InverseLerpDoubleSide(float from, float to, float t, float toRange)
	{
		if (t > to)
		{
			return Mathf.InverseLerp(toRange, to, t);
		}
		return Mathf.InverseLerp(from, to, t);
	}

	private static void LerpIt(ref Vector3 val, Vector3 to, float t)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		val = Vector3.LerpUnclamped(val, to, t);
	}
}
