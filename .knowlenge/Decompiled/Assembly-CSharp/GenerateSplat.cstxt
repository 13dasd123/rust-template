using UnityEngine;

public class GenerateSplat : ProceduralComponent
{
	public override void Process(uint seed)
	{
		byte[,,] map = TerrainMeta.SplatMap.dst;
		int res = TerrainMeta.SplatMap.res;
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		TerrainBiomeMap biomemap = TerrainMeta.BiomeMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		float noiseX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float noiseZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = splatmap.Coordinate(i);
				float normZ = splatmap.Coordinate(z);
				float num = TerrainMeta.DenormalizeX(normX);
				float num2 = TerrainMeta.DenormalizeZ(normZ);
				float height = heightmap.GetHeight01(normX, normZ);
				float slope = heightmap.GetSlope(normX, normZ);
				float biome = biomemap.GetBiome(normX, normZ, 8);
				float biome2 = biomemap.GetBiome(normX, normZ, 4);
				float biome3 = biomemap.GetBiome(normX, normZ, 2);
				float biome4 = biomemap.GetBiome(normX, normZ, 1);
				float num3 = 0f;
				float num4 = 0f;
				float num5 = 0f;
				float num6 = 0f;
				float num7 = 0f;
				float num8 = 0f;
				float num9 = 0f;
				float num10 = 0f;
				if (slope > 40f)
				{
					float num11 = (1f - num3) * Mathf.InverseLerp(40f, 60f, slope);
					num4 += num11;
					num3 = num4 + num5 + num6 + num7 + num8 + num9 + num10;
				}
				if (biome > 0f)
				{
					float num12 = (1f - num3) * biome;
					num10 += num12;
					num3 = num4 + num5 + num6 + num7 + num8 + num9 + num10;
				}
				float num13 = (1f - num3) * Mathf.InverseLerp(0.502f, 0.501f, height);
				float num14 = Mathf.Clamp01(Noise.Billow(num + noiseX, num2 + noiseZ, 4, 0.05000000074505806, 0.5));
				num9 += num13 * num14;
				num6 += num13 * (1f - num14);
				num3 = num4 + num5 + num6 + num7 + num8 + num9 + num10;
				float num15 = ((!topomap.GetTopology(normX, normZ, 32)) ? 0f : Mathf.Clamp01(Noise.Turbulence(num + noiseX, num2 + noiseZ, 4, 0.02500000037252903, 1.25) - 0.25f));
				if (biome2 > 0f)
				{
					float num16 = (1f - num3) * biome2;
					num8 += num16 * num15;
					num5 += num16 * (1f - num15);
					num3 = num4 + num5 + num6 + num7 + num8 + num9 + num10;
				}
				if (biome3 > 0f)
				{
					float num17 = (1f - num3) * biome3;
					num8 += num17 * num15;
					num5 += num17 * (1f - num15);
					num3 = num4 + num5 + num6 + num7 + num8 + num9 + num10;
				}
				if (biome4 > 0f)
				{
					float num18 = (1f - num3) * biome4;
					float num19 = Mathf.Clamp01(Noise.Turbulence(num + noiseX, num2 + noiseZ, 4, 0.009999999776482582, 1.5));
					num8 += num18 * num15;
					num5 += num18 * (1f - num15) * num19;
					num6 += num18 * (1f - num15) * (1f - num19);
					num3 = num4 + num5 + num5 + num7 + num8 + num9 + num10;
				}
				map[3, z, i] = TextureData.Float2Byte(num4);
				map[4, z, i] = TextureData.Float2Byte(num5);
				map[2, z, i] = TextureData.Float2Byte(num6);
				map[0, z, i] = TextureData.Float2Byte(num7);
				map[5, z, i] = TextureData.Float2Byte(num8);
				map[6, z, i] = TextureData.Float2Byte(num9);
				map[1, z, i] = TextureData.Float2Byte(num10);
			}
		});
	}
}
