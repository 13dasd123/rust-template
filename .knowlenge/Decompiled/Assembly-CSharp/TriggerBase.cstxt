using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Oxide.Core;
using Rust;
using UnityEngine;

public class TriggerBase : BaseMonoBehaviour
{
	public LayerMask interestLayers;

	[NonSerialized]
	public HashSet<GameObject> contents;

	[NonSerialized]
	public HashSet<BaseEntity> entityContents;

	internal virtual GameObject InterestedInObject(GameObject obj)
	{
		int num = 1 << obj.layer;
		if ((interestLayers.value & num) != num)
		{
			return null;
		}
		return obj;
	}

	protected virtual void OnDisable()
	{
		if (!Rust.Application.isQuitting && contents != null)
		{
			GameObject[] array = contents.ToArray();
			foreach (GameObject targetObj in array)
			{
				OnTriggerExit(targetObj);
			}
			contents = null;
		}
	}

	internal virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			Interface.CallHook("OnEntityEnter", this, ent);
			entityContents.Add(ent);
		}
	}

	internal virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null)
		{
			Interface.CallHook("OnEntityLeave", this, ent);
			entityContents.Remove(ent);
		}
	}

	internal virtual void OnObjectAdded(GameObject obj)
	{
		if (!(obj == null))
		{
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(obj);
			if ((bool)baseEntity)
			{
				OnEntityEnter(baseEntity);
				baseEntity.EnterTrigger(this);
			}
		}
	}

	internal virtual void OnObjectRemoved(GameObject obj)
	{
		if (!(obj == null))
		{
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(obj);
			if ((bool)baseEntity)
			{
				OnEntityLeave(baseEntity);
				baseEntity.LeaveTrigger(this);
			}
		}
	}

	internal void RemoveInvalidEntities()
	{
		if (entityContents == null)
		{
			return;
		}
		Collider component = GetComponent<Collider>();
		if (component == null)
		{
			return;
		}
		Bounds bounds = component.bounds;
		bounds.Expand(1f);
		BaseEntity[] array = entityContents.ToArray();
		foreach (BaseEntity baseEntity in array)
		{
			if (baseEntity == null)
			{
				Debug.LogWarning("Trigger " + ToString() + " contains destroyed entity.");
			}
			else if (!bounds.Contains(baseEntity.ClosestPoint(base.transform.position)))
			{
				Debug.LogWarning("Trigger " + ToString() + " contains entity that is too far away: " + baseEntity.ToString());
				RemoveEntity(baseEntity);
			}
		}
	}

	internal bool CheckEntity(BaseEntity ent)
	{
		if (ent == null)
		{
			return true;
		}
		Collider component = GetComponent<Collider>();
		if (component == null)
		{
			return true;
		}
		Bounds bounds = component.bounds;
		bounds.Expand(1f);
		return bounds.Contains(ent.ClosestPoint(base.transform.position));
	}

	internal virtual void OnObjects()
	{
	}

	internal virtual void OnEmpty()
	{
		contents = null;
		entityContents = null;
	}

	public void RemoveObject(GameObject obj)
	{
		if (!(obj == null))
		{
			Collider component = obj.GetComponent<Collider>();
			if (!(component == null))
			{
				OnTriggerExit(component);
			}
		}
	}

	public void RemoveEntity(BaseEntity obj)
	{
		OnTriggerExit(obj.gameObject);
	}

	private void OnTriggerEnter(Collider collider)
	{
		if (this == null)
		{
			return;
		}
		using (TimeWarning.New("TriggerBase.OnTriggerEnter"))
		{
			GameObject gameObject = InterestedInObject(collider.gameObject);
			if (gameObject == null)
			{
				return;
			}
			if (contents == null)
			{
				contents = new HashSet<GameObject>();
			}
			if (contents.Contains(gameObject))
			{
				return;
			}
			int count = contents.Count;
			contents.Add(gameObject);
			OnObjectAdded(gameObject);
			if (count == 0 && contents.Count == 1)
			{
				OnObjects();
			}
		}
		if (Debugging.checktriggers)
		{
			RemoveInvalidEntities();
		}
	}

	private void OnTriggerExit(Collider collider)
	{
		if (this == null || collider == null)
		{
			return;
		}
		GameObject gameObject = InterestedInObject(collider.gameObject);
		if (!(gameObject == null))
		{
			OnTriggerExit(gameObject);
			if (Debugging.checktriggers)
			{
				RemoveInvalidEntities();
			}
		}
	}

	private void OnTriggerExit(GameObject targetObj)
	{
		if (contents != null && contents.Contains(targetObj))
		{
			contents.Remove(targetObj);
			OnObjectRemoved(targetObj);
			if (contents == null || contents.Count == 0)
			{
				OnEmpty();
			}
		}
	}
}
