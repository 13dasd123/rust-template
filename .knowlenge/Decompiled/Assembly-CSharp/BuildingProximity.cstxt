using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BuildingProximity : PrefabAttribute
{
	private struct ProximityInfo
	{
		public bool hit;

		public bool connection;

		public Line line;

		public float sqrDist;
	}

	private const float distance = 5f;

	private const float forgiveness = 0.01f;

	private const float foundation_width = 3f;

	private const float foundation_extents = 1.5f;

	private Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	protected bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation)
	{
		OBB oBB = new OBB(position, rotation, bounds);
		float radius = bounds.size.Max() + 5f;
		List<BuildingBlock> obj = Pool.GetList<BuildingBlock>();
		Vis.Entities(oBB.position, radius, obj, 2097152);
		uint num = 0u;
		for (int i = 0; i < obj.Count; i++)
		{
			BuildingBlock buildingBlock = obj[i];
			Construction blockDefinition = buildingBlock.blockDefinition;
			Vector3 position2 = buildingBlock.transform.position;
			Quaternion rotation2 = buildingBlock.transform.rotation;
			ProximityInfo proximity = GetProximity(construction, position, rotation, blockDefinition, position2, rotation2);
			if (proximity.connection)
			{
				BuildingManager.Building building = buildingBlock.GetBuilding();
				if (building != null)
				{
					BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
					if (dominatingBuildingPrivilege != null)
					{
						if (!construction.canBypassBuildingPermission && !dominatingBuildingPrivilege.IsAuthed(player))
						{
							Construction.lastPlacementError = "Cannot attach to unauthorized building";
							Pool.FreeList(ref obj);
							return true;
						}
						if (num == 0)
						{
							num = building.ID;
						}
						else if (num != building.ID)
						{
							Construction.lastPlacementError = "Cannot connect two buildings with cupboards";
							Pool.FreeList(ref obj);
							return true;
						}
					}
				}
			}
			if (proximity.hit)
			{
				Vector3 v = proximity.line.point1 - proximity.line.point0;
				if (!(Mathf.Abs(v.y) > 2.99f) && !(v.Magnitude2D() > 1.49f))
				{
					Construction.lastPlacementError = "Not enough space";
					Pool.FreeList(ref obj);
					return true;
				}
			}
		}
		Pool.FreeList(ref obj);
		return false;
	}

	private ProximityInfo GetProximity(Construction construction1, Vector3 position1, Quaternion rotation1, Construction construction2, Vector3 position2, Quaternion rotation2)
	{
		List<ConstructionSocket> obj = Pool.GetList<ConstructionSocket>();
		List<ConstructionSocket> obj2 = Pool.GetList<ConstructionSocket>();
		ProximityInfo result = default(ProximityInfo);
		result.hit = false;
		result.connection = false;
		result.line = default(Line);
		result.sqrDist = float.MaxValue;
		for (int i = 0; i < construction1.allSockets.Length; i++)
		{
			ConstructionSocket constructionSocket = construction1.allSockets[i] as ConstructionSocket;
			if (constructionSocket == null)
			{
				continue;
			}
			bool flag = false;
			for (int j = 0; j < construction2.allSockets.Length; j++)
			{
				Socket_Base socket = construction2.allSockets[j];
				if (constructionSocket.CanConnect(position1, rotation1, socket, position2, rotation2))
				{
					flag = (result.connection = true);
					break;
				}
			}
			if (!flag)
			{
				obj.Add(constructionSocket);
			}
		}
		for (int k = 0; k < construction2.allSockets.Length; k++)
		{
			ConstructionSocket constructionSocket2 = construction2.allSockets[k] as ConstructionSocket;
			if (constructionSocket2 == null)
			{
				continue;
			}
			bool flag2 = false;
			for (int l = 0; l < construction1.allSockets.Length; l++)
			{
				Socket_Base socket2 = construction1.allSockets[l];
				if (constructionSocket2.CanConnect(position2, rotation2, socket2, position1, rotation1))
				{
					flag2 = (result.connection = true);
					break;
				}
			}
			if (!flag2)
			{
				obj2.Add(constructionSocket2);
			}
		}
		for (int m = 0; m < obj.Count; m++)
		{
			ConstructionSocket constructionSocket3 = obj[m];
			if (constructionSocket3.socketType != ConstructionSocket.Type.Foundation)
			{
				continue;
			}
			Vector3 selectPivot = constructionSocket3.GetSelectPivot(position1, rotation1);
			Vector3 vector = rotation1 * constructionSocket3.worldRotation * Vector3.right * 1.5f;
			for (int n = 0; n < obj2.Count; n++)
			{
				ConstructionSocket constructionSocket4 = obj2[n];
				if (constructionSocket4.socketType != ConstructionSocket.Type.Foundation)
				{
					continue;
				}
				Vector3 selectPivot2 = constructionSocket4.GetSelectPivot(position2, rotation2);
				Vector3 vector2 = rotation2 * constructionSocket4.worldRotation * Vector3.right * 1.5f;
				if (constructionSocket3.IsCompatible(constructionSocket4))
				{
					Line line = new Line(selectPivot, selectPivot2);
					Line line2 = new Line(selectPivot, selectPivot2 + vector2);
					Line line3 = new Line(selectPivot, selectPivot2 - vector2);
					Line line4 = new Line(selectPivot + vector, selectPivot2);
					Line line5 = new Line(selectPivot - vector, selectPivot2);
					float sqrMagnitude = (line.point1 - line.point0).sqrMagnitude;
					float sqrMagnitude2 = (line2.point1 - line2.point0).sqrMagnitude;
					float sqrMagnitude3 = (line3.point1 - line3.point0).sqrMagnitude;
					float sqrMagnitude4 = (line4.point1 - line4.point0).sqrMagnitude;
					float sqrMagnitude5 = (line5.point1 - line5.point0).sqrMagnitude;
					if (sqrMagnitude < result.sqrDist)
					{
						result.hit = true;
						result.line = line;
						result.sqrDist = sqrMagnitude;
					}
					if (sqrMagnitude2 < result.sqrDist)
					{
						result.hit = true;
						result.line = line2;
						result.sqrDist = sqrMagnitude2;
					}
					if (sqrMagnitude3 < result.sqrDist)
					{
						result.hit = true;
						result.line = line3;
						result.sqrDist = sqrMagnitude3;
					}
					if (sqrMagnitude4 < result.sqrDist)
					{
						result.hit = true;
						result.line = line4;
						result.sqrDist = sqrMagnitude4;
					}
					if (sqrMagnitude5 < result.sqrDist)
					{
						result.hit = true;
						result.line = line5;
						result.sqrDist = sqrMagnitude5;
					}
				}
			}
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		return result;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		bounds = rootObj.GetComponent<BaseEntity>().bounds;
	}

	protected override Type GetIndexedType()
	{
		return typeof(BuildingProximity);
	}

	public static bool Check(BasePlayer player, Construction construction, Vector3 position, Quaternion rotation, BuildingProximity[] volumes)
	{
		for (int i = 0; i < volumes.Length; i++)
		{
			if (volumes[i].Check(player, construction, position, rotation))
			{
				return true;
			}
		}
		return false;
	}
}
