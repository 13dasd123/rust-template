using System.Collections.Generic;
using Apex.AI;
using Rust.Ai.HTN;

public class TaskQualifier : QualifierBase
{
	private ITask _task;

	private float _lastScore;

	public void Reset()
	{
		_lastScore = 0f;
		if (_task != null)
		{
			_task.Reset();
		}
	}

	public float Decompose(IAIContext context, ref List<PrimitiveTaskSelector> plan)
	{
		if (_task == null)
		{
			if (base.action is SelectorAction { selector: not null } selectorAction)
			{
				_task = selectorAction.selector as ITask;
				if (_task != null)
				{
					_lastScore = DecomposeTask(_task, context, ref plan);
					return _lastScore;
				}
			}
			if (base.action is AILinkAction aILinkAction)
			{
				IUtilityAI aI = AIManager.GetAI(aILinkAction.aiId);
				if (aI.rootSelector is ITask)
				{
					_task = aI.rootSelector as ITask;
					if (_task != null)
					{
						_lastScore = DecomposeTask(_task, context, ref plan);
						return _lastScore;
					}
				}
			}
			_lastScore = -1f;
			return _lastScore;
		}
		_lastScore = DecomposeTask(_task, context, ref plan);
		return _lastScore;
	}

	private float DecomposeTask(ITask task, IAIContext context, ref List<PrimitiveTaskSelector> plan)
	{
		float num = TestPreconditions(task, context);
		if (num <= 0f)
		{
			return num;
		}
		return task.Decompose(context, ref plan);
	}

	private float TestPreconditions(ITask task, IAIContext context)
	{
		foreach (ICompositeScorer precondition in task.Preconditions)
		{
			if (precondition.Score(context, precondition.scorers) <= 0f)
			{
				return 0f;
			}
		}
		return 1f;
	}

	public override float Score(IAIContext context)
	{
		return _lastScore;
	}
}
