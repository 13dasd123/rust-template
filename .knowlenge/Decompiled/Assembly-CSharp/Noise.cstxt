using System;
using ConVar;
using UnityEngine;

public static class Noise
{
	public const float MIN = -1E+09f;

	public const float MAX = 1E+09f;

	private static bool native;

	public static float Simplex1D(double x)
	{
		if (native)
		{
			return (float)NativeNoise.Simplex1D(x);
		}
		return (float)ManagedNoise.Simplex1D(x);
	}

	public static float Simplex2D(double x, double y)
	{
		if (native)
		{
			return (float)NativeNoise.Simplex2D(x, y);
		}
		return (float)ManagedNoise.Simplex2D(x, y);
	}

	public static float Turbulence(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5)
	{
		if (native)
		{
			return (float)NativeNoise.Turbulence(x, y, octaves, frequency, amplitude, lacunarity, gain);
		}
		return (float)ManagedNoise.Turbulence(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Billow(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5)
	{
		if (native)
		{
			return (float)NativeNoise.Billow(x, y, octaves, frequency, amplitude, lacunarity, gain);
		}
		return (float)ManagedNoise.Billow(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Ridge(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5)
	{
		if (native)
		{
			return (float)NativeNoise.Ridge(x, y, octaves, frequency, amplitude, lacunarity, gain);
		}
		return (float)ManagedNoise.Ridge(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Sharp(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5)
	{
		if (native)
		{
			return (float)NativeNoise.Sharp(x, y, octaves, frequency, amplitude, lacunarity, gain);
		}
		return (float)ManagedNoise.Sharp(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceIQ(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5)
	{
		if (native)
		{
			return (float)NativeNoise.TurbulenceIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
		}
		return (float)ManagedNoise.TurbulenceIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float BillowIQ(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5)
	{
		if (native)
		{
			return (float)NativeNoise.BillowIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
		}
		return (float)ManagedNoise.BillowIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float RidgeIQ(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5)
	{
		if (native)
		{
			return (float)NativeNoise.RidgeIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
		}
		return (float)ManagedNoise.RidgeIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float SharpIQ(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5)
	{
		if (native)
		{
			return (float)NativeNoise.SharpIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
		}
		return (float)ManagedNoise.SharpIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceWarp(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5, double warp = 0.25)
	{
		if (native)
		{
			return (float)NativeNoise.TurbulenceWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
		}
		return (float)ManagedNoise.TurbulenceWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float BillowWarp(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5, double warp = 0.25)
	{
		if (native)
		{
			return (float)NativeNoise.BillowWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
		}
		return (float)ManagedNoise.BillowWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float RidgeWarp(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5, double warp = 0.25)
	{
		if (native)
		{
			return (float)NativeNoise.RidgeWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
		}
		return (float)ManagedNoise.RidgeWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float SharpWarp(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5, double warp = 0.25)
	{
		if (native)
		{
			return (float)NativeNoise.SharpWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
		}
		return (float)ManagedNoise.SharpWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float Jordan(double x, double y, int octaves = 1, double frequency = 1.0, double amplitude = 1.0, double lacunarity = 2.0, double gain = 0.5, double warp = 1.0, double damp = 1.0, double damp_scale = 1.0)
	{
		if (native)
		{
			return (float)NativeNoise.Jordan(x, y, octaves, frequency, amplitude, lacunarity, gain, warp, damp, damp_scale);
		}
		return (float)ManagedNoise.Jordan(x, y, octaves, frequency, amplitude, lacunarity, gain, warp, damp, damp_scale);
	}

	public static void ConnectToNativeBackend()
	{
		if (Global.safemode)
		{
			native = false;
			Debug.LogWarning("Running in safe mode, forcing managed noise backend.");
			return;
		}
		try
		{
			native = true;
			double[] array = new double[12];
			double[] array2 = new double[12];
			for (int i = 0; i < 12; i++)
			{
				array[i] = UnityEngine.Random.Range(-1E+09f, 1E+09f);
				array2[i] = UnityEngine.Random.Range(-1E+09f, 1E+09f);
			}
			double[] array3 = new double[12];
			double[] array4 = new double[12];
			double[] array5 = new double[12]
			{
				NativeNoise.Simplex1D(array[0]),
				NativeNoise.Simplex1D(array[1]),
				NativeNoise.Simplex1D(array[2]),
				NativeNoise.Simplex2D(array[3], array2[3]),
				NativeNoise.Simplex2D(array[4], array2[4]),
				NativeNoise.Simplex2D(array[5], array2[5]),
				NativeNoise.Simplex1D(array[6], out array3[6]),
				NativeNoise.Simplex1D(array[7], out array3[7]),
				NativeNoise.Simplex1D(array[8], out array3[8]),
				NativeNoise.Simplex2D(array[9], array2[9], out array3[9], out array4[9]),
				NativeNoise.Simplex2D(array[10], array2[10], out array3[10], out array4[10]),
				NativeNoise.Simplex2D(array[11], array2[11], out array3[11], out array4[11])
			};
			double[] array6 = new double[12];
			double[] array7 = new double[12];
			double[] array8 = new double[12]
			{
				ManagedNoise.Simplex1D(array[0]),
				ManagedNoise.Simplex1D(array[1]),
				ManagedNoise.Simplex1D(array[2]),
				ManagedNoise.Simplex2D(array[3], array2[3]),
				ManagedNoise.Simplex2D(array[4], array2[4]),
				ManagedNoise.Simplex2D(array[5], array2[5]),
				ManagedNoise.Simplex1D(array[6], out array6[6]),
				ManagedNoise.Simplex1D(array[7], out array6[7]),
				ManagedNoise.Simplex1D(array[8], out array6[8]),
				ManagedNoise.Simplex2D(array[9], array2[9], out array6[9], out array7[9]),
				ManagedNoise.Simplex2D(array[10], array2[10], out array6[10], out array7[10]),
				ManagedNoise.Simplex2D(array[11], array2[11], out array6[11], out array7[11])
			};
			for (int j = 0; j < 12; j++)
			{
				if (array5[j] != array8[j] || array3[j] != array6[j] || array4[j] != array7[j])
				{
					string text = "(" + array5[j] + " " + array3[j] + " " + array4[j] + ")";
					string text2 = "(" + array8[j] + " " + array6[j] + " " + array7[j] + ")";
					Debug.LogWarning("Noise test #" + j + " returned " + text + " != " + text2);
					native = false;
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogWarning(ex.Message);
			native = false;
		}
		finally
		{
			if (!native)
			{
				Debug.LogWarning("Cannot use native noise backend, using managed fallback instead.");
			}
		}
	}

	public static bool IsUsingNativeBackend()
	{
		return native;
	}
}
