using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

private sealed class Parser : IDisposable
{
	private enum TOKEN
	{
		NONE,
		CURLY_OPEN,
		CURLY_CLOSE,
		SQUARED_OPEN,
		SQUARED_CLOSE,
		COLON,
		COMMA,
		STRING,
		NUMBER,
		TRUE,
		FALSE,
		NULL
	}

	private const string WORD_BREAK = "{}[],:\"";

	private StringReader json;

	private char PeekChar => Convert.ToChar(json.Peek());

	private char NextChar => Convert.ToChar(json.Read());

	private string NextWord
	{
		get
		{
			StringBuilder stringBuilder = new StringBuilder();
			while (!IsWordBreak(PeekChar))
			{
				stringBuilder.Append(NextChar);
				if (json.Peek() == -1)
				{
					break;
				}
			}
			return stringBuilder.ToString();
		}
	}

	private TOKEN NextToken
	{
		get
		{
			EatWhitespace();
			if (json.Peek() == -1)
			{
				return TOKEN.NONE;
			}
			switch (PeekChar)
			{
			case '{':
				return TOKEN.CURLY_OPEN;
			case '}':
				json.Read();
				return TOKEN.CURLY_CLOSE;
			case '[':
				return TOKEN.SQUARED_OPEN;
			case ']':
				json.Read();
				return TOKEN.SQUARED_CLOSE;
			case ',':
				json.Read();
				return TOKEN.COMMA;
			case '"':
				return TOKEN.STRING;
			case ':':
				return TOKEN.COLON;
			case '-':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				return TOKEN.NUMBER;
			default:
				return NextWord switch
				{
					"false" => TOKEN.FALSE, 
					"true" => TOKEN.TRUE, 
					"null" => TOKEN.NULL, 
					_ => TOKEN.NONE, 
				};
			}
		}
	}

	private Parser(string jsonString)
	{
		json = new StringReader(jsonString);
	}

	public static bool IsWordBreak(char c)
	{
		return char.IsWhiteSpace(c) || "{}[],:\"".IndexOf(c) != -1;
	}

	public static object Parse(string jsonString)
	{
		using Parser parser = new Parser(jsonString);
		return parser.ParseValue();
	}

	public void Dispose()
	{
		json.Dispose();
		json = null;
	}

	private Dictionary<string, object> ParseObject()
	{
		Dictionary<string, object> dictionary = new Dictionary<string, object>();
		json.Read();
		while (true)
		{
			switch (NextToken)
			{
			case TOKEN.COMMA:
				continue;
			case TOKEN.NONE:
				return null;
			case TOKEN.CURLY_CLOSE:
				return dictionary;
			}
			string text = ParseString();
			if (text == null)
			{
				return null;
			}
			if (NextToken != TOKEN.COLON)
			{
				return null;
			}
			json.Read();
			dictionary[text] = ParseValue();
		}
	}

	private List<object> ParseArray()
	{
		List<object> list = new List<object>();
		json.Read();
		bool flag = true;
		while (flag)
		{
			TOKEN nextToken = NextToken;
			switch (nextToken)
			{
			case TOKEN.NONE:
				return null;
			case TOKEN.SQUARED_CLOSE:
				flag = false;
				break;
			default:
			{
				object item = ParseByToken(nextToken);
				list.Add(item);
				break;
			}
			case TOKEN.COMMA:
				break;
			}
		}
		return list;
	}

	private object ParseValue()
	{
		TOKEN nextToken = NextToken;
		return ParseByToken(nextToken);
	}

	private object ParseByToken(TOKEN token)
	{
		return token switch
		{
			TOKEN.STRING => ParseString(), 
			TOKEN.NUMBER => ParseNumber(), 
			TOKEN.CURLY_OPEN => ParseObject(), 
			TOKEN.SQUARED_OPEN => ParseArray(), 
			TOKEN.TRUE => true, 
			TOKEN.FALSE => false, 
			TOKEN.NULL => null, 
			_ => null, 
		};
	}

	private string ParseString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		json.Read();
		bool flag = true;
		while (flag)
		{
			if (json.Peek() == -1)
			{
				flag = false;
				break;
			}
			char nextChar = NextChar;
			switch (nextChar)
			{
			case '"':
				flag = false;
				break;
			case '\\':
				if (json.Peek() == -1)
				{
					flag = false;
					break;
				}
				nextChar = NextChar;
				switch (nextChar)
				{
				case '"':
				case '/':
				case '\\':
					stringBuilder.Append(nextChar);
					break;
				case 'b':
					stringBuilder.Append('\b');
					break;
				case 'f':
					stringBuilder.Append('\f');
					break;
				case 'n':
					stringBuilder.Append('\n');
					break;
				case 'r':
					stringBuilder.Append('\r');
					break;
				case 't':
					stringBuilder.Append('\t');
					break;
				case 'u':
				{
					char[] array = new char[4];
					for (int i = 0; i < 4; i++)
					{
						array[i] = NextChar;
					}
					stringBuilder.Append((char)Convert.ToInt32(new string(array), 16));
					break;
				}
				}
				break;
			default:
				stringBuilder.Append(nextChar);
				break;
			}
		}
		return stringBuilder.ToString();
	}

	private object ParseNumber()
	{
		string nextWord = NextWord;
		if (nextWord.IndexOf('.') == -1)
		{
			long.TryParse(nextWord, out var result);
			return result;
		}
		double.TryParse(nextWord, out var result2);
		return result2;
	}

	private void EatWhitespace()
	{
		while (char.IsWhiteSpace(PeekChar))
		{
			json.Read();
			if (json.Peek() == -1)
			{
				break;
			}
		}
	}
}
