#define UNITY_ASSERTIONS
using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseCombatEntity : BaseEntity
{
	public enum LifeState
	{
		Alive,
		Dead
	}

	[Serializable]
	public struct Pickup
	{
		public bool enabled;

		[ItemSelector(ItemCategory.All)]
		public ItemDefinition itemTarget;

		public int itemCount;

		[Tooltip("Should we set the condition of the item based on the health of the picked up entity")]
		public bool setConditionFromHealth;

		[Tooltip("How much to reduce the item condition when picking up")]
		public float subtractCondition;

		[Tooltip("Must have building access to pick up")]
		public bool requireBuildingPrivilege;

		[Tooltip("Must have hammer equipped to pick up")]
		public bool requireHammer;

		[Tooltip("Inventory Must be empty (if applicable) to be picked up")]
		public bool requireEmptyInv;
	}

	[Serializable]
	public struct Repair
	{
		public bool enabled;

		[ItemSelector(ItemCategory.All)]
		public ItemDefinition itemTarget;
	}

	[Header("BaseCombatEntity")]
	public SkeletonProperties skeletonProperties;

	public ProtectionProperties baseProtection;

	public float startHealth;

	public Pickup pickup;

	public Repair repair;

	public bool ShowHealthInfo = true;

	public LifeState lifestate;

	public bool sendsHitNotification;

	public bool sendsMeleeHitNotification = true;

	public float _health;

	public float _maxHealth = 100f;

	public float lastAttackedTime = float.NegativeInfinity;

	protected float lastDealtDamageTime = float.NegativeInfinity;

	private int lastNotifyFrame;

	private const float MAX_HEALTH_REPAIR = 50f;

	[NonSerialized]
	public DamageType lastDamage;

	[NonSerialized]
	public BaseEntity lastAttacker;

	[NonSerialized]
	public Collider _collider;

	[NonSerialized]
	public bool ResetLifeStateOnSpawn = true;

	protected DirectionProperties[] propDirection;

	public Vector3 lastHostilePos = Vector3.zero;

	public float lastHostileTime = float.NegativeInfinity;

	public Vector3 LastAttackedDir { get; private set; }

	public float SecondsSinceAttacked => UnityEngine.Time.time - lastAttackedTime;

	public float SecondsSinceDealtDamage => UnityEngine.Time.time - lastDealtDamageTime;

	public float healthFraction
	{
		get
		{
			return Health() / MaxHealth();
		}
		set
		{
			health = MaxHealth() * value;
		}
	}

	public float health
	{
		get
		{
			return _health;
		}
		set
		{
			float num = _health;
			_health = Mathf.Clamp(value, 0f, MaxHealth());
			if (base.isServer && _health != num)
			{
				OnHealthChanged(num, _health);
			}
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("BaseCombatEntity.OnRpcMessage"))
		{
			if (rpc == 4143599628u && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - RPC_PickupStart "));
				}
				using (TimeWarning.New("RPC_PickupStart"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("RPC_PickupStart", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_PickupStart(rpc2);
						}
					}
					catch (Exception exception)
					{
						player.Kick("RPC Error in RPC_PickupStart");
						Debug.LogException(exception);
					}
				}
				return true;
			}
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool IsDead()
	{
		return lifestate == LifeState.Dead;
	}

	public virtual bool IsAlive()
	{
		return lifestate == LifeState.Alive;
	}

	public override void ResetState()
	{
		base.ResetState();
		_health = _maxHealth;
		lastAttackedTime = float.NegativeInfinity;
		lastDealtDamageTime = float.NegativeInfinity;
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			UpdateSurroundings();
		}
	}

	public virtual float GetThreatLevel()
	{
		return 0f;
	}

	public override float PenetrationResistance(HitInfo info)
	{
		return (!baseProtection) ? 1f : baseProtection.density;
	}

	public virtual void ScaleDamage(HitInfo info)
	{
		if (info.UseProtection && baseProtection != null)
		{
			baseProtection.Scale(info.damageTypes);
		}
	}

	public HitArea SkeletonLookup(uint boneID)
	{
		if (skeletonProperties == null)
		{
			return (HitArea)(-1);
		}
		return skeletonProperties.FindBone(boneID)?.area ?? ((HitArea)(-1));
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseCombat = Facepunch.Pool.Get<BaseCombat>();
		info.msg.baseCombat.state = (int)lifestate;
		info.msg.baseCombat.health = _health;
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (Health() > MaxHealth())
		{
			health = MaxHealth();
		}
		if (float.IsNaN(Health()))
		{
			health = MaxHealth();
		}
	}

	public override void Load(LoadInfo info)
	{
		if (base.isServer)
		{
			lifestate = LifeState.Alive;
		}
		if (info.msg.baseCombat != null)
		{
			lifestate = (LifeState)info.msg.baseCombat.state;
			_health = info.msg.baseCombat.health;
		}
		base.Load(info);
	}

	public override float Health()
	{
		return _health;
	}

	public override float MaxHealth()
	{
		return _maxHealth;
	}

	public virtual float StartHealth()
	{
		return startHealth;
	}

	public virtual float StartMaxHealth()
	{
		return StartHealth();
	}

	public void DoHitNotify(HitInfo info)
	{
		using (TimeWarning.New("DoHitNotify"))
		{
			if (sendsHitNotification && !(info.Initiator == null) && info.Initiator is BasePlayer && !info.isHeadshot && !(this == info.Initiator) && UnityEngine.Time.frameCount != lastNotifyFrame)
			{
				lastNotifyFrame = UnityEngine.Time.frameCount;
				bool flag = info.Weapon is BaseMelee;
				if (base.isServer && (!flag || sendsMeleeHitNotification))
				{
					bool arg = info.Initiator.net.connection == info.Predicted;
					ClientRPCPlayer(null, info.Initiator as BasePlayer, "HitNotify", arg);
				}
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		using (TimeWarning.New("BaseCombatEntity.OnAttacked"))
		{
			if (!IsDead())
			{
				DoHitNotify(info);
			}
			if (base.isServer)
			{
				Hurt(info);
			}
		}
		base.OnAttacked(info);
	}

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return pickup.enabled && (!pickup.requireBuildingPrivilege || (player.CanBuild() && (!pickup.requireHammer || player.IsHoldingEntity<Hammer>())));
	}

	public virtual void OnPickedUp(Item createdItem, BasePlayer player)
	{
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_PickupStart(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanPickup(rpc.player))
		{
			Item item = ItemManager.Create(pickup.itemTarget, pickup.itemCount, skinID);
			if (pickup.setConditionFromHealth && item.hasCondition)
			{
				item.conditionNormalized = Mathf.Clamp01(healthFraction - pickup.subtractCondition);
			}
			rpc.player.GiveItem(item, GiveItemReason.PickedUp);
			OnPickedUp(item, rpc.player);
			Kill();
		}
	}

	public virtual List<ItemAmount> BuildCost()
	{
		if (repair.itemTarget == null)
		{
			return null;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(repair.itemTarget);
		if (itemBlueprint == null)
		{
			return null;
		}
		return itemBlueprint.ingredients;
	}

	public virtual float RepairCostFraction()
	{
		return 0.5f;
	}

	public virtual List<ItemAmount> RepairCost(float healthMissingFraction)
	{
		List<ItemAmount> list = BuildCost();
		if (list == null)
		{
			return null;
		}
		List<ItemAmount> list2 = new List<ItemAmount>();
		foreach (ItemAmount item in list)
		{
			int num = Mathf.RoundToInt(item.amount * RepairCostFraction() * healthMissingFraction);
			if (num > 0)
			{
				list2.Add(new ItemAmount(item.itemDef, num));
			}
		}
		return list2;
	}

	public virtual void OnRepair()
	{
		Effect.server.Run("assets/bundled/prefabs/fx/build/repair.prefab", this, 0u, Vector3.zero, Vector3.zero);
	}

	public virtual void OnRepairFinished()
	{
		Effect.server.Run("assets/bundled/prefabs/fx/build/repair_full.prefab", this, 0u, Vector3.zero, Vector3.zero);
	}

	public virtual void OnRepairFailed()
	{
		Effect.server.Run("assets/bundled/prefabs/fx/build/repair_failed.prefab", this, 0u, Vector3.zero, Vector3.zero);
	}

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		if (SecondsSinceAttacked <= 30f)
		{
			OnRepairFailed();
			return;
		}
		float num = MaxHealth() - health;
		float num2 = num / MaxHealth();
		if (num <= 0f || num2 <= 0f)
		{
			OnRepairFailed();
			return;
		}
		List<ItemAmount> list = RepairCost(num2);
		if (list == null)
		{
			return;
		}
		float num3 = list.Sum((ItemAmount x) => x.amount);
		if (num3 > 0f)
		{
			float a = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			a = Mathf.Min(a, 50f / num);
			if (a <= 0f)
			{
				OnRepairFailed();
				return;
			}
			int num4 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(a * item.amount);
				int num5 = player2.inventory.Take(null, item.itemid, amount);
				if (num5 > 0)
				{
					num4 += num5;
					player2.Command("note.inv", item.itemid, num5 * -1);
				}
			}
			float num6 = (float)num4 / num3;
			health += num * num6;
			SendNetworkUpdate();
		}
		else
		{
			health += num;
			SendNetworkUpdate();
		}
		if (health >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

	public virtual void InitializeHealth(float newhealth, float newmax)
	{
		_maxHealth = newmax;
		_health = newhealth;
		lifestate = LifeState.Alive;
	}

	public override void ServerInit()
	{
		_collider = TransformEx.GetComponentInChildrenIncludeDisabled<Collider>(base.transform);
		propDirection = PrefabAttribute.server.FindAll<DirectionProperties>(prefabID);
		if (ResetLifeStateOnSpawn)
		{
			InitializeHealth(StartHealth(), StartMaxHealth());
			lifestate = LifeState.Alive;
		}
		base.ServerInit();
	}

	public virtual void Hurt(float amount)
	{
		Hurt(Mathf.Abs(amount), DamageType.Generic);
	}

	public virtual void Hurt(float amount, DamageType type, BaseEntity attacker = null, bool useProtection = true)
	{
		using (TimeWarning.New("Hurt"))
		{
			HitInfo hitInfo = new HitInfo(attacker, this, type, amount, base.transform.position);
			hitInfo.UseProtection = useProtection;
			Hurt(hitInfo);
		}
	}

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50L))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			health = num - info.damageTypes.Total();
			SendNetworkUpdate();
			if (SingletonComponent<AiManager>.Instance != null && SingletonComponent<AiManager>.Instance.enabled && SingletonComponent<AiManager>.Instance.UseIntensity)
			{
				SingletonComponent<AiManager>.Instance.OnHit(info);
			}
			if (ConVar.Global.developer > 1)
			{
				Debug.Log(string.Concat("[Combat]".PadRight(10), base.gameObject.name, " hurt ", info.damageTypes.GetMajorityDamageType(), "/", info.damageTypes.Total(), " - ", health.ToString("0"), " health left"));
			}
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (baseCombatEntity2 != null)
			{
				baseCombatEntity2.MarkHostileTime();
			}
			if (lastDamage != DamageType.Decay)
			{
				lastAttackedTime = UnityEngine.Time.time;
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.ServerPosition - ServerPosition).normalized;
				}
			}
			if (health <= 0f)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.Log(info, num, health, "killed");
				}
				else
				{
					initiatorPlayer.stats.combat.Log(info, num, health);
				}
			}
		}
	}

	public virtual void MarkHostileTime()
	{
		lastHostileTime = UnityEngine.Time.realtimeSinceStartup;
		lastHostilePos = GetEstimatedWorldPosition();
	}

	public virtual void ClearHostileTime()
	{
		lastHostileTime = float.NegativeInfinity;
		lastHostilePos = Vector3.zero;
	}

	public float TimeSinceHostile()
	{
		return UnityEngine.Time.realtimeSinceStartup - lastHostileTime;
	}

	public Vector3 GetHostilePos()
	{
		return lastHostilePos;
	}

	private void DebugHurt(HitInfo info)
	{
		if (!ConVar.Vis.damage)
		{
			return;
		}
		if (info.PointStart != info.PointEnd)
		{
			ConsoleNetwork.BroadcastToAllClients("ddraw.arrow", 60, Color.cyan, info.PointStart, info.PointEnd, 0.1f);
			ConsoleNetwork.BroadcastToAllClients("ddraw.sphere", 60, Color.cyan, info.HitPositionWorld, 0.01f);
		}
		string text = string.Empty;
		for (int i = 0; i < info.damageTypes.types.Length; i++)
		{
			float num = info.damageTypes.types[i];
			if (num != 0f)
			{
				string text2 = text;
				string[] obj = new string[5] { text2, " ", null, null, null };
				DamageType damageType = (DamageType)i;
				obj[2] = damageType.ToString().PadRight(10);
				obj[3] = num.ToString("0.00");
				obj[4] = "\n";
				text = string.Concat(obj);
			}
		}
		string text3 = string.Concat("<color=lightblue>Damage:</color>".PadRight(10), info.damageTypes.Total().ToString("0.00"), "\n<color=lightblue>Health:</color>".PadRight(10), health.ToString("0.00"), " / ", (!(health - info.damageTypes.Total() <= 0f)) ? "<color=green>" : "<color=red>", (health - info.damageTypes.Total()).ToString("0.00"), "</color>", "\n<color=lightblue>HitEnt:</color>".PadRight(10), this, "\n<color=lightblue>HitBone:</color>".PadRight(10), info.boneName, "\n<color=lightblue>Attacker:</color>".PadRight(10), info.Initiator, "\n<color=lightblue>WeaponPrefab:</color>".PadRight(10), info.WeaponPrefab, "\n<color=lightblue>Damages:</color>\n", text);
		ConsoleNetwork.BroadcastToAllClients("ddraw.text", 60, Color.white, info.HitPositionWorld, text3);
	}

	public virtual void ChangeHealth(float amount)
	{
		if (amount != 0f)
		{
			if (amount > 0f)
			{
				Heal(amount);
			}
			else
			{
				Hurt(Mathf.Abs(amount));
			}
		}
	}

	public virtual void OnHealthChanged(float oldvalue, float newvalue)
	{
	}

	public virtual void Heal(float amount)
	{
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " healed");
		}
		health = Mathf.Clamp(health + amount, 0f, MaxHealth());
	}

	public virtual void OnKilled(HitInfo info)
	{
		Kill(DestroyMode.Gib);
	}

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		Interface.CallHook("OnEntityDeath", this, info);
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
		}
		health = 0f;
		lifestate = LifeState.Dead;
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

	public void DieInstantly()
	{
		if (!IsDead())
		{
			if (ConVar.Global.developer > 1)
			{
				Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
			}
			health = 0f;
			lifestate = LifeState.Dead;
			OnKilled(null);
		}
	}

	public void UpdateSurroundings()
	{
		StabilityEntity.updateSurroundingsQueue.Add(WorldSpaceBounds().ToBounds());
	}
}
