using System.Collections;
using Apex.Ai.HTN;
using Apex.Serialization;
using UnityEngine;

public class AStarDuckTimed : OperatorBase<ScientistAStarContext>
{
	[ApexSerialization]
	private float _duckTimeMin = 1f;

	[ApexSerialization]
	private float _duckTimeMax = 1f;

	public override void Execute(ScientistAStarContext context)
	{
		context.Body.modelState.ducked = true;
		context.SetFact(Facts.IsDucking, value: true);
		AStarIsNotNavigatingEffect.ApplyStatic(context, fromPlanner: false, temporary: false);
		context.Domain.StopNavigating();
		if (_duckTimeMin > _duckTimeMax)
		{
			float duckTimeMin = _duckTimeMin;
			_duckTimeMin = _duckTimeMax;
			_duckTimeMax = duckTimeMin;
		}
		float time = Random.value * (_duckTimeMax - _duckTimeMin) + _duckTimeMin;
		context.Body.StartCoroutine(AsyncTimer(context, time));
	}

	public override OperatorStateType Tick(ScientistAStarContext context, PrimitiveTaskSelector task)
	{
		if (context.IsFact(Facts.IsDucking))
		{
			return OperatorStateType.Running;
		}
		ApplyExpectedEffects(context, task);
		return OperatorStateType.Complete;
	}

	public override void Abort(ScientistAStarContext context, PrimitiveTaskSelector task)
	{
		context.Body.StopCoroutine(AsyncTimer(context, 0f));
		Reset(context);
	}

	private IEnumerator AsyncTimer(ScientistAStarContext context, float time)
	{
		yield return CoroutineEx.waitForSeconds(time);
		Reset(context);
	}

	private void Reset(ScientistAStarContext context)
	{
		context.Body.modelState.ducked = false;
		context.SetFact(Facts.IsDucking, value: false);
	}
}
