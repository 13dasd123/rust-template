using System.Collections.Generic;
using Apex.AI;
using Apex.Serialization;
using Rust.Ai.HTN;

public class CompoundTaskSelector : Selector, ITask
{
	[FriendlyName("Decomposition Type", "Should we decompose the children taking only the first valid primitive task, or an order of primitive tasks?")]
	[ApexSerialization]
	private DecompositionType _decomposition;

	[ApexSerialization]
	[FriendlyName("Preconditions", "Requirements of state that must be in place for this task to be valid")]
	private List<ICompositeScorer> _preconditions = new List<ICompositeScorer>(2);

	private List<TaskQualifier> _taskQualifiers = new List<TaskQualifier>(2);

	public List<ICompositeScorer> Preconditions => _preconditions;

	public void Reset()
	{
		if (!_UpdateTasksQualifiers())
		{
			return;
		}
		foreach (TaskQualifier taskQualifier in _taskQualifiers)
		{
			taskQualifier.Reset();
		}
	}

	public float Decompose(IAIContext context, ref List<PrimitiveTaskSelector> plan)
	{
		if (!_UpdateTasksQualifiers())
		{
			return 0f;
		}
		foreach (TaskQualifier taskQualifier in _taskQualifiers)
		{
			float num = taskQualifier.Decompose(context, ref plan);
			if (_decomposition == DecompositionType.One && num > 0f)
			{
				return 1f;
			}
			if (_decomposition == DecompositionType.All && num <= 0f)
			{
				return 0f;
			}
		}
		if (_decomposition == DecompositionType.All)
		{
			return 1f;
		}
		return 0f;
	}

	private bool _UpdateTasksQualifiers()
	{
		if (base.qualifiers.Count == 0)
		{
			return false;
		}
		if (_taskQualifiers.Count != base.qualifiers.Count)
		{
			_taskQualifiers.Clear();
			foreach (IQualifier qualifier in base.qualifiers)
			{
				if (qualifier is TaskQualifier item)
				{
					_taskQualifiers.Add(item);
				}
			}
		}
		return true;
	}

	public override IQualifier Select(IAIContext context, IList<IQualifier> qualifiers, IDefaultQualifier defaultQualifier)
	{
		IQualifier qualifier = defaultQualifier;
		foreach (IQualifier qualifier2 in qualifiers)
		{
			float num = qualifier2.Score(context);
			if (_decomposition == DecompositionType.One && num > 0f)
			{
				return qualifier2;
			}
			if (_decomposition == DecompositionType.All && num <= 0f)
			{
				return base.defaultQualifier;
			}
			qualifier = qualifier2;
		}
		return (_decomposition != DecompositionType.All) ? defaultQualifier : qualifier;
	}
}
