using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public class PuzzleReset : FacepunchBehaviour
{
	public SpawnGroup[] respawnGroups;

	public bool playersBlockReset;

	public float playerDetectionRadius;

	public Transform playerDetectionOrigin;

	public float timeBetweenResets = 30f;

	public bool scaleWithServerPopulation;

	public float GetResetSpacing()
	{
		return timeBetweenResets * ((!scaleWithServerPopulation) ? 1f : (1f - SpawnHandler.PlayerLerp(Spawn.min_rate, Spawn.max_rate)));
	}

	public void Start()
	{
		ResetTimer();
	}

	public void ResetTimer()
	{
		CancelInvoke(TimedReset);
		Invoke(TimedReset, GetResetSpacing());
	}

	public bool PassesResetCheck()
	{
		if (playersBlockReset)
		{
			List<BasePlayer> obj = Facepunch.Pool.GetList<BasePlayer>();
			Vis.Entities(playerDetectionOrigin.position, playerDetectionRadius, obj, 131072);
			bool result = true;
			foreach (BasePlayer item in obj)
			{
				if (!item.IsSleeping() && item.IsAlive() && !item.IsNpc)
				{
					result = false;
					break;
				}
			}
			Facepunch.Pool.FreeList(ref obj);
			return result;
		}
		return true;
	}

	public void TimedReset()
	{
		if (PassesResetCheck())
		{
			DoReset();
			Invoke(TimedReset, GetResetSpacing());
		}
		else
		{
			Invoke(TimedReset, 30f);
		}
	}

	public void DoReset()
	{
		IOEntity component = GetComponent<IOEntity>();
		ResetIOEntRecursive(component, UnityEngine.Time.frameCount);
		component.MarkDirty();
		List<SpawnGroup> obj = Facepunch.Pool.GetList<SpawnGroup>();
		Vis.Components(base.transform.position, 1f, obj, 262144);
		foreach (SpawnGroup item in obj)
		{
			if (!(item == null))
			{
				item.Spawn();
			}
		}
		Facepunch.Pool.FreeList(ref obj);
	}

	public static void ResetIOEntRecursive(IOEntity target, int resetIndex)
	{
		if (target.lastResetIndex == resetIndex)
		{
			return;
		}
		target.lastResetIndex = resetIndex;
		target.ResetIOState();
		IOEntity.IOSlot[] outputs = target.outputs;
		foreach (IOEntity.IOSlot iOSlot in outputs)
		{
			if (iOSlot.connectedTo.Get() != null && iOSlot.connectedTo.Get() != target)
			{
				ResetIOEntRecursive(iOSlot.connectedTo.Get(), resetIndex);
			}
		}
	}
}
