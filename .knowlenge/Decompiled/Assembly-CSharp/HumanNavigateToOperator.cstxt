using System.Collections.Generic;
using Apex.Serialization;
using Rust.Ai;
using UnityEngine;

public class HumanNavigateToOperator : BaseAction
{
	public enum OperatorType
	{
		EnemyLoc,
		RandomLoc,
		Spawn,
		FleeEnemy,
		FleeHurtDir,
		RetreatCover,
		FlankCover,
		AdvanceCover,
		FleeExplosive,
		Sidestep,
		ClosestCover,
		PatrolLoc
	}

	public enum TakeCoverIntention
	{
		Advance,
		Flank,
		Retreat,
		Closest
	}

	[ApexSerialization]
	public OperatorType Operator;

	public override void DoExecute(BaseContext c)
	{
		if (c.GetFact(NPCPlayerApex.Facts.CanNotMove) == 1)
		{
			c.AIAgent.StopMoving();
			if (c is NPCHumanContext nPCHumanContext)
			{
				nPCHumanContext.Human.SetFact(NPCPlayerApex.Facts.PathToTargetStatus, 2);
			}
			return;
		}
		c.AIAgent.SetFact(NPCPlayerApex.Facts.IsRetreatingToCover, 0);
		c.AIAgent.SetFact(NPCPlayerApex.Facts.SidesteppedOutOfCover, 0);
		switch (Operator)
		{
		case OperatorType.EnemyLoc:
			NavigateToEnemy(c as NPCHumanContext);
			break;
		case OperatorType.RandomLoc:
			NavigateToRandomLoc(c as NPCHumanContext);
			break;
		case OperatorType.Spawn:
			NavigateToSpawn(c as NPCHumanContext);
			break;
		case OperatorType.FleeEnemy:
			FleeEnemy(c as NPCHumanContext);
			break;
		case OperatorType.FleeHurtDir:
			FleeHurtDir(c as NPCHumanContext);
			break;
		case OperatorType.RetreatCover:
			NavigateToCover(c as NPCHumanContext, TakeCoverIntention.Retreat);
			break;
		case OperatorType.FlankCover:
			NavigateToCover(c as NPCHumanContext, TakeCoverIntention.Flank);
			break;
		case OperatorType.AdvanceCover:
			NavigateToCover(c as NPCHumanContext, TakeCoverIntention.Advance);
			break;
		case OperatorType.FleeExplosive:
			FleeExplosive(c as NPCHumanContext);
			break;
		case OperatorType.Sidestep:
			Sidestep(c as NPCHumanContext);
			break;
		case OperatorType.ClosestCover:
			NavigateToCover(c as NPCHumanContext, TakeCoverIntention.Closest);
			break;
		case OperatorType.PatrolLoc:
			NavigateToPatrolLoc(c as NPCHumanContext);
			break;
		}
	}

	public static void NavigateToEnemy(NPCHumanContext c)
	{
		if (c.GetFact(NPCPlayerApex.Facts.HasEnemy) <= 0 || !c.AIAgent.IsNavRunning())
		{
			return;
		}
		if (c.GetFact(NPCPlayerApex.Facts.HasLineOfSight) > 0)
		{
			c.AIAgent.GetNavAgent.destination = c.EnemyPosition;
		}
		else
		{
			Memory.SeenInfo info = c.Memory.GetInfo(c.AIAgent.AttackTarget);
			if (info.Entity != null)
			{
				c.AIAgent.GetNavAgent.destination = info.Position;
			}
		}
		c.Human.SetTargetPathStatus();
	}

	public static void NavigateToRandomLoc(NPCHumanContext c)
	{
		if (IsHumanRoamReady.Evaluate(c) && c.AIAgent.IsNavRunning() && NavigateInDirOfBestSample(c, NavPointSampler.SampleCount.Eight, 4f, NavPointSampler.SampleFeatures.DiscourageSharpTurns, c.AIAgent.GetStats.MinRoamRange, c.AIAgent.GetStats.MaxRoamRange))
		{
			float num = c.AIAgent.GetStats.MaxRoamDelay - c.AIAgent.GetStats.MinRoamDelay;
			float num2 = Random.value * num;
			float time = num2 / num;
			float num3 = c.AIAgent.GetStats.RoamDelayDistribution.Evaluate(time);
			float num4 = num3 * num;
			c.NextRoamTime = Time.realtimeSinceStartup + c.AIAgent.GetStats.MinRoamDelay + num4;
			if (c.Human.OnChatter != null)
			{
				c.Human.OnChatter();
			}
		}
	}

	public static void NavigateToPatrolLoc(NPCHumanContext c)
	{
		if (!(c.SquadMember == null) && !(c.SquadMember.Manager == null) && IsHumanRoamReady.Evaluate(c) && c.AIAgent.IsNavRunning())
		{
			PathInterestNode randomPatrolPointInRange = c.SquadMember.Manager.GetRandomPatrolPointInRange(c.Position, c.AIAgent.GetStats.MinRoamRange, c.AIAgent.GetStats.MaxRoamRange);
			if (randomPatrolPointInRange != null)
			{
				c.AIAgent.GetNavAgent.destination = randomPatrolPointInRange.transform.position;
				c.Human.SetTargetPathStatus();
			}
			float num = c.AIAgent.GetStats.MaxRoamDelay - c.AIAgent.GetStats.MinRoamDelay;
			float num2 = Random.value * num;
			float time = num2 / num;
			float num3 = c.AIAgent.GetStats.RoamDelayDistribution.Evaluate(time);
			float num4 = num3 * num;
			c.NextRoamTime = Time.realtimeSinceStartup + c.AIAgent.GetStats.MinRoamDelay + num4;
			if (c.Human.OnChatter != null)
			{
				c.Human.OnChatter();
			}
		}
	}

	public static void NavigateToSpawn(NPCHumanContext c)
	{
		if (c.AIAgent.IsNavRunning())
		{
			c.AIAgent.GetNavAgent.destination = c.AIAgent.GuardPosition;
			c.Human.SetTargetPathStatus();
		}
	}

	public static void NavigateToCover(NPCHumanContext c, TakeCoverIntention intention)
	{
		if (!c.AIAgent.IsNavRunning())
		{
			return;
		}
		c.Human.TimeLastMovedToCover = Time.realtimeSinceStartup;
		switch (intention)
		{
		case TakeCoverIntention.Retreat:
			if (c.CoverSet.Retreat.ReservedCoverPoint != null)
			{
				PathToCover(c, c.CoverSet.Retreat.ReservedCoverPoint.Position);
				c.SetFact(NPCPlayerApex.Facts.IsRetreatingToCover, 1);
			}
			else if (c.CoverSet.Closest.ReservedCoverPoint != null)
			{
				PathToCover(c, c.CoverSet.Closest.ReservedCoverPoint.Position);
				c.SetFact(NPCPlayerApex.Facts.IsRetreatingToCover, 1);
			}
			break;
		case TakeCoverIntention.Flank:
			if (c.CoverSet.Flank.ReservedCoverPoint != null)
			{
				PathToCover(c, c.CoverSet.Flank.ReservedCoverPoint.Position);
				c.SetFact(NPCPlayerApex.Facts.IsRetreatingToCover, 1);
			}
			else if (c.CoverSet.Closest.ReservedCoverPoint != null)
			{
				PathToCover(c, c.CoverSet.Closest.ReservedCoverPoint.Position);
				c.SetFact(NPCPlayerApex.Facts.IsRetreatingToCover, 1);
			}
			break;
		case TakeCoverIntention.Advance:
			if (c.CoverSet.Advance.ReservedCoverPoint != null)
			{
				PathToCover(c, c.CoverSet.Advance.ReservedCoverPoint.Position);
			}
			else if (c.CoverSet.Closest.ReservedCoverPoint != null)
			{
				PathToCover(c, c.CoverSet.Closest.ReservedCoverPoint.Position);
			}
			break;
		default:
			if (c.CoverSet.Closest.ReservedCoverPoint != null)
			{
				PathToCover(c, c.CoverSet.Closest.ReservedCoverPoint.Position);
			}
			break;
		}
	}

	public static void PathToCover(NPCHumanContext c, Vector3 coverPosition)
	{
		c.AIAgent.GetNavAgent.destination = coverPosition;
		c.Human.SetTargetPathStatus();
		c.SetFact(NPCPlayerApex.Facts.IsMovingToCover, 1);
		if (c.Human.OnTakeCover != null)
		{
			c.Human.OnTakeCover();
		}
	}

	public static void FleeEnemy(NPCHumanContext c)
	{
		if (c.AIAgent.IsNavRunning() && NavigateInDirOfBestSample(c, NavPointSampler.SampleCount.Eight, 4f, NavPointSampler.SampleFeatures.RetreatFromTarget, c.AIAgent.GetStats.MinFleeRange, c.AIAgent.GetStats.MaxFleeRange))
		{
			c.SetFact(NPCPlayerApex.Facts.IsFleeing, 1);
		}
	}

	public static void FleeExplosive(NPCHumanContext c)
	{
		if (c.AIAgent.IsNavRunning() && NavigateInDirOfBestSample(c, NavPointSampler.SampleCount.Eight, 4f, NavPointSampler.SampleFeatures.RetreatFromExplosive, c.AIAgent.GetStats.MinFleeRange, c.AIAgent.GetStats.MaxFleeRange))
		{
			c.SetFact(NPCPlayerApex.Facts.IsFleeing, 1);
			if (c.Human.OnFleeExplosive != null)
			{
				c.Human.OnFleeExplosive();
			}
		}
	}

	public static void FleeHurtDir(NPCHumanContext c)
	{
		if (c.AIAgent.IsNavRunning() && NavigateInDirOfBestSample(c, NavPointSampler.SampleCount.Eight, 4f, NavPointSampler.SampleFeatures.RetreatFromDirection, c.AIAgent.GetStats.MinFleeRange, c.AIAgent.GetStats.MaxFleeRange))
		{
			c.SetFact(NPCPlayerApex.Facts.IsFleeing, 1);
		}
	}

	public static void Sidestep(NPCHumanContext c)
	{
		if (c.AIAgent.IsNavRunning() && NavigateInDirOfBestSample(c, NavPointSampler.SampleCount.Eight, 4f, NavPointSampler.SampleFeatures.FlankTarget, 2f, 5f) && c.AIAgent.GetFact(NPCPlayerApex.Facts.IsInCover) == 1)
		{
			c.AIAgent.SetFact(NPCPlayerApex.Facts.SidesteppedOutOfCover, 1);
		}
	}

	private static bool NavigateInDirOfBestSample(NPCHumanContext c, NavPointSampler.SampleCount sampleCount, float radius, NavPointSampler.SampleFeatures features, float minRange, float maxRange)
	{
		List<NavPointSample> list = c.AIAgent.RequestNavPointSamplesInCircle(sampleCount, radius, features);
		if (list == null)
		{
			return false;
		}
		foreach (NavPointSample item in list)
		{
			Vector3 normalized = (item.Position - c.Position).normalized;
			Vector3 vector = c.Position + (normalized * minRange + normalized * ((maxRange - minRange) * Random.value));
			if (!(c.AIAgent.AttackTarget != null) || NavPointSampler.IsValidPointDirectness(vector, c.Position, c.EnemyPosition))
			{
				NavPointSample navPointSample = NavPointSampler.SamplePoint(vector, new NavPointSampler.SampleScoreParams
				{
					WaterMaxDepth = c.AIAgent.GetStats.MaxWaterDepth,
					Agent = c.AIAgent,
					Features = features
				});
				if (!Mathf.Approximately(navPointSample.Score, 0f))
				{
					vector = navPointSample.Position;
					c.AIAgent.GetNavAgent.destination = vector;
					c.Human.SetTargetPathStatus();
					c.AIAgent.SetFact(NPCPlayerApex.Facts.IsMoving, 1, triggerCallback: true, onlyTriggerCallbackOnDiffValue: false);
					return true;
				}
			}
		}
		return false;
	}
}
