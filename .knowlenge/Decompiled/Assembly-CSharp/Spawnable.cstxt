using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class Spawnable : MonoBehaviour, IServerComponent
{
	[ReadOnly]
	public SpawnPopulation Population;

	internal Vector3 SpawnPosition;

	protected void OnEnable()
	{
		if (!Rust.Application.isLoadingSave)
		{
			Add();
		}
	}

	protected void OnDisable()
	{
		if (!Rust.Application.isQuitting && !Rust.Application.isLoadingSave)
		{
			Remove();
		}
	}

	private void Add()
	{
		SpawnPosition = base.transform.position;
		if (Population == null)
		{
			Debug.LogWarning(ToString() + " Population is null, entity spawned from outside the spawn handler?");
		}
		else if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			SingletonComponent<SpawnHandler>.Instance.AddInstance(this);
		}
	}

	private void Remove()
	{
		if (!(Population == null) && (bool)SingletonComponent<SpawnHandler>.Instance)
		{
			SingletonComponent<SpawnHandler>.Instance.RemoveInstance(this);
		}
	}

	private void Kill()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		baseEntity.Kill();
	}

	internal void Save(BaseNetworkable.SaveInfo info)
	{
		if (!(Population == null))
		{
			info.msg.spawnable = Pool.Get<ProtoBuf.Spawnable>();
			info.msg.spawnable.population = Population.FilenameStringId;
		}
	}

	internal void Load(BaseNetworkable.LoadInfo info)
	{
		if (info.msg.spawnable != null)
		{
			Population = FileSystem.Load<SpawnPopulation>(StringPool.Get(info.msg.spawnable.population));
		}
		if (Population != null)
		{
			Add();
			return;
		}
		Debug.LogWarning(string.Concat(base.gameObject, " has no population - should be removed"));
		Kill();
	}

	protected void OnValidate()
	{
		Population = null;
	}
}
