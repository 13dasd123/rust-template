using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class TravellingVendor : BaseEntity, VehicleChassisVisuals<TravellingVendor>.IClientWheelUser, IPathListener
{
	private enum TravellingVendorState
	{
		Stopped,
		Travelling,
		Waiting,
		Aligning
	}

	public static class TravellingVendorFlags
	{
		public const Flags Braking = Flags.Reserved1;

		public const Flags IndicateLeft = Flags.Reserved2;

		public const Flags IndicateRight = Flags.Reserved4;

		public const Flags Lights = Flags.Reserved5;

		public const Flags Hazards = Flags.Reserved6;
	}

	[Flags]
	private enum WheelIsGroundedFlags
	{
		RearLeft = 1,
		RearRight = 2,
		FrontLeft = 4,
		FrontRight = 8
	}

	[Serializable]
	private struct VendorTargetInfo
	{
		public float lastSeenTime;

		public float lastBlockingTime;

		public float blockingAccumulator;

		public float ignoredUntil;

		public bool IsIgnored => ignoredUntil > Time.time;
	}

	[Header("Visuals")]
	public TravellingVendorVisuals visuals;

	[Header("Sounds")]
	public TravellingVendorSounds sounds;

	public SoundPlayer BuySound;

	[Header("References")]
	[SerializeField]
	private VisualCarWheel wheelFL;

	[SerializeField]
	private VisualCarWheel wheelFR;

	[SerializeField]
	private VisualCarWheel wheelRL;

	[SerializeField]
	private VisualCarWheel wheelRR;

	public float client_steering_left;

	public float client_steering_right;

	public Vector3 client_velocity = Vector3.zero;

	private WheelIsGroundedFlags client_wheel_flags;

	public TimeSince timeSinceLastUpdate;

	public VehicleLight headlight;

	public VehicleLight rearLights;

	public VehicleLight rearLeftIndicator;

	public VehicleLight rearRightIndicator;

	private static Collider[] spawncheckColliders = (Collider[])(object)new Collider[2];

	public const string PREFAB_PATH = "assets/prefabs/npc/travelling vendor/travellingvendor.prefab";

	[Header("General")]
	public bool DoAI = true;

	public float ObstacleCheckTime = 0.33f;

	public float MarkerUpdateTime = 0.05f;

	public float TimeBetweenPullovers = 120f;

	[Header("Engine Config")]
	public float motorForceConstant = 300f;

	public float brakeForceConstant = 500f;

	public float acceleration = 2f;

	[Header("Steer Config")]
	public float wheelbase = 3.3f;

	public float rearTrack = 1.6f;

	public float steeringSmoothing = 0.1f;

	public float downforceCoefficient = 10f;

	public float maxSteerAngle = 80f;

	[Header("Trade")]
	public GameObjectRef vendingMachineRef;

	public GameObjectRef vendingMachineFrontRef;

	[Header("Pullover")]
	public float maxPulloverAngleDifference = 15f;

	[Header("Other")]
	public static int obstacleMask = 196608;

	[Header("References")]
	public GameObjectRef mapMarkerEntityPrefab;

	public GameObjectRef preventBuildingPrefab;

	public GameObjectRef backfireEffect;

	public Transform backfirePosition;

	private TriggerVehiclePush pusher;

	private TriggerPlayerForce forcer;

	public NPCVendingMachine vendingMachine;

	[Header("Spline")]
	public float splineMovementSpeed = 2f;

	public Vector3 splineOffset;

	[ServerVar]
	public static bool should_spawn = true;

	[ServerVar]
	public static bool attempt_pullovers = true;

	[ServerVar]
	public static float alive_time_seconds = 1800f;

	[ServerVar]
	public static bool should_destroy_buildings = false;

	[ReplicatedVar(Saved = true)]
	public static float max_speed = 5f;

	private float smoothedSteering;

	private float brakes;

	private float throttle;

	private float targetThrottle = 3f;

	private bool handbrake = true;

	private float steeringAngle;

	private float currentMaxSpeed;

	private Rigidbody myRigidbody;

	private List<RaycastHit> obstacleHits;

	private List<RaycastHit> pulloverHits;

	private Vector3 destination;

	private bool instantLeave;

	private float waitTimeAccumulator;

	private float aliveTimer;

	private TimeSince timeSinceBackfire;

	private bool pullingOver;

	private Vector3 pulloverPosition = Vector3.zero;

	private float pullOverTimer;

	private Vector3 pulloverTangent = Vector3.zero;

	private bool overrideSteering;

	private BaseEntity preventBuildingInstance;

	private RaycastHit hit;

	private TravellingVendorState internalState;

	private WheelIsGroundedFlags wheelFlags;

	private SimpleSplineTranslator splineTranslator;

	private MapMarker mapMarkerInstance;

	private bool globaIndicatorLeft;

	private TimeSince timeSincePlayerDetected;

	private float slowdownStartSpeed;

	private List<Vector3> currentPath;

	private int currentPathIndex;

	private float atDestinationDistance = 8f;

	private bool followingSpine;

	private int splineId = -1;

	private WorldSpline spline;

	private ListDictionary<BasePlayer, VendorTargetInfo> playerRecords;

	private List<BasePlayer> localPlayers;

	private int searchRange = 10;

	private float allowedVendorBlockTime = 1f;

	public Vector3 Velocity => client_velocity;

	public float DriveWheelVelocity => ((Vector3)(ref client_velocity)).magnitude;

	public float SteerAngle => (client_steering_left + client_steering_right) / 2f;

	public float MaxSteerAngle => maxSteerAngle;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("TravellingVendor.OnRpcMessage", 0);
		try
		{
			if (rpc == 831304742 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_OpenMenu "));
				}
				TimeWarning val2 = TimeWarning.New("SV_OpenMenu", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(831304742u, "SV_OpenMenu", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_OpenMenu(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_OpenMenu");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public float GetThrottleInput()
	{
		return 1f;
	}

	[ServerVar(Name = "spawn")]
	public static string svspawntravellingvendor(Arg args)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)SpawnTravellingVendor(((Component)args.Player()).transform.position) != (Object)null))
		{
			return "Failed to spawn Travelling Vendor. Is there a ring road present?";
		}
		return "Spawned Travelling Vendor.";
	}

	[ServerVar(Name = "startevent")]
	public static string svspawntravellingvendorevent(Arg args)
	{
		if (!((Object)(object)SpawnTravellingVendorForEvent() != (Object)null))
		{
			return "Failed to spawn Travelling Vendor.";
		}
		return "Spawned Travelling Vendor.";
	}

	public static TravellingVendor SpawnTravellingVendor(Vector3 position)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		float num = float.PositiveInfinity;
		foreach (PathList mainRoad in TerrainMeta.Path.MainRoads)
		{
			_ = Vector3.zero;
			float num2 = float.PositiveInfinity;
			Vector3[] points = mainRoad.Path.Points;
			foreach (Vector3 val in points)
			{
				float num3 = Vector3.Distance(val, position);
				if (num3 < num2)
				{
					num2 = num3;
				}
			}
			if (num2 < num)
			{
				pathList = mainRoad;
				num = num2;
			}
		}
		if (pathList == null)
		{
			Debug.Log((object)"Couldn't find road to spawn on.");
			return null;
		}
		Vector3 startPoint = pathList.Path.GetStartPoint();
		pathList.Path.GetEndPoint();
		int num4 = pathList.Path.Points.Length - 1;
		IAIPathNode[] nodes = new RuntimePathNode[num4];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num5 = 0;
		int num6 = pathList.Path.MaxIndex - 1;
		for (int j = pathList.Path.MinIndex; j <= num6; j++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[j] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num5] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num5++;
		}
		runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
		runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		int num7 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num7 = Mathf.Clamp(num7, 1, 3);
		num7++;
		for (int k = 0; k < num7; k++)
		{
			int num8 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode = new RuntimeInterestNode(pathList.Path.Points[num8] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
		}
		Vector3 val2 = runtimePath.Nodes[1].Position - startPoint;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/travelling vendor/travellingvendor.prefab", startPoint + Vector3.up * 2f, Quaternion.LookRotation(normalized));
		TravellingVendor travellingVendor = null;
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			travellingVendor = ((Component)baseEntity).GetComponent<TravellingVendor>();
			if (Object.op_Implicit((Object)(object)travellingVendor))
			{
				travellingVendor.Spawn();
				travellingVendor.InstallPath(runtimePath, 1);
			}
			else
			{
				baseEntity.Kill();
			}
		}
		return travellingVendor;
	}

	private static (bool Valid, int Index) GetSpawnPoint(Vector3[] points)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int num = Random.Range(0, points.Length);
		for (int i = 0; i < 15; i++)
		{
			if (CheckSpawnPosition(points[num]))
			{
				return (Valid: true, Index: num);
			}
			num = Random.Range(0, points.Length);
		}
		Debug.Log((object)("Failed to spawn a travelling vendor after " + 15 + " attempts."));
		return (Valid: false, Index: 0);
	}

	public static TravellingVendor SpawnTravellingVendorForEvent()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		if (TerrainMeta.Path.MainRoads.Count == 0)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: No roads available to spawn on.");
			return null;
		}
		foreach (PathList mainRoad in TerrainMeta.Path.MainRoads)
		{
			if (mainRoad.Path.GetStartPoint() == mainRoad.Path.GetEndPoint())
			{
				pathList = mainRoad;
				break;
			}
		}
		if (pathList == null)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: can't find Ring Road.");
			return null;
		}
		if (pathList.Path.Points.Length == 0)
		{
			Debug.Log((object)"Can't spawn Travelling Vendor: Road has no points.");
			return null;
		}
		int num = pathList.Path.Points.Length - 1;
		IAIPathNode[] nodes = new RuntimePathNode[num];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num2 = 0;
		int num3 = pathList.Path.MaxIndex - 1;
		for (int i = pathList.Path.MinIndex; i <= num3; i++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[i] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num2] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num2++;
		}
		runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
		runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		int num4 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num4 = Mathf.Clamp(num4, 1, 3);
		num4++;
		for (int j = 0; j < num4; j++)
		{
			int num5 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode = new RuntimeInterestNode(pathList.Path.Points[num5] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
		}
		(bool, int) spawnPoint = GetSpawnPoint(pathList.Path.Points);
		if (spawnPoint.Item1)
		{
			int item = spawnPoint.Item2;
			Vector3 val = pathList.Path.Points[(item + 1) % pathList.Path.Points.Length] - pathList.Path.Points[item];
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/travelling vendor/travellingvendor.prefab", pathList.Path.Points[item] + Vector3.up * 2f, Quaternion.LookRotation(normalized));
			TravellingVendor travellingVendor = null;
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				travellingVendor = ((Component)baseEntity).GetComponent<TravellingVendor>();
				if (Object.op_Implicit((Object)(object)travellingVendor))
				{
					travellingVendor.Spawn();
					travellingVendor.InstallPath(runtimePath, (item + 1) % pathList.Path.Points.Length);
				}
				else
				{
					baseEntity.Kill();
				}
			}
			return travellingVendor;
		}
		return null;
	}

	private static bool CheckSpawnPosition(Vector3 testPosition)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.TopologyMap.GetTopology(testPosition, 1024))
		{
			return false;
		}
		int num = Physics.OverlapSphereNonAlloc(testPosition, 0.3f, spawncheckColliders, obstacleMask | 0x8000000);
		_ = 0;
		return num == 0;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == vendingMachineRef.GetEntity().prefabID && !Application.isLoadingSave)
		{
			vendingMachine = child as NPCVendingMachine;
			if (base.isServer && (Object)(object)vendingMachine != (Object)null)
			{
				vendingMachine.SetFlag(Flags.Reserved4, b: false);
				vendingMachine.UpdateMapMarker();
				vendingMachine.ChangeRefillTime(alive_time_seconds * 0.334f);
			}
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if ((Object)(object)vendingMachine == (Object)null)
		{
			vendingMachine = ((Component)this).GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", (object)vendingMachine, (object)msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", (object)vendingMachine, (object)msg.player);
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override bool IsDebugging()
	{
		return false;
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		BaseCombatEntity baseCombatEntity = info.Initiator as BaseCombatEntity;
		if ((Object)(object)baseCombatEntity != (Object)null)
		{
			baseCombatEntity.MarkHostileFor();
		}
	}

	public void CreateMapMarker()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		mapMarkerInstance = baseEntity as MapMarker;
	}

	public void CreatePreventBuilding()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(preventBuildingPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		preventBuildingInstance = baseEntity;
	}

	public override void Save(SaveInfo info)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		UpdateWheelFlags();
		info.msg.travellingVendor = Pool.Get<TravellingVendor>();
		info.msg.travellingVendor.steeringAngle = wheelFL.wheelCollider.steerAngle;
		info.msg.travellingVendor.velocity = (IsFollowingSpline() ? (((Component)this).transform.forward * splineTranslator.Speed) : myRigidbody.velocity);
		info.msg.travellingVendor.wheelFlags = (int)wheelFlags;
	}

	public override void ServerInit()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (!base.isClient)
		{
			myRigidbody = ((Component)this).GetComponent<Rigidbody>();
			obstacleHits = Pool.Get<List<RaycastHit>>();
			pulloverHits = Pool.Get<List<RaycastHit>>();
			currentMaxSpeed = max_speed;
			timeSinceBackfire = TimeSince.op_Implicit(0f);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			SetFlag(Flags.Reserved5, b: false);
			NightCheck();
			pusher = ((Component)this).GetComponentInChildren<TriggerVehiclePush>();
			forcer = ((Component)this).GetComponentInChildren<TriggerPlayerForce>();
			CreateMapMarker();
			CreatePreventBuilding();
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateObstacles, 0f, ObstacleCheckTime);
			((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateMarker, 0f, MarkerUpdateTime);
			((FacepunchBehaviour)this).InvokeRepeating((Action)BuildingCheck, 1f, 3f);
			((FacepunchBehaviour)this).InvokeRepeating((Action)NightCheck, 0f, 120f);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)preventBuildingInstance != (Object)null && preventBuildingInstance.IsValid())
		{
			preventBuildingInstance.Kill();
		}
		if ((Object)(object)mapMarkerInstance != (Object)null && mapMarkerInstance.IsValid())
		{
			mapMarkerInstance.Kill();
		}
		if (localPlayers != null)
		{
			Pool.FreeUnmanaged<BasePlayer>(ref localPlayers);
		}
		if (obstacleHits != null)
		{
			Pool.FreeUnmanaged<RaycastHit>(ref obstacleHits);
		}
		if (pulloverHits != null)
		{
			Pool.FreeUnmanaged<RaycastHit>(ref pulloverHits);
		}
		if (currentPath != null)
		{
			Pool.FreeUnmanaged<Vector3>(ref currentPath);
		}
	}

	private void StartBackfire()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(backfireEffect.resourcePath, this, 0u, backfirePosition.localPosition, Vector3.zero);
	}

	private void StartHorn()
	{
		ClientRPC(RpcTarget.NetworkGroup("CL_PlayerDetected"));
	}

	private void FixedUpdate()
	{
		if (!base.isClient && DoAI && HasPath())
		{
			ProcessLifetime();
			ProcessHandbrake();
			if (!IsFollowingSpline())
			{
				DoSteering();
				ApplyDownforce();
			}
			ProcessState();
			FetchTargets();
			SendNetworkUpdate();
		}
	}

	private void ProcessHandbrake()
	{
		if (handbrake && !(aliveTimer <= 5f) && wheelFL.wheelCollider.isGrounded && wheelFR.wheelCollider.isGrounded)
		{
			handbrake = false;
			wheelFL.wheelCollider.brakeTorque = 0f;
			wheelFR.wheelCollider.brakeTorque = 0f;
			wheelRL.wheelCollider.brakeTorque = 0f;
			wheelRR.wheelCollider.brakeTorque = 0f;
		}
	}

	private void SetGlobalIndicator()
	{
		if (HasFlag(Flags.Reserved6))
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (globaIndicatorLeft)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved4, b: true);
		}
	}

	private void TurnOffIndicators()
	{
		if (HasFlag(Flags.Reserved2) || HasFlag(Flags.Reserved4))
		{
			SetFlag(Flags.Reserved2, b: false);
			SetFlag(Flags.Reserved4, b: false);
		}
	}

	private void UpdateMarker()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)mapMarkerInstance == (Object)null))
		{
			((Component)mapMarkerInstance).transform.SetPositionAndRotation(((Component)this).transform.position, ((Component)this).transform.rotation);
			mapMarkerInstance.SendNetworkUpdate();
		}
	}

	private void NightCheck()
	{
		bool flag = (Object)(object)TOD_Sky.Instance != (Object)null && (TOD_Sky.Instance.Cycle.Hour > 19f || TOD_Sky.Instance.Cycle.Hour < 8f);
		if (HasFlag(Flags.Reserved5) != flag)
		{
			SetFlag(Flags.Reserved5, flag);
		}
	}

	private void ProcessLifetime()
	{
		aliveTimer += Time.deltaTime;
		if (!(aliveTimer >= alive_time_seconds))
		{
			return;
		}
		if (localPlayers.Count > 0)
		{
			aliveTimer += 120f;
			return;
		}
		if ((Object)(object)mapMarkerInstance != (Object)null)
		{
			mapMarkerInstance.Kill();
		}
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.Kill();
		}
		TravellingVendorEvent.currentVendor = null;
		Kill();
	}

	private void ProcessState()
	{
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return;
		}
		if (internalState == TravellingVendorState.Stopped)
		{
			targetThrottle = 0f;
			if (HasPath())
			{
				internalState = TravellingVendorState.Travelling;
			}
		}
		if (internalState == TravellingVendorState.Travelling)
		{
			targetThrottle = 2f;
			if (instantLeave)
			{
				instantLeave = false;
			}
			if (overrideSteering)
			{
				overrideSteering = false;
			}
			if (!IsFollowingSpline())
			{
				if (!pullingOver)
				{
					AdvancePath();
					pullOverTimer += Time.deltaTime;
					if (pullOverTimer > TimeBetweenPullovers && attempt_pullovers)
					{
						pullingOver = true;
					}
				}
				else
				{
					HandlePullover();
				}
			}
			if (CheckForObstacle())
			{
				instantLeave = true;
				SetWaiting();
				return;
			}
			if (!IsFollowingSpline())
			{
				ApplyForceAtWheels();
			}
			else
			{
				TravelOnSpline();
			}
			if (IsValidPatrons())
			{
				if (pulloverPosition != Vector3.zero)
				{
					return;
				}
				SetWaiting();
			}
		}
		if (internalState == TravellingVendorState.Aligning)
		{
			targetThrottle = 0.2f;
			Vector3 val = currentPath[GetPathIndexAhead(3)] - currentPath[GetPathIndexAhead(2)];
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float steerAngle = ((Vector3.Dot(((Component)this).transform.right, normalized) <= 0f) ? (0f - MaxSteerAngle) : MaxSteerAngle);
			if (Vector3.Angle(((Component)this).transform.forward, pulloverTangent) > 5f)
			{
				wheelFL.wheelCollider.steerAngle = steerAngle;
				wheelFR.wheelCollider.steerAngle = steerAngle;
				ApplyForceAtWheels();
			}
			else
			{
				overrideSteering = false;
				SetPulloverWaiting();
			}
		}
		if (internalState != TravellingVendorState.Waiting)
		{
			return;
		}
		targetThrottle = 0f;
		if (!IsFollowingSpline())
		{
			ApplyBrakesAtWheels();
		}
		else
		{
			SlowOnSpline();
		}
		if (CheckForObstacle())
		{
			return;
		}
		if (!IsValidPatrons() || instantLeave)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)SetTravelling))
			{
				float num = 0f;
				if (waitTimeAccumulator > 0f)
				{
					num = GetWaitAccumulator();
				}
				float num2 = 10f + num;
				((FacepunchBehaviour)this).Invoke((Action)SetTravelling, instantLeave ? 0f : num2);
				if (!instantLeave)
				{
					((FacepunchBehaviour)this).Invoke((Action)SetGlobalIndicator, num2 - 5f);
				}
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)SetTravelling))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetTravelling);
		}
	}

	private void HandlePullover()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (pulloverPosition == Vector3.zero && !FindPullingOverSpot())
		{
			ResetPullover();
			pulloverPosition = Vector3.zero;
			currentMaxSpeed = 1f;
		}
		else
		{
			if (!AtDestination())
			{
				return;
			}
			if (Vector3.Angle(((Component)this).transform.forward, pulloverTangent) > 5f && pulloverPosition != Vector3.zero)
			{
				Vector3 position = pulloverPosition + pulloverTangent * 2f;
				if (!IsPositionClear(position, 2f))
				{
					SetPulloverWaiting();
					return;
				}
				overrideSteering = true;
				internalState = TravellingVendorState.Aligning;
				SetFlag(Flags.Reserved1, b: false);
			}
			else
			{
				SetPulloverWaiting();
			}
		}
	}

	private void SetPulloverWaiting()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		currentPathIndex = GetPathIndexAhead(4);
		SetDestination(currentPath[currentPathIndex]);
		SetWaiting();
		TurnOffIndicators();
		SetFlag(Flags.Reserved6, b: true);
		waitTimeAccumulator += 60f;
		ResetPullover();
	}

	private bool FindPullingOverSpot()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		pulloverHits.Clear();
		bool flag = Random.value > 0.5f;
		Vector3 val = currentPath[GetPathIndexAhead(3)] - currentPath[GetPathIndexAhead(2)];
		pulloverTangent = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Vector3.Cross(((Component)this).transform.up, pulloverTangent);
		Vector3 val3 = Vector3.Cross(pulloverTangent, ((Component)this).transform.up);
		if (!TryFindClearPulloverPoint(flag, out var testedPosition))
		{
			flag = !flag;
			if (!TryFindClearPulloverPoint(flag, out testedPosition))
			{
				return false;
			}
		}
		globaIndicatorLeft = !flag;
		if (flag)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		else
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		if ((Object)(object)preventBuildingInstance != (Object)null)
		{
			preventBuildingInstance.SetParent(null);
			((Component)preventBuildingInstance).transform.position = pulloverPosition;
		}
		pulloverPosition = testedPosition;
		SetDestination(pulloverPosition, 2f);
		return true;
	}

	private Vector3 GetAdjustedPulloverPoint(bool onLeft)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 side = (onLeft ? Vector3.Cross(pulloverTangent, ((Component)this).transform.up) : Vector3.Cross(((Component)this).transform.up, pulloverTangent));
		Vector3 pulloverPointFromSide = GetPulloverPointFromSide(side);
		float height = TerrainMeta.HeightMap.GetHeight(pulloverPointFromSide);
		pulloverPointFromSide.y = height + 1f;
		return pulloverPointFromSide;
	}

	private bool TryFindClearPulloverPoint(bool onLeft, out Vector3 testedPosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 adjustedPulloverPoint = GetAdjustedPulloverPoint(onLeft);
		Vector3 val = adjustedPulloverPoint - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		testedPosition = adjustedPulloverPoint;
		bool num = IsDirectionClear(normalized, adjustedPulloverPoint);
		bool flag = IsPositionClear(adjustedPulloverPoint);
		return num && flag;
	}

	private Vector3 GetPulloverPointFromSide(Vector3 side, bool inFront = true)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (inFront)
		{
			return currentPath[GetPathIndexAhead(2)] + side * 3.2f + pulloverTangent * 3f;
		}
		return currentPath[GetPathIndexAhead(-2)] + side * 3.2f + pulloverTangent * 3f;
	}

	private bool IsPositionClear(Vector3 position, float radiusCheck = 4.5f)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<Collider> list = Pool.Get<List<Collider>>();
		Vis.Colliders<Collider>(position, radiusCheck, list, obstacleMask, (QueryTriggerInteraction)2);
		bool result = true;
		if (list == null)
		{
			return false;
		}
		if (list.Count > 0)
		{
			foreach (Collider item in list)
			{
				if (!((Object)(object)item == (Object)null) && !((Object)(object)((Component)item).gameObject == (Object)null) && !((Object)(object)((Component)item).transform == (Object)null) && !((Component)item).transform.IsChildOf(((Component)this).transform) && !((Object)(object)((Component)item).transform == (Object)(object)((Component)this).transform) && !((Component)item).CompareTag("IgnoreCollider"))
				{
					result = false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return result;
	}

	private bool IsDirectionClear(Vector3 direction, Vector3 point)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		UpdateObstacleList(pulloverHits, direction, 3.5f);
		foreach (RaycastHit pulloverHit in pulloverHits)
		{
			RaycastHit current = pulloverHit;
			if (!((Component)((RaycastHit)(ref current)).collider).CompareTag("IgnoreCollider") && !((Component)((RaycastHit)(ref current)).collider).CompareTag("Main Terrain") && !((Component)((RaycastHit)(ref current)).collider).transform.IsChildOf(((Component)this).transform) && !((Object)(object)((Component)((RaycastHit)(ref current)).collider).transform == (Object)(object)((Component)this).transform))
			{
				return false;
			}
		}
		float height = TerrainMeta.HeightMap.GetHeight(point);
		Vector3 testPos = point;
		testPos.y = height + 1f;
		if (Vector3Ex.DotDegrees(((Component)this).transform.up, GetTerrainNormal(testPos)) >= maxPulloverAngleDifference)
		{
			return false;
		}
		return true;
	}

	private Vector3 GetTerrainNormal(Vector3 testPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (TransformUtil.GetGroundInfo(testPos, out hit, 100f, LayerMask.op_Implicit(8388608)))
		{
			return ((RaycastHit)(ref hit)).normal;
		}
		return Vector3.zero;
	}

	private void SetWaiting()
	{
		internalState = TravellingVendorState.Waiting;
		((Behaviour)forcer).enabled = false;
		((Behaviour)pusher).enabled = false;
		SetFlag(Flags.Reserved1, b: true);
		targetThrottle = 0f;
		brakes = 1f;
	}

	private void SetTravelling()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)preventBuildingInstance != (Object)null && preventBuildingInstance.parentEntity.uid != net.ID)
		{
			preventBuildingInstance.SetParent(this);
			((Component)preventBuildingInstance).transform.localPosition = Vector3.zero;
		}
		((Behaviour)forcer).enabled = true;
		((Behaviour)pusher).enabled = true;
		if (TimeSince.op_Implicit(timeSinceBackfire) > 30f && Random.value < 0.6f)
		{
			timeSinceBackfire = TimeSince.op_Implicit(0f);
			((FacepunchBehaviour)this).Invoke((Action)StartBackfire, Random.Range(1f, 4f));
		}
		if (HasFlag(Flags.Reserved6))
		{
			SetFlag(Flags.Reserved6, b: false);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TurnOffIndicators))
		{
			((FacepunchBehaviour)this).Invoke((Action)TurnOffIndicators, 3f, 0f);
		}
		SetFlag(Flags.Reserved1, b: false);
		internalState = TravellingVendorState.Travelling;
		brakes = 0f;
	}

	private void AdvancePath()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (currentPath != null)
		{
			if (PathComplete())
			{
				currentPathIndex = 0;
				flag = true;
			}
			else if (AtDestination())
			{
				currentPathIndex = GetPathIndexAhead(2);
				flag = true;
			}
			if (flag)
			{
				SetDestination(currentPath[currentPathIndex]);
			}
		}
	}

	private int GetPathIndexAhead(int ahead)
	{
		if (currentPath == null)
		{
			return 0;
		}
		return (currentPathIndex + ahead) % currentPath.Count;
	}

	private void ResetPullover()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		pullingOver = false;
		pullOverTimer = 0f;
		pulloverPosition = Vector3.zero;
		pulloverTangent = Vector3.zero;
	}

	private float GetWaitAccumulator()
	{
		float result = waitTimeAccumulator;
		waitTimeAccumulator = 0f;
		return result;
	}

	public void ScaleSidewaysFriction(float scale)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		float stiffness = 0.75f + 0.75f * scale;
		WheelFrictionCurve sidewaysFriction = wheelFL.wheelCollider.sidewaysFriction;
		((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = stiffness;
		wheelFL.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelFR.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelRL.wheelCollider.sidewaysFriction = sidewaysFriction;
		wheelRR.wheelCollider.sidewaysFriction = sidewaysFriction;
	}

	private void ApplyDownforce()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		myRigidbody.AddForce(-((Component)this).transform.up * downforceCoefficient);
	}

	private void UpdateWheelFlags()
	{
		if (wheelFL.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.FrontLeft;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.FrontLeft;
		}
		if (wheelFR.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.FrontRight;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.FrontRight;
		}
		if (wheelRL.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.RearLeft;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.RearLeft;
		}
		if (wheelRR.wheelCollider.isGrounded)
		{
			wheelFlags |= WheelIsGroundedFlags.RearRight;
		}
		else
		{
			wheelFlags &= ~WheelIsGroundedFlags.RearRight;
		}
	}

	private void BuildingCheck()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, 1075937536, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is Barricade barricade))
			{
				if (!(item is LootContainer lootContainer))
				{
					if (!(item is ConstructableEntity constructableEntity))
					{
						if (!(item is TreeEntity treeEntity))
						{
							if (!(item is DecayEntity decayEntity))
							{
								if (item is TrainCar { isServer: not false } trainCar && trainCar.IsAlive())
								{
									trainCar.Kill(DestroyMode.Gib);
								}
							}
							else if (should_destroy_buildings && (Object)(object)decayEntity.parentEntity.Get(serverside: true) != (Object)(object)this && decayEntity.isServer && decayEntity.IsAlive())
							{
								decayEntity.Kill(DestroyMode.Gib);
							}
						}
						else if (treeEntity.isServer)
						{
							treeEntity.Kill();
						}
					}
					else if (constructableEntity.isServer && constructableEntity.IsAlive())
					{
						constructableEntity.Kill(DestroyMode.Gib);
					}
				}
				else if (lootContainer.isServer && lootContainer.IsAlive())
				{
					lootContainer.Kill(DestroyMode.Gib);
				}
			}
			else if (barricade.isServer && barricade.IsAlive())
			{
				barricade.Kill(DestroyMode.Gib);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private bool CheckForObstacle()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		if (obstacleHits == null)
		{
			return false;
		}
		if (obstacleHits.Count <= 0)
		{
			return false;
		}
		foreach (RaycastHit obstacleHit in obstacleHits)
		{
			RaycastHit current = obstacleHit;
			if ((Object)(object)((RaycastHit)(ref current)).collider == (Object)null)
			{
				continue;
			}
			if (((RaycastHit)(ref current)).collider.ToBaseEntity() is BradleyAPC)
			{
				obstacleHits.Clear();
				return true;
			}
			if (!(((RaycastHit)(ref current)).collider.ToBaseEntity() is BasePlayer basePlayer) || IsPlayerIgnored(basePlayer) || basePlayer.IsFlying || IsInvalidPlayer(basePlayer))
			{
				continue;
			}
			if (TimeSince.op_Implicit(timeSincePlayerDetected) > 10f)
			{
				((FacepunchBehaviour)this).Invoke((Action)StartHorn, (float)Random.Range(1, 4));
				timeSincePlayerDetected = TimeSince.op_Implicit(0f);
			}
			if (playerRecords.ContainsKey(basePlayer))
			{
				VendorTargetInfo vendorTargetInfo = playerRecords[basePlayer];
				if (vendorTargetInfo.lastBlockingTime > Time.time + 60f)
				{
					vendorTargetInfo.blockingAccumulator = 0f;
					vendorTargetInfo.lastBlockingTime = Time.time;
					playerRecords[basePlayer] = vendorTargetInfo;
					continue;
				}
				vendorTargetInfo.lastBlockingTime = Time.time;
				vendorTargetInfo.blockingAccumulator += Time.deltaTime;
				if (vendorTargetInfo.blockingAccumulator > allowedVendorBlockTime)
				{
					IgnorePlayer(basePlayer);
				}
				else
				{
					playerRecords[basePlayer] = vendorTargetInfo;
				}
			}
			else
			{
				playerRecords.Add(basePlayer, new VendorTargetInfo
				{
					blockingAccumulator = Time.deltaTime,
					ignoredUntil = 0f,
					lastBlockingTime = Time.time,
					lastSeenTime = Time.time
				});
			}
			obstacleHits.Clear();
			return true;
		}
		return false;
	}

	private void UpdateObstacles()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		UpdateObstacleList(obstacleHits, ((Component)this).transform.forward);
	}

	private void UpdateObstacleList(List<RaycastHit> hits, Vector3 forward, float checkRadius = 2.5f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		hits.Clear();
		GamePhysics.TraceAll(new Ray(((Component)this).transform.position + ((Component)this).transform.forward * (((Bounds)(ref bounds)).extents.z / 0.6f - 1f), forward), checkRadius, hits, 15f, obstacleMask | 1 | 0x8000, (QueryTriggerInteraction)1, this);
	}

	private void DoSteering()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 velocity = myRigidbody.velocity;
		float magnitude = ((Vector3)(ref velocity)).magnitude;
		velocity = myRigidbody.velocity;
		float num = Mathf.InverseLerp(5f, 1.5f, magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		ScaleSidewaysFriction(1f - num);
		if (!overrideSteering)
		{
			Vector3 val = ((Component)this).transform.InverseTransformPoint(destination);
			steeringAngle = Mathf.Atan2(val.x, val.z);
			steeringAngle *= 57.29578f;
			float num2 = steeringSmoothing * Time.deltaTime;
			smoothedSteering = Mathf.Lerp(smoothedSteering, steeringAngle, num2);
			wheelFL.wheelCollider.steerAngle = smoothedSteering;
			wheelFR.wheelCollider.steerAngle = smoothedSteering;
		}
	}

	private void ApplyForceAtWheels()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		if (handbrake)
		{
			wheelFL.wheelCollider.brakeTorque = 1000f;
			wheelFR.wheelCollider.brakeTorque = 1000f;
			wheelRL.wheelCollider.brakeTorque = 1000f;
			wheelRR.wheelCollider.brakeTorque = 1000f;
			return;
		}
		throttle = Mathf.MoveTowards(throttle, targetThrottle, acceleration * Time.deltaTime);
		float num = throttle * motorForceConstant * 5f;
		Vector3 velocity = myRigidbody.velocity;
		bool flag = ((Vector3)(ref velocity)).magnitude >= max_speed;
		wheelFL.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelFR.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelRL.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		wheelRR.wheelCollider.brakeTorque = (flag ? brakeForceConstant : 0f);
		if (wheelFL.wheelCollider.isGrounded)
		{
			wheelFL.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelFR.wheelCollider.isGrounded)
		{
			wheelFR.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelRL.wheelCollider.isGrounded)
		{
			wheelRL.wheelCollider.motorTorque = num / 4f;
		}
		if (wheelRR.wheelCollider.isGrounded)
		{
			wheelRR.wheelCollider.motorTorque = num / 4f;
		}
	}

	private void ApplyBrakesAtWheels()
	{
		brakes = Mathf.Clamp(brakes, 0f, 1f);
		wheelFL.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelFR.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelRL.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelRR.wheelCollider.brakeTorque = brakes * brakeForceConstant;
		wheelFR.wheelCollider.motorTorque = 0f;
		wheelFL.wheelCollider.motorTorque = 0f;
		wheelRL.wheelCollider.motorTorque = 0f;
		wheelRR.wheelCollider.motorTorque = 0f;
	}

	private float CalculateSteeringAngle(float radius)
	{
		return Mathf.Atan(wheelbase / radius);
	}

	private void HandleSplineMovement()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		splineTranslator.SetOffset(splineOffset);
		splineTranslator.Update(Time.deltaTime);
		splineTranslator.GetCurrentPositionAndTangent(out var position, out var tangent);
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, position, Time.deltaTime * splineMovementSpeed * 10f);
		Vector3 val = splineTranslator.PeekNextPositionFollowingDirection();
		tangent = val - position;
		Vector3 normalized = ((Vector3)(ref tangent)).normalized;
		((Component)this).transform.forward = normalized;
		Vector3 val2 = ((Component)this).transform.InverseTransformPoint(val);
		steeringAngle = Mathf.Atan2(val2.x, val2.z);
		steeringAngle *= 57.29578f;
		wheelFL.wheelCollider.steerAngle = steeringAngle;
		wheelFR.wheelCollider.steerAngle = steeringAngle;
	}

	private void TravelOnSpline()
	{
		splineTranslator.SetSpeed(splineMovementSpeed);
		slowdownStartSpeed = splineMovementSpeed;
		HandleSplineMovement();
	}

	private void SlowOnSpline()
	{
		splineTranslator.SetSpeed(slowdownStartSpeed);
		HandleSplineMovement();
		slowdownStartSpeed = Mathf.MoveTowards(slowdownStartSpeed, 0f, Time.deltaTime * 2f);
	}

	private void StopSplineMovement()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		overrideSteering = false;
		myRigidbody.isKinematic = false;
		int num = FindClosestNode() + 2 % currentPath.Count;
		currentPathIndex = num;
		SetDestination(currentPath[currentPathIndex]);
	}

	public void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction)
	{
		if (splineId == -1 && (Object)(object)this.spline != (Object)(object)spline)
		{
			if (splineTranslator == null)
			{
				splineTranslator = new SimpleSplineTranslator();
			}
			myRigidbody.isKinematic = true;
			splineTranslator.SetSpline(spline).SetSpeed(splineMovementSpeed).SetDirection(direction)
				.CalculateStartingDistance();
			splineId = pathId;
			this.spline = spline;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CheckForSplineStart))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForSplineStart, 0f, 1f);
			}
		}
		else if (splineId != pathId)
		{
			StopSplineMovement();
			splineId = -1;
			followingSpine = false;
		}
	}

	public void OnBasePathTrigger(int pathId, BasePath path)
	{
	}

	private void CheckForSplineStart()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float start = splineTranslator.GetStart();
		Vector3 positionAtDistance = splineTranslator.GetPositionAtDistance(start, out var _);
		positionAtDistance += splineOffset;
		Vector3 val = ((Component)spline).transform.TransformPoint(positionAtDistance);
		if (Vector3Ex.Distance2D(((Component)this).transform.position, val) < 1.5f)
		{
			overrideSteering = true;
			followingSpine = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForSplineStart);
		}
	}

	public void InstallPath(RuntimePath path, int initialDestination)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (currentPath == null)
		{
			currentPath = Pool.Get<List<Vector3>>();
		}
		currentPath.Clear();
		IAIPathNode[] nodes = path.Nodes;
		foreach (IAIPathNode iAIPathNode in nodes)
		{
			currentPath.Add(iAIPathNode.Position);
		}
		currentPathIndex = initialDestination;
		SetDestination(currentPath[currentPathIndex]);
	}

	private bool HasPath()
	{
		if (currentPath != null)
		{
			return currentPath.Count > 0;
		}
		return false;
	}

	private bool IsFollowingSpline()
	{
		return followingSpine;
	}

	private void ClearPath()
	{
		currentPath.Clear();
		currentPathIndex = -1;
	}

	private bool IndexValid(int index)
	{
		if (!HasPath())
		{
			return false;
		}
		if (index >= 0)
		{
			return index < currentPath.Count;
		}
		return false;
	}

	private Vector3 GetCurrentPathDestination()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		return currentPath[currentPathIndex];
	}

	private bool PathComplete()
	{
		if (HasPath())
		{
			if (currentPathIndex == currentPath.Count - 1)
			{
				return AtDestination();
			}
			return false;
		}
		return true;
	}

	public void SetDestination(Vector3 dest, float destinationDistance = 8f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		atDestinationDistance = destinationDistance;
		destination = dest;
	}

	public bool AtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) <= atDestinationDistance;
	}

	private int FindClosestNode()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		int result = 0;
		for (int i = 0; i < currentPath.Count; i++)
		{
			Vector3 val = currentPath[i];
			float num2 = Vector3Ex.Distance2D(((Component)this).transform.position, val);
			if (num2 < num)
			{
				num = num2;
				result = i;
			}
		}
		return result;
	}

	private void FetchTargets()
	{
		if (playerRecords == null)
		{
			playerRecords = new ListDictionary<BasePlayer, VendorTargetInfo>();
		}
		if (localPlayers == null)
		{
			localPlayers = Pool.Get<List<BasePlayer>>();
		}
		List<BaseEntity> foundEntities = Pool.Get<List<BaseEntity>>();
		FetchCycle(foundEntities);
		Pool.FreeUnmanaged<BaseEntity>(ref foundEntities);
	}

	private void FetchCycle(List<BaseEntity> foundEntities)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vis.Entities(((Component)this).transform.position, searchRange, foundEntities, 133120, (QueryTriggerInteraction)2);
		localPlayers.Clear();
		foreach (BaseEntity foundEntity in foundEntities)
		{
			if (!(foundEntity is BasePlayer basePlayer) || basePlayer is HumanNPC || basePlayer is NPCPlayer || IsInvalidPlayer(basePlayer))
			{
				continue;
			}
			if (playerRecords.ContainsKey(basePlayer))
			{
				VendorTargetInfo vendorTargetInfo = playerRecords[basePlayer];
				vendorTargetInfo.lastSeenTime = Time.time;
				playerRecords[basePlayer] = vendorTargetInfo;
				if (!IsPlayerIgnored(basePlayer))
				{
					localPlayers.Add(basePlayer);
				}
			}
			else
			{
				playerRecords.Add(basePlayer, new VendorTargetInfo
				{
					blockingAccumulator = 0f,
					ignoredUntil = 0f,
					lastBlockingTime = 0f,
					lastSeenTime = Time.time
				});
				localPlayers.Add(basePlayer);
			}
		}
	}

	private bool IsInvalidPlayer(BasePlayer player)
	{
		int result = (int)(0u | (player.IsDead() ? 1u : 0u) | (player.IsSleeping() ? 1u : 0u) | (player.IsHostile() ? 1u : 0u)) | (player.isClient ? 1 : 0);
		if (player.IsHostile())
		{
			IgnorePlayer(player);
		}
		return (byte)result != 0;
	}

	private void IgnorePlayer(BasePlayer player)
	{
		if (localPlayers.Contains(player))
		{
			localPlayers.Remove(player);
		}
		float num = 90f;
		if (playerRecords.ContainsKey(player))
		{
			VendorTargetInfo vendorTargetInfo = playerRecords[player];
			vendorTargetInfo.ignoredUntil = Time.time + num;
			playerRecords[player] = vendorTargetInfo;
		}
		else
		{
			playerRecords.Add(player, new VendorTargetInfo
			{
				blockingAccumulator = 0f,
				ignoredUntil = num,
				lastBlockingTime = 0f,
				lastSeenTime = Time.time
			});
		}
	}

	private bool IsValidPatrons()
	{
		List<BasePlayer> list = localPlayers;
		if ((list != null && list.Count == 0) || localPlayers == null)
		{
			return false;
		}
		return localPlayers.Count > 0;
	}

	private bool IsPlayerIgnored(BasePlayer player)
	{
		if (playerRecords.ContainsKey(player))
		{
			return playerRecords[player].IsIgnored;
		}
		return false;
	}
}
