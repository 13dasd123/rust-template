using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Ionic.Crc;
using Network;
using Network.Visibility;
using ProtoBuf;
using Rust;
using Steamworks;
using Steamworks.Data;
using UnityEngine;

public class ServerMgr : SingletonComponent<ServerMgr>, IServerCallback
{
	private ConnectionAuth auth;

	private bool runFrameUpdate;

	private bool useQueryPort;

	public UserPersistance persistance;

	private string _AssemblyHash;

	private IEnumerator restartCoroutine;

	public ConnectionQueue connectionQueue = new ConnectionQueue();

	private Stopwatch queryTimer = Stopwatch.StartNew();

	private Dictionary<uint, int> unconnectedQueries = new Dictionary<uint, int>();

	private Stopwatch queriesPerSeconTimer = Stopwatch.StartNew();

	private int NumQueriesLastSecond;

	private MemoryStream queryBuffer = new MemoryStream();

	public static int AvailableSlots => ConVar.Server.maxplayers - BasePlayer.activePlayerList.Count();

	private string AssemblyHash
	{
		get
		{
			if (_AssemblyHash == null)
			{
				string location = typeof(ServerMgr).Assembly.Location;
				if (!string.IsNullOrEmpty(location))
				{
					byte[] array = File.ReadAllBytes(location);
					CRC32 cRC = new CRC32();
					cRC.SlurpBlock(array, 0, array.Length);
					_AssemblyHash = cRC.Crc32Result.ToString("x");
				}
				else
				{
					_AssemblyHash = "il2cpp";
				}
			}
			return _AssemblyHash;
		}
	}

	public bool Restarting => restartCoroutine != null;

	public void Initialize(bool loadSave = true, string saveFile = "", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)
	{
		persistance = new UserPersistance(ConVar.Server.rootFolder);
		SpawnMapEntities();
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			using (TimeWarning.New("SpawnHandler.UpdateDistributions"))
			{
				SingletonComponent<SpawnHandler>.Instance.UpdateDistributions();
			}
		}
		if (loadSave)
		{
			skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves);
		}
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			if (!skipInitialSpawn)
			{
				using (TimeWarning.New("SpawnHandler.InitialSpawn", 200L))
				{
					SingletonComponent<SpawnHandler>.Instance.InitialSpawn();
				}
			}
			using (TimeWarning.New("SpawnHandler.StartSpawnTick", 200L))
			{
				SingletonComponent<SpawnHandler>.Instance.StartSpawnTick();
			}
		}
		CreateImportantEntities();
		auth = GetComponent<ConnectionAuth>();
	}

	public void OpenConnection()
	{
		useQueryPort = ConVar.Server.queryport > 0 && ConVar.Server.queryport != ConVar.Server.port;
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			return;
		}
		StartSteamServer();
		Network.Net.sv.callbackHandler = this;
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		EACServer.DoStartup();
		InvokeRepeating("EACUpdate", 1f, 1f);
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
	}

	private void CloseConnection()
	{
		if (persistance != null)
		{
			persistance.Dispose();
			persistance = null;
		}
		EACServer.DoShutdown();
		Network.Net.sv.callbackHandler = null;
		using (TimeWarning.New("sv.Stop"))
		{
			Network.Net.sv.Stop("Shutting Down");
		}
		using (TimeWarning.New("RCon.Shutdown"))
		{
			RCon.Shutdown();
		}
		using (TimeWarning.New("Steamworks.GameServer.Shutdown"))
		{
			if (SteamServer.IsValid)
			{
				UnityEngine.Debug.Log("Steamworks Shutting Down");
				SteamServer.Shutdown();
				UnityEngine.Debug.Log("Okay");
			}
		}
		ConsoleSystem.OnReplicatedVarChanged -= OnReplicatedVarChanged;
	}

	private void OnDisable()
	{
		if (!Rust.Application.isQuitting)
		{
			CloseConnection();
		}
	}

	private void OnApplicationQuit()
	{
		Rust.Application.isQuitting = true;
		CloseConnection();
	}

	private void CreateImportantEntities()
	{
		CreateImportantEntity<EnvSync>("assets/bundled/prefabs/system/net_env.prefab");
		CreateImportantEntity<CommunityEntity>("assets/bundled/prefabs/system/server/community.prefab");
		CreateImportantEntity<ResourceDepositManager>("assets/bundled/prefabs/system/server/resourcedepositmanager.prefab");
		CreateImportantEntity<RelationshipManager>("assets/bundled/prefabs/system/server/relationship_manager.prefab");
		CreateImportantEntity<TreeManager>("assets/bundled/prefabs/system/tree_manager.prefab");
	}

	private void CreateImportantEntity<T>(string prefabName) where T : BaseEntity
	{
		if (!BaseNetworkable.serverEntities.Any((BaseNetworkable x) => x is T))
		{
			UnityEngine.Debug.LogWarning("Missing " + typeof(T).Name + " - creating");
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabName);
			if (baseEntity == null)
			{
				UnityEngine.Debug.LogWarning("Couldn't create");
			}
			else
			{
				baseEntity.Spawn();
			}
		}
	}

	private void StartSteamServer()
	{
		if (!SteamServer.IsValid)
		{
			IPAddress ipAddress = null;
			if (!string.IsNullOrEmpty(ConVar.Server.ip))
			{
				ipAddress = IPAddress.Parse(ConVar.Server.ip);
			}
			SteamServerInit init = new SteamServerInit("rust", "Rust");
			init.IpAddress = ipAddress;
			init.GamePort = (ushort)Network.Net.sv.port;
			init.Secure = ConVar.Server.secure;
			init.VersionString = 2201.ToString();
			if (useQueryPort)
			{
				init.QueryPort = (ushort)ConVar.Server.queryport;
			}
			else
			{
				init = init.WithQueryShareGamePort();
			}
			SteamServer.OnCallbackException = delegate(Exception e)
			{
				UnityEngine.Debug.LogError(e.Message);
				UnityEngine.Debug.LogError(e.StackTrace);
			};
			try
			{
				SteamServer.Init(Rust.Defines.appID, init);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogWarning("Couldn't initialize Steam Server (" + ex.Message + ")");
				Rust.Application.Quit();
				return;
			}
			SteamServer.OnValidateAuthTicketResponse += OnValidateAuthTicketResponse;
			SteamServer.OnSteamServerConnectFailure += OnSteamConnectionFailure;
			SteamServer.OnSteamServersDisconnected += OnSteamServersDisconnected;
			SteamServer.OnSteamServersConnected += OnSteamConnected;
			Steamworks.SteamInventory.OnDefinitionsUpdated += OnInventoryDefinitionsUpdated;
			SteamServer.DedicatedServer = true;
			SteamServer.LogOnAnonymous();
			InvokeRepeating("UpdateServerInformation", 2f, 30f);
			InvokeRepeating("UpdateItemDefinitions", 10f, 3600f);
			DebugEx.Log("SteamServer Initialized");
		}
	}

	private void OnSteamServersDisconnected(Result result)
	{
		UnityEngine.Debug.LogWarning($"SteamServer Disconnected ({result})");
	}

	private void OnSteamConnected()
	{
		UnityEngine.Debug.Log("SteamServer Connected");
		Invoke("UpdateServerInformation", 1f);
	}

	private void OnSteamConnectionFailure(Result result, bool stilltrying)
	{
		UnityEngine.Debug.LogWarning($"SteamServer Connection Failure ({result})");
	}

	private void UpdateItemDefinitions()
	{
		UnityEngine.Debug.Log("Checking for new Steam Item Definitions..");
		Steamworks.SteamInventory.LoadItemDefinitions();
	}

	private void OnInventoryDefinitionsUpdated()
	{
		ItemManager.InvalidateWorkshopSkinCache();
	}

	private void OnValidateAuthTicketResponse(SteamId SteamId, SteamId OwnerId, AuthResponse Status)
	{
		if (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))
		{
			return;
		}
		Network.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) => x.userid == (ulong)SteamId);
		if (connection == null)
		{
			UnityEngine.Debug.LogWarning($"Steam gave us a {Status} ticket response for unconnected id {SteamId}");
			return;
		}
		switch (Status)
		{
		case AuthResponse.OK:
			UnityEngine.Debug.LogWarning($"Steam gave us a 'ok' ticket response for already connected id {SteamId}");
			break;
		case AuthResponse.VACCheckTimedOut:
			break;
		default:
			connection.authStatus = Status.ToString();
			Network.Net.sv.Kick(connection, "Steam: " + Status);
			break;
		}
	}

	private void EACUpdate()
	{
		EACServer.DoUpdate();
	}

	private void Update()
	{
		if (!runFrameUpdate)
		{
			return;
		}
		using (TimeWarning.New("ServerMgr.Update", 500L))
		{
			if (EACServer.playerTracker != null)
			{
				EACServer.playerTracker.BeginFrame();
			}
			try
			{
				using (TimeWarning.New("Net.sv.Cycle", 100L))
				{
					Network.Net.sv.Cycle();
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogWarning("Server Exception: Network Cycle");
				UnityEngine.Debug.LogException(exception, this);
			}
			try
			{
				using (TimeWarning.New("ServerBuildingManager.Cycle"))
				{
					BuildingManager.server.Cycle();
				}
			}
			catch (Exception exception2)
			{
				UnityEngine.Debug.LogWarning("Server Exception: Building Manager");
				UnityEngine.Debug.LogException(exception2, this);
			}
			try
			{
				using (TimeWarning.New("BasePlayer.ServerCycle"))
				{
					bool batchsynctransforms = ConVar.Physics.batchsynctransforms;
					bool autosynctransforms = ConVar.Physics.autosynctransforms;
					if (batchsynctransforms && autosynctransforms)
					{
						UnityEngine.Physics.autoSyncTransforms = false;
					}
					if (!UnityEngine.Physics.autoSyncTransforms)
					{
						UnityEngine.Physics.SyncTransforms();
					}
					BasePlayer.ServerCycle(UnityEngine.Time.deltaTime);
					if (batchsynctransforms && autosynctransforms)
					{
						UnityEngine.Physics.autoSyncTransforms = true;
					}
				}
			}
			catch (Exception exception3)
			{
				UnityEngine.Debug.LogWarning("Server Exception: Player Update");
				UnityEngine.Debug.LogException(exception3, this);
			}
			try
			{
				using (TimeWarning.New("SteamQueryResponse"))
				{
					SteamQueryResponse();
				}
			}
			catch (Exception exception4)
			{
				UnityEngine.Debug.LogWarning("Server Exception: Steam Query");
				UnityEngine.Debug.LogException(exception4, this);
			}
			try
			{
				using (TimeWarning.New("connectionQueue.Cycle"))
				{
					connectionQueue.Cycle(AvailableSlots);
				}
			}
			catch (Exception exception5)
			{
				UnityEngine.Debug.LogWarning("Server Exception: Connection Queue");
				UnityEngine.Debug.LogException(exception5, this);
			}
			try
			{
				using (TimeWarning.New("IOEntity.ProcessQueue"))
				{
					IOEntity.ProcessQueue();
				}
			}
			catch (Exception exception6)
			{
				UnityEngine.Debug.LogWarning("Server Exception: IOEntity.ProcessQueue");
				UnityEngine.Debug.LogException(exception6, this);
			}
			try
			{
				using (TimeWarning.New("AIThinkManager.ProcessQueue"))
				{
					AIThinkManager.ProcessQueue();
				}
			}
			catch (Exception exception7)
			{
				UnityEngine.Debug.LogWarning("Server Exception: AIThinkManager.ProcessQueue");
				UnityEngine.Debug.LogException(exception7, this);
			}
			try
			{
				using (TimeWarning.New("BaseRidableAnimal.ProcessQueue"))
				{
					BaseRidableAnimal.ProcessQueue();
				}
			}
			catch (Exception exception8)
			{
				UnityEngine.Debug.LogWarning("Server Exception: BaseRidableAnimal.ProcessQueue");
				UnityEngine.Debug.LogException(exception8, this);
			}
			if (EACServer.playerTracker != null)
			{
				EACServer.playerTracker.EndFrame();
			}
		}
	}

	private void FixedUpdate()
	{
		using (TimeWarning.New("ServerMgr.FixedUpdate", 500L))
		{
			try
			{
				using (TimeWarning.New("Buoyancy.Cycle", 100L))
				{
					Buoyancy.Cycle();
				}
			}
			catch (Exception exception)
			{
				UnityEngine.Debug.LogWarning("Server Exception: Buoyancy Cycle");
				UnityEngine.Debug.LogException(exception, this);
			}
		}
	}

	private void SteamQueryResponse()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		using (TimeWarning.New("SteamGameServer.GetNextOutgoingPacket"))
		{
			OutgoingPacket packet;
			while (SteamServer.GetOutgoingPacket(out packet))
			{
				Network.Net.sv.SendUnconnected(packet.Address, packet.Port, packet.Data, packet.Size);
			}
		}
	}

	private void DoTick()
	{
		if (SteamServer.IsValid)
		{
			SteamServer.RunCallbacks();
		}
		RCon.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Network.Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

	private void DoHeartbeat()
	{
		ItemManager.Heartbeat();
	}

	public static string GamemodeName()
	{
		return "rust";
	}

	public static string GamemodeTitle()
	{
		return "Rust: Survival Mode";
	}

	public static string GamemodeDesc()
	{
		return "The default Rust survival gamemode";
	}

	public static string GamemodeImage()
	{
		return "https://files.facepunch.com/garry/3c96c182-ab06-40ff-b66e-f4a510053ca4.png";
	}

	public static string GamemodeUrl()
	{
		return "https://rust.facepunch.com";
	}

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		using (TimeWarning.New("UpdateServerInformation"))
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.Name;
			string text = "stok";
			if (Restarting)
			{
				text = "strst";
			}
			string text2 = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text3 = $"gm{GamemodeName()}";
			SteamServer.GameTags = string.Format("mp{0},cp{1},qp{5},v{2}{3},h{4},{6},{7},{8}", ConVar.Server.maxplayers, BasePlayer.activePlayerList.Count, 2201, ConVar.Server.pve ? ",pve" : string.Empty, AssemblyHash, SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued, text, text2, text3);
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = ConVar.Server.description.SplitToChunks(100).ToArray();
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			SteamServer.SetKey("world.seed", World.Seed.ToString());
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("gmd", GamemodeDesc());
			SteamServer.SetKey("gmu", GamemodeUrl());
			SteamServer.SetKey("uptime", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
	}

	public void OnDisconnected(string strReason, Network.Connection connection)
	{
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		SteamServer.EndSession(connection.userid);
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((bool)basePlayer)
		{
			basePlayer.OnDisconnected();
		}
	}

	public static void OnEnterVisibility(Network.Connection connection, Group group)
	{
		if (Network.Net.sv.IsConnected() && Network.Net.sv.write.Start())
		{
			Network.Net.sv.write.PacketID(Message.Type.GroupEnter);
			Network.Net.sv.write.GroupID(group.ID);
			Network.Net.sv.write.Send(new SendInfo(connection));
		}
	}

	public static void OnLeaveVisibility(Network.Connection connection, Group group)
	{
		if (Network.Net.sv.IsConnected())
		{
			if (Network.Net.sv.write.Start())
			{
				Network.Net.sv.write.PacketID(Message.Type.GroupLeave);
				Network.Net.sv.write.GroupID(group.ID);
				Network.Net.sv.write.Send(new SendInfo(connection));
			}
			if (Network.Net.sv.write.Start())
			{
				Network.Net.sv.write.PacketID(Message.Type.GroupDestroy);
				Network.Net.sv.write.GroupID(group.ID);
				Network.Net.sv.write.Send(new SendInfo(connection));
			}
		}
	}

	internal void SpawnMapEntities()
	{
		PrefabPreProcess prefabPreProcess = new PrefabPreProcess(clientside: false, serverside: true);
		BaseEntity[] array = UnityEngine.Object.FindObjectsOfType<BaseEntity>();
		BaseEntity[] array2 = array;
		foreach (BaseEntity baseEntity in array2)
		{
			if (prefabPreProcess.NeedsProcessing(baseEntity.gameObject))
			{
				prefabPreProcess.ProcessObject(null, baseEntity.gameObject, resetLocalTransform: false);
			}
			baseEntity.SpawnAsMapEntity();
		}
		DebugEx.Log($"Map Spawned {array.Length} entities");
		array2 = array;
		foreach (BaseEntity baseEntity2 in array2)
		{
			if (baseEntity2 != null)
			{
				baseEntity2.PostMapEntitySpawn();
			}
		}
	}

	public static BasePlayer.SpawnPoint FindSpawnPoint()
	{
		if (SingletonComponent<SpawnHandler>.Instance != null)
		{
			BasePlayer.SpawnPoint spawnPoint = SpawnHandler.GetSpawnPoint();
			if (spawnPoint != null)
			{
				return spawnPoint;
			}
		}
		BasePlayer.SpawnPoint spawnPoint2 = new BasePlayer.SpawnPoint();
		GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (array.Length != 0)
		{
			GameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];
			spawnPoint2.pos = gameObject.transform.position;
			spawnPoint2.rot = gameObject.transform.rotation;
		}
		else
		{
			UnityEngine.Debug.Log("Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
			if (MainCamera.mainCamera != null)
			{
				spawnPoint2.pos = MainCamera.mainCamera.transform.position;
				spawnPoint2.rot = MainCamera.mainCamera.transform.rotation;
			}
		}
		if (UnityEngine.Physics.Raycast(new Ray(spawnPoint2.pos, Vector3.down), out var hitInfo, 32f, 1537286401))
		{
			spawnPoint2.pos = hitInfo.point;
		}
		return spawnPoint2;
	}

	public void JoinGame(Network.Connection connection)
	{
		using (Approval approval = Facepunch.Pool.Get<Approval>())
		{
			uint num = (uint)ConVar.Server.encryption;
			if (num > 1 && connection.os == "editor" && DeveloperList.Contains(connection.ownerid))
			{
				num = 1u;
			}
			approval.level = UnityEngine.Application.loadedLevelName;
			approval.levelTransfer = World.Transfer;
			approval.levelUrl = World.Url;
			approval.levelSeed = World.Seed;
			approval.levelSize = World.Size;
			approval.checksum = World.Checksum;
			approval.hostname = ConVar.Server.hostname;
			approval.official = ConVar.Server.official;
			approval.encryption = num;
			if (Network.Net.sv.write.Start())
			{
				Network.Net.sv.write.PacketID(Message.Type.Approved);
				approval.WriteToStream(Network.Net.sv.write);
				Network.Net.sv.write.Send(new SendInfo(connection));
			}
			connection.encryptionLevel = num;
			connection.encryptOutgoing = true;
		}
		connection.connected = true;
		SendReplicatedVars(connection);
	}

	internal void Shutdown()
	{
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

	private IEnumerator ServerRestartWarning(string info, int iSeconds)
	{
		if (iSeconds < 0)
		{
			yield break;
		}
		if (!string.IsNullOrEmpty(info))
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restarting: " + info);
		}
		for (int i = iSeconds; i > 0; i--)
		{
			if (i == iSeconds || i % 60 == 0 || (i < 300 && i % 30 == 0) || (i < 60 && i % 10 == 0) || i < 10)
			{
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, $"<color=#fff>SERVER</color> Restarting in {i} seconds!");
				UnityEngine.Debug.Log($"Restarting in {i} seconds");
			}
			yield return CoroutineEx.waitForSeconds(1f);
		}
		ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restarting");
		yield return CoroutineEx.waitForSeconds(2f);
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		for (int j = 0; j < array.Length; j++)
		{
			array[j].Kick("Server Restarting");
		}
		yield return CoroutineEx.waitForSeconds(1f);
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "quit");
	}

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (!(SingletonComponent<ServerMgr>.Instance == null))
		{
			if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
			{
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
				SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
				SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
			}
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

	private static void SendReplicatedVars(Network.Connection connection)
	{
		if (!Network.Net.sv.write.Start())
		{
			return;
		}
		List<ConsoleSystem.Command> replicated = ConsoleSystem.Index.Server.Replicated;
		Network.Net.sv.write.PacketID(Message.Type.ConsoleReplicatedVars);
		Network.Net.sv.write.Int32(replicated.Count);
		foreach (ConsoleSystem.Command item in replicated)
		{
			Network.Net.sv.write.String(item.FullName);
			Network.Net.sv.write.String(item.String);
		}
		Network.Net.sv.write.Send(new SendInfo(connection));
	}

	private static void OnReplicatedVarChanged(string fullName, string value)
	{
		if (!Network.Net.sv.write.Start())
		{
			return;
		}
		List<Network.Connection> obj = Facepunch.Pool.GetList<Network.Connection>();
		foreach (Network.Connection connection in Network.Net.sv.connections)
		{
			if (connection.connected)
			{
				obj.Add(connection);
			}
		}
		Network.Net.sv.write.PacketID(Message.Type.ConsoleReplicatedVars);
		Network.Net.sv.write.Int32(1);
		Network.Net.sv.write.String(fullName);
		Network.Net.sv.write.String(value);
		Network.Net.sv.write.Send(new SendInfo(obj));
		Facepunch.Pool.FreeList(ref obj);
	}

	private void Log(Exception e)
	{
		if (ConVar.Global.developer > 0)
		{
			UnityEngine.Debug.LogException(e);
		}
	}

	public void OnNetworkMessage(Message packet)
	{
		switch (packet.type)
		{
		case Message.Type.GiveUserInformation:
			if (packet.connection.GetPacketsPerSecond(packet.type) > 1)
			{
				Network.Net.sv.Kick(packet.connection, "Packet Flooding: User Information");
				break;
			}
			using (TimeWarning.New("GiveUserInformation", 20L))
			{
				try
				{
					OnGiveUserInformation(packet);
				}
				catch (Exception e7)
				{
					Log(e7);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: User Information");
				}
			}
			packet.connection.AddPacketsPerSecond(packet.type);
			break;
		case Message.Type.Ready:
			if (!packet.connection.isAuthenticated)
			{
				break;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) > 1)
			{
				Network.Net.sv.Kick(packet.connection, "Packet Flooding: Client Ready");
				break;
			}
			using (TimeWarning.New("ClientReady", 20L))
			{
				try
				{
					ClientReady(packet);
				}
				catch (Exception e9)
				{
					Log(e9);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: Client Ready");
				}
			}
			packet.connection.AddPacketsPerSecond(packet.type);
			break;
		case Message.Type.RPCMessage:
			if (!packet.connection.isAuthenticated)
			{
				break;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) > (ulong)ConVar.Server.maxpacketspersecond_rpc)
			{
				Network.Net.sv.Kick(packet.connection, "Paket Flooding: RPC Message");
				break;
			}
			using (TimeWarning.New("OnRPCMessage", 20L))
			{
				try
				{
					OnRPCMessage(packet);
				}
				catch (Exception e8)
				{
					Log(e8);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: RPC Message");
				}
			}
			packet.connection.AddPacketsPerSecond(packet.type);
			break;
		case Message.Type.ConsoleCommand:
			if (!packet.connection.isAuthenticated)
			{
				break;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) > (ulong)ConVar.Server.maxpacketspersecond_command)
			{
				Network.Net.sv.Kick(packet.connection, "Packet Flooding: Client Command");
				break;
			}
			using (TimeWarning.New("OnClientCommand", 20L))
			{
				try
				{
					ConsoleNetwork.OnClientCommand(packet);
				}
				catch (Exception e5)
				{
					Log(e5);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: Client Command");
				}
			}
			packet.connection.AddPacketsPerSecond(packet.type);
			break;
		case Message.Type.DisconnectReason:
			if (!packet.connection.isAuthenticated)
			{
				break;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) > 1)
			{
				Network.Net.sv.Kick(packet.connection, "Packet Flooding: Disconnect Reason");
				break;
			}
			using (TimeWarning.New("ReadDisconnectReason", 20L))
			{
				try
				{
					ReadDisconnectReason(packet);
				}
				catch (Exception e2)
				{
					Log(e2);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: Disconnect Reason");
				}
			}
			packet.connection.AddPacketsPerSecond(packet.type);
			break;
		case Message.Type.Tick:
			if (!packet.connection.isAuthenticated)
			{
				break;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) > (ulong)ConVar.Server.maxpacketspersecond_tick)
			{
				Network.Net.sv.Kick(packet.connection, "Packet Flooding: Player Tick");
				break;
			}
			using (TimeWarning.New("OnPlayerTick", 20L))
			{
				try
				{
					OnPlayerTick(packet);
				}
				catch (Exception e4)
				{
					Log(e4);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: Player Tick");
				}
			}
			packet.connection.AddPacketsPerSecond(packet.type);
			break;
		case Message.Type.EAC:
			using (TimeWarning.New("OnEACMessage", 20L))
			{
				try
				{
					EACServer.OnMessageReceived(packet);
					break;
				}
				catch (Exception e3)
				{
					Log(e3);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: EAC");
					break;
				}
			}
		case Message.Type.World:
			if (!World.Transfer || !packet.connection.isAuthenticated)
			{
				break;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) > (ulong)ConVar.Server.maxpacketspersecond_world)
			{
				Network.Net.sv.Kick(packet.connection, "Packet Flooding: World");
				break;
			}
			using (TimeWarning.New("OnWorldMessage", 20L))
			{
				try
				{
					WorldNetworking.OnMessageReceived(packet);
					break;
				}
				catch (Exception e6)
				{
					Log(e6);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: World");
					break;
				}
			}
		case Message.Type.VoiceData:
			if (!packet.connection.isAuthenticated)
			{
				break;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) > 100)
			{
				Network.Net.sv.Kick(packet.connection, "Packet Flooding: Disconnect Reason");
				break;
			}
			using (TimeWarning.New("OnPlayerVoice", 20L))
			{
				try
				{
					OnPlayerVoice(packet);
				}
				catch (Exception e)
				{
					Log(e);
					Network.Net.sv.Kick(packet.connection, "Invalid Packet: Player Voice");
				}
			}
			packet.connection.AddPacketsPerSecond(packet.type);
			break;
		default:
			ProcessUnhandledPacket(packet);
			break;
		}
	}

	public void ProcessUnhandledPacket(Message packet)
	{
		if (ConVar.Global.developer > 0)
		{
			UnityEngine.Debug.LogWarning("[SERVER][UNHANDLED] " + packet.type);
		}
		Network.Net.sv.Kick(packet.connection, "Sent Unhandled Message");
	}

	public void ReadDisconnectReason(Message packet)
	{
		string text = packet.read.String();
		string text2 = packet.connection.ToString();
		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
		{
			DebugEx.Log(text2 + " disconnecting: " + text);
		}
	}

	private bool SpawnPlayerSleeping(Network.Connection connection)
	{
		BasePlayer basePlayer = BasePlayer.FindSleeping(connection.userid);
		if (basePlayer == null)
		{
			return false;
		}
		if (!basePlayer.IsSleeping())
		{
			UnityEngine.Debug.LogWarning("Player spawning into sleeper that isn't sleeping!");
			basePlayer.Kill();
			return false;
		}
		basePlayer.PlayerInit(connection);
		basePlayer.inventory.SendSnapshot();
		DebugEx.Log(basePlayer.net.connection.ToString() + " joined [" + basePlayer.net.connection.os + "/" + basePlayer.net.connection.ownerid + "]");
		return true;
	}

	private void SpawnNewPlayer(Network.Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		basePlayer.health = 0f;
		basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
		basePlayer.ResetLifeStateOnSpawn = false;
		basePlayer.limitNetworking = true;
		basePlayer.Spawn();
		basePlayer.limitNetworking = false;
		basePlayer.PlayerInit(connection);
		if (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife)
		{
			basePlayer.Respawn();
		}
		else
		{
			basePlayer.SendRespawnOptions();
		}
		DebugEx.Log(basePlayer.net.connection.ToString() + " joined [" + basePlayer.net.connection.os + "/" + basePlayer.net.connection.ownerid + "]");
	}

	private void ClientReady(Message packet)
	{
		packet.connection.decryptIncoming = true;
		using ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read);
		foreach (ClientReady.ClientInfo item in clientReady.clientInfo)
		{
			packet.connection.info.Set(item.name, item.value);
		}
		connectionQueue.JoinedGame(packet.connection);
		using (TimeWarning.New("ClientReady"))
		{
			using (TimeWarning.New("SpawnPlayerSleeping"))
			{
				if (SpawnPlayerSleeping(packet.connection))
				{
					return;
				}
			}
			using (TimeWarning.New("SpawnNewPlayer"))
			{
				SpawnNewPlayer(packet.connection);
			}
		}
	}

	private void OnRPCMessage(Message packet)
	{
		uint uid = packet.read.UInt32();
		uint nameID = packet.read.UInt32();
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(uid) as BaseEntity;
		if (!(baseEntity == null))
		{
			baseEntity.SV_RPCMessage(nameID, packet);
		}
	}

	private void OnPlayerTick(Message packet)
	{
		BasePlayer basePlayer = NetworkPacketEx.Player(packet);
		if (!(basePlayer == null))
		{
			basePlayer.OnReceivedTick(packet.read);
		}
	}

	private void OnPlayerVoice(Message packet)
	{
		BasePlayer basePlayer = NetworkPacketEx.Player(packet);
		if (!(basePlayer == null))
		{
			basePlayer.OnReceivedVoice(packet.read.BytesWithSize());
		}
	}

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Network.Connection.State.Connecting;
		if (packet.read.UInt8() != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String(128u);
		packet.connection.username = packet.read.String(256u);
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.Unread >= 4)
		{
			text = packet.read.String(128u);
		}
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their branch is '", text, "' not '", branch, "'"));
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2201)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2201));
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2201)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2201));
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize(512u);
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
			}
			else
			{
				auth.OnNewConnection(packet.connection);
			}
		}
	}

	public bool OnUnconnectedMessage(int type, NetRead read, uint ip, int port)
	{
		if (useQueryPort)
		{
			return false;
		}
		if (type == 255)
		{
			if (queriesPerSeconTimer.Elapsed.TotalSeconds > 1.0)
			{
				queriesPerSeconTimer.Reset();
				queriesPerSeconTimer.Start();
				NumQueriesLastSecond = 0;
			}
			if (NumQueriesLastSecond > ConVar.Server.queriesPerSecond)
			{
				return false;
			}
			if (read.UInt8() != byte.MaxValue)
			{
				return false;
			}
			if (read.UInt8() != byte.MaxValue)
			{
				return false;
			}
			if (read.UInt8() != byte.MaxValue)
			{
				return false;
			}
			if (queryTimer.Elapsed.TotalSeconds > 60.0)
			{
				queryTimer.Reset();
				queryTimer.Start();
				unconnectedQueries.Clear();
			}
			if (!unconnectedQueries.ContainsKey(ip))
			{
				unconnectedQueries.Add(ip, 0);
			}
			int num = unconnectedQueries[ip] + 1;
			unconnectedQueries[ip] = num;
			if (num > ConVar.Server.ipQueriesPerMin)
			{
				return true;
			}
			NumQueriesLastSecond++;
			read.Position = 0L;
			int unread = read.Unread;
			if (unread > 4096)
			{
				return true;
			}
			if (queryBuffer.Capacity < unread)
			{
				queryBuffer.Capacity = unread;
			}
			int size = read.Read(queryBuffer.GetBuffer(), 0, unread);
			SteamServer.HandleIncomingPacket(queryBuffer.GetBuffer(), size, ip, (ushort)port);
			return true;
		}
		return false;
	}
}
