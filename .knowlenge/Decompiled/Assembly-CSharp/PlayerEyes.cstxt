using System;
using UnityEngine;

public class PlayerEyes : EntityComponent<BasePlayer>
{
	public static readonly Vector3 EyeOffset = new Vector3(0f, 1.5f, 0f);

	public static readonly Vector3 DuckOffset = new Vector3(0f, -0.6f, 0f);

	public Vector3 thirdPersonSleepingOffset = new Vector3(0.43f, 1.25f, 0.7f);

	public LazyAimProperties defaultLazyAim;

	[NonSerialized]
	private Vector3 viewOffset = Vector3.zero;

	[NonSerialized]
	public Quaternion rotation = Quaternion.identity;

	[NonSerialized]
	public Quaternion headRotation = Quaternion.identity;

	[NonSerialized]
	public Quaternion rotationLook = Quaternion.identity;

	public Vector3 position
	{
		get
		{
			if ((bool)base.baseEntity && base.baseEntity.isMounted)
			{
				Vector3 vector = base.baseEntity.GetMounted().EyePositionForPlayer(base.baseEntity);
				if (vector != Vector3.zero)
				{
					return vector;
				}
			}
			Vector3 vector2 = base.transform.position;
			Vector3 up = base.transform.up;
			Vector3 eyeOffset = EyeOffset;
			return vector2 + up * (eyeOffset.y + viewOffset.y);
		}
	}

	public void NetworkUpdate(Quaternion rot)
	{
		viewOffset = ((!base.baseEntity.IsDucked()) ? Vector3.zero : DuckOffset);
		rotation = rot;
	}

	public Ray BodyRay()
	{
		return new Ray(position, BodyForward());
	}

	public Vector3 BodyForward()
	{
		return rotation * Vector3.forward;
	}

	public Vector3 BodyRight()
	{
		return rotation * Vector3.right;
	}

	public Vector3 BodyUp()
	{
		return rotation * Vector3.up;
	}

	public Ray HeadRay()
	{
		return new Ray(position, HeadForward());
	}

	public Vector3 HeadForward()
	{
		return rotation * headRotation * Vector3.forward;
	}

	public Vector3 HeadRight()
	{
		return rotation * headRotation * Vector3.right;
	}

	public Vector3 HeadUp()
	{
		return rotation * headRotation * Vector3.up;
	}
}
