using UnityEngine;

public class TerrainBiomeMap : TerrainMap3D<byte>
{
	public Texture2D BiomeTexture;

	internal int num;

	public override void Setup()
	{
		if (BiomeTexture != null)
		{
			if (BiomeTexture.width == BiomeTexture.height)
			{
				res = BiomeTexture.width;
				this.num = 4;
				src = (dst = new byte[res, res, this.num]);
				Color32[] pixels = BiomeTexture.GetPixels32();
				int i = 0;
				int num = 0;
				for (; i < res; i++)
				{
					int num2 = 0;
					while (num2 < res)
					{
						Color32 color = pixels[num];
						dst[i, num2, 0] = color.r;
						dst[i, num2, 1] = color.g;
						dst[i, num2, 2] = color.b;
						dst[i, num2, 3] = color.a;
						num2++;
						num++;
					}
				}
			}
			else
			{
				Debug.LogError("Invalid biome texture: " + BiomeTexture.name);
			}
		}
		else
		{
			res = terrain.terrainData.alphamapResolution;
			this.num = 4;
			src = (dst = new byte[res, res, this.num]);
		}
	}

	public void GenerateTextures()
	{
		BiomeTexture = new Texture2D(res, res, TextureFormat.RGBA32, mipmap: true, linear: true);
		BiomeTexture.name = "BiomeTexture";
		BiomeTexture.wrapMode = TextureWrapMode.Clamp;
		Color32[] col = new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				byte r = src[z, i, 0];
				byte g = src[z, i, 1];
				byte b = src[z, i, 2];
				byte a = src[z, i, 3];
				ref Color32 reference = ref col[z * res + i];
				reference = new Color32(r, g, b, a);
			}
		});
		BiomeTexture.SetPixels32(col);
	}

	public void ApplyTextures()
	{
		BiomeTexture.Apply(updateMipmaps: true, makeNoLongerReadable: false);
		BiomeTexture.Compress(highQuality: false);
		BiomeTexture.Apply(updateMipmaps: false, makeNoLongerReadable: true);
	}

	public float GetBiomeMax(Vector3 worldPos, int mask = -1)
	{
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiomeMax(normX, normZ, mask);
	}

	public float GetBiomeMax(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiomeMax(x, z, mask);
	}

	public float GetBiomeMax(int x, int z, int mask = -1)
	{
		byte b = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[z, x, i];
				if (b2 >= b)
				{
					b = b2;
				}
			}
		}
		return (int)b;
	}

	public int GetBiomeMaxIndex(Vector3 worldPos, int mask = -1)
	{
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiomeMaxIndex(normX, normZ, mask);
	}

	public int GetBiomeMaxIndex(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiomeMaxIndex(x, z, mask);
	}

	public int GetBiomeMaxIndex(int x, int z, int mask = -1)
	{
		byte b = 0;
		int result = 0;
		for (int i = 0; i < this.num; i++)
		{
			int num = TerrainBiome.IndexToType(i);
			if ((num & mask) != 0)
			{
				byte b2 = src[z, x, i];
				if (b2 >= b)
				{
					b = b2;
					result = i;
				}
			}
		}
		return result;
	}

	public int GetBiomeMaxType(Vector3 worldPos, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(worldPos, mask));
	}

	public int GetBiomeMaxType(float normX, float normZ, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(normX, normZ, mask));
	}

	public int GetBiomeMaxType(int x, int z, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(x, z, mask));
	}

	public float GetBiome(Vector3 worldPos, int mask)
	{
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiome(normX, normZ, mask);
	}

	public float GetBiome(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiome(x, z, mask);
	}

	public float GetBiome(int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			return TextureData.Byte2Float(src[z, x, TerrainBiome.TypeToIndex(mask)]);
		}
		int num = 0;
		for (int i = 0; i < this.num; i++)
		{
			int num2 = TerrainBiome.IndexToType(i);
			if ((num2 & mask) != 0)
			{
				num += src[z, x, i];
			}
		}
		return Mathf.Clamp01(TextureData.Byte2Float(num));
	}

	public void SetBiome(Vector3 worldPos, int id)
	{
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBiome(normX, normZ, id);
	}

	public void SetBiome(float normX, float normZ, int id)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBiome(x, z, id);
	}

	public void SetBiome(int x, int z, int id)
	{
		int num = TerrainBiome.TypeToIndex(id);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[z, x, i] = byte.MaxValue;
			}
			else
			{
				dst[z, x, i] = 0;
			}
		}
	}

	public void SetBiome(Vector3 worldPos, int id, float v)
	{
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBiome(normX, normZ, id, v);
	}

	public void SetBiome(float normX, float normZ, int id, float v)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBiome(x, z, id, v);
	}

	public void SetBiome(int x, int z, int id, float v)
	{
		SetBiome(x, z, id, GetBiome(x, z, id), v);
	}

	public void SetBiomeRaw(int x, int z, Vector4 v, float opacity)
	{
		if (opacity == 0f)
		{
			return;
		}
		float num = Mathf.Clamp01(v.x + v.y + v.z + v.w);
		if (num != 0f)
		{
			float num2 = 1f - opacity * num;
			if (num2 == 0f && opacity == 1f)
			{
				dst[z, x, 0] = TextureData.Float2Byte(v.x);
				dst[z, x, 1] = TextureData.Float2Byte(v.y);
				dst[z, x, 2] = TextureData.Float2Byte(v.z);
				dst[z, x, 3] = TextureData.Float2Byte(v.w);
			}
			else
			{
				dst[z, x, 0] = TextureData.Float2Byte(TextureData.Byte2Float(src[z, x, 0]) * num2 + v.x * opacity);
				dst[z, x, 1] = TextureData.Float2Byte(TextureData.Byte2Float(src[z, x, 1]) * num2 + v.y * opacity);
				dst[z, x, 2] = TextureData.Float2Byte(TextureData.Byte2Float(src[z, x, 2]) * num2 + v.z * opacity);
				dst[z, x, 3] = TextureData.Float2Byte(TextureData.Byte2Float(src[z, x, 3]) * num2 + v.w * opacity);
			}
		}
	}

	private void SetBiome(int x, int z, int id, float old_val, float new_val)
	{
		int num = TerrainBiome.TypeToIndex(id);
		if (old_val >= 1f)
		{
			return;
		}
		float num2 = (1f - new_val) / (1f - old_val);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[z, x, i] = TextureData.Float2Byte(new_val);
			}
			else
			{
				dst[z, x, i] = TextureData.Float2Byte(num2 * TextureData.Byte2Float(dst[z, x, i]));
			}
		}
	}
}
