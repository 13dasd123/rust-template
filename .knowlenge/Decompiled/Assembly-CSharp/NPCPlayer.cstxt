using System;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class NPCPlayer : BasePlayer
{
	public Vector3 finalDestination;

	[NonSerialized]
	private float randomOffset;

	[NonSerialized]
	private Vector3 spawnPos;

	public PlayerInventoryProperties[] loadouts;

	public float stoppingDistance = 0.1f;

	public LayerMask movementMask = 295772417;

	public NavMeshAgent NavAgent;

	public bool IsDormant;

	private float triggerEndTime;

	private float nextTriggerTime;

	private float lastThinkTime;

	private Vector3 lastPos;

	public Vector2i CurrentCoord { get; set; }

	public Vector2i PreviousCoord { get; set; }

	public bool AgencyUpdateRequired { get; set; }

	public bool IsOnOffmeshLinkAndReachedNewCoord { get; set; }

	protected override float PositionTickRate => 0.05f;

	public override void ServerInit()
	{
		if (!base.isClient)
		{
			spawnPos = GetPosition();
			randomOffset = UnityEngine.Random.Range(0f, 1f);
			base.ServerInit();
			UpdateNetworkGroup();
			loadouts[UnityEngine.Random.Range(0, loadouts.Length)].GiveToPlayer(this);
			InvokeRepeating(ServerThink_Internal, 0f, 0.1f);
			lastThinkTime = Time.time;
			Invoke(EquipTest, 1f);
			finalDestination = base.transform.position;
			AgencyUpdateRequired = false;
			IsOnOffmeshLinkAndReachedNewCoord = false;
			if (NavAgent == null)
			{
				NavAgent = GetComponent<NavMeshAgent>();
			}
			if ((bool)NavAgent)
			{
				NavAgent.updateRotation = false;
				NavAgent.updatePosition = false;
			}
		}
	}

	public void RandomMove()
	{
		float num = 8f;
		Vector2 vector = UnityEngine.Random.insideUnitCircle * num;
		SetDestination(spawnPos + new Vector3(vector.x, 0f, vector.y));
	}

	public virtual void SetDestination(Vector3 newDestination)
	{
		finalDestination = newDestination;
	}

	public AttackEntity GetAttackEntity()
	{
		HeldEntity heldEntity = GetHeldEntity();
		return heldEntity as AttackEntity;
	}

	public void ShotTest()
	{
		HeldEntity heldEntity = GetHeldEntity();
		AttackEntity attackEntity = heldEntity as AttackEntity;
		if (attackEntity == null)
		{
			return;
		}
		BaseProjectile baseProjectile = attackEntity as BaseProjectile;
		if ((bool)baseProjectile && baseProjectile.primaryMagazine.contents <= 0)
		{
			baseProjectile.ServerReload();
			NPCPlayerApex nPCPlayerApex = this as NPCPlayerApex;
			if ((bool)nPCPlayerApex && nPCPlayerApex.OnReload != null)
			{
				nPCPlayerApex.OnReload();
			}
		}
		if (!Mathf.Approximately(attackEntity.attackLengthMin, -1f))
		{
			if (!IsInvoking(TriggerDown) && !(Time.time < nextTriggerTime))
			{
				InvokeRepeating(TriggerDown, 0f, 0.01f);
				triggerEndTime = Time.time + UnityEngine.Random.Range(attackEntity.attackLengthMin, attackEntity.attackLengthMax);
				TriggerDown();
			}
		}
		else if (attackEntity != null)
		{
			attackEntity.ServerUse();
		}
	}

	public bool MeleeAttack()
	{
		HeldEntity heldEntity = GetHeldEntity();
		AttackEntity attackEntity = heldEntity as AttackEntity;
		if (attackEntity == null)
		{
			return false;
		}
		BaseMelee baseMelee = attackEntity as BaseMelee;
		if (baseMelee == null)
		{
			return false;
		}
		baseMelee.ServerUse();
		return true;
	}

	public void TriggerDown()
	{
		HeldEntity heldEntity = GetHeldEntity();
		AttackEntity attackEntity = heldEntity as AttackEntity;
		if (attackEntity != null)
		{
			attackEntity.ServerUse();
		}
		if (Time.time > triggerEndTime)
		{
			CancelInvoke(TriggerDown);
			nextTriggerTime = Time.time + ((!(attackEntity != null)) ? 1f : attackEntity.attackSpacing);
		}
	}

	public void EquipTest()
	{
		UpdateActiveItem(inventory.containerBelt.GetSlot(0).uid);
	}

	public void ServerThink_Internal()
	{
		float delta = Time.time - lastThinkTime;
		ServerThink(delta);
		lastThinkTime = Time.time;
	}

	public virtual void ServerThink(float delta)
	{
		TickAi(delta);
	}

	public virtual void Resume()
	{
	}

	public virtual bool IsNavRunning()
	{
		return false;
	}

	public virtual void TickAi(float delta)
	{
		MovementUpdate(delta);
	}

	public virtual void MovementUpdate(float delta)
	{
		if (!base.isClient && IsAlive() && !IsWounded() && IsNavRunning())
		{
			Vector3 moveToPosition = base.transform.position;
			if (NavAgent.isOnOffMeshLink)
			{
				TickNavMeshLinkTraversal(delta, ref moveToPosition);
			}
			else if (NavAgent.hasPath)
			{
				moveToPosition = NavAgent.nextPosition;
			}
			if (ValidateNextPosition(ref moveToPosition))
			{
				UpdateSpeed(delta);
				UpdatePositionAndRotation(moveToPosition);
			}
		}
	}

	private void TickNavMeshLinkTraversal(float delta, ref Vector3 moveToPosition)
	{
		OffMeshLinkData currentOffMeshLinkData = NavAgent.currentOffMeshLinkData;
		if (!currentOffMeshLinkData.valid)
		{
			CompleteNavMeshLinkTraversal(failed: true, ref moveToPosition);
			return;
		}
		Vector3 sourcePosition = currentOffMeshLinkData.endPos + Vector3.up * NavAgent.baseOffset;
		if (NavMesh.SamplePosition(sourcePosition, out var hit, NavAgent.height * 2f, NavAgent.areaMask))
		{
			sourcePosition = hit.position;
			if (IsNavMeshLinkTraversalComplete(moveToPosition, sourcePosition))
			{
				CompleteNavMeshLinkTraversal(failed: false, ref moveToPosition);
			}
			else
			{
				TraverseLink(delta, ref moveToPosition, sourcePosition);
			}
		}
		else
		{
			CompleteNavMeshLinkTraversal(failed: true, ref moveToPosition);
		}
	}

	private bool IsNavMeshLinkTraversalComplete(Vector3 moveToPosition, Vector3 targetPosition)
	{
		return (AiManager.nav_grid && IsOnOffmeshLinkAndReachedNewCoord) || (!AiManager.nav_grid && Vector3Ex.Distance2D(moveToPosition, targetPosition) < 0.15f);
	}

	private void TraverseLink(float delta, ref Vector3 moveToPosition, Vector3 targetPosition)
	{
		float maxDistanceDelta = Mathf.Clamp01(NavAgent.speed * delta);
		moveToPosition = Vector3.MoveTowards(moveToPosition, targetPosition, maxDistanceDelta);
		if (TransformUtil.GetGroundInfo(moveToPosition + new Vector3(0f, 1.25f, 0f), out var hitOut, NavAgent.height, movementMask, base.transform))
		{
			moveToPosition = hitOut.point;
		}
	}

	private void CompleteNavMeshLinkTraversal(bool failed, ref Vector3 moveToPosition)
	{
		NavAgent.CompleteOffMeshLink();
		IsOnOffmeshLinkAndReachedNewCoord = false;
		if (failed)
		{
			NavAgent.ResetPath();
		}
		else if (NavAgent.hasPath)
		{
			moveToPosition = NavAgent.nextPosition;
		}
		Resume();
	}

	private bool ValidateNextPosition(ref Vector3 moveToPosition)
	{
		if (!ValidBounds.Test(moveToPosition))
		{
			Debug.Log(string.Concat("Invalid NavAgent Position: ", this, " ", moveToPosition, " (destroying)"));
			Kill();
			return false;
		}
		return true;
	}

	private void UpdateSpeed(float delta)
	{
		float b = DesiredMoveSpeed();
		NavAgent.speed = Mathf.Lerp(NavAgent.speed, b, delta * 1f);
	}

	private void UpdatePositionAndRotation(Vector3 moveToPosition)
	{
		ServerPosition = moveToPosition;
		SetAimDirection(GetAimDirection());
	}

	public Vector3 GetPosition()
	{
		return base.transform.position;
	}

	public virtual float DesiredMoveSpeed()
	{
		float running = Mathf.Sin(Time.time + randomOffset);
		return GetSpeed(running, 0f);
	}

	public override bool EligibleForWounding(HitInfo info)
	{
		return false;
	}

	public virtual Vector3 GetAimDirection()
	{
		float num = Vector3Ex.Distance2D(finalDestination, GetPosition());
		if (num >= 1f)
		{
			Vector3 vector = finalDestination - GetPosition();
			return new Vector3(vector.x, 0f, vector.z);
		}
		return eyes.BodyForward();
	}

	public virtual void SetAimDirection(Vector3 newAim)
	{
		if (!(newAim == Vector3.zero))
		{
			AttackEntity attackEntity = GetAttackEntity();
			if ((bool)attackEntity)
			{
				newAim = attackEntity.ModifyAIAim(newAim);
			}
			eyes.rotation = Quaternion.LookRotation(newAim, Vector3.up);
			viewAngles = eyes.rotation.eulerAngles;
			ServerRotation = eyes.rotation;
		}
	}
}
