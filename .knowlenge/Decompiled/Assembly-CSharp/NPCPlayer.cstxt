using System;
using UnityEngine;
using UnityEngine.AI;

public class NPCPlayer : BasePlayer
{
	public Vector3 finalDestination;

	[NonSerialized]
	private float randomOffset;

	[NonSerialized]
	private Vector3 spawnPos;

	public PlayerInventoryProperties[] loadouts;

	public LayerMask movementMask = 429990145;

	public NavMeshAgent NavAgent;

	private bool _isDormant;

	private float triggerEndTime;

	protected float nextTriggerTime;

	private float lastThinkTime;

	protected bool _traversingNavMeshLink;

	protected OffMeshLinkData _currentNavMeshLink;

	protected string _currentNavMeshLinkName;

	protected float _currentNavMeshLinkTraversalTime;

	protected float _currentNavMeshLinkTraversalTimeDelta;

	protected Quaternion _currentNavMeshLinkOrientation;

	protected Vector3 _currentNavMeshLinkEndPos;

	private Vector3 lastPos;

	public override bool IsNpc => true;

	public bool AgencyUpdateRequired { get; set; }

	public bool IsOnOffmeshLinkAndReachedNewCoord { get; set; }

	public virtual bool IsDormant
	{
		get
		{
			return _isDormant;
		}
		set
		{
			_isDormant = value;
			if (!_isDormant)
			{
			}
		}
	}

	protected override float PositionTickRate => 0.05f;

	public virtual bool IsOnNavMeshLink
	{
		get
		{
			if (IsNavRunning())
			{
				return NavAgent.isOnOffMeshLink;
			}
			return false;
		}
	}

	public virtual bool HasPath
	{
		get
		{
			if (IsNavRunning())
			{
				return NavAgent.hasPath;
			}
			return false;
		}
	}

	public override void ServerInit()
	{
		if (!base.isClient)
		{
			spawnPos = GetPosition();
			randomOffset = UnityEngine.Random.Range(0f, 1f);
			base.ServerInit();
			UpdateNetworkGroup();
			if (loadouts != null && loadouts.Length > 0)
			{
				loadouts[UnityEngine.Random.Range(0, loadouts.Length)].GiveToPlayer(this);
			}
			else
			{
				Debug.LogWarningFormat("Loadout for NPC {0} was empty.", base.name);
			}
			InvokeRepeating(ServerThink_Internal, 0f, 0.1f);
			lastThinkTime = Time.time;
			Invoke(EquipTest, 1f);
			finalDestination = base.transform.position;
			AgencyUpdateRequired = false;
			IsOnOffmeshLinkAndReachedNewCoord = false;
			if (NavAgent == null)
			{
				NavAgent = GetComponent<NavMeshAgent>();
			}
			if ((bool)NavAgent)
			{
				NavAgent.updateRotation = false;
				NavAgent.updatePosition = false;
			}
		}
	}

	public void RandomMove()
	{
		float num = 8f;
		Vector2 vector = UnityEngine.Random.insideUnitCircle * num;
		SetDestination(spawnPos + new Vector3(vector.x, 0f, vector.y));
	}

	public virtual void SetDestination(Vector3 newDestination)
	{
		finalDestination = newDestination;
	}

	public AttackEntity GetAttackEntity()
	{
		HeldEntity heldEntity = GetHeldEntity();
		return heldEntity as AttackEntity;
	}

	public virtual bool ShotTest()
	{
		HeldEntity heldEntity = GetHeldEntity();
		AttackEntity attackEntity = heldEntity as AttackEntity;
		if (attackEntity == null)
		{
			return false;
		}
		BaseProjectile baseProjectile = attackEntity as BaseProjectile;
		if ((bool)baseProjectile)
		{
			if (baseProjectile.primaryMagazine.contents <= 0)
			{
				baseProjectile.ServerReload();
				NPCPlayerApex nPCPlayerApex = this as NPCPlayerApex;
				if ((bool)nPCPlayerApex && nPCPlayerApex.OnReload != null)
				{
					nPCPlayerApex.OnReload();
				}
				return false;
			}
			if (baseProjectile.NextAttackTime > Time.time)
			{
				return false;
			}
		}
		if (!Mathf.Approximately(attackEntity.attackLengthMin, -1f))
		{
			if (IsInvoking(TriggerDown))
			{
				return true;
			}
			if (Time.time < nextTriggerTime)
			{
				return true;
			}
			InvokeRepeating(TriggerDown, 0f, 0.01f);
			triggerEndTime = Time.time + UnityEngine.Random.Range(attackEntity.attackLengthMin, attackEntity.attackLengthMax);
			TriggerDown();
			return true;
		}
		attackEntity.ServerUse();
		return true;
	}

	public bool MeleeAttack()
	{
		HeldEntity heldEntity = GetHeldEntity();
		AttackEntity attackEntity = heldEntity as AttackEntity;
		if (attackEntity == null)
		{
			return false;
		}
		BaseMelee baseMelee = attackEntity as BaseMelee;
		if (baseMelee == null)
		{
			return false;
		}
		baseMelee.ServerUse();
		return true;
	}

	public virtual void TriggerDown()
	{
		HeldEntity heldEntity = GetHeldEntity();
		AttackEntity attackEntity = heldEntity as AttackEntity;
		if (attackEntity != null)
		{
			attackEntity.ServerUse();
		}
		if (Time.time > triggerEndTime)
		{
			CancelInvoke(TriggerDown);
			nextTriggerTime = Time.time + ((!(attackEntity != null)) ? 1f : attackEntity.attackSpacing);
		}
	}

	public void EquipTest()
	{
		if (inventory.containerBelt.GetSlot(0) != null)
		{
			UpdateActiveItem(inventory.containerBelt.GetSlot(0).uid);
		}
	}

	public void ServerThink_Internal()
	{
		float delta = Time.time - lastThinkTime;
		ServerThink(delta);
		lastThinkTime = Time.time;
	}

	public virtual void ServerThink(float delta)
	{
		TickAi(delta);
	}

	public virtual void Resume()
	{
	}

	public virtual bool IsNavRunning()
	{
		return false;
	}

	public virtual void TickAi(float delta)
	{
		MovementUpdate(delta);
	}

	public virtual void MovementUpdate(float delta)
	{
		if (base.isClient || !IsAlive() || IsWounded() || (!base.isMounted && !IsNavRunning()))
		{
			return;
		}
		if (IsDormant || !syncPosition)
		{
			if (IsNavRunning())
			{
				NavAgent.destination = ServerPosition;
			}
			return;
		}
		Vector3 moveToPosition = base.transform.position;
		if (IsOnNavMeshLink)
		{
			HandleNavMeshLinkTraversal(delta, ref moveToPosition);
		}
		else if (HasPath)
		{
			moveToPosition = NavAgent.nextPosition;
		}
		if (ValidateNextPosition(ref moveToPosition))
		{
			UpdateSpeed(delta);
			UpdatePositionAndRotation(moveToPosition);
		}
	}

	private void HandleNavMeshLinkTraversal(float delta, ref Vector3 moveToPosition)
	{
		if (!_traversingNavMeshLink)
		{
			HandleNavMeshLinkTraversalStart(delta);
		}
		HandleNavMeshLinkTraversalTick(delta, ref moveToPosition);
		if (!IsNavMeshLinkTraversalComplete(delta, ref moveToPosition))
		{
			_currentNavMeshLinkTraversalTimeDelta += delta;
		}
	}

	private bool HandleNavMeshLinkTraversalStart(float delta)
	{
		OffMeshLinkData currentOffMeshLinkData = NavAgent.currentOffMeshLinkData;
		if (!currentOffMeshLinkData.valid || !currentOffMeshLinkData.activated || currentOffMeshLinkData.offMeshLink == null)
		{
			return false;
		}
		Vector3 normalized = (currentOffMeshLinkData.endPos - currentOffMeshLinkData.startPos).normalized;
		normalized.y = 0f;
		Vector3 desiredVelocity = NavAgent.desiredVelocity;
		desiredVelocity.y = 0f;
		float num = Vector3.Dot(desiredVelocity, normalized);
		if (num < 0.1f)
		{
			CompleteNavMeshLink();
			return false;
		}
		_currentNavMeshLink = currentOffMeshLinkData;
		_currentNavMeshLinkName = _currentNavMeshLink.linkType.ToString();
		if (currentOffMeshLinkData.offMeshLink.biDirectional)
		{
			float sqrMagnitude = (currentOffMeshLinkData.endPos - ServerPosition).sqrMagnitude;
			if (sqrMagnitude < 0.05f)
			{
				_currentNavMeshLinkEndPos = currentOffMeshLinkData.startPos;
				_currentNavMeshLinkOrientation = Quaternion.LookRotation(currentOffMeshLinkData.startPos + Vector3.up * (currentOffMeshLinkData.endPos.y - currentOffMeshLinkData.startPos.y) - currentOffMeshLinkData.endPos);
			}
			else
			{
				_currentNavMeshLinkEndPos = currentOffMeshLinkData.endPos;
				_currentNavMeshLinkOrientation = Quaternion.LookRotation(currentOffMeshLinkData.endPos + Vector3.up * (currentOffMeshLinkData.startPos.y - currentOffMeshLinkData.endPos.y) - currentOffMeshLinkData.startPos);
			}
		}
		else
		{
			_currentNavMeshLinkEndPos = currentOffMeshLinkData.endPos;
			_currentNavMeshLinkOrientation = Quaternion.LookRotation(currentOffMeshLinkData.endPos + Vector3.up * (currentOffMeshLinkData.startPos.y - currentOffMeshLinkData.endPos.y) - currentOffMeshLinkData.startPos);
		}
		_traversingNavMeshLink = true;
		NavAgent.ActivateCurrentOffMeshLink(activated: false);
		NavAgent.obstacleAvoidanceType = ObstacleAvoidanceType.NoObstacleAvoidance;
		float num2 = Mathf.Max(NavAgent.speed, 2.8f);
		float magnitude = (_currentNavMeshLink.startPos - _currentNavMeshLink.endPos).magnitude;
		_currentNavMeshLinkTraversalTime = magnitude / num2;
		_currentNavMeshLinkTraversalTimeDelta = 0f;
		if (_currentNavMeshLinkName == "OpenDoorLink" || _currentNavMeshLinkName == "JumpRockLink" || _currentNavMeshLinkName == "JumpFoundationLink")
		{
		}
		return true;
	}

	private void HandleNavMeshLinkTraversalTick(float delta, ref Vector3 moveToPosition)
	{
		if (_currentNavMeshLinkName == "OpenDoorLink")
		{
			moveToPosition = Vector3.Lerp(_currentNavMeshLink.startPos, _currentNavMeshLink.endPos, _currentNavMeshLinkTraversalTimeDelta);
		}
		else if (_currentNavMeshLinkName == "JumpRockLink")
		{
			moveToPosition = Vector3.Lerp(_currentNavMeshLink.startPos, _currentNavMeshLink.endPos, _currentNavMeshLinkTraversalTimeDelta);
		}
		else if (_currentNavMeshLinkName == "JumpFoundationLink")
		{
			moveToPosition = Vector3.Lerp(_currentNavMeshLink.startPos, _currentNavMeshLink.endPos, _currentNavMeshLinkTraversalTimeDelta);
		}
		else
		{
			moveToPosition = Vector3.Lerp(_currentNavMeshLink.startPos, _currentNavMeshLink.endPos, _currentNavMeshLinkTraversalTimeDelta);
		}
	}

	private bool IsNavMeshLinkTraversalComplete(float delta, ref Vector3 moveToPosition)
	{
		if (_currentNavMeshLinkTraversalTimeDelta >= _currentNavMeshLinkTraversalTime)
		{
			moveToPosition = _currentNavMeshLink.endPos;
			_traversingNavMeshLink = false;
			_currentNavMeshLink = default(OffMeshLinkData);
			_currentNavMeshLinkTraversalTime = 0f;
			_currentNavMeshLinkTraversalTimeDelta = 0f;
			_currentNavMeshLinkName = string.Empty;
			_currentNavMeshLinkOrientation = Quaternion.identity;
			CompleteNavMeshLink();
			return true;
		}
		return false;
	}

	private void CompleteNavMeshLink()
	{
		NavAgent.ActivateCurrentOffMeshLink(activated: true);
		NavAgent.CompleteOffMeshLink();
		NavAgent.isStopped = false;
		NavAgent.obstacleAvoidanceType = ObstacleAvoidanceType.HighQualityObstacleAvoidance;
	}

	private bool ValidateNextPosition(ref Vector3 moveToPosition)
	{
		if (!ValidBounds.Test(moveToPosition) && base.transform != null && !base.IsDestroyed)
		{
			Debug.Log(string.Concat("Invalid NavAgent Position: ", this, " ", moveToPosition.ToString(), " (destroying)"));
			Kill();
			return false;
		}
		return true;
	}

	private void UpdateSpeed(float delta)
	{
		float b = DesiredMoveSpeed();
		NavAgent.speed = Mathf.Lerp(NavAgent.speed, b, delta * 8f);
	}

	protected virtual void UpdatePositionAndRotation(Vector3 moveToPosition)
	{
		ServerPosition = moveToPosition;
		SetAimDirection(GetAimDirection());
	}

	public Vector3 GetPosition()
	{
		return base.transform.position;
	}

	public virtual float DesiredMoveSpeed()
	{
		float running = Mathf.Sin(Time.time + randomOffset);
		return GetSpeed(running, 0f);
	}

	public override bool EligibleForWounding(HitInfo info)
	{
		return false;
	}

	public virtual Vector3 GetAimDirection()
	{
		float num = Vector3Ex.Distance2D(finalDestination, GetPosition());
		if (num >= 1f)
		{
			Vector3 normalized = (finalDestination - GetPosition()).normalized;
			return new Vector3(normalized.x, 0f, normalized.z);
		}
		return eyes.BodyForward();
	}

	public virtual void SetAimDirection(Vector3 newAim)
	{
		if (!(newAim == Vector3.zero))
		{
			AttackEntity attackEntity = GetAttackEntity();
			if ((bool)attackEntity)
			{
				newAim = attackEntity.ModifyAIAim(newAim);
			}
			eyes.rotation = Quaternion.LookRotation(newAim, Vector3.up);
			viewAngles = eyes.rotation.eulerAngles;
			ServerRotation = eyes.rotation;
		}
	}
}
