using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public class ArticulatedOccludee : BaseMonoBehaviour
{
	private const float UpdateBoundsFadeStart = 20f;

	private const float UpdateBoundsFadeLength = 1000f;

	private const float UpdateBoundsMaxFrequency = 25f;

	private const float UpdateBoundsMinFrequency = 0.5f;

	public bool registerCullingOnStart;

	private LODGroup lodGroup;

	private List<Renderer> renderers;

	private List<Collider> colliders;

	private OccludeeSphere localOccludee = new OccludeeSphere(-1);

	private bool isVisible = true;

	private SkinnedMeshRenderer fixedBoundsRef;

	public bool IsVisible => isVisible;

	public SkinnedMeshRenderer FixedBoundsRef
	{
		get
		{
			return fixedBoundsRef;
		}
		set
		{
			fixedBoundsRef = value;
		}
	}

	protected virtual void OnEnable()
	{
		if (registerCullingOnStart)
		{
			List<Collider> obj = Pool.GetList<Collider>();
			GetComponentsInChildren(obj);
			LODGroup component = GetComponent<LODGroup>();
			if (component != null)
			{
				ProcessVisibility(component, obj);
			}
			UpdateCullingBounds();
			Pool.FreeList(ref obj);
		}
	}

	protected virtual void OnDisable()
	{
		if (!Rust.Application.isQuitting)
		{
			UnregisterFromCulling();
			ClearVisibility();
		}
	}

	public void ClearVisibility()
	{
		if (lodGroup != null)
		{
			lodGroup.localReferencePoint = Vector3.zero;
			lodGroup.RecalculateBounds();
			lodGroup = null;
		}
		if (renderers != null)
		{
			renderers.Clear();
		}
		if (colliders != null)
		{
			colliders.Clear();
		}
		fixedBoundsRef = null;
		localOccludee = new OccludeeSphere(-1);
	}

	public void ProcessVisibility(LODGroup lod, List<Collider> colliders)
	{
		ProcessVisibility((List<Renderer>)null, colliders);
		lodGroup = lod;
		if (!(lod != null))
		{
			return;
		}
		renderers = new List<Renderer>(16);
		LOD[] lODs = lod.GetLODs();
		for (int i = 0; i < lODs.Length; i++)
		{
			Renderer[] array = lODs[i].renderers;
			foreach (Renderer renderer in array)
			{
				if (renderer != null)
				{
					renderers.Add(renderer);
				}
			}
		}
	}

	public void ProcessVisibility(List<Renderer> renderers, List<Collider> colliders)
	{
		ClearVisibility();
		if (renderers != null && renderers.Count > 0)
		{
			this.renderers = new List<Renderer>(16);
			for (int i = 0; i < renderers.Count; i++)
			{
				Renderer renderer = renderers[i];
				if (renderer != null)
				{
					this.renderers.Add(renderer);
				}
			}
		}
		if (colliders == null || colliders.Count <= 0)
		{
			return;
		}
		this.colliders = new List<Collider>(colliders.Count);
		for (int j = 0; j < colliders.Count; j++)
		{
			Collider collider = colliders[j];
			if (collider != null)
			{
				this.colliders.Add(collider);
			}
		}
	}

	private void RegisterForCulling(OcclusionCulling.Sphere sphere, bool visible)
	{
		if (localOccludee.IsRegistered)
		{
			UnregisterFromCulling();
		}
		int num = OcclusionCulling.RegisterOccludee(sphere.position, sphere.radius, visible, 0.25f, isStatic: false, OnVisibilityChanged);
		if (num >= 0)
		{
			localOccludee = new OccludeeSphere(num, localOccludee.sphere);
			return;
		}
		localOccludee.Invalidate();
		Debug.LogWarning("[OcclusionCulling] Occludee registration failed for " + base.name + ". Too many registered.");
	}

	private void UnregisterFromCulling()
	{
		if (localOccludee.IsRegistered)
		{
			OcclusionCulling.UnregisterOccludee(localOccludee.id);
			localOccludee.Invalidate();
		}
	}

	public void UpdateCullingBounds()
	{
		Vector3 position = Vector3.zero;
		float radius = 0f;
		bool flag = true;
		if (fixedBoundsRef != null)
		{
			Bounds bounds = fixedBoundsRef.bounds;
			position = bounds.center;
			radius = Mathf.Max(Mathf.Max(bounds.extents.x, bounds.extents.y), bounds.extents.z);
		}
		else
		{
			int num = ((renderers != null) ? renderers.Count : 0);
			int num2 = ((colliders != null) ? colliders.Count : 0);
			if (num > 0 && num < num2)
			{
				Bounds bounds2 = renderers[0].bounds;
				for (int i = 1; i < renderers.Count; i++)
				{
					bounds2.Encapsulate(renderers[i].bounds);
				}
				position = bounds2.center;
				radius = Mathf.Max(Mathf.Max(bounds2.extents.x, bounds2.extents.y), bounds2.extents.z);
			}
			else if (num2 > 0)
			{
				Bounds bounds3 = colliders[0].bounds;
				for (int j = 1; j < colliders.Count; j++)
				{
					bounds3.Encapsulate(colliders[j].bounds);
				}
				position = bounds3.center;
				radius = bounds3.extents.magnitude;
			}
			else
			{
				flag = false;
			}
		}
		if (!flag)
		{
			return;
		}
		OcclusionCulling.Sphere sphere = new OcclusionCulling.Sphere(position, radius);
		if (localOccludee.IsRegistered)
		{
			OcclusionCulling.UpdateDynamicOccludee(localOccludee.id, sphere.position, sphere.radius);
			localOccludee.sphere = sphere;
			return;
		}
		bool visible = true;
		if (lodGroup != null)
		{
			visible = lodGroup.enabled;
		}
		RegisterForCulling(sphere, visible);
	}

	protected virtual bool CheckVisibility()
	{
		if (localOccludee.state != null)
		{
			return localOccludee.state.isVisible;
		}
		return true;
	}

	private void ApplyVisibility(bool vis)
	{
		if (lodGroup != null)
		{
			float num = ((!vis) ? 100000 : 0);
			if (num != lodGroup.localReferencePoint.x)
			{
				lodGroup.localReferencePoint = new Vector3(num, num, num);
			}
		}
	}

	protected virtual void OnVisibilityChanged(bool visible)
	{
		if (MainCamera.mainCamera != null)
		{
			float dist = Vector3.Distance(MainCamera.mainCamera.transform.position, base.transform.position);
			VisUpdateUsingCulling(dist, visible);
		}
	}

	private void UpdateVisibility(float delay)
	{
	}

	private void VisUpdateUsingCulling(float dist, bool visibility)
	{
	}

	public virtual void TriggerUpdateVisibilityBounds()
	{
		if (base.enabled)
		{
			float sqrMagnitude = (base.transform.position - MainCamera.mainCamera.transform.position).sqrMagnitude;
			float num = 400f;
			float num2;
			if (sqrMagnitude < num)
			{
				num2 = 1f / Random.Range(15f, 35f);
			}
			else
			{
				float t = Mathf.Clamp01((Mathf.Sqrt(sqrMagnitude) - 20f) * 0.001f);
				float num3 = Mathf.Lerp(0.04f, 2f, t);
				num2 = Random.Range(num3, num3 + 0.04f);
			}
			UpdateVisibility(num2);
			ApplyVisibility(isVisible);
			Invoke(TriggerUpdateVisibilityBounds, num2);
		}
	}
}
