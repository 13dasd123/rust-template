using System;
using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public static class NavPointSampler
{
	public enum SampleCount
	{
		Four,
		Eight,
		Sixteen
	}

	[Flags]
	public enum SampleFeatures
	{
		None = 0,
		DiscourageSharpTurns = 1,
		RetreatFromTarget = 2,
		ApproachTarget = 4,
		FlankTarget = 8,
		RetreatFromDirection = 0x10,
		RetreatFromExplosive = 0x20
	}

	public struct SampleScoreParams
	{
		public float WaterMaxDepth;

		public IAIAgent Agent;

		public SampleFeatures Features;
	}

	private const float HalfPI = (float)Math.PI / 180f;

	private static readonly NavPointSampleComparer NavPointSampleComparer = new NavPointSampleComparer();

	public static bool SampleCircle(SampleCount sampleCount, Vector3 center, float radius, SampleScoreParams scoreParams, ref List<NavPointSample> samples)
	{
		if (scoreParams.Agent == null || scoreParams.Agent.GetNavAgent == null)
		{
			return false;
		}
		float num = 90f;
		switch (sampleCount)
		{
		case SampleCount.Eight:
			num = 45f;
			break;
		case SampleCount.Sixteen:
			num = 22.5f;
			break;
		}
		for (float num2 = 0f; num2 < 360f; num2 += num)
		{
			NavPointSample item = SamplePoint(GetPointOnCircle(center, radius, num2), scoreParams);
			if (item.Score > 0f)
			{
				samples.Add(item);
			}
		}
		samples.Sort(NavPointSampleComparer);
		return samples.Count > 0;
	}

	public static Vector3 GetPointOnCircle(Vector3 center, float radius, float degrees)
	{
		float x = center.x + radius * Mathf.Cos(degrees * ((float)Math.PI / 180f));
		float z = center.z + radius * Mathf.Sin(degrees * ((float)Math.PI / 180f));
		return new Vector3(x, center.y, z);
	}

	public static NavPointSample SamplePoint(Vector3 pos, SampleScoreParams scoreParams)
	{
		float num = 0f;
		if (_SampleNavMesh(ref pos, scoreParams.Agent) && _WaterDepth(pos, scoreParams.WaterMaxDepth) > 0f)
		{
			num = 1f;
			if ((scoreParams.Features & SampleFeatures.DiscourageSharpTurns) > SampleFeatures.None)
			{
				num += _DiscourageSharpTurns(pos, scoreParams.Agent);
			}
			if ((scoreParams.Features & SampleFeatures.RetreatFromTarget) > SampleFeatures.None)
			{
				num += RetreatPointValue(pos, scoreParams.Agent);
			}
			if ((scoreParams.Features & SampleFeatures.ApproachTarget) > SampleFeatures.None)
			{
				num += ApproachPointValue(pos, scoreParams.Agent);
			}
			if ((scoreParams.Features & SampleFeatures.FlankTarget) > SampleFeatures.None)
			{
				num += FlankPointValue(pos, scoreParams.Agent);
			}
			if ((scoreParams.Features & SampleFeatures.RetreatFromDirection) > SampleFeatures.None)
			{
				num += RetreatFromDirection(pos, scoreParams.Agent);
			}
			if ((scoreParams.Features & SampleFeatures.RetreatFromExplosive) > SampleFeatures.None)
			{
				num += RetreatPointValue(pos, scoreParams.Agent);
			}
		}
		NavPointSample result = default(NavPointSample);
		result.Position = pos;
		result.Score = num;
		return result;
	}

	private static bool _SampleNavMesh(ref Vector3 pos, IAIAgent agent)
	{
		if (NavMesh.SamplePosition(pos, out var hit, agent.GetNavAgent.height * 2f, agent.GetNavAgent.areaMask))
		{
			pos = hit.position;
			return true;
		}
		return false;
	}

	private static float _WaterDepth(Vector3 pos, float maxDepth)
	{
		float waterDepth = WaterLevel.GetWaterDepth(pos);
		if (Mathf.Approximately(waterDepth, 0f))
		{
			return 1f;
		}
		waterDepth = Mathf.Min(waterDepth, maxDepth);
		return 1f - waterDepth / maxDepth;
	}

	private static float _DiscourageSharpTurns(Vector3 pos, IAIAgent agent)
	{
		Vector3 normalized = (pos - agent.Entity.ServerPosition).normalized;
		float num = Vector3.Dot(agent.Entity.transform.forward, normalized);
		if (num > 0.45f)
		{
			return 1f;
		}
		if (num > 0f)
		{
			return num;
		}
		return 0f;
	}

	public static bool IsValidPointDirectness(Vector3 point, Vector3 pos, Vector3 targetPos)
	{
		Vector3 vector = pos - targetPos;
		Vector3 vector2 = pos - point;
		float num = Vector3.Dot(vector.normalized, vector2.normalized);
		if (num > 0f && vector2.sqrMagnitude > vector.sqrMagnitude)
		{
			return false;
		}
		return true;
	}

	public static float PointDirectnessToTarget(Vector3 point, Vector3 pos, Vector3 targetPos)
	{
		float num = Vector3.Distance(pos, targetPos);
		float num2 = Vector3.Distance(point, targetPos);
		float num3 = Vector3.Distance(pos, point);
		return (num - num2) / num3;
	}

	public static float RetreatPointValue(Vector3 point, IAIAgent agent)
	{
		if (agent.AttackTarget == null)
		{
			return 0f;
		}
		float num = PointDirectnessToTarget(point, agent.Entity.ServerPosition, agent.AttackTarget.ServerPosition);
		if (num <= -0.5f)
		{
			return num * -1f;
		}
		return 0f;
	}

	public static float RetreatPointValueExplosive(Vector3 point, IAIAgent agent)
	{
		if (!(agent.GetContext(Guid.Empty) is BaseContext baseContext) || baseContext.DeployedExplosives.Count == 0 || baseContext.DeployedExplosives[0] == null || baseContext.DeployedExplosives[0].IsDestroyed)
		{
			return 0f;
		}
		float num = PointDirectnessToTarget(point, agent.Entity.ServerPosition, baseContext.DeployedExplosives[0].ServerPosition);
		if (num <= -0.5f)
		{
			return num * -1f;
		}
		return 0f;
	}

	public static float ApproachPointValue(Vector3 point, IAIAgent agent)
	{
		if (agent.AttackTarget == null)
		{
			return 0f;
		}
		float num = PointDirectnessToTarget(point, agent.Entity.ServerPosition, agent.AttackTarget.ServerPosition);
		if (num >= 0.5f)
		{
			return num;
		}
		return 0f;
	}

	public static float FlankPointValue(Vector3 point, IAIAgent agent)
	{
		if (agent.AttackTarget == null)
		{
			return 0f;
		}
		float num = PointDirectnessToTarget(point, agent.Entity.ServerPosition, agent.AttackTarget.ServerPosition);
		if (num >= -0.1f && num <= 0.1f)
		{
			return 1f;
		}
		return 0f;
	}

	public static float RetreatFromDirection(Vector3 point, IAIAgent agent)
	{
		if (agent.Entity.LastAttackedDir == Vector3.zero)
		{
			return 0f;
		}
		Vector3 normalized = (point - agent.Entity.ServerPosition).normalized;
		float num = Vector3.Dot(agent.Entity.LastAttackedDir, normalized);
		if (num > -0.5f)
		{
			return 0f;
		}
		return 1f;
	}
}
