using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using ConVar;
using UnityEngine;

public static class World
{
	public static uint Seed { get; set; }

	public static uint Salt { get; set; }

	public static uint Size { get; set; }

	public static string Checksum { get; set; }

	public static string Url { get; set; }

	public static bool Procedural { get; set; }

	public static bool Cached { get; set; }

	public static WorldSerialization Serialization { get; set; }

	public static string Name
	{
		get
		{
			if (CanLoadFromUrl())
			{
				return Path.GetFileNameWithoutExtension(WWW.UnEscapeURL(Url));
			}
			return Application.loadedLevelName;
		}
	}

	public static string MapFileName
	{
		get
		{
			if (CanLoadFromUrl())
			{
				return Name + ".map";
			}
			return Name.Replace(" ", string.Empty).ToLower() + "." + Size + "." + Seed + "." + 172 + ".map";
		}
	}

	public static string MapFolderName => Server.rootFolder;

	public static string SaveFileName
	{
		get
		{
			if (CanLoadFromUrl())
			{
				return Name + "." + 172 + ".sav";
			}
			return Name.Replace(" ", string.Empty).ToLower() + "." + Size + "." + Seed + "." + 172 + ".sav";
		}
	}

	public static string SaveFolderName => Server.rootFolder;

	public static bool CanLoadFromUrl()
	{
		return !string.IsNullOrEmpty(Url);
	}

	public static bool CanLoadFromDisk()
	{
		return File.Exists(MapFolderName + "/" + MapFileName);
	}

	public static void CleanupOldFiles()
	{
		Regex regex1 = new Regex("proceduralmap\\.[0-9]+\\.[0-9]+\\.[0-9]+\\.map");
		Regex regex2 = new Regex("\\.[0-9]+\\.[0-9]+\\." + 172 + "\\.map");
		IEnumerable<string> enumerable = from path in Directory.GetFiles(MapFolderName, "*.map")
			where regex1.IsMatch(path) && !regex2.IsMatch(path)
			select path;
		foreach (string item in enumerable)
		{
			try
			{
				File.Delete(item);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
			}
		}
	}

	public static void InitSeed(int seed)
	{
		InitSeed((uint)seed);
	}

	public static void InitSeed(uint seed)
	{
		if (seed == 0)
		{
			seed = MurmurHashEx.MurmurHashUnsigned(SeedIdentifier()) % int.MaxValue;
		}
		if (seed == 0)
		{
			seed = 123456u;
		}
		Seed = seed;
		Server.seed = (int)seed;
	}

	private static string SeedIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_" + 172;
	}

	public static void InitSalt(int salt)
	{
		InitSalt((uint)salt);
	}

	public static void InitSalt(uint salt)
	{
		if (salt == 0)
		{
			salt = MurmurHashEx.MurmurHashUnsigned(SaltIdentifier()) % int.MaxValue;
		}
		if (salt == 0)
		{
			salt = 654321u;
		}
		Salt = salt;
		Server.salt = (int)salt;
	}

	private static string SaltIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_salt";
	}

	public static void InitSize(int size)
	{
		InitSize((uint)size);
	}

	public static void InitSize(uint size)
	{
		if (size == 0)
		{
			size = 4000u;
		}
		if (size < 1000)
		{
			size = 1000u;
		}
		if (size > 6000)
		{
			size = 6000u;
		}
		Size = size;
		Server.worldsize = (int)size;
	}

	public static byte[] GetMap(string name)
	{
		return Serialization.GetMap(name)?.data;
	}

	public static void AddMap(string name, byte[] data)
	{
		Serialization.AddMap(name, data);
	}

	public static void AddPrefab(string category, uint id, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		Serialization.AddPrefab(category, id, position, rotation, scale);
		if (!Cached)
		{
			Spawn(category, id, position, rotation, scale);
		}
	}

	public static WorldSerialization.PathData PathListToPathData(PathList src)
	{
		WorldSerialization.PathData pathData = new WorldSerialization.PathData();
		pathData.name = src.Name;
		pathData.spline = src.Spline;
		pathData.start = src.Start;
		pathData.end = src.End;
		pathData.width = src.Width;
		pathData.innerPadding = src.InnerPadding;
		pathData.outerPadding = src.OuterPadding;
		pathData.innerFade = src.InnerFade;
		pathData.outerFade = src.OuterFade;
		pathData.randomScale = src.RandomScale;
		pathData.meshOffset = src.MeshOffset;
		pathData.terrainOffset = src.TerrainOffset;
		pathData.splat = src.Splat;
		pathData.topology = src.Topology;
		pathData.nodes = Array.ConvertAll(src.Path.Points, (Converter<Vector3, WorldSerialization.VectorData>)((Vector3 item) => item));
		return pathData;
	}

	public static PathList PathDataToPathList(WorldSerialization.PathData src)
	{
		PathList pathList = new PathList(src.name, Array.ConvertAll(src.nodes, (Converter<WorldSerialization.VectorData, Vector3>)((WorldSerialization.VectorData item) => item)));
		pathList.Spline = src.spline;
		pathList.Start = src.start;
		pathList.End = src.end;
		pathList.Width = src.width;
		pathList.InnerPadding = src.innerPadding;
		pathList.OuterPadding = src.outerPadding;
		pathList.InnerFade = src.innerFade;
		pathList.OuterFade = src.outerFade;
		pathList.RandomScale = src.randomScale;
		pathList.MeshOffset = src.meshOffset;
		pathList.TerrainOffset = src.terrainOffset;
		pathList.Splat = src.splat;
		pathList.Topology = src.topology;
		pathList.Path.RecalculateTangents();
		return pathList;
	}

	public static IEnumerable<PathList> GetPaths(string name)
	{
		return Serialization.GetPaths(name).Select(PathDataToPathList);
	}

	public static void AddPaths(IEnumerable<PathList> paths)
	{
		foreach (PathList path in paths)
		{
			AddPath(path);
		}
	}

	public static void AddPath(PathList path)
	{
		Serialization.AddPath(PathListToPathData(path));
	}

	public static IEnumerator Spawn(float deltaTime, Action<string> statusFunction = null)
	{
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == Serialization.world.prefabs.Count - 1)
			{
				Status(statusFunction, "Spawning World ({0}/{1})", i + 1, Serialization.world.prefabs.Count);
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			Spawn(Serialization.world.prefabs[i]);
		}
	}

	public static void Spawn()
	{
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			Spawn(Serialization.world.prefabs[i]);
		}
	}

	private static void Spawn(WorldSerialization.PrefabData prefab)
	{
		Spawn(prefab.category, prefab.id, prefab.position, prefab.rotation, prefab.scale);
	}

	private static void Spawn(string category, uint id, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		GameObject gameObject = Prefab.DefaultManager.CreatePrefab(StringPool.Get(id), position, rotation, scale);
		if ((bool)gameObject)
		{
			GameObjectEx.SetHierarchyGroup(gameObject, category);
		}
	}

	private static void Status(Action<string> statusFunction, string status, object obj1)
	{
		statusFunction?.Invoke(string.Format(status, obj1));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2, object obj3)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2, obj3));
	}

	private static void Status(Action<string> statusFunction, string status, params object[] objs)
	{
		statusFunction?.Invoke(string.Format(status, objs));
	}
}
