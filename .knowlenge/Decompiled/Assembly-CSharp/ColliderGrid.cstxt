using System.Collections;
using System.Diagnostics;
using ConVar;
using Rust;
using UnityEngine;

public class ColliderGrid : SingletonComponent<ColliderGrid>, IServerComponent
{
	public static bool Paused;

	public float CellSize = 50f;

	public float MaxMilliseconds = 0.1f;

	private WorldSpaceGrid<ColliderCell> grid;

	private PrefabPool pool;

	private Stopwatch watch = Stopwatch.StartNew();

	public ColliderCell this[Vector3 worldPos]
	{
		get
		{
			if (grid == null)
			{
				Init();
			}
			return grid[worldPos];
		}
	}

	public bool NeedsTimeout => watch.Elapsed.TotalMilliseconds > (double)MaxMilliseconds;

	protected void OnEnable()
	{
		StartCoroutine(UpdateCoroutine());
	}

	public static void RefreshAll()
	{
		if ((bool)SingletonComponent<ColliderGrid>.Instance)
		{
			SingletonComponent<ColliderGrid>.Instance.Refresh();
		}
	}

	public void Refresh()
	{
		if (grid == null)
		{
			Init();
		}
		for (int i = 0; i < grid.CellCount; i++)
		{
			for (int j = 0; j < grid.CellCount; j++)
			{
				grid[i, j].Refresh();
			}
		}
	}

	private void Init()
	{
		grid = new WorldSpaceGrid<ColliderCell>(TerrainMeta.Size.x, CellSize);
		for (int i = 0; i < grid.CellCount; i++)
		{
			for (int j = 0; j < grid.CellCount; j++)
			{
				grid[i, j] = new ColliderCell(this, grid.GridToWorldCoords(new Vector2i(i, j)));
			}
		}
		pool = new PrefabPool();
	}

	public MeshColliderBatch CreateInstance()
	{
		GameObject gameObject = pool.Pop();
		if ((bool)gameObject)
		{
			PrefabInfoEx.AwakeFromInstantiate(gameObject);
		}
		else
		{
			gameObject = MeshColliderBatch.CreateInstance();
			if (Pool.collider_batches)
			{
				PrefabInfoEx.EnablePooling(gameObject, 0u);
			}
		}
		return gameObject.GetComponent<MeshColliderBatch>();
	}

	public void RecycleInstance(MeshColliderBatch instance)
	{
		if (PrefabInfoEx.SupportsPooling(instance.gameObject))
		{
			pool.Push(instance.gameObject);
		}
		else
		{
			GameManager.Destroy(instance.gameObject);
		}
	}

	public int MeshCount()
	{
		if (grid == null)
		{
			return 0;
		}
		int num = 0;
		for (int i = 0; i < grid.CellCount; i++)
		{
			for (int j = 0; j < grid.CellCount; j++)
			{
				num += grid[i, j].MeshCount();
			}
		}
		return num;
	}

	public int BatchedMeshCount()
	{
		if (grid == null)
		{
			return 0;
		}
		int num = 0;
		for (int i = 0; i < grid.CellCount; i++)
		{
			for (int j = 0; j < grid.CellCount; j++)
			{
				num += grid[i, j].BatchedMeshCount();
			}
		}
		return num;
	}

	public void ResetTimeout()
	{
		watch.Reset();
		watch.Start();
	}

	private IEnumerator UpdateCoroutine()
	{
		while (true)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			if (Rust.Application.isReceiving || Rust.Application.isLoading || Paused || grid == null)
			{
				continue;
			}
			ResetTimeout();
			for (int x = 0; x < grid.CellCount; x++)
			{
				for (int z = 0; z < grid.CellCount; z++)
				{
					ColliderCell cell = grid[x, z];
					if (cell.NeedsRefresh())
					{
						IEnumerator enumerator = cell.RefreshAsync();
						while (enumerator.MoveNext())
						{
							yield return enumerator.Current;
						}
					}
					if (NeedsTimeout)
					{
						yield return CoroutineEx.waitForEndOfFrame;
						ResetTimeout();
					}
				}
			}
		}
	}
}
