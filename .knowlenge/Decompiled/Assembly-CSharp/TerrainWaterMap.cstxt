using UnityEngine;

public class TerrainWaterMap : TerrainMap2D<float>
{
	public Texture2D WaterTexture;

	private float normY;

	public override void Setup()
	{
		if (WaterTexture != null)
		{
			if (WaterTexture.width == WaterTexture.height)
			{
				res = WaterTexture.width;
				src = (dst = new float[res, res]);
				Color32[] pixels = WaterTexture.GetPixels32();
				int i = 0;
				int num = 0;
				for (; i < res; i++)
				{
					int num2 = 0;
					while (num2 < res)
					{
						Color32 c = pixels[num];
						dst[i, num2] = TextureData.DecodeFloat(c);
						num2++;
						num++;
					}
				}
			}
			else
			{
				Debug.LogError("Invalid height texture: " + WaterTexture.name);
			}
		}
		else
		{
			res = terrain.terrainData.heightmapResolution / 2 + 1;
			src = (dst = new float[res, res]);
		}
		normY = TerrainMeta.Size.x / TerrainMeta.Size.y / (float)res;
	}

	public void GenerateTextures()
	{
		Color32[] heights = new Color32[res * res];
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float height = GetHeight01(i, z);
				ref Color32 reference = ref heights[z * res + i];
				reference = TextureData.EncodeFloat(height);
			}
		});
		WaterTexture = new Texture2D(res, res, TextureFormat.RGBA32, mipmap: true, linear: true);
		WaterTexture.name = "WaterTexture";
		WaterTexture.wrapMode = TextureWrapMode.Clamp;
		WaterTexture.SetPixels32(heights);
	}

	public void ApplyTextures()
	{
		WaterTexture.Apply(updateMipmaps: true, makeNoLongerReadable: true);
	}

	public float GetHeight(Vector3 worldPos)
	{
		return TerrainMeta.Position.y + GetHeight01(worldPos) * TerrainMeta.Size.y;
	}

	public float GetHeight(float normX, float normZ)
	{
		return TerrainMeta.Position.y + GetHeight01(normX, normZ) * TerrainMeta.Size.y;
	}

	public float GetHeight(int x, int z)
	{
		return TerrainMeta.Position.y + GetHeight01(x, z) * TerrainMeta.Size.y;
	}

	public float GetHeight01(Vector3 worldPos)
	{
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetHeight01(normX, normZ);
	}

	public float GetHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int num6 = Mathf.Min(num4 + 1, num);
		int num7 = Mathf.Min(num5 + 1, num);
		float a = Mathf.Lerp(src[num5, num4], src[num5, num6], num2 - (float)num4);
		float b = Mathf.Lerp(src[num7, num4], src[num7, num6], num2 - (float)num4);
		return Mathf.Lerp(a, b, num3 - (float)num5);
	}

	public float GetHeight01(int x, int z)
	{
		return src[z, x];
	}

	public Vector3 GetNormal(Vector3 worldPos)
	{
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetNormal(normX, normZ);
	}

	public Vector3 GetNormal(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int num6 = Mathf.Min(num4 + 1, num);
		int num7 = Mathf.Min(num5 + 1, num);
		float num8 = src[num5, num6] - src[num5, num4];
		float num9 = src[num7, num4] - src[num5, num4];
		return new Vector3(0f - num8, normY, 0f - num9).normalized;
	}

	public Vector3 GetNormal(int x, int z)
	{
		int max = res - 1;
		int num = Mathf.Clamp(x - 1, 0, max);
		int num2 = Mathf.Clamp(z - 1, 0, max);
		int num3 = Mathf.Clamp(x + 1, 0, max);
		int num4 = Mathf.Clamp(z + 1, 0, max);
		float num5 = (src[num2, num3] - src[num2, num]) * 0.5f;
		float num6 = (src[num4, num] - src[num2, num]) * 0.5f;
		return new Vector3(0f - num5, normY, 0f - num6).normalized;
	}

	public float GetSlope(Vector3 worldPos)
	{
		return Vector3.Angle(Vector3.up, GetNormal(worldPos));
	}

	public float GetSlope(float normX, float normZ)
	{
		return Vector3.Angle(Vector3.up, GetNormal(normX, normZ));
	}

	public float GetSlope(int x, int z)
	{
		return Vector3.Angle(Vector3.up, GetNormal(x, z));
	}

	public float GetSlope01(Vector3 worldPos)
	{
		return GetSlope(worldPos) * (1f / 90f);
	}

	public float GetSlope01(float normX, float normZ)
	{
		return GetSlope(normX, normZ) * (1f / 90f);
	}

	public float GetSlope01(int x, int z)
	{
		return GetSlope(x, z) * (1f / 90f);
	}

	public float GetDepth(Vector3 worldPos)
	{
		return GetHeight(worldPos) - TerrainMeta.HeightMap.GetHeight(worldPos);
	}

	public float GetDepth(float normX, float normZ)
	{
		return GetHeight(normX, normZ) - TerrainMeta.HeightMap.GetHeight(normX, normZ);
	}

	public void SetHeight(Vector3 worldPos, float height)
	{
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height);
	}

	public void SetHeight(float normX, float normZ, float height)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height);
	}

	public void SetHeight(int x, int z, float height)
	{
		dst[z, x] = height;
	}
}
