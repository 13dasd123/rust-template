using ConVar;
using Rust.Ai.HTN.Scientist.Reasoners;
using UnityEngine;
using UnityEngine.AI;

public class NavigateToPreferredFightingRange : BaseNavigateTo
{
	public static Vector3 GetPreferredFightingPosition(ScientistContext context, bool snapToAllowedRange = true)
	{
		if (UnityEngine.Time.time - context.Memory.CachedPreferredDistanceDestinationTime < 0.01f)
		{
			return context.Memory.CachedPreferredDistanceDestination;
		}
		NpcPlayerInfo target = context.GetPrimaryEnemyPlayerTarget();
		if (target.Player != null)
		{
			Vector3 bodyPosition = context.BodyPosition;
			if (context.GetFact(Facts.Frustration) <= ConVar.AI.npc_htn_player_frustration_threshold)
			{
				bodyPosition = NavigateToCover.GetCoverPosition(CoverTactic.Closest, context);
			}
			else
			{
				AttackEntity firearm = context.Domain.GetFirearm();
				float preferredRange = PreferredFightingRangeReasoner.GetPreferredRange(context, ref target, firearm);
				float num = preferredRange * preferredRange;
				Vector3 vector;
				float magnitude;
				if (target.SqrDistance < num)
				{
					vector = context.Body.transform.position - target.Player.transform.position;
					magnitude = vector.magnitude;
					vector.Normalize();
				}
				else
				{
					vector = target.Player.transform.position - context.Body.transform.position;
					magnitude = vector.magnitude;
					vector.Normalize();
				}
				float num2 = magnitude - preferredRange;
				bodyPosition = context.Body.transform.position + vector * num2;
			}
			Vector3 vector2 = bodyPosition;
			for (int i = 0; i < 10; i++)
			{
				if (NavMesh.SamplePosition(vector2 + Vector3.up * 0.1f, out var hit, 2f * context.Domain.NavAgent.height, -1))
				{
					Vector3 position = hit.position;
					if (snapToAllowedRange)
					{
						context.Domain.ToAllowedMovementDestination(position);
					}
					if (context.Memory.IsValid(position))
					{
						context.Memory.CachedPreferredDistanceDestination = position;
						context.Memory.CachedPreferredDistanceDestinationTime = UnityEngine.Time.time;
						return position;
					}
				}
				else
				{
					context.Memory.AddFailedDestination(vector2);
				}
				Vector2 vector3 = Random.insideUnitCircle * 5f;
				vector2 = bodyPosition + new Vector3(vector3.x, 0f, vector3.y);
			}
		}
		return context.Body.transform.position;
	}

	protected override Vector3 _GetDestination(ScientistContext context)
	{
		return GetPreferredFightingPosition(context, snapToAllowedRange: false);
	}
}
