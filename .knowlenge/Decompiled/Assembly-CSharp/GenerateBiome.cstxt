using UnityEngine;

public class GenerateBiome : ProceduralComponent
{
	public override void Process(uint seed)
	{
		int res = TerrainMeta.BiomeMap.res;
		byte[,,] map = TerrainMeta.BiomeMap.dst;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		float noiseX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float noiseZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float normfac = 1f / (float)(res - 1);
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = (float)i * normfac;
				float num = (float)z * normfac;
				float num2 = TerrainMeta.DenormalizeX(normX);
				float num3 = TerrainMeta.DenormalizeZ(num);
				float height = heightmap.GetHeight01(normX, num);
				float num4 = Noise.Turbulence(num2 + noiseX, num3 + noiseZ, 6, 0.009999999776482582, 0.009999999776482582);
				float num5 = 0.8f * num;
				float num6 = 4f * Mathf.Clamp01(height + num4 - 0.51f);
				float num7 = Mathf.Clamp01(num5 + num6);
				if (num7 <= 0.4f)
				{
					float num8 = Mathf.InverseLerp(0.4f, 0.29999998f, num7);
					map[z, i, 0] = TextureData.Float2Byte(num8);
					map[z, i, 1] = TextureData.Float2Byte(1f - num8);
				}
				else if (num7 <= 0.6f)
				{
					float num9 = Mathf.InverseLerp(0.6f, 0.5f, num7);
					map[z, i, 1] = TextureData.Float2Byte(num9);
					map[z, i, 2] = TextureData.Float2Byte(1f - num9);
				}
				else
				{
					float num10 = Mathf.InverseLerp(0.7f, 0.59999996f, num7);
					map[z, i, 2] = TextureData.Float2Byte(num10);
					map[z, i, 3] = TextureData.Float2Byte(1f - num10);
				}
			}
		});
	}
}
