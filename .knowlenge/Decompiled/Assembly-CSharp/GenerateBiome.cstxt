using UnityEngine;

public class GenerateBiome : ProceduralComponent
{
	public override void Process(uint seed)
	{
		int res = TerrainMeta.BiomeMap.res;
		byte[,,] map = TerrainMeta.BiomeMap.dst;
		TerrainBiomeMap biomemap = TerrainMeta.BiomeMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		float noiseX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float noiseZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float lootAngle = TerrainMeta.LootAxisAngle;
		float biomeAngle = TerrainMeta.BiomeAxisAngle;
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float num = biomemap.Coordinate(i);
				float num2 = biomemap.Coordinate(z);
				float num3 = TerrainMeta.DenormalizeX(num);
				float num4 = TerrainMeta.DenormalizeZ(num2);
				float height = heightmap.GetHeight01(num, num2);
				float num5 = Noise.Turbulence(num3 + noiseX, num4 + noiseZ, 6, 0.009999999776482582, 0.009999999776482582);
				Vector2 v = new Vector2(num * 2f - 1f, num2 * 2f - 1f);
				float value = (v.Rotate(lootAngle).y + 1f) * 0.5f;
				float a = (v.Rotate(biomeAngle).y + 1f) * 0.5f;
				float t = Mathf.InverseLerp(0.35f, 0.25f, value);
				float num6 = Mathf.Lerp(a, 0.47500002f, t);
				float num7 = 4f * Mathf.Clamp01(height + num5 - 0.525f);
				float num8 = Mathf.Clamp01(num6 + num7);
				if (num8 <= 0.45000002f)
				{
					float num9 = Mathf.InverseLerp(0.45000002f, 0.35f, num8);
					map[0, z, i] = TextureData.Float2Byte(num9);
					map[1, z, i] = TextureData.Float2Byte(1f - num9);
				}
				else if (num8 <= 0.6f)
				{
					float num10 = Mathf.InverseLerp(0.6f, 0.5f, num8);
					map[1, z, i] = TextureData.Float2Byte(num10);
					map[2, z, i] = TextureData.Float2Byte(1f - num10);
				}
				else
				{
					float num11 = Mathf.InverseLerp(0.7f, 0.59999996f, num8);
					map[2, z, i] = TextureData.Float2Byte(num11);
					map[3, z, i] = TextureData.Float2Byte(1f - num11);
				}
			}
		});
	}
}
