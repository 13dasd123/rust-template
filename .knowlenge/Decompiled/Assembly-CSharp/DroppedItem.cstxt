using ConVar;
using Oxide.Core;
using Rust;
using UnityEngine;

public class DroppedItem : WorldItem
{
	[Header("DroppedItem")]
	public GameObject itemModel;

	public override void ServerInit()
	{
		base.ServerInit();
		Invoke(IdleDestroy, GetDespawnDuration());
		ReceiveCollisionMessages(b: true);
	}

	public float GetDespawnDuration()
	{
		int num = ((item == null) ? 1 : item.despawnMultiplier);
		return ConVar.Server.itemdespawn * (float)num;
	}

	public void IdleDestroy()
	{
		DestroyItem();
		Kill();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (item != null)
		{
			DroppedItem droppedItem = hitEntity as DroppedItem;
			if (!(droppedItem == null) && droppedItem.item != null && !(droppedItem.item.info != item.info))
			{
				droppedItem.OnDroppedOn(this);
			}
		}
	}

	public void OnDroppedOn(DroppedItem di)
	{
		if (item != null && di.item != null && Interface.CallHook("CanCombineDroppedItem", this, di) == null && item.info.stackable > 1 && !(di.item.info != item.info) && (!di.item.IsBlueprint() || di.item.blueprintTarget == item.blueprintTarget))
		{
			int num = di.item.amount + item.amount;
			if (num <= item.info.stackable && num != 0)
			{
				di.DestroyItem();
				di.Kill();
				item.amount = num;
				item.MarkDirty();
				Invoke(IdleDestroy, GetDespawnDuration());
				Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	internal override void OnParentRemoved()
	{
		Rigidbody component = GetComponent<Rigidbody>();
		if (component == null || Rust.Application.isQuitting)
		{
			base.OnParentRemoved();
			return;
		}
		Vector3 estimatedWorldPosition = GetEstimatedWorldPosition();
		Quaternion estimatedWorldRotation = GetEstimatedWorldRotation();
		SetParent(null);
		if (UnityEngine.Physics.Raycast(estimatedWorldPosition + Vector3.up * 2f, Vector3.down, out var hitInfo, 2f, 27328512) && estimatedWorldPosition.y < hitInfo.point.y)
		{
			estimatedWorldPosition += Vector3.up * 1.5f;
		}
		base.transform.position = estimatedWorldPosition;
		base.transform.rotation = estimatedWorldRotation;
		component.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		component.isKinematic = false;
		component.useGravity = true;
		component.WakeUp();
		Invoke(IdleDestroy, GetDespawnDuration());
		Invoke(base.SwitchToFastPhysics, 5f);
	}

	public override void PostInitShared()
	{
		base.PostInitShared();
		GameObject gameObject = null;
		gameObject = ((item == null || !item.info.worldModelPrefab.isValid) ? Object.Instantiate(itemModel) : item.info.worldModelPrefab.Instantiate());
		gameObject.transform.SetParent(base.transform, worldPositionStays: false);
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.identity;
		TransformEx.SetLayerRecursive(gameObject, base.gameObject.layer);
		WorldModel component = gameObject.GetComponent<WorldModel>();
		float mass = ((!component) ? 1f : component.mass);
		float drag = 0.1f;
		float angularDrag = 0.1f;
		if (base.isServer)
		{
			Rigidbody rigidbody = base.gameObject.AddComponent<Rigidbody>();
			rigidbody.mass = mass;
			rigidbody.drag = drag;
			rigidbody.angularDrag = angularDrag;
			rigidbody.interpolation = RigidbodyInterpolation.None;
			ConVar.Physics.ApplyDropped(rigidbody, this);
			Renderer[] componentsInChildren = gameObject.GetComponentsInChildren<Renderer>(includeInactive: true);
			foreach (Renderer renderer in componentsInChildren)
			{
				renderer.enabled = false;
			}
		}
		if (item != null)
		{
			PhysicsEffects component2 = base.gameObject.GetComponent<PhysicsEffects>();
			if (component2 != null)
			{
				component2.entity = this;
				if (item.info.physImpactSoundDef != null)
				{
					component2.physImpactSoundDef = item.info.physImpactSoundDef;
				}
			}
		}
		gameObject.SetActive(value: true);
	}
}
