using UnityEngine;

public class Buoyancy : MonoBehaviour
{
	public BuoyancyPoint[] points;

	public GameObjectRef[] waterImpacts;

	public Rigidbody rigidBody;

	public float buoyancyScale = 1f;

	public float submergedFraction;

	public bool doEffects = true;

	public bool clientSide;

	public float waveHeightScale = 0.5f;

	public static string DefaultWaterImpact()
	{
		return "assets/bundled/prefabs/fx/impacts/physics/water-enter-exit.prefab";
	}

	public void FixedUpdate()
	{
		BuoyancyFixedUpdate();
	}

	public Vector3 GetFlowDirection(Vector3 point)
	{
		if (TerrainMeta.WaterMap == null)
		{
			return Vector3.zero;
		}
		Vector3 normal = TerrainMeta.WaterMap.GetNormal(point);
		float num = Mathf.Clamp01(Mathf.Abs(normal.y));
		normal.y = 0f;
		normal = normal.normalized;
		return normal * num;
	}

	public void EnsurePointsInitialized()
	{
		if (points == null || points.Length == 0)
		{
			Rigidbody component = GetComponent<Rigidbody>();
			if (component != null)
			{
				GameObject gameObject = new GameObject("BuoyancyPoint");
				gameObject.transform.parent = component.gameObject.transform;
				gameObject.transform.localPosition = component.centerOfMass;
				BuoyancyPoint buoyancyPoint = gameObject.AddComponent<BuoyancyPoint>();
				buoyancyPoint.buoyancyForce = component.mass * (0f - Physics.gravity.y);
				buoyancyPoint.buoyancyForce *= 1.32f;
				buoyancyPoint.size = 0.2f;
				points = new BuoyancyPoint[1];
				points[0] = buoyancyPoint;
			}
		}
	}

	public void BuoyancyFixedUpdate()
	{
		if (TerrainMeta.WaterMap == null)
		{
			return;
		}
		EnsurePointsInitialized();
		if (rigidBody == null)
		{
			Debug.LogWarning("No rigidbody on buoyancypoint : " + base.gameObject.name + " on root : " + base.gameObject.transform.root.name);
		}
		else
		{
			if (rigidBody.IsSleeping() || buoyancyScale == 0f)
			{
				return;
			}
			int num = 0;
			BuoyancyPoint[] array = points;
			foreach (BuoyancyPoint buoyancyPoint in array)
			{
				Vector3 position = buoyancyPoint.transform.position;
				WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(position);
				Vector3 localPosition = buoyancyPoint.transform.localPosition;
				bool flag = false;
				if (position.y < waterInfo.surfaceLevel)
				{
					flag = true;
					num++;
					float currentDepth = waterInfo.currentDepth;
					float num2 = Mathf.InverseLerp(0f, buoyancyPoint.size, currentDepth);
					float num3 = 1f + Mathf.PerlinNoise(buoyancyPoint.randomOffset + Time.time * buoyancyPoint.waveFrequency, 0f) * buoyancyPoint.waveScale;
					rigidBody.AddForceAtPosition(Vector3.up * buoyancyPoint.buoyancyForce * num3 * num2 * buoyancyScale, position, ForceMode.Force);
					Vector3 flowDirection = GetFlowDirection(position);
					if (flowDirection != Vector3.up)
					{
						rigidBody.AddForceAtPosition(flowDirection * buoyancyPoint.buoyancyForce * 0.25f * buoyancyScale, position, ForceMode.Force);
					}
				}
				if (buoyancyPoint.doSplashEffects && ((!buoyancyPoint.wasSubmergedLastFrame && flag) || (!flag && buoyancyPoint.wasSubmergedLastFrame)) && doEffects && rigidBody.GetRelativePointVelocity(buoyancyPoint.transform.localPosition).magnitude > 1f)
				{
					string strName = ((waterImpacts == null || waterImpacts.Length <= 0 || !waterImpacts[0].isValid) ? DefaultWaterImpact() : waterImpacts[0].resourcePath);
					Vector3 vector = new Vector3(Random.Range(-0.25f, 0.25f), 0f, Random.Range(-0.25f, 0.25f));
					if (clientSide)
					{
						Effect.client.Run(strName, position + vector, Vector3.up);
					}
					else
					{
						Effect.server.Run(strName, position + vector, Vector3.up);
					}
					buoyancyPoint.nexSplashTime = Time.time + 0.25f;
				}
				buoyancyPoint.wasSubmergedLastFrame = flag;
			}
			if (points.Length > 0)
			{
				submergedFraction = (float)num / (float)points.Length;
			}
		}
	}
}
