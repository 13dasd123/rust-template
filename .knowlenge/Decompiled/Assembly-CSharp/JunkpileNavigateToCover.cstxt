using Apex.Serialization;
using UnityEngine;
using UnityEngine.AI;

public class JunkpileNavigateToCover : BaseNavigateTo
{
	[ApexSerialization]
	private CoverTactic _preferredTactic;

	public static CoverPoint GetCover(CoverTactic tactic, ScientistJunkpileContext context)
	{
		switch (tactic)
		{
		case CoverTactic.Retreat:
			if (context.BestRetreatCover != null && context.BestRetreatCover.IsValidFor(context.Body))
			{
				return context.BestRetreatCover;
			}
			if (context.BestFlankCover != null && context.BestFlankCover.IsValidFor(context.Body))
			{
				return context.BestFlankCover;
			}
			if (context.BestAdvanceCover != null && context.BestAdvanceCover.IsValidFor(context.Body))
			{
				return context.BestAdvanceCover;
			}
			break;
		case CoverTactic.Flank:
			if (context.BestFlankCover != null && context.BestFlankCover.IsValidFor(context.Body))
			{
				return context.BestFlankCover;
			}
			if (context.BestRetreatCover != null && context.BestRetreatCover.IsValidFor(context.Body))
			{
				return context.BestRetreatCover;
			}
			if (context.BestAdvanceCover != null && context.BestAdvanceCover.IsValidFor(context.Body))
			{
				return context.BestAdvanceCover;
			}
			break;
		case CoverTactic.Advance:
			if (context.BestAdvanceCover != null && context.BestAdvanceCover.IsValidFor(context.Body))
			{
				return context.BestAdvanceCover;
			}
			if (context.BestFlankCover != null && context.BestFlankCover.IsValidFor(context.Body))
			{
				return context.BestFlankCover;
			}
			if (context.BestRetreatCover != null && context.BestRetreatCover.IsValidFor(context.Body))
			{
				return context.BestRetreatCover;
			}
			break;
		case CoverTactic.Closest:
			if (context.ClosestCover != null && context.ClosestCover.IsValidFor(context.Body))
			{
				return context.ClosestCover;
			}
			break;
		}
		return null;
	}

	private static Vector3 _GetCoverPosition(CoverTactic tactic, ScientistJunkpileContext context)
	{
		switch (tactic)
		{
		case CoverTactic.Retreat:
			if (context.BestRetreatCover != null && context.BestRetreatCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Retreat);
				context.ReserveCoverPoint(context.BestRetreatCover);
				return context.BestRetreatCover.Position;
			}
			if (context.BestFlankCover != null && context.BestFlankCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Flank);
				context.ReserveCoverPoint(context.BestFlankCover);
				return context.BestFlankCover.Position;
			}
			if (context.BestAdvanceCover != null && context.BestAdvanceCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Advance);
				context.ReserveCoverPoint(context.BestAdvanceCover);
				return context.BestAdvanceCover.Position;
			}
			break;
		case CoverTactic.Flank:
			if (context.BestFlankCover != null && context.BestFlankCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Flank);
				context.ReserveCoverPoint(context.BestFlankCover);
				return context.BestFlankCover.Position;
			}
			if (context.BestRetreatCover != null && context.BestRetreatCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Retreat);
				context.ReserveCoverPoint(context.BestRetreatCover);
				return context.BestRetreatCover.Position;
			}
			if (context.BestAdvanceCover != null && context.BestAdvanceCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Advance);
				context.ReserveCoverPoint(context.BestAdvanceCover);
				return context.BestAdvanceCover.Position;
			}
			break;
		case CoverTactic.Advance:
			if (context.BestAdvanceCover != null && context.BestAdvanceCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Advance);
				context.ReserveCoverPoint(context.BestAdvanceCover);
				return context.BestAdvanceCover.Position;
			}
			if (context.BestFlankCover != null && context.BestFlankCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Flank);
				context.ReserveCoverPoint(context.BestFlankCover);
				return context.BestFlankCover.Position;
			}
			if (context.BestRetreatCover != null && context.BestRetreatCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Retreat);
				context.ReserveCoverPoint(context.BestRetreatCover);
				return context.BestRetreatCover.Position;
			}
			break;
		case CoverTactic.Closest:
			if (context.ClosestCover != null && context.ClosestCover.IsValidFor(context.Body))
			{
				context.SetFact(Facts.CoverTactic, CoverTactic.Closest);
				context.ReserveCoverPoint(context.ClosestCover);
				return context.ClosestCover.Position;
			}
			break;
		}
		return context.Body.transform.position;
	}

	public static Vector3 GetCoverPosition(CoverTactic tactic, ScientistJunkpileContext context)
	{
		if (Time.time - context.Memory.CachedCoverDestinationTime < 0.01f)
		{
			return context.Memory.CachedCoverDestination;
		}
		Vector3 vector = _GetCoverPosition(tactic, context);
		Vector3 vector2 = vector;
		if ((vector2 - context.Memory.CachedCoverDestination).sqrMagnitude < 2f)
		{
			return context.Memory.CachedCoverDestination;
		}
		for (int i = 0; i < 10; i++)
		{
			bool flag = false;
			if (NavMesh.FindClosestEdge(vector2, out var hit, context.Domain.NavAgent.areaMask))
			{
				Vector3 position = hit.position;
				if (context.Memory.IsValid(position))
				{
					context.Memory.CachedCoverDestination = position;
					context.Memory.CachedCoverDestinationTime = Time.time;
					return position;
				}
				flag = true;
			}
			if (NavMesh.SamplePosition(vector2, out hit, 2f * context.Domain.NavAgent.height, context.Domain.NavAgent.areaMask))
			{
				Vector3 vector3 = context.Domain.ToAllowedMovementDestination(hit.position);
				if (context.Memory.IsValid(vector3))
				{
					context.Memory.CachedCoverDestination = vector3;
					context.Memory.CachedCoverDestinationTime = Time.time;
					return vector3;
				}
				flag = true;
			}
			if (!flag)
			{
				context.Memory.AddFailedDestination(vector2);
			}
			Vector2 vector4 = Random.insideUnitCircle * 5f;
			vector2 = vector + new Vector3(vector4.x, 0f, vector4.y);
		}
		return context.BodyPosition;
	}

	protected override Vector3 _GetDestination(ScientistJunkpileContext context)
	{
		return GetCoverPosition(_preferredTactic, context);
	}

	protected override void OnPathFailed(ScientistJunkpileContext context)
	{
		context.SetFact(Facts.CoverTactic, CoverTactic.None);
		context.Domain.NavAgent.stoppingDistance = 1f;
	}

	protected override void OnPathComplete(ScientistJunkpileContext context)
	{
		context.SetFact(Facts.CoverTactic, CoverTactic.None);
		context.Domain.NavAgent.stoppingDistance = 1f;
	}

	protected override void OnPreStart(ScientistJunkpileContext context)
	{
		context.Domain.NavAgent.stoppingDistance = 1f;
	}
}
