#define UNITY_ASSERTIONS
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Ionic.Crc;
using UnityEngine.Assertions;

public abstract class FileStorage : IDisposable
{
	private class CacheData
	{
		public byte[] data;

		public uint entityID;

		public uint numID;
	}

	public enum Type
	{
		png,
		jpg
	}

	private CRC32 crc = new CRC32();

	private Dictionary<uint, CacheData> _cache = new Dictionary<uint, CacheData>();

	public static FileStorage server = new ServerStorage();

	~FileStorage()
	{
		Dispose();
	}

	public void Dispose()
	{
	}

	private uint GetCRC(byte[] data, Type type)
	{
		crc.Reset();
		crc.SlurpBlock(data, 0, data.Length);
		crc.UpdateCRC((byte)type);
		return (uint)crc.Crc32Result;
	}

	public uint Store(byte[] data, Type type, uint entityID, uint numID = 0u)
	{
		using (TimeWarning.New("FileStorage.Store"))
		{
			string folder = GetFolder(entityID, numID, create: true);
			uint cRC = GetCRC(data, type);
			File.WriteAllBytes(folder + cRC, data);
			_cache.Remove(cRC);
			_cache.Add(cRC, new CacheData
			{
				data = data,
				entityID = entityID,
				numID = numID
			});
			return cRC;
		}
	}

	public byte[] Get(uint crcId, Type type, uint entityID)
	{
		using (TimeWarning.New("FileStorage.Get"))
		{
			if (_cache.TryGetValue(crcId, out var value))
			{
				Assert.IsTrue(value.data != null, "FileStorage cache contains a null texture");
				return value.data;
			}
			DirectoryInfo directoryInfo = new DirectoryInfo(GetFolder(entityID, 0u, create: false));
			if (!directoryInfo.Exists)
			{
				return null;
			}
			string path = directoryInfo.FullName + crcId;
			if (!File.Exists(path))
			{
				return null;
			}
			byte[] array = File.ReadAllBytes(path);
			if (array == null)
			{
				return null;
			}
			if (GetCRC(array, type) != crcId)
			{
				return null;
			}
			_cache.Remove(crcId);
			_cache.Add(crcId, new CacheData
			{
				data = array,
				entityID = entityID,
				numID = 0u
			});
			return array;
		}
	}

	public abstract string GetFolder(uint entityid, uint numid, bool create);

	public abstract void Cleanup();

	public void Remove(uint crc, Type type, uint entityID)
	{
		DirectoryInfo parent = new DirectoryInfo(GetFolder(entityID, 0u, create: false)).Parent;
		if (parent.Exists)
		{
			if (_cache.ContainsKey(crc))
			{
				_cache.Remove(crc);
			}
			parent.Delete(recursive: true);
		}
	}

	public void RemoveEntityNum(uint entityid, uint numid)
	{
		DirectoryInfo directoryInfo = new DirectoryInfo(GetFolder(entityid, numid, create: false));
		if (directoryInfo.Exists)
		{
			directoryInfo.Delete(recursive: true);
		}
		uint[] array = (from x in _cache
			where x.Value.entityID == entityid && x.Value.numID == numid
			select x.Key).ToArray();
		foreach (uint key in array)
		{
			_cache.Remove(key);
		}
	}

	internal void RemoveAllByEntity(uint entityid)
	{
	}
}
