using System;
using System.Collections.Generic;
using System.IO;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class BallistaGun : BaseVehicleSeat
{
	[Serializable]
	private struct Ammo
	{
		public ItemDefinition item;

		public GameObject go;
	}

	[Serializable]
	private struct FiringEffect
	{
		public ItemDefinition item;

		public GameObjectRef effectPrefab;
	}

	private enum AimDirection
	{
		Left,
		Right,
		Up,
		Down
	}

	[Header("Ballista")]
	[SerializeField]
	private bool isMountedOnVehicle = true;

	[SerializeField]
	private float turnSensivity = 2f;

	[SerializeField]
	private float reloadTime = 3f;

	[SerializeField]
	private float fovMultiplier = 1f;

	[SerializeField]
	private bool noHeadshots = true;

	[SerializeField]
	private CapsuleCollider playerServerCollider;

	[SerializeField]
	private BaseProjectile.Magazine magazine;

	[Space]
	[SerializeField]
	private Transform muzzle;

	[SerializeField]
	private Transform pitchTransform;

	[SerializeField]
	public Transform yawTransform;

	[SerializeField]
	public Transform mountTransform;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private GameObject ammoParent;

	public DamageRenderer damageRenderer;

	private Vector3 aimDir;

	[SerializeField]
	private Ammo[] ammoPrefabs;

	[SerializeField]
	[Header("IK")]
	public Transform leftHandTarget;

	[SerializeField]
	public Transform rightHandTarget;

	[SerializeField]
	[Header("Effects")]
	private FiringEffect[] muzzleFireEffects;

	[SerializeField]
	private SoundDefinition reloadedSound;

	[SerializeField]
	private SoundDefinition aimMovementSoundDef;

	[SerializeField]
	private AnimationCurve aimMovementGainCurve;

	private Sound aimMovementSound;

	private SoundModulation.Modulator aimMovementGainMod;

	[Space]
	[SerializeField]
	private bool runSideChecks;

	[SerializeField]
	private Transform leftGroundCheckTransform;

	[SerializeField]
	private Transform rightGroundCheckTransform;

	[SerializeField]
	private Transform[] leftSideCheckPositions;

	[SerializeField]
	private Transform[] rightSideCheckPositions;

	[SerializeField]
	private Vector3 originalLocalMountPos;

	[SerializeField]
	private bool runBoundsChecks;

	[SerializeField]
	private Bounds[] areaChecks;

	[NonSerialized]
	public Ballista ballistaOwner;

	[HideInInspector]
	public float reloadProgress;

	private bool justReloaded;

	private BasePlayer reloadingPlayer;

	private float steerInput;

	private float verticalRatio;

	private bool wasShowingLegs;

	private TimeSince lastReloadStartTime;

	private float fixedMountYRotation;

	[ClientVar(ClientAdmin = true)]
	public static bool debug;

	public const Flags Flag_Reloading = Flags.Reserved4;

	public const Flags Flag_Loaded = Flags.Reserved5;

	private readonly float progressTickRate = 0.1f;

	private RealTimeSinceEx timeSinceLastServerTick;

	private Vector3 lastSentAimDir = Vector3.zero;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BallistaGun.OnRpcMessage", 0);
		try
		{
			if (rpc == 1188838966 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_CancelReload "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_CancelReload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1188838966u, "SERVER_CancelReload", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1188838966u, "SERVER_CancelReload", this, player, includeMounted: true))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1188838966u, "SERVER_CancelReload", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1188838966u, "SERVER_CancelReload", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_CancelReload(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_CancelReload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 296086248 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_FireClientProjectile "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_FireClientProjectile", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(296086248u, "SERVER_FireClientProjectile", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(296086248u, "SERVER_FireClientProjectile", this, player, includeMounted: true))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(296086248u, "SERVER_FireClientProjectile", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(296086248u, "SERVER_FireClientProjectile", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_FireClientProjectile(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_FireClientProjectile");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2817383917u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ReloadStart "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ReloadStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2817383917u, "SERVER_ReloadStart", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2817383917u, "SERVER_ReloadStart", this, player, includeMounted: true))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2817383917u, "SERVER_ReloadStart", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2817383917u, "SERVER_ReloadStart", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_ReloadStart(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_ReloadStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4118009042u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SwitchAmmoTo "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SwitchAmmoTo", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg5 = rPCMessage;
						SERVER_SwitchAmmoTo(msg5);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex4)
				{
					Debug.LogException(ex4);
					player.Kick("RPC Error in SERVER_SwitchAmmoTo");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool HasOwner()
	{
		return (Object)(object)ballistaOwner != (Object)null;
	}

	private bool IsLoaded()
	{
		if (HasFlag(Flags.Reserved5) && magazine.contents == magazine.capacity)
		{
			return reloadProgress >= 0.94f;
		}
		return false;
	}

	private bool CanFire()
	{
		if (IsLoaded() && !HasFlag(Flags.Reserved4))
		{
			return !OwnerIsWaterlogged();
		}
		return false;
	}

	private bool CanReload()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (!IsLoaded() && TimeSince.op_Implicit(lastReloadStartTime) > 1f)
		{
			return !OwnerIsWaterlogged();
		}
		return false;
	}

	public bool OwnerIsWaterlogged()
	{
		if (HasOwner())
		{
			return ballistaOwner.IsWaterlogged();
		}
		return false;
	}

	public override void InitShared()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		originalLocalMountPos = mountAnchor.localPosition;
	}

	private bool UpdateManualAim(InputState inputState)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		float y = mountAnchor.position.y;
		MoveMountAnchor();
		float num = y - mountAnchor.position.y;
		float num2 = 0f;
		if (Mathf.Abs(num) > 0.0001f)
		{
			num2 = (0f - num) * 50f;
		}
		float num3 = (0f - inputState.current.mouseDelta.y) * turnSensivity;
		float num4 = inputState.current.mouseDelta.x * turnSensivity;
		float num5 = turnSensivity * 2.5f;
		if (inputState.IsDown(BUTTON.LEFT))
		{
			num4 -= num5;
		}
		if (inputState.IsDown(BUTTON.RIGHT))
		{
			num4 += num5;
		}
		if (inputState.IsDown(BUTTON.BACKWARD))
		{
			num3 += num5;
		}
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			num3 += 0f - num5;
		}
		num3 += num2;
		if (!CanRotateInDirection(num4 > 0f))
		{
			num4 = 0f;
		}
		if (runBoundsChecks)
		{
			if (num4 != 0f && !CheckBallistaBounds((!(num4 < 0f)) ? AimDirection.Right : AimDirection.Left))
			{
				num4 = 0f;
			}
			if (num3 != 0f && !CheckBallistaBounds((num3 < 0f) ? AimDirection.Up : AimDirection.Down))
			{
				num3 = 0f;
			}
		}
		Quaternion val = Quaternion.LookRotation(aimDir, ((Component)this).transform.up);
		Vector3 val2 = ((Quaternion)(ref val)).eulerAngles + new Vector3(num3, num4, 0f);
		val2.x = ClampPitch(val2.x);
		Transform val3 = (HasOwner() ? ((Component)this).transform.parent : yawTransform);
		float y2 = val2.y;
		val = Quaternion.LookRotation(val3.forward, ((Component)this).transform.up);
		val2.y = ClampYaw(y2, ((Quaternion)(ref val)).eulerAngles.y);
		Vector3 val4 = Quaternion.Euler(val2) * Vector3.forward;
		bool result = !Mathf.Approximately(aimDir.x, val4.x) || !Mathf.Approximately(aimDir.y, val4.y) || !Mathf.Approximately(aimDir.z, val4.z);
		aimDir = val4;
		return result;
	}

	private bool CanRotateInDirection(bool rotatingLeft)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Transform checkTransform = (rotatingLeft ? leftGroundCheckTransform : rightGroundCheckTransform);
		Transform[] array = (rotatingLeft ? leftSideCheckPositions : rightSideCheckPositions);
		if (!HasGround(checkTransform))
		{
			return false;
		}
		if (runSideChecks)
		{
			Transform[] array2 = array;
			foreach (Transform val in array2)
			{
				if (HasColliderBlockingRotation(val.position, val.forward))
				{
					return false;
				}
			}
		}
		return true;
	}

	public void RotateBallista(float dt)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		if ((isMountedOnVehicle && (Object)(object)((Component)this).transform.parent == (Object)null) || aimDir == Vector3.zero)
		{
			return;
		}
		float num = 50f;
		Transform val = (isMountedOnVehicle ? ((Component)this).transform.parent : ((Component)this).transform);
		Vector3 val2 = val.InverseTransformDirection(aimDir);
		if (!(val2 == Vector3.zero))
		{
			Quaternion val3 = Quaternion.LookRotation(val2, Vector3.up);
			float num2 = ClampYaw(((Quaternion)(ref val3)).eulerAngles.y, 0f);
			float num3 = ClampPitch(((Quaternion)(ref val3)).eulerAngles.x);
			Quaternion val4 = Quaternion.Euler(0f, num2, 0f);
			Quaternion val5 = Quaternion.Euler(num3, 0f, 0f);
			Quaternion val6 = val.rotation * val4;
			if (yawTransform.rotation != val6)
			{
				yawTransform.rotation = Mathx.Lerp(yawTransform.rotation, val6, num, dt);
			}
			if (pitchTransform.localRotation != val5)
			{
				pitchTransform.localRotation = Mathx.Lerp(pitchTransform.localRotation, val5, num, dt);
			}
		}
	}

	private void UpdatePlayerModelPose()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(muzzle.forward, Vector3.up);
		float num = Mathf.InverseLerp(pitchClamp.y, pitchClamp.x, Mathf.DeltaAngle(0f, ((Quaternion)(ref val)).eulerAngles.x));
		verticalRatio = Mathf.Lerp(-1f, 1f, num);
	}

	private float ClampPitch(float pitch)
	{
		float num = Mathf.Clamp(Mathf.DeltaAngle(0f, pitch), pitchClamp.x, pitchClamp.y);
		if (num < 0f)
		{
			num += 360f;
		}
		return num;
	}

	private float ClampYaw(float targetYaw, float parentYaw)
	{
		float num = Mathf.DeltaAngle(parentYaw, targetYaw);
		num = Mathf.Clamp(num, yawClamp.x, yawClamp.y);
		return parentYaw + num;
	}

	private Item GetAmmoFromPlayerInventory(BasePlayer player)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Item item = player.inventory.FindItemByItemID(magazine.ammoType.itemid);
		if (item == null && !magazine.allowAmmoSwitching)
		{
			return null;
		}
		if (item == null)
		{
			Item item2 = player.inventory.FindAmmo(magazine.definition.ammoTypes);
			if (item2 == null)
			{
				return null;
			}
			item = player.inventory.FindItemByItemID(item2.info.itemid);
			if (item == null)
			{
				return null;
			}
		}
		return item;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	private bool HasGround(Transform checkTransform)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f;
		RaycastHit val = default(RaycastHit);
		return Physics.SphereCast(checkTransform.position + Vector3.up * 0.6f, 0.1f, Vector3.down, ref val, num, 1503731969);
	}

	private bool HasColliderBlockingRotation(Vector3 origin, Vector3 direction)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.2f;
		RaycastHit val = default(RaycastHit);
		return Physics.SphereCast(origin, 0.05f, direction, ref val, num, 1503731969);
	}

	private void MoveMountAnchor()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		float num = 2f;
		Vector3 val = mountAnchor.parent.TransformPoint(originalLocalMountPos) + Vector3.up * 0.8f;
		Vector3 down = Vector3.down;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.SphereCast(val, 0.05f, down, ref val2, num, 1503731969))
		{
			float y = ((RaycastHit)(ref val2)).point.y;
			float y2 = mountAnchor.parent.TransformPoint(originalLocalMountPos).y;
			if (Mathf.Abs(y - y2) < 0.5f)
			{
				mountAnchor.position = ((RaycastHit)(ref val2)).point;
			}
		}
	}

	private bool CanRotate()
	{
		if (HasOwner())
		{
			return !ballistaOwner.IsStationary();
		}
		return AnyMounted();
	}

	private bool CanSeeFirePoint(BasePlayer player, float radius)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = player.eyes.center;
		Vector3 position = player.eyes.position;
		Vector3 position2 = muzzle.position;
		int layerMask = 2162688;
		if (GamePhysics.LineOfSightRadius(center, position, layerMask, radius, this))
		{
			return GamePhysics.LineOfSightRadius(position, position2, layerMask, radius, this);
		}
		return false;
	}

	private bool CheckBallistaBounds(AimDirection direction)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		List<Bounds> list = Pool.Get<List<Bounds>>();
		bool num = direction == AimDirection.Up || direction == AimDirection.Down;
		Vector3 val = pitchTransform.position;
		if (num)
		{
			Vector3 val2 = ((direction == AimDirection.Up) ? pitchTransform.up : (-pitchTransform.up));
			val += ((Vector3)(ref val2)).normalized * 0.05f;
			list.Add(areaChecks[areaChecks.Length - 1]);
		}
		else
		{
			int num2 = ((direction != 0) ? 1 : 0);
			list.Add(areaChecks[num2]);
			list.Add(areaChecks[areaChecks.Length - 1]);
		}
		bool result = true;
		foreach (Bounds item in list)
		{
			if (SocketMod_AreaCheck.IsInArea(val, pitchTransform.rotation, item, LayerMask.op_Implicit(1503731969), this))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<Bounds>(ref list);
		return result;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)ServerTick, Random.Range(0f, 1f), 0.015f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)SendAimDir, Random.Range(0f, 1f), 0.2f, 0.05f);
	}

	private void ServerTick()
	{
		if (base.isServer)
		{
			float dt = (float)(double)timeSinceLastServerTick;
			timeSinceLastServerTick = 0.0;
			if (CanRotate())
			{
				RotateBallista(dt);
			}
			if (!HasOwner() && AnyMounted() && IsSeatClipping(this))
			{
				DismountAllPlayers();
			}
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		UpdateManualAim(inputState);
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		base.OnParentChanging(oldParent, newParent);
		if ((Object)(object)newParent != (Object)null && aimDir == Vector3.zero)
		{
			aimDir = ((Component)newParent).transform.forward;
		}
	}

	public override void OnPlayerMounted()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerMounted();
		TogglePlayerServerCollider(active: true);
		aimDir = pitchTransform.forward;
		SendAimDirImmediate();
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		TogglePlayerServerCollider(active: false);
		if (HasFlag(Flags.Reserved4))
		{
			StopReload();
		}
	}

	private void LoadAmmo(BasePlayer player)
	{
		if (!((Object)(object)player != (Object)(object)GetMounted()) && !IsLoaded())
		{
			Item ammoFromPlayerInventory = GetAmmoFromPlayerInventory(player);
			if (ammoFromPlayerInventory != null)
			{
				SetFlag(Flags.Reserved5, b: true);
				magazine.ammoType = ammoFromPlayerInventory.info;
				magazine.contents = 1;
				ammoFromPlayerInventory.UseItem();
			}
		}
	}

	public void SendAimDir()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (lastSentAimDir == Vector3.zero || Vector3.Angle(lastSentAimDir, aimDir) > 0.03f)
		{
			SendAimDirImmediate();
		}
	}

	public void SendAimDirImmediate(bool force = false)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		lastSentAimDir = aimDir;
		ClientRPC<Vector3, bool>(RpcTarget.NetworkGroup("CLIENT_ReceiveAimDir"), aimDir, force);
	}

	private void ReloadProgress()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)reloadingPlayer == (Object)null || (Object)(object)reloadingPlayer != (Object)(object)GetMounted() || reloadingPlayer.IsDead() || reloadingPlayer.IsSleeping() || Vector3Ex.Distance2D(((Component)reloadingPlayer).transform.position, ((Component)this).transform.position) > 3f)
		{
			StopReload();
			return;
		}
		reloadProgress += progressTickRate / reloadTime;
		if (reloadProgress >= 1f)
		{
			reloadProgress = 1f;
			LoadAmmo(reloadingPlayer);
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				SendAimDirImmediate(force: true);
			}, 0.5f);
			StopReload();
		}
		else
		{
			SendNetworkUpdateImmediate();
		}
	}

	public void StopReload()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)ReloadProgress);
		reloadingPlayer = null;
		SetFlag(Flags.Reserved4, b: false);
	}

	public void TogglePlayerServerCollider(bool active)
	{
		((Collider)playerServerCollider).enabled = active;
	}

	[RPC_Server]
	private void SERVER_SwitchAmmoTo(RPCMessage msg)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted == (Object)null || (Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)mounted)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == magazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return;
		}
		ItemModProjectile component = ((Component)itemDefinition).GetComponent<ItemModProjectile>();
		if (Object.op_Implicit((Object)(object)component) && component.IsAmmo(magazine.definition.ammoTypes))
		{
			if (magazine.contents > 0)
			{
				mounted.GiveItem(ItemManager.CreateByItemID(magazine.ammoType.itemid, magazine.contents, 0uL));
				magazine.contents = 0;
				SetFlag(Flags.Reserved5, b: false);
			}
			magazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			mounted.inventory.ServerUpdate(0f);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	[RPC_Server.FromOwner(true)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.IsVisible(3f)]
	private void SERVER_FireClientProjectile(RPCMessage msg)
	{
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (!IsLoaded() || magazine.contents != 1 || (Object)(object)player != (Object)(object)GetMounted() || !CanFire() || player.InSafeZone() || Interface.CallHook("OnSiegeWeaponFire", (object)ballistaOwner, (object)player) != null)
			{
				return;
			}
			ItemDefinition ammoType = magazine.ammoType;
			if ((Object)(object)ammoType == (Object)null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, null, "item_missing");
				return;
			}
			ItemModProjectile component = ((Component)ammoType).GetComponent<ItemModProjectile>();
			if ((Object)(object)component == (Object)null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, null, "mod_missing");
				return;
			}
			ProjectileShoot val = ProjectileShoot.Deserialize((Stream)(object)msg.read);
			if (val.projectiles.Count != 1)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, null, "count_mismatch");
				return;
			}
			player.CleanupExpiredProjectiles();
			Guid projectileGroupId = Guid.NewGuid();
			foreach (Projectile projectile in val.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.LogInvalid(player, null, "duplicate_id");
				}
				else if (ValidateFirePos(player, projectile.startPos))
				{
					player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, null, ammoType, projectileGroupId, Vector3.zero);
					Effect effect = new Effect();
					effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
					((EffectData)effect).scale = 1f;
					effect.pooledString = component.projectileObject.resourcePath;
					((EffectData)effect).number = projectile.seed;
					EffectNetwork.Send(effect);
				}
			}
			if (val != null)
			{
				val.Dispose();
			}
			SendAimDirImmediate(force: true);
			player.MarkHostileFor();
			SignalBroadcast(Signal.Attack, string.Empty, msg.connection);
			magazine.contents = 0;
			reloadProgress = 0f;
			SetFlag(Flags.Reserved5, b: false);
			if (HasOwner())
			{
				ballistaOwner.RefreshLastUseTime();
				ballistaOwner.OnFired();
			}
			SingletonComponent<NpcNoiseManager>.Instance.OnWeaponShot(player, null);
		}
	}

	protected bool VerifyClientRPC(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			Debug.LogWarning((object)"Received RPC from null player");
			return false;
		}
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted == (Object)null)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Owner not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "owner_missing");
			return false;
		}
		if ((Object)(object)mounted != (Object)(object)player)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "player_mismatch");
			return false;
		}
		if (player.IsDead())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player dead (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "player_dead");
			return false;
		}
		if (player.IsWounded())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player down (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "player_down");
			return false;
		}
		if (player.IsSleeping())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player sleeping (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "player_sleeping");
			return false;
		}
		if (player.desyncTimeRaw > ConVar.AntiHack.maxdesync)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player stalled (" + base.ShortPrefabName + " with " + player.desyncTimeRaw + "s)");
			player.stats.combat.LogInvalid(player, null, "player_stalled");
			return false;
		}
		if ((Object)(object)magazine.ammoType == (Object)null)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Item not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "item_missing");
			return false;
		}
		return true;
	}

	protected bool ValidateFirePos(BasePlayer player, Vector3 firePos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		if (Vector3Ex.IsNaNOrInfinity(firePos))
		{
			string shortPrefabName = base.ShortPrefabName;
			AntiHack.Log(player, AntiHackType.EyeHack, "Contains NaN (" + shortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "eye_nan");
			flag = false;
		}
		if (ConVar.AntiHack.eye_protection > 0)
		{
			Vector3 val;
			if (ConVar.AntiHack.eye_protection >= 1)
			{
				val = player.GetParentVelocity();
				float magnitude = ((Vector3)(ref val)).magnitude;
				val = player.GetMountVelocity();
				float num = magnitude + ((Vector3)(ref val)).magnitude + ConVar.AntiHack.eye_forgiveness;
				float num2 = Vector3.Distance(((Component)muzzle).transform.position, firePos);
				if (num2 > num)
				{
					string shortPrefabName2 = base.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.EyeHack, "Distance (" + shortPrefabName2 + " on attack with " + num2 + "m > " + num + "m)");
					player.stats.combat.LogInvalid(player, null, "eye_distance");
					flag = false;
				}
			}
			int num3 = 2162688;
			if (ConVar.AntiHack.eye_terraincheck)
			{
				num3 |= 0x800000;
			}
			if (ConVar.AntiHack.eye_vehiclecheck)
			{
				num3 |= 0x8000000;
			}
			if (ConVar.AntiHack.eye_protection >= 2 && !CanSeeFirePoint(player, 0.05f))
			{
				string shortPrefabName3 = base.ShortPrefabName;
				string[] obj = new string[8] { "Line of sight (", shortPrefabName3, " on attack) ", null, null, null, null, null };
				val = player.eyes.center;
				obj[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
				obj[4] = " ";
				val = player.eyes.position;
				obj[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
				obj[6] = " ";
				val = firePos;
				obj[7] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
				AntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj));
				player.stats.combat.LogInvalid(player, null, "eye_los");
				flag = false;
			}
		}
		if (!flag)
		{
			AntiHack.AddViolation(player, AntiHackType.EyeHack, ConVar.AntiHack.eye_penalty);
		}
		return flag;
	}

	protected override bool BroadcastSignalFromClientFilter(Signal signal)
	{
		return signal == Signal.Attack;
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.FromOwner(true)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SERVER_ReloadStart(RPCMessage msg)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		BasePlayer mounted = GetMounted();
		if (!((Object)(object)mounted == (Object)null) && !((Object)(object)player == (Object)null) && !((Object)(object)player != (Object)(object)mounted))
		{
			reloadingPlayer = player;
			SetFlag(Flags.Reserved4, b: true);
			ClientRPC<NetworkableId>(RpcTarget.NetworkGroup("CLIENT_StartReloading"), reloadingPlayer.net.ID);
			((FacepunchBehaviour)this).InvokeRepeating((Action)ReloadProgress, 0f, progressTickRate);
			if (HasOwner())
			{
				ballistaOwner.RefreshLastUseTime();
			}
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.FromOwner(true)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.IsVisible(3f)]
	public void SERVER_CancelReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player != (Object)(object)reloadingPlayer))
		{
			StopReload();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (CanRotate())
		{
			RotateBallista(1000f);
		}
	}

	public override void DoRepair(BasePlayer player)
	{
		if (HasParent() && HasOwner())
		{
			ballistaOwner.DoRepair(player);
		}
		else
		{
			base.DoRepair(player);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && HasOwner())
		{
			ballistaOwner.Hurt(info);
		}
		else
		{
			base.Hurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if (HasParent() && HasOwner() && !ballistaOwner.IsDead())
		{
			ballistaOwner.Die();
		}
	}

	public void AdminReload(int ammo)
	{
		reloadProgress = 1f;
		StopReload();
		ItemDefinition ammoType = null;
		switch (ammo)
		{
		case 1:
			ammoType = ItemManager.FindItemDefinition("ballista.bolt.hammerhead");
			break;
		case 2:
			ammoType = ItemManager.FindItemDefinition("ballista.bolt.incendiary");
			break;
		case 3:
			ammoType = ItemManager.FindItemDefinition("ballista.bolt.piercer");
			break;
		case 4:
			ammoType = ItemManager.FindItemDefinition("ballista.bolt.pitchfork");
			break;
		}
		SetFlag(Flags.Reserved5, b: true);
		magazine.ammoType = ammoType;
		magazine.contents = 1;
		SendNetworkUpdateImmediate();
	}

	[ServerVar]
	public static void reload(Arg arg)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
		}
		else
		{
			if (!basePlayer.IsAdmin)
			{
				return;
			}
			int @int = arg.GetInt(0, 1);
			@int = Mathf.Clamp(@int, 1, 4);
			BallistaGun[] array = Util.FindAll<BallistaGun>();
			int num = 0;
			BallistaGun[] array2 = array;
			foreach (BallistaGun ballistaGun in array2)
			{
				if (ballistaGun.isServer && Vector3.Distance(((Component)ballistaGun).transform.position, ((Component)basePlayer).transform.position) <= 10f)
				{
					ballistaGun.AdminReload(@int);
					num++;
				}
			}
			arg.ReplyWith($"Reloaded {num} ballistas.");
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!isMountedOnVehicle || HasOwner())
		{
			info.msg.ballistaGun = Pool.Get<BallistaGun>();
			info.msg.ballistaGun.magazine = magazine.Save();
			info.msg.ballistaGun.reloadProgress = reloadProgress;
			info.msg.ballistaGun.aimDir = aimDir;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (info.msg.ballistaGun != null)
		{
			if (info.msg.ballistaGun.magazine != null)
			{
				magazine.Load(info.msg.ballistaGun.magazine);
			}
			if (base.isServer)
			{
				reloadProgress = info.msg.ballistaGun.reloadProgress;
				aimDir = info.msg.ballistaGun.aimDir;
			}
		}
		base.Load(info);
	}
}
