using System.Collections.Generic;
using Facepunch;
using Rust;
using UnityEngine;

public static class DamageUtil
{
	public static void RadiusDamage(BaseEntity attackingPlayer, BaseEntity weaponPrefab, Vector3 pos, float minradius, float radius, List<DamageTypeEntry> damage, int layers, bool useLineOfSight)
	{
		using (TimeWarning.New("DamageUtil.RadiusDamage"))
		{
			List<HitInfo> list = Pool.GetList<HitInfo>();
			List<BaseCombatEntity> obj = Pool.GetList<BaseCombatEntity>();
			List<BaseCombatEntity> obj2 = Pool.GetList<BaseCombatEntity>();
			Vis.Entities(pos, radius, obj2, layers);
			for (int i = 0; i < obj2.Count; i++)
			{
				BaseCombatEntity baseCombatEntity = obj2[i];
				if (!baseCombatEntity.isServer || obj.Contains(baseCombatEntity))
				{
					continue;
				}
				Vector3 vector = baseCombatEntity.ClosestPoint(pos);
				float num = Vector3.Distance(vector, pos);
				float num2 = Mathf.Clamp01((num - minradius) / (radius - minradius));
				if (!(num2 > 1f))
				{
					float amount = 1f - num2;
					if (!useLineOfSight || baseCombatEntity.IsVisible(pos))
					{
						HitInfo hitInfo = new HitInfo();
						hitInfo.Initiator = attackingPlayer;
						hitInfo.WeaponPrefab = weaponPrefab;
						hitInfo.damageTypes.Add(damage);
						hitInfo.damageTypes.ScaleAll(amount);
						hitInfo.HitPositionWorld = vector;
						hitInfo.HitNormalWorld = (pos - vector).normalized;
						hitInfo.PointStart = pos;
						hitInfo.PointEnd = hitInfo.HitPositionWorld;
						list.Add(hitInfo);
						obj.Add(baseCombatEntity);
					}
				}
			}
			for (int j = 0; j < obj.Count; j++)
			{
				BaseCombatEntity baseCombatEntity2 = obj[j];
				HitInfo info = list[j];
				baseCombatEntity2.Hurt(info);
				baseCombatEntity2.DoHitNotify(info);
			}
			Pool.FreeList(ref obj);
			Pool.FreeList(ref obj2);
		}
	}
}
