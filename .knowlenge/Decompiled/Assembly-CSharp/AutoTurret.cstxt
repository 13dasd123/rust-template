#define UNITY_ASSERTIONS
using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class AutoTurret : StorageContainer
{
	public static class TurretFlags
	{
		public const Flags Peacekeeper = Flags.Reserved1;
	}

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public float bulletSpeed = 200f;

	public BaseCombatEntity target;

	public Transform eyePos;

	public Transform muzzlePos;

	public Vector3 aimDir;

	public Transform gun_yaw;

	public Transform gun_pitch;

	public float sightRange = 30f;

	public SoundDefinition turnLoopDef;

	public SoundDefinition movementChangeDef;

	public SoundDefinition ambientLoopDef;

	public SoundDefinition focusCameraDef;

	public float focusSoundFreqMin = 2.5f;

	public float focusSoundFreqMax = 7f;

	public GameObjectRef peacekeeperToggleSound;

	public GameObjectRef onlineSound;

	public GameObjectRef offlineSound;

	public GameObjectRef targetAcquiredEffect;

	public GameObjectRef targetLostEffect;

	public float aimCone;

	public List<PlayerNameID> authorizedPlayers = new List<PlayerNameID>();

	public ItemDefinition ammoType;

	private float nextShotTime;

	private float nextVisCheck;

	private float lastTargetSeenTime;

	private bool targetVisible = true;

	private bool booting;

	private float nextIdleAimTime;

	private Vector3 targetAimDir = Vector3.forward;

	private float nextTargetScanTime;

	private Item ammoItem;

	private const float bulletDamage = 15f;

	private float nextForcedAimTime;

	private Vector3 lastSentAimDir = Vector3.zero;

	private static float[] visibilityOffsets = new float[3] { 0f, 0.2f, -0.2f };

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("AutoTurret.OnRpcMessage"))
		{
			if (rpc == 2017592092 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - AddSelfAuthorize "));
				}
				using (TimeWarning.New("AddSelfAuthorize"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("AddSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							AddSelfAuthorize(rpc2);
						}
					}
					catch (Exception exception)
					{
						player.Kick("RPC Error in AddSelfAuthorize");
						Debug.LogException(exception);
					}
				}
				return true;
			}
			if (rpc == 3024779371u && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - ClearList "));
				}
				using (TimeWarning.New("ClearList"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("ClearList", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							ClearList(rpc3);
						}
					}
					catch (Exception exception2)
					{
						player.Kick("RPC Error in ClearList");
						Debug.LogException(exception2);
					}
				}
				return true;
			}
			if (rpc == 3523413432u && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - FlipAim "));
				}
				using (TimeWarning.New("FlipAim"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("FlipAim", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							FlipAim(rpc4);
						}
					}
					catch (Exception exception3)
					{
						player.Kick("RPC Error in FlipAim");
						Debug.LogException(exception3);
					}
				}
				return true;
			}
			if (rpc == 2101914649 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - RemoveSelfAuthorize "));
				}
				using (TimeWarning.New("RemoveSelfAuthorize"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("RemoveSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RemoveSelfAuthorize(rpc5);
						}
					}
					catch (Exception exception4)
					{
						player.Kick("RPC Error in RemoveSelfAuthorize");
						Debug.LogException(exception4);
					}
				}
				return true;
			}
			if (rpc == 786675805 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - SERVER_AttackAll "));
				}
				using (TimeWarning.New("SERVER_AttackAll"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("SERVER_AttackAll", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc6 = rPCMessage;
							SERVER_AttackAll(rpc6);
						}
					}
					catch (Exception exception5)
					{
						player.Kick("RPC Error in SERVER_AttackAll");
						Debug.LogException(exception5);
					}
				}
				return true;
			}
			if (rpc == 2795490276u && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - SERVER_Peacekeeper "));
				}
				using (TimeWarning.New("SERVER_Peacekeeper"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("SERVER_Peacekeeper", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc7 = rPCMessage;
							SERVER_Peacekeeper(rpc7);
						}
					}
					catch (Exception exception6)
					{
						player.Kick("RPC Error in SERVER_Peacekeeper");
						Debug.LogException(exception6);
					}
				}
				return true;
			}
			if (rpc == 1498407638 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - SERVER_TurnOff "));
				}
				using (TimeWarning.New("SERVER_TurnOff"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("SERVER_TurnOff", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc8 = rPCMessage;
							SERVER_TurnOff(rpc8);
						}
					}
					catch (Exception exception7)
					{
						player.Kick("RPC Error in SERVER_TurnOff");
						Debug.LogException(exception7);
					}
				}
				return true;
			}
			if (rpc == 1156714392 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - SERVER_TurnOn "));
				}
				using (TimeWarning.New("SERVER_TurnOn"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("SERVER_TurnOn", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc9 = rPCMessage;
							SERVER_TurnOn(rpc9);
						}
					}
					catch (Exception exception8)
					{
						player.Kick("RPC Error in SERVER_TurnOn");
						Debug.LogException(exception8);
					}
				}
				return true;
			}
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsOnline()
	{
		return IsOn();
	}

	public bool IsOffline()
	{
		return !IsOnline();
	}

	public float AngleToTarget(BaseCombatEntity potentialtarget)
	{
		Vector3 vector = AimOffset(potentialtarget);
		Vector3 position = muzzlePos.transform.position;
		Vector3 normalized = (vector - position).normalized;
		return Vector3.Angle(muzzlePos.forward, normalized);
	}

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		return AngleToTarget(potentialtarget) <= 90f;
	}

	public override bool CanPickup(BasePlayer player)
	{
		return base.CanPickup(player) && IsOffline() && IsAuthed(player);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.autoturret = Facepunch.Pool.Get<ProtoBuf.AutoTurret>();
		info.msg.autoturret.users = authorizedPlayers;
	}

	public override void PostSave(SaveInfo info)
	{
		base.PostSave(info);
		info.msg.autoturret.users = null;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.autoturret != null)
		{
			authorizedPlayers = info.msg.autoturret.users;
			info.msg.autoturret.users = null;
		}
	}

	public Vector3 AimOffset(BaseCombatEntity aimat)
	{
		BasePlayer basePlayer = aimat as BasePlayer;
		if (basePlayer != null)
		{
			return basePlayer.eyes.position;
		}
		return aimat.transform.position + new Vector3(0f, 0.3f, 0f);
	}

	public float GetAimSpeed()
	{
		if (HasTarget())
		{
			return 5f;
		}
		return 1f;
	}

	public void UpdateAiming()
	{
		if (!(aimDir == Vector3.zero))
		{
			float num = ((!base.isServer) ? 5f : 8f);
			Quaternion quaternion = Quaternion.LookRotation(aimDir);
			Quaternion quaternion2 = Quaternion.Euler(0f, quaternion.eulerAngles.y, 0f);
			Quaternion quaternion3 = Quaternion.Euler(quaternion.eulerAngles.x, 0f, 0f);
			if (gun_yaw.transform.rotation != quaternion2)
			{
				gun_yaw.transform.rotation = Quaternion.Lerp(gun_yaw.transform.rotation, quaternion2, UnityEngine.Time.deltaTime * num);
			}
			if (gun_pitch.transform.localRotation != quaternion3)
			{
				gun_pitch.transform.localRotation = Quaternion.Lerp(gun_pitch.transform.localRotation, quaternion3, UnityEngine.Time.deltaTime * num);
			}
		}
	}

	public bool IsAuthed(BasePlayer player)
	{
		return authorizedPlayers.Any((PlayerNameID x) => x.userid == player.userID);
	}

	public bool AnyAuthed()
	{
		return authorizedPlayers.Count > 0;
	}

	public bool CanChangeSettings(BasePlayer player)
	{
		return IsAuthed(player) && IsOffline();
	}

	public override bool SupportsPooling()
	{
		return true;
	}

	public bool PeacekeeperMode()
	{
		return HasFlag(Flags.Reserved1);
	}

	public void SetOnline()
	{
		SetIsOnline(online: true);
	}

	public void SetIsOnline(bool online)
	{
		if (online != HasFlag(Flags.On) && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			booting = false;
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
			}
		}
	}

	public void InitiateShutdown()
	{
		if (!IsOffline() && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

	public void SetPeacekeepermode(bool isOn)
	{
		bool flag = PeacekeeperMode();
		if (flag != isOn)
		{
			SetFlag(Flags.Reserved1, isOn);
			Effect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnTurretModeToggle", this);
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void FlipAim(RPCMessage rpc)
	{
		if (!IsOnline() && IsAuthed(rpc.player) && !booting)
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!IsOnline() && Interface.CallHook("OnTurretAuthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = rpc2.player.userID;
			playerNameID.username = rpc2.player.displayName;
			authorizedPlayers.Add(playerNameID);
			SendNetworkUpdate();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SERVER_TurnOn(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player))
		{
			InitiateStartup();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SERVER_TurnOff(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player))
		{
			InitiateShutdown();
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SERVER_Peacekeeper(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player))
		{
			SetPeacekeepermode(isOn: true);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SERVER_AttackAll(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player))
		{
			SetPeacekeepermode(isOn: false);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		InvokeRepeating(ServerTick, UnityEngine.Random.Range(0f, 1f), 0.015f);
		InvokeRandomized(SendAimDir, UnityEngine.Random.Range(0f, 1f), 0.2f, 0.05f);
		InvokeRandomized(TargetScan, UnityEngine.Random.Range(0f, 1f), 1f, 0.1f);
	}

	public void SendAimDir()
	{
		if (UnityEngine.Time.realtimeSinceStartup > nextForcedAimTime || HasTarget() || Vector3.Angle(lastSentAimDir, aimDir) > 0.03f)
		{
			lastSentAimDir = aimDir;
			ClientRPC(null, "CLIENT_ReceiveAimDir", aimDir);
			nextForcedAimTime = UnityEngine.Time.realtimeSinceStartup + 2f;
		}
	}

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((!(targ == null)) ? targetAcquiredEffect.resourcePath : targetLostEffect.resourcePath, base.transform.position, Vector3.up);
			}
			target = targ;
		}
	}

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.GetList<RaycastHit>();
		Vector3 position = eyePos.transform.position;
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 normalized = (vector - position).normalized;
		Vector3 vector2 = Vector3.Cross(normalized, Vector3.up);
		for (int i = 0; i < 3; i++)
		{
			Vector3 vector3 = vector + vector2 * visibilityOffsets[i];
			Vector3 normalized2 = (vector3 - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized2), 0f, obj3, num * 1.1f, 1084434689);
			for (int j = 0; j < obj3.Count; j++)
			{
				RaycastHit hit = obj3[j];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == obj || entity.EqualNetID(obj)))
				{
					Facepunch.Pool.FreeList(ref obj3);
					return true;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj3);
		return false;
	}

	public void FireGun(Vector3 targetPos, float aimCone)
	{
		if (IsOffline())
		{
			return;
		}
		Vector3 vector = muzzlePos.transform.position - muzzlePos.forward * 0.25f;
		Vector3 forward = muzzlePos.transform.forward;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, forward);
		targetPos = vector + modifiedAimConeDirection * 300f;
		List<RaycastHit> obj = Facepunch.Pool.GetList<RaycastHit>();
		GamePhysics.TraceAll(new Ray(vector, modifiedAimConeDirection), 0f, obj, 300f, 1084435201);
		for (int i = 0; i < obj.Count; i++)
		{
			RaycastHit hit = obj[i];
			BaseEntity entity = RaycastHitEx.GetEntity(hit);
			if (!(entity != null) || (!(entity == this) && !entity.EqualNetID(this)))
			{
				BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					ApplyDamage(baseCombatEntity, hit.point, modifiedAimConeDirection);
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					targetPos = hit.point;
					break;
				}
			}
		}
		ClientRPC(null, "CLIENT_FireGun", targetPos);
		Facepunch.Pool.FreeList(ref obj);
	}

	private void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
	{
		float num = 15f * UnityEngine.Random.Range(0.9f, 1.1f);
		if (entity is BasePlayer && entity != target)
		{
			num *= 0.5f;
		}
		if (PeacekeeperMode() && entity == target)
		{
			target.MarkHostileTime();
		}
		HitInfo info = new HitInfo(this, entity, DamageType.Bullet, num, point);
		entity.OnAttacked(info);
		if (entity is BasePlayer || entity is BaseNpc)
		{
			HitInfo hitInfo = new HitInfo();
			hitInfo.HitPositionWorld = point;
			hitInfo.HitNormalWorld = -normal;
			hitInfo.HitMaterial = StringPool.Get("Flesh");
			Effect.server.ImpactEffect(hitInfo);
		}
	}

	public void IdleTick()
	{
		if (UnityEngine.Time.realtimeSinceStartup > nextIdleAimTime)
		{
			nextIdleAimTime = UnityEngine.Time.realtimeSinceStartup + UnityEngine.Random.Range(4f, 5f);
			Quaternion quaternion = Quaternion.LookRotation(eyePos.forward, Vector3.up);
			quaternion *= Quaternion.AngleAxis(UnityEngine.Random.Range(-45f, 45f), Vector3.up);
			targetAimDir = quaternion * Vector3.forward;
		}
		if (!HasTarget())
		{
			aimDir = Vector3.Lerp(aimDir, targetAimDir, UnityEngine.Time.deltaTime * 2f);
		}
	}

	public bool HasAmmo()
	{
		return ammoItem != null && ammoItem.amount > 0 && ammoItem.parent == inventory;
	}

	public void Reload()
	{
		foreach (Item item in inventory.itemList)
		{
			if (item.info.itemid == ammoType.itemid && item.amount > 0)
			{
				ammoItem = item;
				break;
			}
		}
	}

	public void EnsureReloaded()
	{
		if (!HasAmmo())
		{
			Reload();
		}
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		EnsureReloaded();
		nextShotTime = UnityEngine.Time.time;
	}

	public void TargetTick()
	{
		if (UnityEngine.Time.realtimeSinceStartup >= nextVisCheck)
		{
			nextVisCheck = UnityEngine.Time.realtimeSinceStartup + UnityEngine.Random.Range(0.2f, 0.3f);
			targetVisible = ObjectVisible(target);
			if (targetVisible)
			{
				lastTargetSeenTime = UnityEngine.Time.realtimeSinceStartup;
			}
		}
		if (UnityEngine.Time.time >= nextShotTime && targetVisible && AngleToTarget(target) < 10f)
		{
			EnsureReloaded();
			if (HasAmmo())
			{
				FireGun(AimOffset(target), aimCone);
				nextShotTime = UnityEngine.Time.time + 0.115f;
				ammoItem.UseItem();
			}
			else
			{
				nextShotTime = UnityEngine.Time.time + 60f;
			}
		}
		if (target.IsDead() || UnityEngine.Time.realtimeSinceStartup - lastTargetSeenTime > 3f || Vector3.Distance(base.transform.position, target.transform.position) > sightRange || (PeacekeeperMode() && !IsEntityHostile(target)))
		{
			SetTarget(null);
		}
	}

	public bool HasTarget()
	{
		return target != null && target.IsAlive();
	}

	public void OfflineTick()
	{
		aimDir = Vector3.up;
	}

	public bool IsEntityHostile(BaseCombatEntity ent)
	{
		int num = 0;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			HeldEntity heldEntity = basePlayer.GetHeldEntity();
			if (heldEntity != null)
			{
				AttackEntity attackEntity = heldEntity as AttackEntity;
				if (attackEntity != null && attackEntity.hostile)
				{
					num++;
				}
			}
		}
		float num2 = Vector3Ex.Distance2D(ent.GetHostilePos(), base.transform.position);
		if (num2 < sightRange && ent.TimeSinceHostile() < Sentry.hostileduration)
		{
			num++;
		}
		return num > 0;
	}

	public void TargetScan()
	{
		if (HasTarget() || IsOffline())
		{
			return;
		}
		List<BaseCombatEntity> obj = Facepunch.Pool.GetList<BaseCombatEntity>();
		Vis.Entities(eyePos.transform.position, sightRange, obj, 133120);
		for (int i = 0; i < obj.Count; i++)
		{
			BaseCombatEntity baseCombatEntity = obj[i];
			if (!baseCombatEntity.IsAlive() || !InFiringArc(baseCombatEntity) || !ObjectVisible(baseCombatEntity))
			{
				continue;
			}
			if (!Sentry.targetall)
			{
				BasePlayer basePlayer = baseCombatEntity as BasePlayer;
				if ((bool)basePlayer && IsAuthed(basePlayer))
				{
					continue;
				}
			}
			if (baseCombatEntity is AutoTurret)
			{
				continue;
			}
			if (PeacekeeperMode())
			{
				if (!IsEntityHostile(baseCombatEntity))
				{
					continue;
				}
				if (target == null)
				{
					nextShotTime = UnityEngine.Time.time + 1f;
				}
			}
			SetTarget(baseCombatEntity);
			break;
		}
		Facepunch.Pool.FreeList(ref obj);
	}

	public void ServerTick()
	{
		if (!base.isClient && !base.IsDestroyed)
		{
			if (!IsOnline())
			{
				OfflineTick();
			}
			else if (HasTarget())
			{
				TargetTick();
			}
			else
			{
				IdleTick();
			}
			UpdateFacingToTarget();
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if ((!IsOnline() || HasTarget()) && targetVisible)
		{
			return;
		}
		AutoTurret autoTurret = info.Initiator as AutoTurret;
		if (!(autoTurret != null))
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			if (!basePlayer || !IsAuthed(basePlayer))
			{
				SetTarget(info.Initiator as BaseCombatEntity);
			}
		}
	}

	public void UpdateFacingToTarget()
	{
		if (target != null && targetVisible)
		{
			Vector3 vector = AimOffset(target);
			Vector3 vector2 = gun_pitch.transform.InverseTransformPoint(muzzlePos.transform.position);
			vector2.z = (vector2.x = 0f);
			Vector3 vector3 = vector - (gun_pitch.position + vector2);
			aimDir = vector3;
		}
		UpdateAiming();
	}
}
