using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using FIMSpace;
using FIMSpace.FSpine;
using UnityEngine;
using UnityEngine.EventSystems;

[DefaultExecutionOrder(-11)]
[AddComponentMenu("FImpossible Creations/Spine Animator 2")]
public class FSpineAnimator : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon, IClientComponent
{
	public enum EFSpineEditorCategory
	{
		Setup,
		Tweak,
		Adjust,
		Physical
	}

	public enum EFDeltaType
	{
		DeltaTime,
		SmoothDeltaTime,
		UnscaledDeltaTime,
		FixedDeltaTime,
		SafeDelta
	}

	public enum EParamChange
	{
		GoBackSpeed,
		SpineAnimatorAmount,
		AngleLimit,
		StraightenSpeed,
		PositionSmoother,
		RotationSmoother
	}

	public class HeadBone
	{
		public Transform baseTransform;

		public Transform transform;

		private Vector3 snapshotPoseBaseTrSpacePosition;

		public Vector3 SnapshotPosition;

		private Quaternion snapshotPoseBaseTrSpaceRotationF;

		private Quaternion snapshotPoseBaseTrSpaceRotationB;

		public Quaternion snapshotPoseLocalRotation;

		public Quaternion SnapshotRotation;

		public Vector3 InitialLocalPosition { get; private set; }

		public Quaternion InitialLocalRotation { get; private set; }

		public HeadBone(Transform t)
		{
			transform = t;
		}

		public void PrepareBone(Transform baseTransform, List<SpineBone> bones, int index)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			TakePoseSnapshot(baseTransform, bones, index);
			InitialLocalPosition = transform.localPosition;
			InitialLocalRotation = transform.localRotation;
		}

		internal Quaternion GetLocalRotationDiff()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			return transform.rotation * Quaternion.Inverse(snapshotPoseLocalRotation);
		}

		public void SetCoordsForFrameForward()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			SnapshotPosition = baseTransform.TransformPoint(snapshotPoseBaseTrSpacePosition);
			SnapshotRotation = baseTransform.rotation * snapshotPoseBaseTrSpaceRotationF;
		}

		public void SetCoordsForFrameBackward()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			SnapshotPosition = baseTransform.TransformPoint(snapshotPoseBaseTrSpacePosition);
			SnapshotRotation = baseTransform.rotation * snapshotPoseBaseTrSpaceRotationB;
		}

		public void TakePoseSnapshot(Transform targetSpace, List<SpineBone> bones, int index)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0114: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_015e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			baseTransform = targetSpace;
			snapshotPoseBaseTrSpacePosition = targetSpace.InverseTransformPoint(transform.position);
			Vector3 val2;
			Vector3 val3;
			if (index == bones.Count - 1)
			{
				Vector3 val = targetSpace.InverseTransformPoint(transform.position) - targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
				val2 = snapshotPoseBaseTrSpacePosition + val;
				val3 = targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
			}
			else if (index == 0)
			{
				val2 = targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
				Vector3 val4 = targetSpace.InverseTransformPoint(transform.position) - targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
				val3 = snapshotPoseBaseTrSpacePosition + val4;
			}
			else
			{
				val2 = targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
				val3 = targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
			}
			snapshotPoseBaseTrSpaceRotationF = Quaternion.Inverse(targetSpace.rotation) * Quaternion.LookRotation(val2 - snapshotPoseBaseTrSpacePosition);
			snapshotPoseBaseTrSpaceRotationB = Quaternion.Inverse(targetSpace.rotation) * Quaternion.LookRotation(val3 - snapshotPoseBaseTrSpacePosition);
			snapshotPoseLocalRotation = Quaternion.Inverse(targetSpace.rotation) * transform.rotation;
		}
	}

	[Serializable]
	public class SpineBone
	{
		public Transform transform;

		public Vector3 ProceduralPosition;

		public Quaternion ProceduralRotation;

		public Vector3 HelperDiffPosition;

		public Quaternion HelperDiffRoation;

		public Vector3 PreviousPosition;

		public Vector3 DefaultForward;

		public float StraightenFactor;

		public float TargetStraightenFactor;

		private float boneLengthB = 0.1f;

		private float boneLengthF = 0.1f;

		private Vector3 boneLocalOffsetB;

		private Vector3 boneLocalOffsetF;

		public float MotionWeight = 1f;

		public Quaternion FinalRotation;

		public Vector3 FinalPosition;

		public Vector3 ManualPosOffset;

		public Quaternion ManualRotOffset;

		public Vector3 ReferencePosition;

		public Vector3 PreviousReferencePosition;

		public Quaternion ReferenceRotation;

		private Quaternion lastKeyframeRotation;

		private Vector3 lastKeyframePosition;

		private Vector3 lastFinalLocalPosition;

		private Quaternion lastFinalLocalRotation;

		public Vector3 forward;

		public Vector3 right;

		public Vector3 up;

		public bool Collide = true;

		public float CollisionRadius = 1f;

		public Vector3 ColliderOffset = Vector3.zero;

		public float BoneLength { get; private set; }

		public Vector3 BoneLocalOffset { get; private set; }

		public Vector3 InitialLocalPosition { get; private set; }

		public Quaternion InitialLocalRotation { get; private set; }

		public void UpdateReferencePosition(Vector3 pos)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			PreviousReferencePosition = ReferencePosition;
			ReferencePosition = pos;
		}

		public void ZeroKeyframeCheck()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			if (lastFinalLocalRotation.QIsSame(transform.localRotation))
			{
				transform.localRotation = lastKeyframeRotation;
			}
			else
			{
				lastKeyframeRotation = transform.localRotation;
			}
			if (lastFinalLocalPosition.VIsSame(transform.localPosition))
			{
				transform.localPosition = lastKeyframePosition;
			}
			else
			{
				lastKeyframePosition = transform.localPosition;
			}
		}

		public void RefreshFinalLocalPose()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			lastFinalLocalPosition = transform.localPosition;
			lastFinalLocalRotation = transform.localRotation;
		}

		public SpineBone(Transform t)
		{
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			transform = t;
			ManualPosOffset = Vector3.zero;
			ColliderOffset = Vector3.zero;
			Collide = true;
			CollisionRadius = 1f;
		}

		public void PrepareBone(Transform baseTransform, List<SpineBone> bones, int index)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_0156: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0173: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_018d: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0193: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			InitialLocalPosition = transform.localPosition;
			InitialLocalRotation = transform.localRotation;
			Vector3 val = ((index != bones.Count - 1) ? bones[index + 1].transform.position : ((bones[index].transform.childCount <= 0) ? bones[index - 1].transform.position : bones[index].transform.GetChild(0).position));
			if (index == 0)
			{
				val = bones[index + 1].transform.position;
			}
			if (Vector3.Distance(baseTransform.InverseTransformPoint(val), baseTransform.InverseTransformPoint(bones[index].transform.position)) < 0.01f)
			{
				int num = index + 2;
				if (num < bones.Count)
				{
					DefaultForward = transform.InverseTransformPoint(bones[num].transform.position);
				}
				else
				{
					DefaultForward = transform.InverseTransformPoint(val - baseTransform.position);
				}
			}
			else
			{
				DefaultForward = transform.InverseTransformPoint(val);
			}
			Vector3 val2 = baseTransform.InverseTransformPoint(transform.position) - baseTransform.InverseTransformPoint(val);
			boneLengthB = ((Vector3)(ref val2)).magnitude;
			boneLocalOffsetB = baseTransform.InverseTransformPoint(val);
			val2 = baseTransform.InverseTransformPoint(transform.position) - baseTransform.InverseTransformPoint(val);
			boneLengthF = ((Vector3)(ref val2)).magnitude;
			boneLocalOffsetF = baseTransform.InverseTransformPoint(val);
			if (((Vector3)(ref ManualPosOffset)).sqrMagnitude == 0f)
			{
				ManualPosOffset = Vector3.zero;
			}
			val2 = ((Quaternion)(ref ManualRotOffset)).eulerAngles;
			if (((Vector3)(ref val2)).sqrMagnitude == 0f)
			{
				ManualRotOffset = Quaternion.identity;
			}
			SetDistanceForFrameForward();
			PrepareAxes(baseTransform, bones, index);
		}

		public void SetDistanceForFrameForward()
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			BoneLength = boneLengthF;
			BoneLocalOffset = boneLocalOffsetF;
		}

		public void SetDistanceForFrameBackward()
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			BoneLength = boneLengthB;
			BoneLocalOffset = boneLocalOffsetB;
		}

		public float GetUnscalledBoneLength()
		{
			if (boneLengthF > boneLengthB)
			{
				return boneLengthF;
			}
			return boneLengthB;
		}

		private void PrepareAxes(Transform baseTransform, List<SpineBone> bonesList, int index)
		{
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_0106: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0117: Unknown result type (might be due to invalid IL or missing references)
			//IL_0118: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			Transform val;
			Vector3 position;
			Vector3 position2;
			if (index == bonesList.Count - 1)
			{
				if (transform.childCount == 1)
				{
					val = transform;
					Transform child = transform.GetChild(0);
					position = val.position;
					position2 = child.position;
				}
				else
				{
					val = transform;
					_ = transform;
					position = bonesList[index - 1].transform.position;
					position2 = transform.position;
				}
			}
			else
			{
				val = transform;
				Transform obj = bonesList[index + 1].transform;
				position = val.position;
				position2 = obj.position;
			}
			Vector3 val2 = val.InverseTransformDirection(position2) - val.InverseTransformDirection(position);
			Vector3 val3 = baseTransform.up;
			Vector3 val4 = transform.TransformDirection(val2);
			val4 = Vector3.ProjectOnPlane(val3, ((Vector3)(ref val4)).normalized);
			Vector3 normalized = ((Vector3)(ref val4)).normalized;
			Vector3 val5 = val.InverseTransformDirection(position + normalized) - val.InverseTransformDirection(position);
			Vector3 val6 = Vector3.Cross(transform.TransformDirection(val2), transform.TransformDirection(val5));
			Vector3 val7 = val.InverseTransformDirection(position + val6) - val.InverseTransformDirection(position);
			right = ((Vector3)(ref val7)).normalized;
			up = ((Vector3)(ref val5)).normalized;
			forward = ((Vector3)(ref val2)).normalized;
		}

		internal void CalculateDifferencePose(Vector3 upAxis, Vector3 rightAxis)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			HelperDiffPosition = ProceduralPosition - ReferencePosition;
			Quaternion val = ProceduralRotation * Quaternion.FromToRotation(up, upAxis) * Quaternion.FromToRotation(right, rightAxis);
			Quaternion val2 = ReferenceRotation * Quaternion.FromToRotation(up, upAxis) * Quaternion.FromToRotation(right, rightAxis);
			HelperDiffRoation = val * Quaternion.Inverse(val2);
		}

		internal void ApplyDifferencePose()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			FinalPosition = transform.position + HelperDiffPosition;
			FinalRotation = HelperDiffRoation * transform.rotation;
		}

		public void Editor_SetLength(float length)
		{
			if (!Application.isPlaying)
			{
				BoneLength = length;
			}
		}

		public float GetCollisionRadiusScaled()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return CollisionRadius * transform.lossyScale.x;
		}
	}

	public enum EFixedMode
	{
		None,
		Basic,
		Late
	}

	private bool collisionInitialized;

	private bool forceRefreshCollidersData;

	[FPD_Percentage(0f, 1f, false, true, "%", false)]
	[Tooltip("You can use this variable to blend intensity of spine animator motion over skeleton animation\n\nValue = 1: Animation with spine Animator motion\nValue = 0: Only skeleton animation")]
	public float SpineAnimatorAmount = 1f;

	private Quaternion Rotate180 = Quaternion.Euler(0f, 180f, 0f);

	private int initAfterTPoseCounter;

	private bool fixedUpdated;

	private bool lateFixedIsRunning;

	private bool fixedAllow = true;

	private bool chainReverseFlag;

	public EFSpineEditorCategory _Editor_Category;

	public bool _Editor_PivotoffsetXYZ;

	private bool _editor_isQuitting;

	private int leadingBoneIndex;

	private int chainIndexDirection = 1;

	private int chainIndexOffset = 1;

	protected float delta = 0.016f;

	protected float unifiedDelta = 0.016f;

	protected float elapsedDeltaHelper;

	protected int updateLoops = 1;

	private bool initialized;

	private Vector3 previousPos;

	private bool wasBlendedOut;

	private List<FSpineBoneConnector> connectors;

	private float referenceDistance = 0.1f;

	public Vector3 ModelForwardAxis = Vector3.forward;

	public Vector3 ModelForwardAxisScaled = Vector3.forward;

	public Vector3 ModelUpAxis = Vector3.up;

	public Vector3 ModelUpAxisScaled = Vector3.up;

	internal Vector3 ModelRightAxis = Vector3.right;

	internal Vector3 ModelRightAxisScaled = Vector3.right;

	public List<SpineBone> SpineBones;

	public List<Transform> SpineTransforms;

	private HeadBone frontHead;

	private HeadBone backHead;

	private HeadBone headBone;

	[Tooltip("Main character object - by default it is game object to which Spine Animator is attached.\n\nYou can use it to control spine of character from different game object.")]
	public Transform BaseTransform;

	public Transform ForwardReference;

	[Tooltip("If your spine lead bone is in beggining of your hierarchy chain then toggle it.\n\nComponent's gizmos can help you out to define which bone should be leading (check head gizmo when you switch this toggle).")]
	public bool LastBoneLeading = true;

	[Tooltip("Sometimes spine chain can face in different direction than desired or you want your characters to move backward with spine motion.")]
	public bool ReverseForward;

	[Tooltip("If you're using 'Animate Physics' on animator you should set this variable to be enabled.")]
	public EFixedMode AnimatePhysics;

	public Transform AnchorRoot;

	[Tooltip("Connecting lead bone position to given transform, useful when it is tail and you already animating spine with other Spine Animator component.")]
	public Transform HeadAnchor;

	[Tooltip("Letting head anchor to animate rotation")]
	public bool AnimateAnchor = true;

	[Tooltip("If you need to offset leading bone rotation.")]
	public Vector3 LeadBoneRotationOffset = Vector3.zero;

	[Tooltip("If Lead Bone Rotation Offset should affect reference pose or bone rotation")]
	public bool LeadBoneOffsetReference = true;

	[Tooltip("List of bone positioning/rotation fixers if using paws positioning with IK controlls disconnected out of arms/legs in the hierarchy")]
	public List<SpineAnimator_FixIKControlledBones> BonesFixers = new List<SpineAnimator_FixIKControlledBones>();

	[Tooltip("Useful when you use few spine animators and want to rely on animated position and rotation by other spine animator.")]
	public bool UpdateAsLast;

	public bool QueueToLastUpdate;

	[Tooltip("If corrections should affect spine chain children.")]
	public bool ManualAffectChain;

	[Tooltip("Often when you drop model to scene, it's initial pose is much different than animations, which causes problems, this toggle solves it at start.")]
	public bool StartAfterTPose = true;

	[Tooltip("If you want spine animator to stop computing when choosed mesh is not visible in any camera view (editor's scene camera is detecting it too)")]
	public Renderer OptimizeWithMesh;

	[Tooltip("Delta Time for Spine Animator calculations")]
	public EFDeltaType DeltaType = EFDeltaType.SafeDelta;

	[Tooltip("Making update rate stable for target rate.\nIf this value is = 0 then update rate is unlimited.")]
	public float UpdateRate;

	[Tooltip("In some cases you need to use chain corrections, it will cost a bit more in performance, not much but always.")]
	public bool UseCorrections;

	[Tooltip("Sometimes offsetting model's pivot position gives better results using spine animator, offset forward axis so front legs are in centrum and see the difference (generating additional transform inside hierarchy)")]
	public Vector3 MainPivotOffset = new Vector3(0f, 0f, 0f);

	[Tooltip("Generating offset runtime only, allows you to adjust it on prefabs on scene")]
	public bool PivotOffsetOnStart = true;

	[Range(0f, 1f)]
	[Tooltip("If animation of changing segments position should be smoothed - creating a little gumy effect.")]
	public float PosSmoother;

	[Tooltip("If animation of changing segments rotation should be smoothed - making it more soft, but don't overuse it!")]
	[Range(0f, 1f)]
	public float RotSmoother;

	[Range(0f, 1f)]
	[Tooltip("We stretching segments to bigger value than bones are by default to create some extra effect which looks good but sometimes it can stretch to much if you using position smoothing, you can adjust it here.")]
	public float MaxStretching = 1f;

	[Tooltip("Making algorithm referencing back to static rotation if value = 0f | at 1 motion have more range and is more slithery.")]
	[Range(0f, 1f)]
	public float Slithery = 1f;

	[Range(1f, 91f)]
	[Tooltip("Limiting rotation angle difference between each segment of spine.")]
	public float AngleLimit = 40f;

	[Range(0f, 1f)]
	[Tooltip("Smoothing how fast limiting should make segments go back to marginal pose.")]
	public float LimitSmoother = 0.35f;

	[Range(0f, 15f)]
	[Tooltip("How fast spine should be rotated to straight pose when your character moves.")]
	public float StraightenSpeed = 7.5f;

	public bool TurboStraighten;

	[Tooltip("Spine going back to straight position constantly with choosed speed intensity.")]
	[Range(0f, 1f)]
	public float GoBackSpeed;

	[Range(0f, 1f)]
	[Tooltip("Elastic spring effect good for tails to make them more 'meaty'.")]
	public float Springiness;

	[Tooltip("How much effect on spine chain should have character movement.")]
	[Range(0f, 1f)]
	public float MotionInfluence = 1f;

	[Tooltip("Useful when your creature jumps on moving platform, so when platform moves spine is not reacting, by default world space is used (null).")]
	public Transform MotionSpace;

	[Tooltip("Fade rotations to sides or rotation up/down with this parameter - can be helpful for character jump handling")]
	public Vector2 RotationsFade = Vector2.one;

	[SerializeField]
	[HideInInspector]
	private Transform mainPivotOffsetTransform;

	[Tooltip("<! Most models can not need this !> Offset for bones rotations, thanks to that animation is able to rotate to segments in a correct way, like from center of mass.")]
	public Vector3 SegmentsPivotOffset = new Vector3(0f, 0f, 0f);

	[Tooltip("Multiplies distance value between bones segments - can be useful for use with humanoid skeletons")]
	public float DistancesMultiplier = 1f;

	[Tooltip("Pushing segments in world direction (should have included ground collider to collide with).")]
	public Vector3 GravityPower = Vector3.zero;

	protected Vector3 gravityScale = Vector3.zero;

	[Tooltip("[Experimental] Using some simple calculations to make spine bend on colliders.")]
	public bool UseCollisions;

	public List<Collider> IncludedColliders;

	protected List<FImp_ColliderData_Base> IncludedCollidersData;

	protected List<FImp_ColliderData_Base> CollidersDataToCheck;

	[Tooltip("If disabled Colliders can be offsetted a bit in wrong way - check pink spheres in scene view (playmode, with true positions disabled colliders are fitting to stiff reference pose) - but it gives more stable collision projection! But to avoid stuttery you can increase position smoothing.")]
	public bool UseTruePosition;

	public Vector3 OffsetAllColliders = Vector3.zero;

	public AnimationCurve CollidersScale = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	public float CollidersScaleMul = 6.5f;

	[Range(0f, 1f)]
	public float DifferenceScaleFactor;

	[Tooltip("If you want to continue checking collision if segment collides with one collider (very useful for example when you using gravity power with ground)")]
	public bool DetailedCollision = true;

	[SerializeField]
	[HideInInspector]
	private bool _CheckedPivot;

	private bool updateSpineAnimator;

	private bool callSpineReposeCalculations = true;

	public string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Spine Animator/SpineAnimator_SmallIcon";
		}
	}

	[Obsolete("Use SpineAnimatorAmount instead, but remember that it works in reversed way -> SpineAnimatorAmount 1 = BlendToOriginal 0  and  SpineAnimatorAmount 0 = BlendToOriginal 1")]
	public float BlendToOriginal
	{
		get
		{
			return 1f - SpineAnimatorAmount;
		}
		set
		{
			SpineAnimatorAmount = 1f - value;
		}
	}

	public bool EndBoneIsHead
	{
		get
		{
			return LastBoneLeading;
		}
		set
		{
			LastBoneLeading = EndBoneIsHead;
		}
	}

	private void RemovePivotOffset()
	{
		if (!Application.isPlaying && Object.op_Implicit((Object)(object)mainPivotOffsetTransform))
		{
			RestoreBasePivotChildren();
		}
	}

	public void UpdatePivotOffsetState()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (SpineBones.Count <= 1)
		{
			return;
		}
		if (MainPivotOffset == Vector3.zero)
		{
			if (Object.op_Implicit((Object)(object)mainPivotOffsetTransform) && mainPivotOffsetTransform.childCount > 0)
			{
				mainPivotOffsetTransform.localPosition = MainPivotOffset;
				RestoreBasePivotChildren();
			}
			return;
		}
		if (!Object.op_Implicit((Object)(object)mainPivotOffsetTransform))
		{
			mainPivotOffsetTransform = new GameObject("Main Pivot Offset-Spine Animator-" + ((Object)this).name).transform;
			mainPivotOffsetTransform.SetParent(GetBaseTransform(), false);
			mainPivotOffsetTransform.localPosition = Vector3.zero;
			mainPivotOffsetTransform.localRotation = Quaternion.identity;
			mainPivotOffsetTransform.localScale = Vector3.one;
		}
		if (mainPivotOffsetTransform.childCount == 0)
		{
			for (int num = GetBaseTransform().childCount - 1; num >= 0; num--)
			{
				if (!((Object)(object)GetBaseTransform().GetChild(num) == (Object)(object)mainPivotOffsetTransform))
				{
					GetBaseTransform().GetChild(num).SetParent(mainPivotOffsetTransform, true);
				}
			}
		}
		mainPivotOffsetTransform.localPosition = MainPivotOffset;
	}

	private void RestoreBasePivotChildren()
	{
		if (!_editor_isQuitting)
		{
			for (int num = mainPivotOffsetTransform.childCount - 1; num >= 0; num--)
			{
				mainPivotOffsetTransform.GetChild(num).SetParent(mainPivotOffsetTransform.parent, true);
			}
		}
	}

	private void PreMotionBoneOffsets()
	{
		if (UseCorrections && ManualAffectChain && callSpineReposeCalculations)
		{
			PreMotionNoHead();
			PreMotionHead();
		}
	}

	private void PreMotionNoHead()
	{
		if (((Vector3)(ref SegmentsPivotOffset)).sqrMagnitude != 0f)
		{
			for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; i++)
			{
				SegmentPreOffsetWithPivot(i);
			}
		}
		else
		{
			for (int j = 1 - chainIndexOffset; j < SpineBones.Count - chainIndexOffset; j++)
			{
				SegmentPreOffset(j);
			}
		}
	}

	private void PreMotionHead()
	{
		if (((Vector3)(ref SegmentsPivotOffset)).sqrMagnitude != 0f)
		{
			SegmentPreOffsetWithPivot(leadingBoneIndex);
		}
		else
		{
			SegmentPreOffset(leadingBoneIndex);
		}
	}

	private void SegmentPreOffset(int i)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (((Vector3)(ref SpineBones[i].ManualPosOffset)).sqrMagnitude != 0f)
		{
			Transform transform = SpineBones[i].transform;
			transform.position += SpineBones[i].ProceduralRotation * SpineBones[i].ManualPosOffset;
		}
		Transform transform2 = SpineBones[i].transform;
		transform2.rotation *= SpineBones[i].ManualRotOffset;
	}

	private void SegmentPreOffsetWithPivot(int i)
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (((Vector3)(ref SpineBones[i].ManualPosOffset)).sqrMagnitude != 0f)
		{
			Transform transform = SpineBones[i].transform;
			transform.position += SpineBones[i].ProceduralRotation * SpineBones[i].ManualPosOffset;
		}
		Transform transform2 = SpineBones[i].transform;
		transform2.position += SpineBones[i].ProceduralRotation * (SegmentsPivotOffset * (SpineBones[i].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.z));
		Transform transform3 = SpineBones[i].transform;
		transform3.rotation *= SpineBones[i].ManualRotOffset;
	}

	private void PostMotionBoneOffsets()
	{
		if (UseCorrections && !ManualAffectChain)
		{
			PostMotionHead();
			PostMotionNoHead();
		}
	}

	private void PostMotionNoHead()
	{
		if (((Vector3)(ref SegmentsPivotOffset)).sqrMagnitude != 0f)
		{
			for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; i++)
			{
				SegmentPostOffsetWithPivot(i);
			}
		}
		else
		{
			for (int j = 1 - chainIndexOffset; j < SpineBones.Count - chainIndexOffset; j++)
			{
				SegmentPostOffset(j);
			}
		}
	}

	private void PostMotionHead()
	{
		if (((Vector3)(ref SegmentsPivotOffset)).sqrMagnitude != 0f)
		{
			SegmentPostOffsetWithPivot(leadingBoneIndex);
		}
		else
		{
			SegmentPostOffset(leadingBoneIndex);
		}
	}

	private void SegmentPostOffset(int i)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (((Vector3)(ref SpineBones[i].ManualPosOffset)).sqrMagnitude != 0f)
		{
			SpineBone spineBone = SpineBones[i];
			spineBone.FinalPosition += SpineBones[i].ProceduralRotation * SpineBones[i].ManualPosOffset;
		}
		SpineBone spineBone2 = SpineBones[i];
		spineBone2.FinalRotation *= SpineBones[i].ManualRotOffset;
	}

	private void SegmentPostOffsetWithPivot(int i)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (((Vector3)(ref SpineBones[i].ManualPosOffset)).sqrMagnitude != 0f)
		{
			SpineBone spineBone = SpineBones[i];
			spineBone.FinalPosition += SpineBones[i].ProceduralRotation * SpineBones[i].ManualPosOffset;
		}
		SpineBone spineBone2 = SpineBones[i];
		spineBone2.FinalPosition += SpineBones[i].ProceduralRotation * (SegmentsPivotOffset * (SpineBones[i].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.z));
		SpineBone spineBone3 = SpineBones[i];
		spineBone3.FinalRotation *= SpineBones[i].ManualRotOffset;
	}

	private void BeginPhysicsUpdate()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		gravityScale = GravityPower * delta;
		if (!UseCollisions)
		{
			return;
		}
		if (!collisionInitialized)
		{
			InitColliders();
		}
		else
		{
			RefreshCollidersDataList();
		}
		CollidersDataToCheck.Clear();
		for (int i = 0; i < IncludedCollidersData.Count; i++)
		{
			if ((Object)(object)IncludedCollidersData[i].Collider == (Object)null)
			{
				forceRefreshCollidersData = true;
				break;
			}
			if (((Component)IncludedCollidersData[i].Collider).gameObject.activeInHierarchy)
			{
				IncludedCollidersData[i].RefreshColliderData();
				CollidersDataToCheck.Add(IncludedCollidersData[i]);
			}
		}
	}

	public void RefreshCollidersDataList()
	{
		if (IncludedColliders.Count == IncludedCollidersData.Count && !forceRefreshCollidersData)
		{
			return;
		}
		IncludedCollidersData.Clear();
		for (int num = IncludedColliders.Count - 1; num >= 0; num--)
		{
			if ((Object)(object)IncludedColliders[num] == (Object)null)
			{
				IncludedColliders.RemoveAt(num);
			}
			else
			{
				FImp_ColliderData_Base colliderDataFor = FImp_ColliderData_Base.GetColliderDataFor(IncludedColliders[num]);
				IncludedCollidersData.Add(colliderDataFor);
			}
		}
		forceRefreshCollidersData = false;
	}

	private float GetColliderSphereRadiusFor(int i)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		int index = i - 1;
		if (LastBoneLeading)
		{
			if (i == SpineBones.Count - 1)
			{
				return 0f;
			}
			index = i + 1;
		}
		else if (i == 0)
		{
			return 0f;
		}
		float num = 1f;
		if (SpineBones.Count > 1)
		{
			num = Vector3.Distance(SpineBones[1].transform.position, SpineBones[0].transform.position);
		}
		float num2 = num;
		Vector3 val = SpineBones[i].transform.position - SpineBones[index].transform.position;
		float num3 = Mathf.Lerp(num2, ((Vector3)(ref val)).magnitude * 0.5f, DifferenceScaleFactor);
		float num4 = SpineBones.Count - 1;
		if (num4 <= 0f)
		{
			num4 = 1f;
		}
		float num5 = 1f / num4;
		return 0.5f * num3 * CollidersScaleMul * CollidersScale.Evaluate(num5 * (float)i);
	}

	public void AddCollider(Collider collider)
	{
		if (!IncludedColliders.Contains(collider))
		{
			IncludedColliders.Add(collider);
		}
	}

	private void InitColliders()
	{
		for (int i = 0; i < SpineBones.Count; i++)
		{
			SpineBones[i].CollisionRadius = GetColliderSphereRadiusFor(i);
		}
		IncludedCollidersData = new List<FImp_ColliderData_Base>();
		RefreshCollidersDataList();
		collisionInitialized = true;
	}

	public void CheckForColliderDuplicates()
	{
		for (int i = 0; i < IncludedColliders.Count; i++)
		{
			Collider col = IncludedColliders[i];
			if (IncludedColliders.Count((Collider o) => (Object)(object)o == (Object)(object)col) > 1)
			{
				IncludedColliders.RemoveAll((Collider o) => (Object)(object)o == (Object)(object)col);
				IncludedColliders.Add(col);
			}
		}
	}

	public void PushIfSegmentInsideCollider(SpineBone bone, ref Vector3 targetPoint)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointOffset;
		if (UseTruePosition)
		{
			Vector3 val = targetPoint;
			pointOffset = bone.FinalPosition - val + bone.transform.TransformVector(bone.ColliderOffset + OffsetAllColliders);
		}
		else
		{
			pointOffset = bone.transform.TransformVector(bone.ColliderOffset + OffsetAllColliders);
		}
		if (!DetailedCollision)
		{
			for (int i = 0; i < CollidersDataToCheck.Count && !CollidersDataToCheck[i].PushIfInside(ref targetPoint, bone.GetCollisionRadiusScaled(), pointOffset); i++)
			{
			}
			return;
		}
		for (int j = 0; j < CollidersDataToCheck.Count; j++)
		{
			CollidersDataToCheck[j].PushIfInside(ref targetPoint, bone.GetCollisionRadiusScaled(), pointOffset);
		}
	}

	private void CalculateBonesCoordinates()
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (LastBoneLeading)
		{
			for (int num = SpineBones.Count - 2; num >= 0; num--)
			{
				CalculateTargetBoneRotation(num);
				CalculateTargetBonePosition(num);
				SpineBones[num].CalculateDifferencePose(ModelUpAxis, ModelRightAxis);
				SpineBones[num].ApplyDifferencePose();
			}
		}
		else
		{
			for (int i = 1; i < SpineBones.Count; i++)
			{
				CalculateTargetBoneRotation(i);
				CalculateTargetBonePosition(i);
				SpineBones[i].CalculateDifferencePose(ModelUpAxis, ModelRightAxis);
				SpineBones[i].ApplyDifferencePose();
			}
		}
	}

	private void CalculateTargetBonePosition(int index)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		SpineBone spineBone = SpineBones[index - chainIndexDirection];
		SpineBone spineBone2 = SpineBones[index];
		Vector3 targetPoint = spineBone.ProceduralPosition - spineBone2.ProceduralRotation * ModelForwardAxisScaled * (spineBone2.BoneLength * DistancesMultiplier);
		if (spineBone2.Collide)
		{
			targetPoint += gravityScale;
		}
		if (Springiness > 0f && !LastBoneLeading)
		{
			Vector3 val = spineBone2.ProceduralPosition - spineBone2.PreviousPosition;
			Vector3 proceduralPosition = spineBone2.ProceduralPosition;
			spineBone2.PreviousPosition = spineBone2.ProceduralPosition;
			proceduralPosition += val * (1f - Mathf.Lerp(0.05f, 0.25f, Springiness));
			Vector3 val2 = spineBone.ProceduralPosition - proceduralPosition;
			float magnitude = ((Vector3)(ref val2)).magnitude;
			Matrix4x4 localToWorldMatrix = spineBone.transform.localToWorldMatrix;
			((Matrix4x4)(ref localToWorldMatrix)).SetColumn(3, Vector4.op_Implicit(spineBone.ProceduralPosition));
			Vector3 val3 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(spineBone2.transform.localPosition);
			Vector3 val4 = val3 - proceduralPosition;
			proceduralPosition += val4 * Mathf.Lerp(0.05f, 0.2f, Springiness);
			val4 = val3 - proceduralPosition;
			float magnitude2 = ((Vector3)(ref val4)).magnitude;
			float num = magnitude * (1f - Mathf.Lerp(0f, 0.2f, Springiness)) * 2f;
			if (magnitude2 > num)
			{
				proceduralPosition += val4 * ((magnitude2 - num) / magnitude2);
			}
			if (MaxStretching < 1f)
			{
				float num2 = Vector3.Distance(spineBone2.ProceduralPosition, proceduralPosition);
				if (num2 > 0f)
				{
					float num3 = spineBone2.BoneLength * 4f * MaxStretching;
					if (num2 > num3)
					{
						proceduralPosition = Vector3.Lerp(proceduralPosition, targetPoint, Mathf.InverseLerp(num2, 0f, num3));
					}
				}
			}
			targetPoint = Vector3.Lerp(targetPoint, proceduralPosition, Mathf.Lerp(0.3f, 0.9f, Springiness));
		}
		if (PosSmoother > 0f && MaxStretching < 1f)
		{
			float num4 = Vector3.Distance(spineBone2.ProceduralPosition, targetPoint);
			if (num4 > 0f)
			{
				float num5 = spineBone2.BoneLength * 4f * MaxStretching;
				if (num4 > num5)
				{
					spineBone2.ProceduralPosition = Vector3.Lerp(spineBone2.ProceduralPosition, targetPoint, Mathf.InverseLerp(num4, 0f, num5));
				}
			}
		}
		if (UseCollisions && spineBone2.Collide)
		{
			PushIfSegmentInsideCollider(spineBone2, ref targetPoint);
		}
		if (PosSmoother == 0f)
		{
			spineBone2.ProceduralPosition = targetPoint;
		}
		else
		{
			spineBone2.ProceduralPosition = Vector3.LerpUnclamped(spineBone2.ProceduralPosition, targetPoint, Mathf.LerpUnclamped(1f, unifiedDelta, PosSmoother));
		}
	}

	private void CalculateTargetBoneRotation(int index)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		SpineBone spineBone = SpineBones[index - chainIndexDirection];
		SpineBone spineBone2 = SpineBones[index];
		Quaternion val = ((Slithery >= 1f) ? spineBone.ProceduralRotation : ((!(Slithery > 0f)) ? spineBone2.ReferenceRotation : Quaternion.LerpUnclamped(spineBone2.ReferenceRotation, spineBone.ProceduralRotation, Slithery)));
		Vector3 val2 = spineBone.ProceduralPosition - spineBone2.ProceduralPosition;
		if (val2 == Vector3.zero)
		{
			val2 = spineBone2.transform.rotation * spineBone2.DefaultForward;
		}
		if (RotationsFade != Vector2.one)
		{
			val2.x *= RotationsFade.x;
			val2.z *= RotationsFade.x;
			val2.y *= RotationsFade.y;
		}
		Quaternion val3 = Quaternion.LookRotation(val2, spineBone.ProceduralRotation * ModelUpAxis);
		if (AngleLimit < 91f)
		{
			float num = Quaternion.Angle(val3, val);
			if (num > AngleLimit)
			{
				float num2 = 0f;
				num2 = Mathf.InverseLerp(0f, num, num - AngleLimit);
				Quaternion val4 = Quaternion.LerpUnclamped(val3, val, num2);
				float num3 = Mathf.Min(1f, num / (AngleLimit / 0.75f));
				num3 = Mathf.Sqrt(Mathf.Pow(num3, 4f)) * num3;
				val3 = ((LimitSmoother != 0f) ? Quaternion.LerpUnclamped(val3, val4, unifiedDelta * (1f - LimitSmoother) * 50f * num3) : Quaternion.LerpUnclamped(val3, val4, num3));
			}
		}
		if (GoBackSpeed <= 0f)
		{
			if (StraightenSpeed > 0f)
			{
				Vector3 val5 = spineBone2.ReferencePosition - spineBone2.PreviousReferencePosition;
				float num4 = ((Vector3)(ref val5)).magnitude / spineBone2.GetUnscalledBoneLength();
				if (num4 > 0.5f)
				{
					num4 = 0.5f;
				}
				float num5 = num4 * (1f + StraightenSpeed / 5f);
				spineBone2.StraightenFactor = Mathf.Lerp(spineBone2.StraightenFactor, num5, unifiedDelta * (7f + StraightenSpeed));
				if (num4 > 0.0001f)
				{
					val3 = Quaternion.Lerp(val3, val, unifiedDelta * spineBone2.StraightenFactor * (StraightenSpeed + 5f) * (TurboStraighten ? 6f : 1f));
				}
			}
		}
		else
		{
			float num6 = 0f;
			if (StraightenSpeed > 0f)
			{
				if (previousPos != RoundPosDiff(SpineBones[leadingBoneIndex].ProceduralPosition))
				{
					spineBone2.TargetStraightenFactor = 1f;
				}
				else if (spineBone2.TargetStraightenFactor > 0f)
				{
					spineBone2.TargetStraightenFactor -= delta * (5f + StraightenSpeed);
				}
				spineBone2.StraightenFactor = Mathf.Lerp(spineBone2.StraightenFactor, spineBone2.TargetStraightenFactor, unifiedDelta * (1f + StraightenSpeed));
				if (spineBone2.StraightenFactor > 0.025f)
				{
					num6 = spineBone2.StraightenFactor * StraightenSpeed * (TurboStraighten ? 6f : 1f);
				}
			}
			val3 = Quaternion.Lerp(val3, val, unifiedDelta * (Mathf.Lerp(0f, 55f, GoBackSpeed) + num6));
		}
		if (RotSmoother == 0f)
		{
			spineBone2.ProceduralRotation = val3;
		}
		else
		{
			spineBone2.ProceduralRotation = Quaternion.LerpUnclamped(spineBone2.ProceduralRotation, val3, Mathf.LerpUnclamped(0f, Mathf.LerpUnclamped(1f, unifiedDelta, RotSmoother), MotionInfluence));
		}
	}

	private void UpdateChainIndexHelperVariables()
	{
		if (chainReverseFlag == LastBoneLeading)
		{
			return;
		}
		chainReverseFlag = LastBoneLeading;
		if (LastBoneLeading)
		{
			leadingBoneIndex = SpineBones.Count - 1;
			chainIndexDirection = -1;
			chainIndexOffset = 1;
			headBone = backHead;
		}
		else
		{
			leadingBoneIndex = 0;
			chainIndexDirection = 1;
			chainIndexOffset = 0;
			headBone = frontHead;
		}
		if (LastBoneLeading)
		{
			for (int i = 0; i < SpineBones.Count; i++)
			{
				SpineBones[i].SetDistanceForFrameBackward();
			}
		}
		else
		{
			for (int j = 0; j < SpineBones.Count; j++)
			{
				SpineBones[j].SetDistanceForFrameForward();
			}
		}
	}

	private void RefreshReferencePose()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)HeadAnchor) && !AnimateAnchor)
		{
			SpineBones[leadingBoneIndex].transform.localRotation = SpineBones[leadingBoneIndex].InitialLocalRotation;
		}
		if (LastBoneLeading)
		{
			headBone.SetCoordsForFrameBackward();
			if (!Object.op_Implicit((Object)(object)HeadAnchor))
			{
				SpineBones[leadingBoneIndex].UpdateReferencePosition(headBone.SnapshotPosition);
				SpineBones[leadingBoneIndex].ReferenceRotation = BaseTransform.rotation;
			}
			else
			{
				SpineBones[leadingBoneIndex].UpdateReferencePosition(headBone.transform.position);
				SpineBones[leadingBoneIndex].ReferenceRotation = BaseTransform.rotation;
			}
			if (((Vector3)(ref LeadBoneRotationOffset)).sqrMagnitude != 0f && LeadBoneOffsetReference)
			{
				SpineBone spineBone = SpineBones[leadingBoneIndex];
				spineBone.ReferenceRotation *= Quaternion.Euler(LeadBoneRotationOffset);
			}
			if (ReverseForward)
			{
				SpineBone spineBone2 = SpineBones[leadingBoneIndex];
				spineBone2.ReferenceRotation *= Rotate180;
			}
			for (int num = SpineBones.Count - 2; num >= 0; num--)
			{
				SpineBones[num].ReferenceRotation = SpineBones[num + 1].ReferenceRotation;
				SpineBones[num].UpdateReferencePosition(SpineBones[num + 1].ReferencePosition - SpineBones[num].ReferenceRotation * ModelForwardAxis * (SpineBones[num].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.x));
			}
		}
		else
		{
			headBone.SetCoordsForFrameForward();
			if (!Object.op_Implicit((Object)(object)HeadAnchor))
			{
				SpineBones[leadingBoneIndex].UpdateReferencePosition(headBone.SnapshotPosition);
				SpineBones[leadingBoneIndex].ReferenceRotation = BaseTransform.rotation;
			}
			else
			{
				SpineBones[leadingBoneIndex].UpdateReferencePosition(headBone.transform.position);
				SpineBones[leadingBoneIndex].ReferenceRotation = headBone.GetLocalRotationDiff();
			}
			if (((Vector3)(ref LeadBoneRotationOffset)).sqrMagnitude != 0f && LeadBoneOffsetReference)
			{
				SpineBone spineBone3 = SpineBones[leadingBoneIndex];
				spineBone3.ReferenceRotation *= Quaternion.Euler(LeadBoneRotationOffset);
			}
			if (ReverseForward)
			{
				SpineBone spineBone4 = SpineBones[leadingBoneIndex];
				spineBone4.ReferenceRotation *= Rotate180;
			}
			for (int i = 1; i < SpineBones.Count; i++)
			{
				SpineBones[i].ReferenceRotation = SpineBones[i - 1].ReferenceRotation;
				SpineBones[i].UpdateReferencePosition(SpineBones[i - 1].ReferencePosition - SpineBones[i].ReferenceRotation * ModelForwardAxis * (SpineBones[i].BoneLength * DistancesMultiplier * BaseTransform.lossyScale.x));
			}
		}
	}

	private void ReposeSpine()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		UpdateChainIndexHelperVariables();
		RefreshReferencePose();
		for (int i = 0; i < SpineBones.Count; i++)
		{
			SpineBones[i].ProceduralPosition = SpineBones[i].ReferencePosition;
			SpineBones[i].ProceduralRotation = SpineBones[i].ReferenceRotation;
			SpineBones[i].PreviousPosition = SpineBones[i].ReferencePosition;
			SpineBones[i].FinalPosition = SpineBones[i].ReferencePosition;
			SpineBones[i].FinalRotation = SpineBones[i].ReferenceRotation;
		}
	}

	private void BeginBaseBonesUpdate()
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)HeadAnchor != (Object)null)
		{
			SpineBones[leadingBoneIndex].ProceduralRotation = headBone.GetLocalRotationDiff();
			SpineBones[leadingBoneIndex].ProceduralPosition = SpineBones[leadingBoneIndex].transform.position;
		}
		else
		{
			SpineBones[leadingBoneIndex].ProceduralPosition = SpineBones[leadingBoneIndex].ReferencePosition;
			SpineBones[leadingBoneIndex].ProceduralRotation = SpineBones[leadingBoneIndex].ReferenceRotation;
		}
		if (((Vector3)(ref LeadBoneRotationOffset)).sqrMagnitude != 0f && !LeadBoneOffsetReference)
		{
			SpineBone spineBone = SpineBones[leadingBoneIndex];
			spineBone.ProceduralRotation *= Quaternion.Euler(LeadBoneRotationOffset);
		}
		SpineBones[leadingBoneIndex].CalculateDifferencePose(ModelUpAxis, ModelRightAxis);
		SpineBones[leadingBoneIndex].ApplyDifferencePose();
	}

	private IEnumerator LateFixed()
	{
		WaitForFixedUpdate fixedWait = CoroutineEx.waitForFixedUpdate;
		lateFixedIsRunning = true;
		do
		{
			yield return fixedWait;
			PreCalibrateBones();
			fixedAllow = true;
		}
		while (lateFixedIsRunning);
	}

	public void OnDestroy()
	{
		RemovePivotOffset();
	}

	private void OnValidate()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!_CheckedPivot)
		{
			if (MainPivotOffset != Vector3.zero)
			{
				PivotOffsetOnStart = false;
			}
			_CheckedPivot = true;
		}
		if (SpineBones == null)
		{
			SpineBones = new List<SpineBone>();
		}
		if (!PivotOffsetOnStart)
		{
			UpdatePivotOffsetState();
		}
		if (UseCollisions)
		{
			CheckForColliderDuplicates();
		}
		if (UpdateRate < 0f)
		{
			UpdateRate = 0f;
		}
		ModelRightAxis = Vector3.Cross(ModelForwardAxis, ModelUpAxis);
	}

	public void AddConnector(FSpineBoneConnector connector)
	{
		if (connectors == null)
		{
			connectors = new List<FSpineBoneConnector>();
		}
		if (!connectors.Contains(connector))
		{
			connectors.Add(connector);
		}
	}

	public void Init()
	{
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		if (SpineBones.Count == 0)
		{
			if (SpineTransforms.Count <= 2)
			{
				Debug.Log((object)("[SPINE ANIMATOR] could not initialize Spine Animator inside '" + ((Object)this).name + "' because there are no bones to animate!"));
				return;
			}
			CreateSpineChain(SpineTransforms[0], SpineTransforms[SpineTransforms.Count - 1]);
			Debug.Log((object)("[SPINE ANIMATOR] Auto Bone Conversion from old version of Spine Animator! Please select your objects with Spine Animator to pre-convert it instead of automatically doing it when game Starts! (" + ((Object)this).name + ")"));
		}
		if (initialized)
		{
			Debug.Log((object)("[Spine Animator] " + ((Object)this).name + " is already initialized!"));
			return;
		}
		if ((Object)(object)BaseTransform == (Object)null)
		{
			BaseTransform = FindBaseTransform();
		}
		for (int i = 0; i < SpineBones.Count; i++)
		{
			Vector3 val = ((i != SpineBones.Count - 1) ? SpineBones[i + 1].transform.position : ((SpineBones[i].transform.childCount <= 0) ? (SpineBones[i - 1].transform.position + (SpineBones[i - 1].transform.position - SpineBones[i].transform.position)) : SpineBones[i].transform.GetChild(0).position));
			if (Vector3.Distance(SpineBones[i].transform.position, val) < 0.01f)
			{
				Vector3 val2 = SpineBones[SpineBones.Count - 1].transform.position - SpineBones[SpineBones.Count - 2].transform.parent.position;
				float magnitude = ((Vector3)(ref val2)).magnitude;
				Vector3 val3 = SpineBones[i].transform.position - BaseTransform.position;
				Vector3 val4 = BaseTransform.InverseTransformDirection(val3);
				val4.y = 0f;
				((Vector3)(ref val4)).Normalize();
				SpineBones[i + 1].DefaultForward = val4;
				SpineBones[i + 1].transform.position = SpineBones[i + 1].transform.position + BaseTransform.TransformDirection(val4) * magnitude * -0.125f;
			}
		}
		referenceDistance = 0f;
		for (int j = 0; j < SpineBones.Count; j++)
		{
			SpineBones[j].PrepareBone(BaseTransform, SpineBones, j);
			referenceDistance += SpineBones[j].BoneLength;
		}
		referenceDistance /= SpineBones.Count;
		frontHead = new HeadBone(SpineBones[0].transform);
		frontHead.PrepareBone(BaseTransform, SpineBones, 0);
		backHead = new HeadBone(SpineBones[SpineBones.Count - 1].transform);
		backHead.PrepareBone(BaseTransform, SpineBones, SpineBones.Count - 1);
		if (LastBoneLeading)
		{
			headBone = backHead;
		}
		else
		{
			headBone = frontHead;
		}
		CollidersDataToCheck = new List<FImp_ColliderData_Base>();
		chainReverseFlag = !LastBoneLeading;
		UpdateChainIndexHelperVariables();
		ReposeSpine();
		initialized = true;
	}

	public void CreateSpineChain(Transform start, Transform end)
	{
		if ((Object)(object)start == (Object)null || (Object)(object)end == (Object)null)
		{
			Debug.Log((object)"[SPINE ANIMATOR] Can't create spine chain if one of the bones is null!");
			return;
		}
		List<Transform> list = new List<Transform>();
		Transform val = end;
		while ((Object)(object)val != (Object)null && !((Object)(object)val == (Object)(object)start))
		{
			list.Add(val);
			val = val.parent;
		}
		if ((Object)(object)val == (Object)null)
		{
			Debug.Log((object)("[SPINE ANIMATOR] '" + ((Object)start).name + "' is not child of '" + ((Object)end).name + "' !"));
			return;
		}
		list.Add(start);
		list.Reverse();
		SpineBones = new List<SpineBone>();
		for (int i = 0; i < list.Count; i++)
		{
			SpineBone item = new SpineBone(list[i]);
			SpineBones.Add(item);
		}
	}

	private void PreCalibrateBones()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < SpineBones.Count; i++)
		{
			SpineBones[i].transform.localPosition = SpineBones[i].InitialLocalPosition;
			SpineBones[i].transform.localRotation = SpineBones[i].InitialLocalRotation;
		}
		if (BonesFixers.Count > 0)
		{
			for (int j = 0; j < BonesFixers.Count; j++)
			{
				BonesFixers[j].Calibration();
			}
		}
	}

	private void CalibrateBones()
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (BonesFixers.Count > 0)
		{
			for (int i = 0; i < BonesFixers.Count; i++)
			{
				BonesFixers[i].UpdateOnAnimator();
			}
		}
		if (connectors != null)
		{
			for (int j = 0; j < connectors.Count; j++)
			{
				connectors[j].RememberAnimatorState();
			}
		}
		ModelForwardAxisScaled = Vector3.Scale(ModelForwardAxis, BaseTransform.localScale);
		ModelUpAxisScaled = Vector3.Scale(ModelUpAxis, BaseTransform.localScale);
	}

	private void DeltaTimeCalculations()
	{
		switch (DeltaType)
		{
		case EFDeltaType.SafeDelta:
			delta = Mathf.Lerp(delta, GetClampedSmoothDelta(), 0.05f);
			break;
		case EFDeltaType.DeltaTime:
			delta = Time.deltaTime;
			break;
		case EFDeltaType.SmoothDeltaTime:
			delta = Time.smoothDeltaTime;
			break;
		case EFDeltaType.UnscaledDeltaTime:
			delta = Time.unscaledDeltaTime;
			break;
		case EFDeltaType.FixedDeltaTime:
			delta = Time.fixedDeltaTime;
			break;
		}
		unifiedDelta = Mathf.Pow(delta, 0.1f) * 0.04f;
	}

	private void StableUpdateRateCalculations()
	{
		updateLoops = 1;
		float num = 1f / UpdateRate;
		elapsedDeltaHelper += delta;
		updateLoops = 0;
		while (elapsedDeltaHelper >= num)
		{
			elapsedDeltaHelper -= num;
			if (++updateLoops >= 3)
			{
				elapsedDeltaHelper = 0f;
				break;
			}
		}
	}

	private void ApplyNewBonesCoordinates()
	{
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		if (SpineAnimatorAmount >= 1f)
		{
			SpineBones[leadingBoneIndex].transform.position = SpineBones[leadingBoneIndex].FinalPosition;
			SpineBones[leadingBoneIndex].transform.rotation = SpineBones[leadingBoneIndex].FinalRotation;
			for (int i = 1 - chainIndexOffset; i < SpineBones.Count - chainIndexOffset; i++)
			{
				SpineBones[i].transform.position = SpineBones[i].FinalPosition;
				SpineBones[i].transform.rotation = SpineBones[i].FinalRotation;
				SpineBones[i].RefreshFinalLocalPose();
			}
			SpineBones[leadingBoneIndex].RefreshFinalLocalPose();
		}
		else
		{
			SpineBones[leadingBoneIndex].transform.position = Vector3.LerpUnclamped(SpineBones[leadingBoneIndex].transform.position, SpineBones[leadingBoneIndex].FinalPosition, SpineAnimatorAmount * SpineBones[leadingBoneIndex].MotionWeight);
			SpineBones[leadingBoneIndex].transform.rotation = Quaternion.LerpUnclamped(SpineBones[leadingBoneIndex].transform.rotation, SpineBones[leadingBoneIndex].FinalRotation, SpineAnimatorAmount * SpineBones[leadingBoneIndex].MotionWeight);
			for (int j = 1 - chainIndexOffset; j < SpineBones.Count - chainIndexOffset; j++)
			{
				SpineBones[j].transform.position = Vector3.LerpUnclamped(SpineBones[j].transform.position, SpineBones[j].FinalPosition, SpineAnimatorAmount * SpineBones[j].MotionWeight);
				SpineBones[j].transform.rotation = Quaternion.LerpUnclamped(SpineBones[j].transform.rotation, SpineBones[j].FinalRotation, SpineAnimatorAmount * SpineBones[j].MotionWeight);
				SpineBones[j].RefreshFinalLocalPose();
			}
			SpineBones[leadingBoneIndex].RefreshFinalLocalPose();
		}
	}

	private void EndUpdate()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		previousPos = SpineBones[leadingBoneIndex].ProceduralPosition;
		if (connectors != null)
		{
			for (int i = 0; i < connectors.Count; i++)
			{
				connectors[i].RefreshAnimatorState();
			}
		}
		if (BonesFixers.Count > 0)
		{
			for (int j = 0; j < BonesFixers.Count; j++)
			{
				BonesFixers[j].UpdateAfterProcedural();
			}
		}
	}

	public void OnDrop(PointerEventData data)
	{
	}

	public Transform FindBaseTransform()
	{
		Transform result = ((Component)this).transform;
		Transform val = ((Component)this).transform.parent;
		FSpineAnimator fSpineAnimator = null;
		if ((Object)(object)val != (Object)null)
		{
			for (int i = 0; i < 32; i++)
			{
				Transform parent = val.parent;
				fSpineAnimator = ((Component)val).GetComponent<FSpineAnimator>();
				if (Object.op_Implicit((Object)(object)fSpineAnimator))
				{
					break;
				}
				val = parent;
				if ((Object)(object)parent == (Object)null)
				{
					break;
				}
			}
		}
		if ((Object)(object)fSpineAnimator != (Object)null)
		{
			result = ((!((Object)(object)fSpineAnimator.BaseTransform != (Object)null)) ? ((Component)fSpineAnimator).transform : fSpineAnimator.BaseTransform);
			if ((Object)(object)((Component)fSpineAnimator).transform != (Object)(object)((Component)this).transform)
			{
				UpdateAsLast = true;
			}
		}
		return result;
	}

	public SpineBone GetLeadingBone()
	{
		if (SpineBones == null || SpineBones.Count == 0)
		{
			return null;
		}
		if (LastBoneLeading)
		{
			return SpineBones[SpineBones.Count - 1];
		}
		return SpineBones[0];
	}

	public SpineBone GetEndBone()
	{
		if (SpineBones == null || SpineBones.Count == 0)
		{
			return null;
		}
		if (LastBoneLeading)
		{
			return SpineBones[0];
		}
		return SpineBones[SpineBones.Count - 1];
	}

	public Transform GetHeadBone()
	{
		if (SpineBones.Count <= 0)
		{
			return ((Component)this).transform;
		}
		if (LastBoneLeading)
		{
			return SpineBones[SpineBones.Count - 1].transform;
		}
		return SpineBones[0].transform;
	}

	public SpineBone GetLeadBone()
	{
		if (LastBoneLeading)
		{
			return SpineBones[SpineBones.Count - 1];
		}
		return SpineBones[0];
	}

	public Transform GetBaseTransform()
	{
		if ((Object)(object)BaseTransform == (Object)null)
		{
			return ((Component)this).transform;
		}
		return BaseTransform;
	}

	private Vector3 RoundPosDiff(Vector3 pos, int digits = 1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)Math.Round(pos.x, digits), (float)Math.Round(pos.y, digits), (float)Math.Round(pos.z, digits));
	}

	private Vector3 RoundToBiggestValue(Vector3 vec)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		if (Mathf.Abs(vec.y) > Mathf.Abs(vec.x))
		{
			num = 1;
			if (Mathf.Abs(vec.z) > Mathf.Abs(vec.y))
			{
				num = 2;
			}
		}
		else if (Mathf.Abs(vec.z) > Mathf.Abs(vec.x))
		{
			num = 2;
		}
		switch (num)
		{
		case 0:
			((Vector3)(ref vec))..ctor(Mathf.Round(vec.x), 0f, 0f);
			break;
		case 1:
			((Vector3)(ref vec))..ctor(0f, Mathf.Round(vec.y), 0f);
			break;
		default:
			((Vector3)(ref vec))..ctor(0f, 0f, Mathf.Round(vec.z));
			break;
		}
		return vec;
	}

	private float GetClampedSmoothDelta()
	{
		return Mathf.Clamp(Time.smoothDeltaTime, 0f, 0.1f);
	}

	public List<Transform> GetOldSpineTransforms()
	{
		return SpineTransforms;
	}

	public void ClearOldSpineTransforms()
	{
		if (SpineTransforms != null)
		{
			SpineTransforms.Clear();
		}
	}

	public void User_ChangeParameter(EParamChange parameter, float to, float transitionDuration, float executionDelay = 0f)
	{
		if (transitionDuration <= 0f && executionDelay <= 0f)
		{
			SetValue(parameter, to);
		}
		else
		{
			((MonoBehaviour)this).StartCoroutine(IEChangeValue(parameter, to, transitionDuration, executionDelay));
		}
	}

	public void User_ChangeParameterAndRestore(EParamChange parameter, float to, float transitionDuration, float restoreAfter = 0f)
	{
		float value = GetValue(parameter);
		((MonoBehaviour)this).StartCoroutine(IEChangeValue(parameter, to, transitionDuration, 0f));
		((MonoBehaviour)this).StartCoroutine(IEChangeValue(parameter, value, transitionDuration, transitionDuration + restoreAfter));
	}

	public void User_ResetBones()
	{
		_ResetBones();
	}

	private IEnumerator IEChangeValue(EParamChange param, float to, float duration, float executionDelay)
	{
		if (executionDelay > 0f)
		{
			yield return CoroutineEx.waitForSeconds(executionDelay);
		}
		if (duration > 0f)
		{
			float elapsed = 0f;
			float startVal = GetValue(param);
			while (elapsed < duration)
			{
				elapsed += Time.deltaTime;
				float num = elapsed / duration;
				if (num > 1f)
				{
					num = 1f;
				}
				SetValue(param, Mathf.LerpUnclamped(startVal, to, num));
				yield return null;
			}
		}
		SetValue(param, to);
	}

	private float GetValue(EParamChange param)
	{
		return param switch
		{
			EParamChange.GoBackSpeed => GoBackSpeed, 
			EParamChange.SpineAnimatorAmount => SpineAnimatorAmount, 
			EParamChange.AngleLimit => AngleLimit, 
			EParamChange.StraightenSpeed => StraightenSpeed, 
			EParamChange.PositionSmoother => PosSmoother, 
			EParamChange.RotationSmoother => RotSmoother, 
			_ => 0f, 
		};
	}

	private void SetValue(EParamChange param, float val)
	{
		switch (param)
		{
		case EParamChange.GoBackSpeed:
			GoBackSpeed = val;
			break;
		case EParamChange.SpineAnimatorAmount:
			SpineAnimatorAmount = val;
			break;
		case EParamChange.AngleLimit:
			AngleLimit = val;
			break;
		case EParamChange.StraightenSpeed:
			StraightenSpeed = val;
			break;
		case EParamChange.PositionSmoother:
			PosSmoother = val;
			break;
		case EParamChange.RotationSmoother:
			RotSmoother = val;
			break;
		}
	}

	private void _ResetBones()
	{
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!LastBoneLeading)
		{
			for (int num = SpineBones.Count - 1; num >= 0; num--)
			{
				SpineBones[num].ProceduralPosition = SpineBones[num].ReferencePosition;
				SpineBones[num].ProceduralRotation = SpineBones[num].ReferenceRotation;
				SpineBones[num].PreviousPosition = SpineBones[num].ReferencePosition;
				SpineBones[num].FinalPosition = SpineBones[num].ReferencePosition;
				SpineBones[num].FinalRotation = SpineBones[num].ReferenceRotation;
			}
		}
		else
		{
			for (int i = 0; i < SpineBones.Count; i++)
			{
				SpineBones[i].ProceduralPosition = SpineBones[i].ReferencePosition;
				SpineBones[i].ProceduralRotation = SpineBones[i].ReferenceRotation;
				SpineBones[i].PreviousPosition = SpineBones[i].ReferencePosition;
				SpineBones[i].FinalPosition = SpineBones[i].ReferencePosition;
				SpineBones[i].FinalRotation = SpineBones[i].ReferenceRotation;
			}
		}
		float goBackSpeed = GoBackSpeed;
		GoBackSpeed = 10f;
		Update();
		FixedUpdate();
		delta = 0.25f;
		LateUpdate();
		GoBackSpeed = goBackSpeed;
	}

	private void Reset()
	{
		BaseTransform = FindBaseTransform();
		_CheckedPivot = true;
	}

	private void Start()
	{
		if (UpdateAsLast)
		{
			((Behaviour)this).enabled = false;
			((Behaviour)this).enabled = true;
		}
		if ((Object)(object)BaseTransform == (Object)null)
		{
			BaseTransform = ((Component)this).transform;
		}
		initialized = false;
		if (PivotOffsetOnStart && (Object)(object)mainPivotOffsetTransform == (Object)null)
		{
			UpdatePivotOffsetState();
		}
		if (!StartAfterTPose)
		{
			Init();
		}
		else
		{
			initAfterTPoseCounter = 0;
		}
	}

	internal void Update()
	{
		TimeWarning val = TimeWarning.New("FSpineAnimator:Update", 0);
		try
		{
			if (!initialized)
			{
				if (!StartAfterTPose)
				{
					updateSpineAnimator = false;
					return;
				}
				if (initAfterTPoseCounter <= 5)
				{
					initAfterTPoseCounter++;
					updateSpineAnimator = false;
					return;
				}
				Init();
			}
			if ((Object)(object)OptimizeWithMesh != (Object)null && !OptimizeWithMesh.isVisible)
			{
				updateSpineAnimator = false;
				return;
			}
			if (delta <= Mathf.Epsilon)
			{
				updateSpineAnimator = false;
			}
			if (SpineBones.Count == 0)
			{
				Debug.LogError((object)("[SPINE ANIMATOR] No spine bones defined in " + ((Object)this).name + " !"));
				initialized = false;
				updateSpineAnimator = false;
				return;
			}
			if ((Object)(object)BaseTransform == (Object)null)
			{
				BaseTransform = ((Component)this).transform;
			}
			UpdateChainIndexHelperVariables();
			if (SpineAnimatorAmount <= 0.01f)
			{
				wasBlendedOut = true;
				updateSpineAnimator = false;
				return;
			}
			if (wasBlendedOut)
			{
				ReposeSpine();
				wasBlendedOut = false;
			}
			updateSpineAnimator = true;
			if (AnimatePhysics == EFixedMode.None)
			{
				PreCalibrateBones();
				callSpineReposeCalculations = true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal void FixedUpdate()
	{
		TimeWarning val = TimeWarning.New("FSpineAnimator:FixedUpdate", 0);
		try
		{
			if (updateSpineAnimator && AnimatePhysics == EFixedMode.Basic)
			{
				PreCalibrateBones();
				callSpineReposeCalculations = true;
				fixedUpdated = true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal void LateUpdate()
	{
		TimeWarning val = TimeWarning.New("FSpineAnimator:LateUpdate", 0);
		try
		{
			if (!updateSpineAnimator)
			{
				return;
			}
			if (AnimatePhysics == EFixedMode.Late)
			{
				if (!lateFixedIsRunning)
				{
					((MonoBehaviour)this).StartCoroutine(LateFixed());
				}
				if (fixedAllow)
				{
					fixedAllow = false;
					callSpineReposeCalculations = true;
				}
			}
			else
			{
				if (lateFixedIsRunning)
				{
					lateFixedIsRunning = false;
				}
				if (AnimatePhysics == EFixedMode.Basic)
				{
					if (!fixedUpdated)
					{
						return;
					}
					fixedUpdated = false;
				}
			}
			CalibrateBones();
			DeltaTimeCalculations();
			if (UpdateRate > 0f)
			{
				StableUpdateRateCalculations();
				unifiedDelta = delta;
				if (UseCorrections && ManualAffectChain)
				{
					if (updateLoops > 0)
					{
						PreMotionNoHead();
					}
					PreMotionHead();
				}
				RefreshReferencePose();
				BeginBaseBonesUpdate();
				for (int i = 0; i < updateLoops; i++)
				{
					BeginPhysicsUpdate();
					if (callSpineReposeCalculations)
					{
						CalculateBonesCoordinates();
					}
				}
				if (UseCorrections && !ManualAffectChain && callSpineReposeCalculations)
				{
					if (updateLoops > 0)
					{
						PostMotionNoHead();
					}
					PostMotionHead();
				}
				if (callSpineReposeCalculations)
				{
					callSpineReposeCalculations = false;
				}
			}
			else
			{
				RefreshReferencePose();
				PreMotionBoneOffsets();
				BeginPhysicsUpdate();
				BeginBaseBonesUpdate();
				if (callSpineReposeCalculations)
				{
					CalculateBonesCoordinates();
					PostMotionBoneOffsets();
					callSpineReposeCalculations = false;
				}
			}
			ApplyNewBonesCoordinates();
			EndUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}
