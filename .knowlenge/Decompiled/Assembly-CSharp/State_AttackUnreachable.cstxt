using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.AI;

[SoftRequireComponent(typeof(RootMotionPlayer))]
[SoftRequireComponent(typeof(LimitedTurnNavAgent))]
public class State_AttackUnreachable : FSMStateBase
{
	public AnimationClip animClip;

	public float duration = 0.75f;

	public float apexHeight;

	public float damage = 35f;

	public DamageType damageType = DamageType.Bite;

	public float groundCheckDistance = 2f;

	private Vector3 startLocation;

	private Vector3 destination;

	private float startTime;

	private bool goingBack;

	private LockState.LockHandle targetLock;

	private LockState.LockHandle movementLock;

	public override EFSMStateStatus OnStateEnter()
	{
		if (!Owner.FindTarget(out var target) || !(target is BasePlayer basePlayer))
		{
			return EFSMStateStatus.Failure;
		}
		destination = target.transform.position;
		if (!basePlayer.IsOnGround() && !base.Agent.SampleGroundPositionWithPhysics(target.transform.position, out destination, groundCheckDistance))
		{
			return EFSMStateStatus.Failure;
		}
		if (!State_MoveToLastReachablePointNearTarget.CanJumpFromPosToPos(Owner, Owner.transform.position, destination))
		{
			return EFSMStateStatus.Failure;
		}
		movementLock = base.Agent.Pause();
		Owner.GetComponent<NavMeshAgent>().enabled = false;
		startLocation = Owner.transform.position;
		startTime = Time.time;
		goingBack = false;
		Owner.transform.rotation = Quaternion.LookRotation((destination - startLocation).WithY(0f));
		targetLock = base.Senses.LockCurrentTarget();
		base.AnimPlayer.PlayServer(animClip);
		return base.OnStateEnter();
	}

	public override EFSMStateStatus OnStateUpdate(float deltaTime)
	{
		float num = (Time.time - startTime) / Mathf.Max(duration, 0.001f);
		if (num >= 1f && !goingBack)
		{
			goingBack = true;
			startTime += duration;
			num -= 1f;
			Vector3 vector = destination;
			destination = startLocation;
			startLocation = vector;
			Owner.transform.rotation = Quaternion.LookRotation((destination - startLocation).WithY(0f));
			if (Owner.FindTarget(out var target) && target is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.Hurt(damage, damageType, Owner);
			}
			base.AnimPlayer.StopServer();
			base.AnimPlayer.PlayServer(animClip);
		}
		else if (num >= 1f)
		{
			return EFSMStateStatus.Success;
		}
		Vector3 vector2 = Vector3.Lerp(startLocation, destination, 0.5f) + Vector3.up * (apexHeight + Mathf.Abs(destination.y - startLocation.y));
		Vector3 a = Vector3.Lerp(startLocation, vector2, num);
		Vector3 b = Vector3.Lerp(vector2, destination, num);
		Vector3 position = Vector3.Lerp(a, b, num);
		Owner.transform.position = position;
		return base.OnStateUpdate(deltaTime);
	}

	public override void OnStateExit()
	{
		Owner.GetComponent<NavMeshAgent>().enabled = true;
		base.Senses.UnlockTarget(ref targetLock);
		base.Agent.Unpause(ref movementLock);
	}
}
