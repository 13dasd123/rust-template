using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ElectricBattery : IOEntity
{
	public int maxOutput;

	public float maxCapactiySeconds;

	public float capacitySeconds;

	public bool rechargable;

	public float chargeRatio = 0.25f;

	private const float tickRateSeconds = 1f;

	public override bool IsRootEntity()
	{
		return true;
	}

	public override void SendAdditionalData(BasePlayer player)
	{
		float arg = 0f;
		ClientRPCPlayer(null, player, "Client_ReceiveAdditionalData", currentEnergy, GetPassthroughAmount(), capacitySeconds, arg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		InvokeRandomized(CheckDischarge, Random.Range(0f, 1f), 1f, 0.1f);
	}

	public void CheckDischarge()
	{
		IOEntity iOEntity = outputs[0].connectedTo.Get();
		if ((bool)iOEntity)
		{
			SetDischarging(iOEntity.WantsPower());
		}
		else
		{
			SetDischarging(wantsOn: false);
		}
	}

	public void SetDischarging(bool wantsOn)
	{
		SetPassthroughOn(wantsOn);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		if (IsOn())
		{
			return Mathf.FloorToInt((float)maxOutput * ((!(capacitySeconds >= 1f)) ? 0f : 1f));
		}
		return 0;
	}

	public override bool WantsPower()
	{
		return capacitySeconds < maxCapactiySeconds;
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (inputSlot != 0)
		{
			return;
		}
		if (!IsPowered())
		{
			if (rechargable)
			{
				CancelInvoke(AddCharge);
			}
		}
		else if (rechargable && !IsInvoking(AddCharge))
		{
			InvokeRandomized(AddCharge, 1f, 1f, 0.1f);
		}
	}

	public void TickUsage()
	{
		bool flag = capacitySeconds > 0f;
		if (capacitySeconds >= 1f)
		{
			capacitySeconds -= 1f;
		}
		if (capacitySeconds <= 0f)
		{
			capacitySeconds = 0f;
			if (flag)
			{
				MarkDirty();
				SendNetworkUpdate();
			}
		}
	}

	public void AddCharge()
	{
		float num = Mathf.InverseLerp(0f, maxOutput, currentEnergy);
		capacitySeconds += 1f * num * chargeRatio;
		capacitySeconds = Mathf.Clamp(capacitySeconds, 0f, maxCapactiySeconds);
	}

	public void SetPassthroughOn(bool wantsOn)
	{
		if (wantsOn == IsOn())
		{
			return;
		}
		SetFlag(Flags.On, wantsOn);
		if (IsOn())
		{
			if (!IsInvoking(TickUsage))
			{
				InvokeRandomized(TickUsage, 1f, 1f, 0.1f);
			}
		}
		else
		{
			CancelInvoke(TickUsage);
		}
		MarkDirty();
	}

	public void Unbusy()
	{
		SetFlag(Flags.Busy, b: false);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.ioEntity == null)
		{
			info.msg.ioEntity = Pool.Get<ProtoBuf.IOEntity>();
		}
		info.msg.ioEntity.genericFloat1 = capacitySeconds;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.ioEntity != null)
		{
			capacitySeconds = info.msg.ioEntity.genericFloat1;
		}
	}
}
