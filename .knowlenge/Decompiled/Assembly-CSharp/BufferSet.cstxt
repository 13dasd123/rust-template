using System;
using RustNative;
using UnityEngine;

public class BufferSet
{
	public ComputeBuffer inputBuffer;

	public ComputeBuffer resultBuffer;

	public int width;

	public int height;

	public int capacity;

	public int count;

	public Texture2D inputTexture;

	public RenderTexture resultTexture;

	public Texture2D resultReadTexture;

	public IntPtr readbackInst = IntPtr.Zero;

	public Color[] inputData = new Color[0];

	public Color32[] resultData = new Color32[0];

	private bool usingFallback = true;

	private Material fallbackMat;

	private ComputeShader compute;

	public void Attach(Material fallbackMat)
	{
		this.fallbackMat = fallbackMat;
		usingFallback = true;
	}

	public void Attach(ComputeShader computeShader)
	{
		compute = computeShader;
		usingFallback = false;
	}

	public void Dispose(bool data = true)
	{
		if (inputBuffer != null)
		{
			inputBuffer.Dispose();
			inputBuffer = null;
		}
		if (resultBuffer != null)
		{
			resultBuffer.Dispose();
			resultBuffer = null;
		}
		if (inputTexture != null)
		{
			UnityEngine.Object.DestroyImmediate(inputTexture);
			inputTexture = null;
		}
		if (resultTexture != null)
		{
			RenderTexture.active = null;
			UnityEngine.Object.DestroyImmediate(resultTexture);
			resultTexture = null;
		}
		if (resultReadTexture != null)
		{
			UnityEngine.Object.DestroyImmediate(resultReadTexture);
			resultReadTexture = null;
		}
		if (readbackInst != IntPtr.Zero)
		{
			RustNative.Graphics.BufferReadback.Destroy(readbackInst);
			readbackInst = IntPtr.Zero;
		}
		if (data)
		{
			inputData = new Color[0];
			resultData = new Color32[0];
			capacity = 0;
			count = 0;
		}
	}

	public bool CheckResize(int count, int granularity)
	{
		if (count > capacity || (usingFallback && resultTexture != null && !resultTexture.IsCreated()))
		{
			Dispose(data: false);
			int num = count / granularity * granularity + granularity;
			if (usingFallback)
			{
				width = Mathf.CeilToInt(Mathf.Sqrt(num));
				height = Mathf.CeilToInt((float)num / (float)width);
				inputTexture = new Texture2D(width, height, TextureFormat.RGBAFloat, mipmap: false, linear: true);
				inputTexture.name = "_Input";
				inputTexture.filterMode = FilterMode.Point;
				inputTexture.wrapMode = TextureWrapMode.Clamp;
				resultTexture = new RenderTexture(width, height, 0, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Linear);
				resultTexture.name = "_Result";
				resultTexture.filterMode = FilterMode.Point;
				resultTexture.wrapMode = TextureWrapMode.Clamp;
				resultTexture.useMipMap = false;
				resultTexture.Create();
				resultReadTexture = new Texture2D(width, height, TextureFormat.ARGB32, mipmap: false, linear: true);
				resultReadTexture.name = "_ResultRead";
				resultReadTexture.filterMode = FilterMode.Point;
				resultReadTexture.wrapMode = TextureWrapMode.Clamp;
				readbackInst = RustNative.Graphics.BufferReadback.CreateForTexture(resultTexture.GetNativeTexturePtr(), (uint)width, (uint)height, (uint)resultTexture.format);
				capacity = width * height;
			}
			else
			{
				inputBuffer = new ComputeBuffer(num, 16);
				resultBuffer = new ComputeBuffer(num, 4);
				uint size = (uint)(num * 4);
				readbackInst = RustNative.Graphics.BufferReadback.CreateForBuffer(resultBuffer.GetNativeBufferPtr(), size);
				capacity = num;
			}
			Array.Resize(ref inputData, capacity);
			Array.Resize(ref resultData, capacity);
			this.count = count;
			return true;
		}
		return false;
	}

	public void UploadData()
	{
		if (usingFallback)
		{
			inputTexture.SetPixels(inputData);
			inputTexture.Apply();
		}
		else
		{
			inputBuffer.SetData(inputData);
		}
	}

	private int AlignDispatchSize(int dispatchSize)
	{
		return (dispatchSize + 63) / 64;
	}

	public void Dispatch(int count)
	{
		if (usingFallback)
		{
			RenderBuffer activeColorBuffer = UnityEngine.Graphics.activeColorBuffer;
			RenderBuffer activeDepthBuffer = UnityEngine.Graphics.activeDepthBuffer;
			fallbackMat.SetTexture("_Input", inputTexture);
			UnityEngine.Graphics.Blit(inputTexture, resultTexture, fallbackMat, 0);
			UnityEngine.Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		}
		else
		{
			compute.SetBuffer(0, "_Input", inputBuffer);
			compute.SetBuffer(0, "_Result", resultBuffer);
			compute.Dispatch(0, AlignDispatchSize(count), 1, 1);
		}
	}

	public void IssueRead()
	{
		if (!SafeMode)
		{
			RustNative.Graphics.BufferReadback.IssueRead(readbackInst);
		}
	}

	public void GetResults()
	{
		if (!SafeMode)
		{
			RustNative.Graphics.BufferReadback.GetData(readbackInst, ref resultData[0]);
		}
		else if (usingFallback)
		{
			RenderTexture.active = resultTexture;
			resultReadTexture.ReadPixels(new Rect(0f, 0f, width, height), 0, 0);
			resultReadTexture.Apply();
			Color32[] pixels = resultReadTexture.GetPixels32();
			Array.Copy(pixels, resultData, resultData.Length);
		}
		else
		{
			resultBuffer.GetData(resultData);
		}
	}
}
