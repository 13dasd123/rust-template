using System;
using System.Collections.Generic;
using UnityEngine;

public static class FileSystem
{
	public struct Operation
	{
		private string path;

		private AsyncOperation request;

		public bool isDone => request == null || request.isDone;

		public float progress => (request == null) ? 1f : request.progress;

		public Operation(string path, AsyncOperation request)
		{
			this.path = path;
			this.request = request;
		}

		public static implicit operator AsyncOperation(Operation op)
		{
			return op.request;
		}

		public T Load<T>() where T : UnityEngine.Object
		{
			T result = (T)null;
			if (!isDone)
			{
				return result;
			}
			if (cache.ContainsKey(path))
			{
				result = cache[path] as T;
			}
			else if (request is AssetBundleRequest assetBundleRequest && assetBundleRequest.asset != null)
			{
				cache.Add(path, assetBundleRequest.asset);
				result = assetBundleRequest.asset as T;
			}
			return result;
		}
	}

	public static IFileSystem iface = null;

	public static Dictionary<string, UnityEngine.Object> cache = new Dictionary<string, UnityEngine.Object>();

	public static GameObject[] LoadPrefabs(string folder)
	{
		if (!folder.EndsWith("/"))
		{
			Debug.LogWarning("FileSystem.LoadPrefabs - folder should end in '/' - " + folder);
		}
		if (!folder.StartsWith("assets/"))
		{
			Debug.LogWarning("FileSystem.LoadPrefabs - should start with assets/ - " + folder);
		}
		return LoadAll<GameObject>(folder, ".prefab");
	}

	public static GameObject LoadPrefab(string filePath)
	{
		if (!filePath.StartsWith("assets/", StringComparison.CurrentCultureIgnoreCase))
		{
			Debug.LogWarning("FileSystem.LoadPrefab - should start with assets/ - " + filePath);
		}
		return Load<GameObject>(filePath);
	}

	public static string[] FindAll(string folder, string search = "")
	{
		return iface.FindAll(folder, search);
	}

	public static T[] LoadAll<T>(string folder, string search = "") where T : UnityEngine.Object
	{
		List<T> list = new List<T>();
		string[] array = FindAll(folder, search);
		foreach (string filePath in array)
		{
			T val = Load<T>(filePath);
			if (val != null)
			{
				list.Add(val);
			}
		}
		return list.ToArray();
	}

	public static T Load<T>(string filePath, bool bComplain = true) where T : UnityEngine.Object
	{
		filePath = filePath.ToLower();
		T val = (T)null;
		if (cache.ContainsKey(filePath))
		{
			val = cache[filePath] as T;
		}
		else
		{
			val = iface.Load<T>(filePath, bComplain);
			if (val != null)
			{
				cache.Add(filePath, val);
			}
		}
		return val;
	}

	public static Operation LoadAsync(string filePath)
	{
		filePath = filePath.ToLower();
		return (!cache.ContainsKey(filePath)) ? new Operation(filePath, iface.LoadAsync(filePath)) : new Operation(filePath, null);
	}
}
