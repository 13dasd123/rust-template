using System;
using System.Collections;
using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FLook;
using FIMSpace.FTools;
using UnityEngine;
using UnityEngine.EventSystems;

[DefaultExecutionOrder(-10)]
[AddComponentMenu("FImpossible Creations/Look Animator 2")]
public class FLookAnimator : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon, IClientComponent
{
	[Serializable]
	public class CompensationBone
	{
		public Transform Transform;

		private Vector3 compensatedPosition;

		private Quaternion compensatedRotation;

		private Quaternion lastFinalLocalRotation;

		private Quaternion lastKeyframeLocalRotation;

		private Vector3 lastFinalLocalPosition;

		private Vector3 lastKeyframeLocalPosition;

		public CompensationBone(Transform t)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			Transform = t;
			if (Object.op_Implicit((Object)(object)t))
			{
				lastKeyframeLocalPosition = t.localPosition;
				lastKeyframeLocalRotation = t.localRotation;
			}
		}

		public void RefreshCompensationFrame()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			compensatedPosition = Transform.position;
			compensatedRotation = Transform.rotation;
		}

		public void CheckForZeroKeyframes()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			if (lastFinalLocalRotation.QIsSame(Transform.localRotation))
			{
				Transform.localRotation = lastKeyframeLocalRotation;
				compensatedRotation = Transform.rotation;
			}
			else
			{
				lastKeyframeLocalRotation = Transform.localRotation;
			}
			if (lastFinalLocalPosition.VIsSame(Transform.localPosition))
			{
				Transform.localPosition = lastKeyframeLocalPosition;
				compensatedPosition = Transform.position;
			}
			else
			{
				lastKeyframeLocalPosition = Transform.localPosition;
			}
		}

		public void SetRotationCompensation(float weight)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			if (weight > 0f)
			{
				if (weight >= 1f)
				{
					Transform.rotation = compensatedRotation;
				}
				else
				{
					Transform.rotation = Quaternion.LerpUnclamped(Transform.rotation, compensatedRotation, weight);
				}
				lastFinalLocalRotation = Transform.localRotation;
			}
		}

		public void SetPositionCompensation(float weight)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			if (weight > 0f)
			{
				if (weight >= 1f)
				{
					Transform.position = compensatedPosition;
				}
				else
				{
					Transform.position = Vector3.LerpUnclamped(Transform.position, compensatedPosition, weight);
				}
				lastFinalLocalPosition = Transform.localPosition;
			}
		}
	}

	[Serializable]
	public class LookBone
	{
		public Transform Transform;

		public Quaternion animatedStaticRotation;

		public Quaternion targetStaticRotation;

		public Quaternion localStaticRotation;

		public Quaternion animatedTargetRotation;

		public Quaternion targetRotation;

		public Vector3 correctionOffset;

		public Quaternion finalRotation;

		public Quaternion lastKeyframeRotation;

		public Quaternion lastFinalLocalRotation;

		public Vector3 forward;

		public Vector3 right;

		public Vector3 up;

		public Vector3 initLocalPos = Vector3.zero;

		public Quaternion initLocalRot = Quaternion.identity;

		public Vector3 targetDelayPosition;

		public Vector3 animatedDelayPosition;

		public float lookWeight = 1f;

		public float lookWeightB = 1f;

		public float motionWeight = 1f;

		public Quaternion correctionOffsetQ => Quaternion.Euler(correctionOffset);

		public LookBone(Transform t)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			Transform = t;
			correctionOffset = Vector3.zero;
			if ((Object)(object)t != (Object)null)
			{
				initLocalPos = t.localPosition;
				initLocalRot = t.localRotation;
			}
		}

		public void RefreshBoneDirections(Transform baseTransform)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)Transform == (Object)null))
			{
				forward = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.forward), Vector3.forward) * Vector3.forward;
				up = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.up), Vector3.up) * Vector3.up;
				right = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.right), Vector3.right) * Vector3.right;
			}
		}

		public void RefreshStaticRotation(bool hard = true)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			targetStaticRotation = Transform.rotation;
			if (initLocalPos == Vector3.zero)
			{
				initLocalPos = Transform.localPosition;
			}
			if (hard)
			{
				animatedStaticRotation = targetStaticRotation;
			}
			localStaticRotation = Transform.localRotation;
		}

		internal void CalculateMotion(Quaternion targetLook, float overallWeightMultiplier, float delta, float mainWeight)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			targetRotation = GetTargetRot(targetLook, motionWeight * overallWeightMultiplier);
			if (delta < 1f)
			{
				animatedTargetRotation = Quaternion.LerpUnclamped(animatedTargetRotation, targetRotation, delta);
			}
			else
			{
				animatedTargetRotation = targetRotation;
			}
			finalRotation = Quaternion.LerpUnclamped(Transform.rotation, animatedTargetRotation * Transform.rotation, mainWeight);
		}

		internal Quaternion GetTargetRot(Quaternion targetLook, float weight)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Quaternion.LerpUnclamped(Quaternion.identity, targetLook, weight);
		}
	}

	public enum EEditorLookCategory
	{
		Setup,
		Tweak,
		Limit,
		Features,
		Corrections
	}

	public enum EFAxisFixOrder
	{
		Parental,
		FromBased,
		FullManual,
		ZYX
	}

	public enum EFHeadLookState
	{
		Null,
		Following,
		OutOfMaxRotation,
		ClampedAngle,
		OutOfMaxDistance
	}

	public enum EFFollowMode
	{
		FollowObject,
		LocalOffset,
		WorldOffset,
		ToFollowSpaceOffset,
		FollowJustPosition
	}

	public enum EFDeltaType
	{
		DeltaTime,
		SmoothDeltaTime,
		UnscaledDeltaTime,
		FixedDeltaTime
	}

	public enum EFAnimationStyle
	{
		SmoothDamp,
		FastLerp,
		Linear
	}

	private GameObject generatedMomentTarget;

	private bool wasMomentLookTransform;

	[Tooltip("Enabling laggy movement for head and delaying position")]
	public bool BirdMode;

	private bool birdModeInitialized;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Bird mode laggy movement for neck amount, lowering this value will cause crossfade motion of laggy movement and basic follow rotation")]
	public float LagRotation = 0.85f;

	[Tooltip("How often should be acquired new target position for laggy movement, time to trigger it will be slightly randomized")]
	[FPD_Suffix(0.1f, 1f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	public float LagEvery = 0.285f;

	[FPD_Percentage(0f, 1f, false, true, "%", false)]
	[Tooltip("Bird mode keeping previous position until distance is reached")]
	public float DelayPosition;

	[Tooltip("How far distance to go back should have head to move (remind movement of pigeons to yourself)")]
	public float DelayMaxDistance = 0.25111f;

	[Tooltip("How quick head and neck should go back to right position after reaching distance")]
	[Range(0f, 1f)]
	public float DelayGoSpeed = 0.6f;

	public Vector3 BirdTargetPosition = Vector3.forward;

	private Vector3 birdTargetPositionMemory = Vector3.forward;

	private float lagTimer;

	private float preWeightFaloff = -1f;

	private float[] baseWeights;

	private float[] targetWeights;

	public bool UseEyes;

	[Tooltip("Target on which eyes will look, set to null if target should be the same as for head target")]
	public Transform EyesTarget;

	[Space(4f)]
	[Tooltip("Eyes transforms / bones (origin should be in center of the sphere")]
	public Transform LeftEye;

	public bool InvertLeftEye;

	[Tooltip("Eyes transforms / bones (origin should be in center of the sphere")]
	public Transform RightEye;

	public bool InvertRightEye;

	[Tooltip("Look clamping reference rotation transform, mostly parent of eye objects. If nothing is assigned then algorithm will use 'Lead Bone' as reference.")]
	public Transform HeadReference;

	public Vector3 EyesOffsetRotation;

	public Vector3 LeftEyeOffsetRotation = Vector3.zero;

	public Vector3 RightEyeOffsetRotation = Vector3.zero;

	[Tooltip("How fast eyes should follow target")]
	[Range(0f, 1f)]
	public float EyesSpeed = 0.5f;

	[FPD_Percentage(0f, 1f, false, true, "%", false)]
	public float EyesBlend = 1f;

	[Tooltip("In what angle eyes should go back to deafult position")]
	[Range(0f, 180f)]
	public Vector2 EyesXRange = new Vector2(-60f, 60f);

	public Vector2 EyesYRange = new Vector2(-50f, 50f);

	[Tooltip("If your eyes don't have baked keyframes in animation this value should be enabled, otherwise eyes would go crazy")]
	public bool EyesNoKeyframes = true;

	public bool CustomEyesLogics;

	private float EyesOutOfRangeBlend = 1f;

	private Transform[] eyes;

	private Vector3[] eyeForwards;

	private Quaternion[] eyesInitLocalRotations;

	private Quaternion[] eyesLerpRotations;

	private float _eyesBlend;

	private Vector3 headForward;

	[Tooltip("When switching targets character will make small nod to make it look more natural, set higher value for toony effect")]
	[Range(-1f, 1f)]
	public float NoddingTransitions;

	public Vector3 NodAxis = Vector3.right;

	[Tooltip("Set zero to use only leading bone, set -1 to 1 to spread this motion over backbones")]
	[Range(-1f, 1f)]
	public float BackBonesNod = 0.15f;

	private float nodProgress;

	private float nodValue;

	private float nodPower;

	private float nodDuration = 1f;

	private float smoothingTimer;

	private float smoothingPower = 1f;

	private float smoothingTime = 1f;

	private float smoothingEffect = 1f;

	public int ParentalOffsetsV = 2;

	private Vector3 lookFreezeFocusPoint;

	private Vector3 smoothLookPosition = Vector3.zero;

	private Vector3 _velo_smoothLookPosition = Vector3.zero;

	private Vector3 finalLookPosition = Vector3.zero;

	private bool usingAxisCorrection;

	private Matrix4x4 axisCorrectionMatrix;

	private float delta;

	[Tooltip("If your neck bones are rotated in a wrong way, you can try putting here parent game object of last back bone in chain")]
	public Transform ParentalReferenceBone;

	private Quaternion _parentalBackParentRot;

	private Vector2 _parentalAngles = Vector2.zero;

	private bool animatePhysicsWorking;

	private bool triggerAnimatePhysics;

	private int startAfterTPoseCounter;

	private Vector3 unclampedLookAngles = Vector3.zero;

	private Vector3 targetLookAngles = Vector3.zero;

	private Vector3 animatedLookAngles = Vector3.zero;

	private Vector3 finalLookAngles = Vector3.zero;

	private Quaternion lastBaseRotation;

	private Vector3 _preLookAboveLookAngles = Vector3.zero;

	private Vector3 _velo_animatedLookAngles = Vector3.zero;

	private float _rememberSideLookHorizontalAngle;

	private Vector3 leadBoneInitLocalOffset = Vector3.zero;

	private EFHeadLookState previousState;

	private bool _stopLooking;

	private Transform activeLookTarget;

	private Vector3 activeLookPosition;

	private Transform preActiveLookTarget;

	private bool isLooking;

	[Tooltip("If moment transform should be destroyed when max distance range is exceed")]
	public bool DestroyMomentTargetOnMaxDistance = true;

	private float whenAboveGoBackDuration;

	private float whenAboveGoBackTimer;

	private float _whenAboveGoBackVelo;

	private float _whenAboveGoBackVerticalVelo;

	private Vector2 whenAboveGoBackAngles;

	[Range(0f, 1f)]
	[Tooltip("If you want to remove animator's keyframes and replace them by look animation")]
	public float OverrideRotations;

	private bool overrideRefInitialized;

	private UniRotateBone headOv;

	private int lastClipHash;

	private bool refreshReferencePose;

	private float monitorTransitionTime = 0.8f;

	private List<Quaternion> _monitorTransitionStart;

	public int BackBonesCount;

	public int _preBackBonesCount;

	public List<LookBone> LookBones;

	[Tooltip("When target to follow is null then head will stop moving instead of going back to look in forward direction")]
	public bool NoTargetHeadStops;

	private Quaternion targetLookRotation;

	private float finalMotionWeight = 1f;

	private float animatedMotionWeight = 1f;

	private float _velo_animatedMotionWeight = 1f;

	private float changeTargetSmootherWeight;

	private float changeTargetSmootherBones;

	private Vector3 preLookDir;

	public bool _editor_hideEyes;

	public string _editor_displayName = "Look Animator 2";

	public EEditorLookCategory _Editor_Category;

	[Tooltip("Lead / Head bone - head of look chain")]
	public Transform LeadBone;

	[Tooltip("Base root transform - object which moves / rotates - character transform / game object")]
	public Transform BaseTransform;

	[Tooltip("Faloff value of how weight of animation should be spread over bones")]
	public float FaloffValue = 0.35f;

	public float FaloffValueB = 1.1f;

	[Tooltip("When character is looking far back in big angle or far high, you can automate weights falloff value")]
	public bool BigAngleAutomation;

	[Tooltip("When character is looking far back in big angle or far high, you can automate compensation values")]
	public bool BigAngleAutomationCompensation;

	[Tooltip("If bone weights spread should be computed automatically or by hand")]
	public bool AutoBackbonesWeights = true;

	[Tooltip("When you want use curve for more custom falloff or define it by simple slider - 'FaloffValue'")]
	public bool CurveSpread;

	[Tooltip("Configurable rotation weight placed over back bones - when you will use for example spine bones, here you can define how much will they rotate towards target in reference to other animated bones")]
	public AnimationCurve BackBonesFalloff = AnimationCurve.Linear(0f, 1f, 1f, 0.1f);

	[Header("If you don't want arms to be rotated when spine", order = 1)]
	[Header("bone is rotated by script (drag & drop here)", order = 3)]
	public List<CompensationBone> CompensationBones = new List<CompensationBone>();

	[Range(0f, 1f)]
	public float CompensationWeight = 0.5f;

	[Range(0f, 1f)]
	public float CompensationWeightB = 0.5f;

	[Range(0f, 1f)]
	public float CompensatePositions;

	[Range(0f, 1f)]
	public float CompensatePositionsB;

	private float targetCompensationWeight = 0.5f;

	private float targetCompensationPosWeight;

	[Tooltip("Making script start after first frame so initialization will not catch TPose initial bones rotations, which can cause some wrong offsets for rotations")]
	public bool StartAfterTPose = true;

	[Tooltip("Update with waiting for fixed update clock")]
	public bool AnimatePhysics;

	[Tooltip("If you want look animator to stop computing when choosed mesh is not visible in any camera view (editor's scene camera is detecting it too)")]
	public Renderer OptimizeWithMesh;

	[Tooltip("Object which will be main target of look.\n\nYou can use feature called 'Moment Target' to look at other object for a moment then look back on ObjectToFollow - check LookAnimator.SetMomentLookTarget()")]
	public Transform ObjectToFollow;

	[Tooltip("Position offset on 'ObjectToFollow'")]
	public Vector3 FollowOffset;

	[Tooltip("If 'FollowOffset' should be world position translation\n\nor target object local space translation\n\nor we don't want to use ObjectToFollow and use just 'FollowOffset' position.")]
	public EFFollowMode FollowMode;

	[Range(0f, 2.5f)]
	[Tooltip("How fast character should rotate towards focus direction.\n\nRotationSpeed = 2.5 -> Instant rotation\n\nIt is speed of transition for look direction (no bones rotations smoothing)")]
	public float RotationSpeed = 0.65f;

	private bool instantRotation;

	[Range(0f, 1f)]
	[Tooltip("This variable is making rotation animation become very smooth (but also slower).\nIt is enabling smooth rotation transition in bone rotations")]
	public float UltraSmoother;

	[Range(25f, 180f)]
	[Tooltip("If target is too much after transform's back we smooth rotating head back to default animation's rotation")]
	[Header("Look forward if this angle is exceeded", order = 1)]
	public float StopLookingAbove = 180f;

	[Tooltip("If object in rotation range should be detected only when is nearer than 'StopLookingAbove' to avoid stuttery target changes")]
	[Range(0.1f, 1f)]
	public float StopLookingAboveFactor = 1f;

	[Range(0f, 1f)]
	[Tooltip("If your character moves head too fast when loosing / changing target, here you can adjust it")]
	public float ChangeTargetSmoothing;

	[Tooltip("Switch to enable advanced settings for back bones falloff")]
	public bool AdvancedFalloff;

	[Tooltip("Max distance to target object to lost interest in it.\nValue = 0 -> Not using distance limits.\nWhen you have moment target - after exceeding distance moment target will be forgotten!")]
	public float MaximumDistance;

	[Tooltip("When Character is looking at something on his back but more on his right he look to right, when target suddenly goes more on his left and again to right very frequently you can set with this variable range from which rotating head to opposide shoulder side should be triggered to prevent strange looking behaviour when looking at dynamic objects")]
	[FPD_Suffix(0f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float HoldRotateToOppositeUntil;

	[Range(0f, 1f)]
	[Tooltip("If object in range should be detected only when is nearer than 'MaxDistance' to avoid stuttery target changes")]
	public float MaxOutDistanceFactor;

	[Tooltip("If distance should be measured not using Up (y) axis")]
	public bool Distance2D;

	[Tooltip("Offsetting point from which we want to measure distance to target")]
	public Vector3 DistanceMeasurePoint;

	[FPD_Suffix(0f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("Minimum angle needed to trigger head follow movement. Can be useful to make eyes move first and then head when angle is bigger")]
	public float LookWhenAbove;

	private float animatedLookWhenAbove;

	[Tooltip("Separated start look angle for vertical look axis\n\nWhen Zero it will have same value as 'LookWhenAbove'")]
	[FPD_Suffix(0f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float LookWhenAboveVertical;

	private float animatedLookWhenAboveVertical;

	[FPD_Suffix(0f, 3f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	[Tooltip("Head going back looking in front of target after this amount of seconds")]
	public float WhenAboveGoBackAfter;

	[Tooltip("Head going back looking in front of target after this amount of seconds")]
	[FPD_Suffix(0f, 3f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	public float WhenAboveGoBackAfterVertical;

	[FPD_Suffix(0.05f, 1f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	[Tooltip("Head going back looking in front of target after this amount of seconds")]
	public float WhenAboveGoBackDuration = 0.2f;

	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("Rotating towards target slower when target don't need much angle to look at")]
	public float StartLookElasticRangeX;

	[Tooltip("Separated elastic start angle for vertical look axis\n\nIf zero then value will be same like 'StartLookElasticRange'")]
	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float StartLookElasticRangeY;

	[Header("Limits for rotation | Horizontal: X Vertical: Y")]
	public Vector2 XRotationLimits = new Vector2(-80f, 80f);

	[FPD_Suffix(0f, 60f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("Making clamp ranges elastic, so when it starts to reach clamp value it slows like muscles needs more effort")]
	public float XElasticRange = 20f;

	[Tooltip("When head want go back to default state of looking, it will blend with default animation instead of changing values of rotation variables to go back")]
	public bool LimitHolder = true;

	public Vector2 YRotationLimits = new Vector2(-50f, 50f);

	[FPD_Suffix(0f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("Making clamp ranges elastic, so when it starts to reach clamp value it slows like muscles needs more effort")]
	public float YElasticRange = 15f;

	[FPD_Percentage(0f, 1f, false, true, "%", false)]
	[Tooltip("You can use this variable to blend intensity of look animator motion over skeleton animation\n\nValue = 1: Animation with Look Animator motion\nValue = 0: Only skeleton animation")]
	public float LookAnimatorAmount = 1f;

	[Tooltip("If head look seems to be calculated like it is not looking from center of head but far from bottom or over it - you can adjust it - check scene view gizmos")]
	public Vector3 StartLookPointOffset;

	[Tooltip("Freezes reference start look position in x and z axes to avoid re-reaching max rotation limits when hips etc. are rotating in animation clip.\n\nIf your character is crouching or so, you would like to have this parameter disabled")]
	public bool AnchorStartLookPoint = true;

	[Tooltip("In some cases you'll want to refresh anchor position during gameplay to make it more fitting to character's animation poses")]
	public bool RefreshStartLookPoint = true;

	[Tooltip("[When some of your bones are rotating making circles]\n\nDon't set hard rotations for bones, use animation rotation and add rotation offset to bones so animation's rotations are animated correctly (useful when using attack animations for example)")]
	public bool SyncWithAnimator = true;

	[Tooltip("When using above action, we need to keep remembered rotations of animation clip from first frame, with monitoring we will remember root rotations from each new animation played")]
	public bool MonitorAnimator;

	private Quaternion rootStaticRotation;

	[FPD_Percentage(0f, 3f, true, true, "%", false)]
	[Tooltip("When you want create strange effects - this variable will overrotate bones")]
	public float WeightsMultiplier = 1f;

	[Range(0.1f, 2.5f)]
	[Tooltip("If speed of looking toward target should be limited then lower this value")]
	public float MaxRotationSpeed = 2.5f;

	[Range(0f, 1f)]
	[Tooltip("When character is rotating and head is rotating with it instead of keep focusing on target, change this value higher")]
	public float BaseRotationCompensation;

	[Tooltip("If your skeleton have not animated keyframes in animation clip then bones would start doing circles with this option disabled\n\nIn most cases all keyframes are filled, if you're sure for baked keyframes you can disable this option to avoid some not needed calculations")]
	public bool DetectZeroKeyframes = true;

	[Tooltip("Target position to look can be smoothed out instead of immediate position changes")]
	[Range(0f, 1f)]
	public float LookAtPositionSmoother;

	[Tooltip("Delta Time for Look Animator calculations")]
	public EFDeltaType DeltaType;

	[Tooltip("Multiplier for delta time resulting in changed speed of calculations for Look Animator")]
	public float SimulationSpeed = 1f;

	[Range(0f, 1f)]
	[Tooltip("It will make head animation stiff but perfectly looking at target")]
	public float OverrideHeadForPerfectLookDirection;

	[Tooltip("Resetting bones before animators update to avoid bones twisting if bones are not animated using unity animator")]
	public bool Calibration = true;

	[Tooltip("With crazy flipped axes from models done in different modelling softwares, sometimes you have to change axes order for Quaternion.LookRotation to work correctly")]
	public EFAxisFixOrder FixingPreset;

	[Tooltip("If your model is not facing 'Z' axis (blue) you can adjust it with this value")]
	public Vector3 ModelForwardAxis = Vector3.forward;

	[Tooltip("If your model is not pointing up 'Y' axis (green) you can adjust it with this value")]
	public Vector3 ModelUpAxis = Vector3.up;

	[Tooltip("Defines model specific bones orientation in order to fix Quaternion.LookRotation axis usage")]
	public Vector3 ManualFromAxis = Vector3.forward;

	public Vector3 ManualToAxis = Vector3.forward;

	public Vector3 FromAuto;

	public Vector3 OffsetAuto;

	public Vector3 parentalReferenceLookForward;

	public Vector3 parentalReferenceUp;

	public Vector3 DynamicReferenceUp;

	[Tooltip("Additional degrees of rotations for head look - for simple correction, sometimes you have just to rotate head in y axis by 90 degrees")]
	public Vector3 RotationOffset = new Vector3(0f, 0f, 0f);

	[Tooltip("Additional degrees of rotations for backones - for example when you have wolf and his neck is going up in comparison to keyfarmed animation\nVariable name 'BackBonesAddOffset'")]
	public Vector3 BackBonesAddOffset = new Vector3(0f, 0f, 0f);

	[Tooltip("[ADVANCED] Axes multiplier for custom fixing flipped armature rotations")]
	public Vector3 RotCorrectionMultiplier = new Vector3(1f, 1f, 1f);

	[Tooltip("View debug rays in scene window")]
	public bool DebugRays;

	[Tooltip("Animation curve mode for rotating toward target")]
	public EFAnimationStyle AnimationStyle;

	[Tooltip("Updating reference axis for parental look rotation mode every frame")]
	public bool ConstantParentalAxisUpdate = true;

	private bool updateLookAnimator = true;

	private bool wasUpdating;

	public Transform MomentLookTransform { get; private set; }

	public EFHeadLookState LookState { get; protected set; }

	public bool initialized { get; protected set; }

	public string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Look Animator/LookAnimator_SmallIcon";
		}
	}

	public bool UseBoneOffsetRotation => SyncWithAnimator;

	[Obsolete("Use LookAnimatorAmount instead, but remember that it works in reversed way -> LookAnimatorAmount 1 = BlendToOriginal 0  and  LookAnimatorAmount 0 = BlendToOriginal 1, simply you can replace it by using '1 - LookAnimatorAmount'")]
	public float BlendToOriginal
	{
		get
		{
			return 1f - LookAnimatorAmount;
		}
		set
		{
			LookAnimatorAmount = 1f - value;
		}
	}

	[Obsolete("Now using StartLookPointOffset as more responsive naming")]
	public Vector3 LookReferenceOffset
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return StartLookPointOffset;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			StartLookPointOffset = value;
		}
	}

	[Obsolete("Now using AnchorStartLookPoint as more responsive naming")]
	public bool AnchorReferencePoint
	{
		get
		{
			return AnchorStartLookPoint;
		}
		set
		{
			AnchorStartLookPoint = value;
		}
	}

	[Obsolete("Now using RefreshStartLookPoint as more responsive naming")]
	public bool RefreshAnchor
	{
		get
		{
			return RefreshStartLookPoint;
		}
		set
		{
			RefreshStartLookPoint = value;
		}
	}

	[Obsolete("Now using LookWhenAbove as more responsive naming")]
	public float MinHeadLookAngle
	{
		get
		{
			return LookWhenAbove;
		}
		set
		{
			LookWhenAbove = value;
		}
	}

	[Obsolete("Now using StopLookingAbove as more responsive naming")]
	public float MaxRotationDiffrence
	{
		get
		{
			return StopLookingAbove;
		}
		set
		{
			StopLookingAbove = value;
		}
	}

	[Obsolete("Now using SyncWithAnimator as more responsive naming")]
	public bool AnimateWithSource
	{
		get
		{
			return SyncWithAnimator;
		}
		set
		{
			SyncWithAnimator = value;
		}
	}

	public void SwitchLooking(bool? enableLooking = null, float transitionTime = 0.2f, Action callback = null)
	{
		bool enableAnimation = true;
		if (!enableLooking.HasValue)
		{
			if (LookAnimatorAmount > 0.5f)
			{
				enableAnimation = false;
			}
		}
		else if (enableLooking == false)
		{
			enableAnimation = false;
		}
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).StartCoroutine(SwitchLookingTransition(transitionTime, enableAnimation, callback));
	}

	public void SwitchLooking(bool enable = true)
	{
		SwitchLooking(enable, 0.5f);
	}

	public void SetLookTarget(Transform transform)
	{
		ObjectToFollow = transform;
		MomentLookTransform = null;
	}

	public void SetLookPosition(Vector3 targetPosition)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		FollowMode = EFFollowMode.FollowJustPosition;
		FollowOffset = targetPosition;
	}

	public Vector2 GetUnclampedLookAngles()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(unclampedLookAngles);
	}

	public Vector2 GetLookAngles()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(animatedLookAngles);
	}

	public Vector2 GetTargetLookAngles()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(targetLookAngles);
	}

	public EFHeadLookState GetCurrentLookState()
	{
		return LookState;
	}

	public Vector2 ComputeAnglesTowards(Vector3 worldPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = worldPosition - GetLookStartMeasurePosition();
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Quaternion val3;
		if (usingAxisCorrection)
		{
			Matrix4x4 inverse = ((Matrix4x4)(ref axisCorrectionMatrix)).inverse;
			val = ((Matrix4x4)(ref inverse)).MultiplyVector(normalized);
			normalized = ((Vector3)(ref val)).normalized;
			Vector3 val2 = normalized;
			val = ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyVector(ModelUpAxis);
			val3 = Quaternion.LookRotation(val2, ((Vector3)(ref val)).normalized);
			normalized = WrapVector(((Quaternion)(ref val3)).eulerAngles);
		}
		else
		{
			normalized = BaseTransform.InverseTransformDirection(normalized);
			val3 = Quaternion.LookRotation(normalized, BaseTransform.TransformDirection(ModelUpAxis));
			normalized = WrapVector(((Quaternion)(ref val3)).eulerAngles);
		}
		return Vector2.op_Implicit(normalized);
	}

	public GameObject SetMomentLookTarget(Transform parent = null, Vector3? position = null, float? destroyTimer = null, bool worldPosition = false)
	{
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Expected O, but got Unknown
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Expected O, but got Unknown
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		_ = MomentLookTransform;
		if (Object.op_Implicit((Object)(object)MomentLookTransform))
		{
			_ = MomentLookTransform.parent;
		}
		GameObject val;
		if (!destroyTimer.HasValue)
		{
			if (!Object.op_Implicit((Object)(object)generatedMomentTarget))
			{
				generatedMomentTarget = new GameObject(((Object)((Component)((Component)this).transform).gameObject).name + "-MomentLookTarget " + Time.frameCount);
			}
			else
			{
				((Object)generatedMomentTarget).name = ((Object)((Component)((Component)this).transform).gameObject).name + "-MomentLookTarget " + Time.frameCount;
			}
			val = generatedMomentTarget;
		}
		else
		{
			val = new GameObject(((Object)((Component)((Component)this).transform).gameObject).name + "-MomentLookTarget " + Time.frameCount);
		}
		if ((Object)(object)parent != (Object)null)
		{
			val.transform.SetParent(parent);
			if (position.HasValue)
			{
				if (worldPosition)
				{
					val.transform.position = position.Value;
				}
				else
				{
					val.transform.localPosition = position.Value;
				}
			}
			else
			{
				val.transform.localPosition = Vector3.zero;
			}
		}
		else if (position.HasValue)
		{
			val.transform.position = position.Value;
		}
		MomentLookTransform = val.transform;
		wasMomentLookTransform = true;
		TargetChangedMeasures();
		if (destroyTimer.HasValue)
		{
			Object.Destroy((Object)(object)val, destroyTimer.Value);
		}
		return val;
	}

	public void SetMomentLookTransform(Transform transform, float timeToLeft = 0f)
	{
		MomentLookTransform = transform;
		wasMomentLookTransform = true;
		TargetChangedMeasures();
		if (timeToLeft > 0f)
		{
			((MonoBehaviour)this).StartCoroutine(CResetMomentLookTransform(null, timeToLeft));
		}
	}

	public void ForceDestroyMomentTarget()
	{
		if (Object.op_Implicit((Object)(object)generatedMomentTarget))
		{
			Object.Destroy((Object)(object)generatedMomentTarget);
		}
		else if (Object.op_Implicit((Object)(object)MomentLookTransform))
		{
			MomentLookTransform = null;
		}
	}

	private void InitBirdMode()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!birdModeInitialized)
		{
			lagTimer = 0f;
			birdTargetPositionMemory = GetLookAtPosition();
			BirdTargetPosition = birdTargetPositionMemory;
			birdModeInitialized = true;
		}
	}

	private void CalculateBirdMode()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		lagTimer -= delta;
		if (lagTimer < 0f)
		{
			birdTargetPositionMemory = smoothLookPosition;
		}
		if (LagRotation >= 1f)
		{
			BirdTargetPosition = birdTargetPositionMemory;
		}
		else
		{
			BirdTargetPosition = Vector3.Lerp(smoothLookPosition, birdTargetPositionMemory, LagRotation);
		}
		if (lagTimer < 0f)
		{
			lagTimer = Random.Range(LagEvery * 0.85f, LagEvery * 1.15f);
		}
		if (!(DelayPosition > 0f))
		{
			return;
		}
		for (int i = 0; i < LookBones.Count; i++)
		{
			LookBones[i].Transform.localPosition = LookBones[i].initLocalPos;
		}
		float num = Vector3.Distance(Vector3.Scale(LookBones[0].targetDelayPosition, new Vector3(1f, 0f, 1f)), Vector3.Scale(LeadBone.position, new Vector3(1f, 0f, 1f)));
		float num2 = Mathf.Abs(LookBones[0].targetDelayPosition.y - LeadBone.position.y);
		if (num > DelayMaxDistance || num2 > DelayMaxDistance / 1.65f)
		{
			for (int num3 = LookBones.Count - 1; num3 >= 0; num3--)
			{
				LookBones[num3].targetDelayPosition = LookBones[num3].Transform.position;
			}
		}
		for (int num4 = LookBones.Count - 1; num4 >= 0; num4--)
		{
			LookBones[num4].animatedDelayPosition = Vector3.Lerp(LookBones[num4].animatedDelayPosition, LookBones[num4].targetDelayPosition, delta * Mathf.Lerp(5f, 30f, DelayGoSpeed));
			LookBones[num4].Transform.position = Vector3.Lerp(LookBones[num4].Transform.position, LookBones[num4].animatedDelayPosition, LookBones[num4].lookWeight * DelayPosition * finalMotionWeight);
		}
	}

	public void SetAutoWeightsDefault()
	{
		CalculateRotationWeights(FaloffValue);
		if (!BigAngleAutomation)
		{
			for (int i = 1; i < LookBones.Count; i++)
			{
				LookBones[i].lookWeight = targetWeights[i];
				LookBones[i].motionWeight = targetWeights[i];
			}
		}
		else
		{
			for (int j = 1; j < LookBones.Count; j++)
			{
				LookBones[j].lookWeight = targetWeights[j];
			}
		}
	}

	public void UpdateAutomationWeights()
	{
		float num = Mathf.InverseLerp(45f, 170f, Mathf.Abs(unclampedLookAngles.y));
		for (int i = 0; i < LookBones.Count; i++)
		{
			LookBones[i].motionWeight = Mathf.LerpUnclamped(LookBones[i].lookWeight, LookBones[i].lookWeightB, num);
		}
	}

	public void RefreshBoneMotionWeights()
	{
		for (int i = 1; i < LookBones.Count; i++)
		{
			LookBones[i].motionWeight = LookBones[i].lookWeight;
		}
	}

	public float[] CalculateRotationWeights(float falloff)
	{
		if (LookBones.Count > 1)
		{
			float num = 0f;
			if (baseWeights == null)
			{
				baseWeights = new float[LookBones.Count];
			}
			if (baseWeights.Length != LookBones.Count)
			{
				baseWeights = new float[LookBones.Count];
			}
			if (targetWeights == null)
			{
				targetWeights = new float[LookBones.Count];
			}
			if (targetWeights.Length != LookBones.Count)
			{
				targetWeights = new float[LookBones.Count];
			}
			if (BackBonesFalloff.length < 2 || !CurveSpread)
			{
				CalculateWeights(baseWeights);
				for (int i = 0; i < baseWeights.Length; i++)
				{
					num += baseWeights[i];
				}
				float num2 = 1f / (float)(LookBones.Count - 1);
				for (int j = 1; j < LookBones.Count; j++)
				{
					targetWeights[j] = Mathf.LerpUnclamped(baseWeights[j - 1], num2, falloff * 1.25f);
				}
			}
			else
			{
				num = 0f;
				float num3 = 1f;
				float num4 = 1f / (float)(LookBones.Count - 1);
				for (int k = 1; k < LookBones.Count; k++)
				{
					targetWeights[k] = BackBonesFalloff.Evaluate(num4 * (float)k) / num3;
					num += targetWeights[k];
				}
				for (int l = 1; l < LookBones.Count; l++)
				{
					targetWeights[l] /= num;
				}
			}
		}
		return targetWeights;
	}

	private void CalculateWeights(float[] weights)
	{
		float num = 1f;
		float num2 = 0.75f;
		float num3 = num;
		weights[0] = num * num2 * 0.65f;
		num3 -= weights[0];
		for (int i = 1; i < weights.Length - 1; i++)
		{
			num3 -= (weights[i] = num3 / (1f + (1f - num2)) * num2);
		}
		weights[^1] = num3;
		num3 = 0f;
	}

	public Transform GetHeadReference()
	{
		if ((Object)(object)HeadReference != (Object)null)
		{
			return HeadReference;
		}
		return LeadBone;
	}

	public Transform GetEyesTarget()
	{
		if ((Object)(object)EyesTarget == (Object)null)
		{
			return GetLookAtTransform();
		}
		return EyesTarget;
	}

	[Obsolete("Now please use GetEyesTarget() or GetLookAtTransform() methods")]
	public Transform GetCurrentTarget()
	{
		return GetEyesTarget();
	}

	public Vector3 GetEyesTargetPosition()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)EyesTarget == (Object)null)
		{
			return GetLookAtPosition();
		}
		return EyesTarget.position;
	}

	private void InitEyesModule()
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		eyes = (Transform[])(object)new Transform[0];
		if ((Object)(object)LeftEye != (Object)null || (Object)(object)RightEye != (Object)null)
		{
			if ((Object)(object)LeftEye != (Object)null && (Object)(object)RightEye != (Object)null)
			{
				eyes = (Transform[])(object)new Transform[2] { LeftEye, RightEye };
			}
			else if ((Object)(object)LeftEye != (Object)null)
			{
				eyes = (Transform[])(object)new Transform[1] { LeftEye };
			}
			else
			{
				eyes = (Transform[])(object)new Transform[1] { RightEye };
			}
		}
		eyeForwards = (Vector3[])(object)new Vector3[eyes.Length];
		eyesInitLocalRotations = (Quaternion[])(object)new Quaternion[eyes.Length];
		eyesLerpRotations = (Quaternion[])(object)new Quaternion[eyes.Length];
		for (int i = 0; i < eyeForwards.Length; i++)
		{
			Vector3 val = eyes[i].position + Vector3.Scale(BaseTransform.forward, ((Component)eyes[i]).transform.lossyScale);
			Vector3 position = eyes[i].position;
			Vector3[] array = eyeForwards;
			int num = i;
			Vector3 val2 = eyes[i].InverseTransformPoint(val) - eyes[i].InverseTransformPoint(position);
			array[num] = ((Vector3)(ref val2)).normalized;
			eyesInitLocalRotations[i] = eyes[i].localRotation;
			eyesLerpRotations[i] = eyes[i].rotation;
		}
		headForward = Quaternion.FromToRotation(GetHeadReference().InverseTransformDirection(BaseTransform.forward), Vector3.forward) * Vector3.forward;
	}

	private void UpdateEyesLogics()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_042e: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		if (CustomEyesLogics)
		{
			return;
		}
		if (EyesNoKeyframes)
		{
			for (int i = 0; i < eyeForwards.Length; i++)
			{
				eyes[i].localRotation = eyesInitLocalRotations[i];
			}
		}
		Transform val = EyesTarget;
		if ((Object)(object)val == (Object)null)
		{
			val = ((!((Object)(object)MomentLookTransform != (Object)null)) ? ObjectToFollow : MomentLookTransform);
		}
		bool flag = false;
		if ((Object)(object)val == (Object)null)
		{
			flag = true;
		}
		else if ((Object)(object)EyesTarget == (Object)null && LookState != EFHeadLookState.ClampedAngle && LookState != EFHeadLookState.Following)
		{
			flag = true;
		}
		if (flag)
		{
			EyesOutOfRangeBlend = Mathf.Max(0f, EyesOutOfRangeBlend - delta);
		}
		else
		{
			EyesOutOfRangeBlend = Mathf.Min(1f, EyesOutOfRangeBlend + delta);
		}
		_eyesBlend = EyesBlend * EyesOutOfRangeBlend * LookAnimatorAmount;
		if (_eyesBlend <= 0f || !((Object)(object)val != (Object)null))
		{
			return;
		}
		Vector3 lookStartMeasurePosition = GetLookStartMeasurePosition();
		Quaternion val2 = Quaternion.LookRotation(val.position - lookStartMeasurePosition);
		Vector3 eulerAngles = ((Quaternion)(ref val2)).eulerAngles;
		Quaternion val3 = GetHeadReference().rotation * Quaternion.FromToRotation(headForward, Vector3.forward);
		Vector3 eulerAngles2 = ((Quaternion)(ref val3)).eulerAngles;
		Vector2 val4 = Vector2.op_Implicit(new Vector3(Mathf.DeltaAngle(eulerAngles.x, eulerAngles2.x), Mathf.DeltaAngle(eulerAngles.y, eulerAngles2.y)));
		if (val4.x > EyesYRange.y)
		{
			eulerAngles.x = eulerAngles2.x - EyesYRange.y;
		}
		else if (val4.x < EyesYRange.x)
		{
			eulerAngles.x = eulerAngles2.x - EyesYRange.x;
		}
		if (val4.y > 0f - EyesXRange.x)
		{
			eulerAngles.y = eulerAngles2.y - EyesXRange.y;
		}
		else if (val4.y < 0f - EyesXRange.y)
		{
			eulerAngles.y = eulerAngles2.y + EyesXRange.y;
		}
		for (int j = 0; j < eyes.Length; j++)
		{
			Quaternion rotation = eyes[j].rotation;
			Quaternion val5 = Quaternion.Euler(eulerAngles);
			float num = 1f;
			if ((Object)(object)eyes[j] == (Object)(object)LeftEye)
			{
				if (InvertLeftEye)
				{
					num = -1f;
				}
			}
			else if ((Object)(object)eyes[j] == (Object)(object)RightEye && InvertRightEye)
			{
				num = -1f;
			}
			val5 *= Quaternion.FromToRotation(eyeForwards[j], Vector3.forward * num);
			val5 *= eyesInitLocalRotations[j];
			eyes[j].rotation = val5;
			Transform obj = eyes[j];
			obj.rotation *= Quaternion.Inverse(eyesInitLocalRotations[j]);
			if (EyesOffsetRotation != Vector3.zero)
			{
				Transform obj2 = eyes[j];
				obj2.rotation *= Quaternion.Euler(EyesOffsetRotation);
			}
			switch (j)
			{
			case 0:
				if (LeftEyeOffsetRotation != Vector3.zero)
				{
					Transform obj4 = eyes[j];
					obj4.rotation *= Quaternion.Euler(LeftEyeOffsetRotation);
				}
				break;
			case 1:
				if (RightEyeOffsetRotation != Vector3.zero)
				{
					Transform obj3 = eyes[j];
					obj3.rotation *= Quaternion.Euler(RightEyeOffsetRotation);
				}
				break;
			}
			val5 = eyes[j].rotation;
			eyesLerpRotations[j] = Quaternion.Slerp(eyesLerpRotations[j], val5, delta * Mathf.Lerp(2f, 40f, EyesSpeed));
			eyes[j].rotation = Quaternion.Slerp(rotation, eyesLerpRotations[j], _eyesBlend);
		}
	}

	private void NoddingChangeTargetCalculations(float angleAmount)
	{
		if ((nodProgress < nodDuration / 10f || nodProgress > nodDuration * 0.85f) && NoddingTransitions != 0f)
		{
			nodProgress = 0f;
			nodDuration = Mathf.Lerp(1f, 0.45f, RotationSpeed / 2.5f);
			if (ChangeTargetSmoothing > 0f)
			{
				nodDuration *= Mathf.Lerp(1f, 1.55f, ChangeTargetSmoothing);
			}
			nodDuration *= Mathf.Lerp(0.8f, 1.4f, Mathf.InverseLerp(10f, 140f, angleAmount));
			nodPower = Mathf.Lerp(0.3f, 1f, Mathf.InverseLerp(8f, 55f, angleAmount));
		}
	}

	private void NoddingCalculations()
	{
		if (nodProgress < nodDuration)
		{
			if (nodProgress < nodDuration)
			{
				nodProgress += delta;
			}
			else
			{
				nodProgress = nodDuration;
			}
			float value = nodProgress / nodDuration;
			value = FEasing.EaseOutCubic(0f, 1f, value);
			if (value >= 1f)
			{
				nodValue = 0f;
			}
			else
			{
				nodValue = Mathf.Sin(value * MathF.PI);
			}
		}
	}

	public void SetRotationSmoothing(float smoothingDuration = 0.5f, float smoothingPower = 2f)
	{
		if (!(smoothingDuration <= 0f))
		{
			smoothingTimer = smoothingDuration;
			smoothingTime = smoothingDuration;
			this.smoothingPower = smoothingPower;
		}
	}

	private void UpdateSmoothing()
	{
		if (smoothingTimer > 0f)
		{
			smoothingTimer -= delta;
			smoothingEffect = 1f + smoothingTimer / smoothingTime * smoothingPower;
		}
		else
		{
			smoothingEffect = 1f;
		}
	}

	private void AnimateBonesUnsynced(Quaternion diffOnMain, Quaternion backTarget, float d)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		if (nodValue > 0f && BackBonesNod != 0f)
		{
			backTarget *= Quaternion.Euler(NodAxis * (nodValue * nodPower * (0f - NoddingTransitions) * 40f) * BackBonesNod);
		}
		Quaternion targetLook;
		for (int i = 1; i < LookBones.Count; i++)
		{
			LookBones[i].Transform.localRotation = LookBones[i].localStaticRotation;
			targetLook = backTarget * LookBones[i].correctionOffsetQ * Quaternion.Inverse(diffOnMain * LookBones[i].animatedStaticRotation);
			LookBones[i].CalculateMotion(targetLook, WeightsMultiplier, d, finalMotionWeight);
		}
		LookBones[0].Transform.localRotation = LookBones[0].localStaticRotation;
		targetLook = ((!(nodValue <= 0f)) ? (targetLookRotation * LookBones[0].correctionOffsetQ * Quaternion.Euler(NodAxis * (nodValue * nodPower * (0f - NoddingTransitions) * 40f)) * Quaternion.Inverse(diffOnMain * LookBones[0].animatedStaticRotation)) : (targetLookRotation * LookBones[0].correctionOffsetQ * Quaternion.Inverse(diffOnMain * LookBones[0].animatedStaticRotation)));
		LookBones[0].CalculateMotion(targetLook, WeightsMultiplier, d, finalMotionWeight);
	}

	private void AnimateBonesSynced(Quaternion diffOnMain, Quaternion backTarget, float d)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		if (nodValue > 0f && BackBonesNod != 0f)
		{
			backTarget *= Quaternion.Euler(NodAxis * (nodValue * nodPower * (0f - NoddingTransitions) * 40f) * BackBonesNod);
		}
		Quaternion targetLook;
		for (int num = LookBones.Count - 1; num >= 1; num--)
		{
			targetLook = backTarget * LookBones[num].correctionOffsetQ * Quaternion.Inverse(diffOnMain * LookBones[num].animatedStaticRotation);
			LookBones[num].CalculateMotion(targetLook, WeightsMultiplier, d, finalMotionWeight);
		}
		targetLook = ((!(nodValue <= 0f)) ? (targetLookRotation * (LookBones[0].correctionOffsetQ * Quaternion.Euler(NodAxis * (nodValue * nodPower * (0f - NoddingTransitions) * 40f))) * Quaternion.Inverse(diffOnMain * LookBones[0].animatedStaticRotation)) : (targetLookRotation * LookBones[0].correctionOffsetQ * Quaternion.Inverse(diffOnMain * LookBones[0].animatedStaticRotation)));
		LookBones[0].CalculateMotion(targetLook, WeightsMultiplier, d, finalMotionWeight);
	}

	private void AnimateBonesParental(float d)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0430: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_065e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0663: Unknown result type (might be due to invalid IL or missing references)
		//IL_0664: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0370: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05da: Unknown result type (might be due to invalid IL or missing references)
		//IL_05db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0606: Unknown result type (might be due to invalid IL or missing references)
		//IL_060b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0610: Unknown result type (might be due to invalid IL or missing references)
		//IL_0615: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_0641: Unknown result type (might be due to invalid IL or missing references)
		//IL_0646: Unknown result type (might be due to invalid IL or missing references)
		//IL_064b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0650: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0509: Unknown result type (might be due to invalid IL or missing references)
		//IL_050e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0513: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_0519: Unknown result type (might be due to invalid IL or missing references)
		//IL_054a: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0559: Unknown result type (might be due to invalid IL or missing references)
		//IL_055a: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0590: Unknown result type (might be due to invalid IL or missing references)
		//IL_0595: Unknown result type (might be due to invalid IL or missing references)
		//IL_059a: Unknown result type (might be due to invalid IL or missing references)
		float num = nodValue * nodPower * (0f - NoddingTransitions) * 40f;
		float num2 = num * BackBonesNod;
		bool flag = false;
		if (BackBonesAddOffset != Vector3.zero || NoddingTransitions != 0f)
		{
			flag = true;
		}
		for (int num3 = LookBones.Count - 1; num3 >= 1; num3--)
		{
			Quaternion val = Quaternion.identity;
			if (flag || LookBones[num3].correctionOffset != Vector3.zero)
			{
				if (ParentalOffsetsV == 2)
				{
					val *= Quaternion.AngleAxis(BackBonesAddOffset.x + LookBones[num3].correctionOffset.x + NodAxis.x * num2, LookBones[num3].right);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.y + LookBones[num3].correctionOffset.y + NodAxis.y * num2, LookBones[num3].up);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.z + LookBones[num3].correctionOffset.z + NodAxis.z * num2, LookBones[num3].forward);
				}
				else if (ParentalOffsetsV == 1)
				{
					val *= Quaternion.AngleAxis(BackBonesAddOffset.x + LookBones[num3].correctionOffset.x + NodAxis.x * num2, LookBones[num3].Transform.right);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.y + LookBones[num3].correctionOffset.y + NodAxis.y * num2, LookBones[num3].Transform.up);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.z + LookBones[num3].correctionOffset.z + NodAxis.z * num2, LookBones[num3].Transform.forward);
				}
				else
				{
					val *= Quaternion.AngleAxis(BackBonesAddOffset.x + LookBones[num3].correctionOffset.x + NodAxis.x * num2, BaseTransform.right);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.y + LookBones[num3].correctionOffset.y + NodAxis.y * num2, BaseTransform.up);
					val *= Quaternion.AngleAxis(BackBonesAddOffset.z + LookBones[num3].correctionOffset.z + NodAxis.z * num2, BaseTransform.forward);
				}
			}
			LookBones[num3].CalculateMotion(targetLookRotation * val, WeightsMultiplier, d, finalMotionWeight);
		}
		Quaternion val2 = Quaternion.identity;
		if (LookBones[0].correctionOffset != Vector3.zero || NoddingTransitions != 0f)
		{
			if (ParentalOffsetsV == 2)
			{
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.x + NodAxis.x * num, LookBones[0].Transform.right);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.y + NodAxis.y * num, LookBones[0].Transform.up);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.z + NodAxis.z * num, LookBones[0].Transform.forward);
			}
			else if (ParentalOffsetsV == 1)
			{
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.x + NodAxis.x * num, LookBones[0].right);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.y + NodAxis.y * num, LookBones[0].up);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.z + NodAxis.z * num, LookBones[0].forward);
			}
			else
			{
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.x + NodAxis.x * num, BaseTransform.right);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.y + NodAxis.y * num, BaseTransform.up);
				val2 *= Quaternion.AngleAxis(LookBones[0].correctionOffset.z + NodAxis.z * num, BaseTransform.forward);
			}
		}
		LookBones[0].CalculateMotion(targetLookRotation * val2, WeightsMultiplier, d, finalMotionWeight);
	}

	private void CalculateLookAnimation()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		_stopLooking = false;
		if (FollowMode != EFFollowMode.FollowJustPosition && (Object)(object)ObjectToFollow == (Object)null && (Object)(object)MomentLookTransform == (Object)null)
		{
			_stopLooking = true;
		}
		LookPositionUpdate();
		LookWhenAboveGoBackCalculations();
		if (_stopLooking)
		{
			finalLookPosition = ((Component)this).transform.TransformPoint(lookFreezeFocusPoint);
		}
		else if (!BirdMode)
		{
			finalLookPosition = smoothLookPosition;
		}
		else
		{
			finalLookPosition = BirdTargetPosition;
		}
		Vector3 val;
		Quaternion val3;
		Vector3 val5;
		if (FixingPreset != 0)
		{
			if (LookState == EFHeadLookState.OutOfMaxDistance)
			{
				targetLookAngles = Vector3.MoveTowards(targetLookAngles, Vector3.zero, 1f + RotationSpeed);
			}
			else
			{
				val = finalLookPosition - GetLookStartMeasurePosition();
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				if (usingAxisCorrection)
				{
					Matrix4x4 inverse = ((Matrix4x4)(ref axisCorrectionMatrix)).inverse;
					val = ((Matrix4x4)(ref inverse)).MultiplyVector(normalized);
					normalized = ((Vector3)(ref val)).normalized;
					Vector3 val2 = normalized;
					val = ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyVector(ModelUpAxis);
					val3 = Quaternion.LookRotation(val2, ((Vector3)(ref val)).normalized);
					normalized = WrapVector(((Quaternion)(ref val3)).eulerAngles);
				}
				else
				{
					normalized = BaseTransform.InverseTransformDirection(normalized);
					val3 = Quaternion.LookRotation(normalized, BaseTransform.TransformDirection(ModelUpAxis));
					normalized = WrapVector(((Quaternion)(ref val3)).eulerAngles);
				}
				targetLookAngles = normalized;
			}
			Vector2 angles = Vector2.op_Implicit(targetLookAngles);
			angles = LimitAnglesCalculations(angles);
			AnimateAnglesTowards(angles);
			if (usingAxisCorrection)
			{
				Quaternion val4 = Quaternion.FromToRotation(Vector3.right, Vector3.Cross(Vector3.up, ModelForwardAxis));
				val4 = Quaternion.Euler(finalLookAngles) * val4 * BaseTransform.rotation;
				val5 = ((Quaternion)(ref val4)).eulerAngles;
			}
			else
			{
				val5 = finalLookAngles + BaseTransform.eulerAngles;
			}
			val5 += RotationOffset;
			val5 = ConvertFlippedAxes(val5);
		}
		else
		{
			val = finalLookPosition - GetLookStartMeasurePosition();
			val3 = LookRotationParental(((Vector3)(ref val)).normalized);
			val5 = ((Quaternion)(ref val3)).eulerAngles;
		}
		if (!_stopLooking)
		{
			lookFreezeFocusPoint = BaseTransform.InverseTransformPoint(finalLookPosition);
		}
		targetLookRotation = Quaternion.Euler(val5);
		SetTargetBonesRotations();
	}

	private void SetTargetBonesRotations()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (FixingPreset == EFAxisFixOrder.Parental)
		{
			if (UltraSmoother <= 0f)
			{
				AnimateBonesParental(1f);
			}
			else
			{
				AnimateBonesParental(delta * Mathf.Lerp(21f, 3f, UltraSmoother));
			}
			return;
		}
		Quaternion backTarget = targetLookRotation * Quaternion.Euler(BackBonesAddOffset);
		Quaternion diffOnMain = BaseTransform.rotation * Quaternion.Inverse(rootStaticRotation);
		if (UseBoneOffsetRotation)
		{
			if (UltraSmoother <= 0f)
			{
				AnimateBonesSynced(diffOnMain, backTarget, 1f);
			}
			else
			{
				AnimateBonesSynced(diffOnMain, backTarget, delta * Mathf.Lerp(21f, 3f, UltraSmoother));
			}
		}
		else if (UltraSmoother <= 0f)
		{
			AnimateBonesUnsynced(diffOnMain, backTarget, 1f);
		}
		else
		{
			AnimateBonesUnsynced(diffOnMain, backTarget, delta * Mathf.Lerp(21f, 3f, UltraSmoother));
		}
	}

	private Quaternion LookRotationParental(Vector3 direction)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		if (!SyncWithAnimator)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				LookBones[i].Transform.localRotation = LookBones[i].localStaticRotation;
			}
		}
		if ((Object)(object)ParentalReferenceBone == (Object)null)
		{
			_parentalBackParentRot = LeadBone.parent.rotation;
		}
		else
		{
			_parentalBackParentRot = ParentalReferenceBone.rotation;
		}
		Vector3 val = Quaternion.Inverse(_parentalBackParentRot) * ((Vector3)(ref direction)).normalized;
		_parentalAngles.y = AngleAroundAxis(parentalReferenceLookForward, val, parentalReferenceUp);
		Vector3 axis = Vector3.Cross(parentalReferenceUp, val);
		Vector3 firstDirection = val - Vector3.Project(val, parentalReferenceUp);
		_parentalAngles.x = AngleAroundAxis(firstDirection, val, axis);
		_parentalAngles = LimitAnglesCalculations(_parentalAngles);
		_parentalAngles = AnimateAnglesTowards(_parentalAngles);
		Vector3 referenceRightDir = Vector3.Cross(parentalReferenceUp, parentalReferenceLookForward);
		if (NoddingTransitions != 0f)
		{
			float num = nodValue * nodPower * 40f;
			_parentalAngles.x += num * BackBonesNod;
		}
		if (RotationOffset != Vector3.zero)
		{
			_parentalAngles += new Vector2(RotationOffset.x, RotationOffset.y);
		}
		return ParentalRotationMaths(referenceRightDir, _parentalAngles.x, _parentalAngles.y);
	}

	private Quaternion ParentalRotationMaths(Vector3 referenceRightDir, float xAngle, float yAngle)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Quaternion.AngleAxis(yAngle, parentalReferenceUp) * Quaternion.AngleAxis(xAngle, referenceRightDir) * parentalReferenceLookForward;
		Vector3 dynamicReferenceUp = parentalReferenceUp;
		Vector3.OrthoNormalize(ref val, ref dynamicReferenceUp);
		Vector3 val2 = val;
		DynamicReferenceUp = dynamicReferenceUp;
		Vector3.OrthoNormalize(ref val2, ref DynamicReferenceUp);
		return _parentalBackParentRot * Quaternion.LookRotation(val2, DynamicReferenceUp) * Quaternion.Inverse(_parentalBackParentRot * Quaternion.LookRotation(parentalReferenceLookForward, parentalReferenceUp));
	}

	private void UpdateCorrectionMatrix()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (ModelUpAxis != Vector3.up || ModelForwardAxis != Vector3.forward)
		{
			usingAxisCorrection = true;
			axisCorrectionMatrix = Matrix4x4.TRS(BaseTransform.position, Quaternion.LookRotation(BaseTransform.TransformDirection(ModelForwardAxis), BaseTransform.TransformDirection(ModelUpAxis)), BaseTransform.lossyScale);
		}
		else
		{
			usingAxisCorrection = false;
		}
	}

	private IEnumerator AnimatePhysicsClock()
	{
		animatePhysicsWorking = true;
		while (true)
		{
			yield return CoroutineEx.waitForFixedUpdate;
			triggerAnimatePhysics = true;
		}
	}

	private IEnumerator SwitchLookingTransition(float transitionTime, bool enableAnimation, Action callback = null)
	{
		float time = 0f;
		float startBlend = LookAnimatorAmount;
		while (time < transitionTime)
		{
			time += delta;
			float num = time / transitionTime;
			if (enableAnimation)
			{
				LookAnimatorAmount = Mathf.Lerp(startBlend, 1f, num);
			}
			else
			{
				LookAnimatorAmount = Mathf.Lerp(startBlend, 0f, num);
			}
			yield return null;
		}
		callback?.Invoke();
	}

	private IEnumerator CResetMomentLookTransform(Transform transform, float time)
	{
		yield return null;
		yield return null;
		yield return CoroutineEx.waitForSeconds(time);
		yield return null;
		MomentLookTransform = transform;
	}

	public Vector2 LimitAnglesCalculations(Vector2 angles)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0432: Unknown result type (might be due to invalid IL or missing references)
		//IL_0452: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d8: Unknown result type (might be due to invalid IL or missing references)
		if (LookState == EFHeadLookState.OutOfMaxDistance)
		{
			angles = Vector2.MoveTowards(angles, Vector2.zero, 2.75f + RotationSpeed);
			return angles;
		}
		unclampedLookAngles = Vector2.op_Implicit(angles);
		if (LookState != EFHeadLookState.OutOfMaxRotation)
		{
			if (Mathf.Abs(angles.y) > StopLookingAbove)
			{
				LookState = EFHeadLookState.OutOfMaxRotation;
				return angles;
			}
		}
		else
		{
			if (!(Mathf.Abs(angles.y) <= StopLookingAbove * StopLookingAboveFactor))
			{
				angles = Vector2.op_Implicit(Vector3.MoveTowards(Vector2.op_Implicit(angles), Vector2.op_Implicit(Vector2.zero), 2.75f + RotationSpeed));
				return angles;
			}
			LookState = EFHeadLookState.Null;
		}
		if (LookState == EFHeadLookState.Null)
		{
			LookState = EFHeadLookState.Following;
		}
		if (LookState == EFHeadLookState.Following || LookState == EFHeadLookState.ClampedAngle)
		{
			if (angles.y < XRotationLimits.x)
			{
				angles.y = GetClampedAngle(unclampedLookAngles.y, XRotationLimits.x, XElasticRange, -1f);
				if (angles.y < unclampedLookAngles.y)
				{
					angles.y = unclampedLookAngles.y;
				}
				LookState = EFHeadLookState.ClampedAngle;
			}
			else if (angles.y > XRotationLimits.y)
			{
				angles.y = GetClampedAngle(unclampedLookAngles.y, XRotationLimits.y, XElasticRange);
				if (angles.y > unclampedLookAngles.y)
				{
					angles.y = unclampedLookAngles.y;
				}
				LookState = EFHeadLookState.ClampedAngle;
			}
			else
			{
				LookState = EFHeadLookState.Following;
			}
			if (angles.x < YRotationLimits.x)
			{
				angles.x = GetClampedAngle(angles.x, YRotationLimits.x, YElasticRange, -1f);
				if (angles.x < unclampedLookAngles.x)
				{
					angles.x = unclampedLookAngles.x;
				}
				LookState = EFHeadLookState.ClampedAngle;
			}
			else if (angles.x > YRotationLimits.y)
			{
				angles.x = GetClampedAngle(angles.x, YRotationLimits.y, YElasticRange);
				if (angles.x > unclampedLookAngles.x)
				{
					angles.x = unclampedLookAngles.x;
				}
				LookState = EFHeadLookState.ClampedAngle;
			}
			else if (LookState != EFHeadLookState.ClampedAngle)
			{
				LookState = EFHeadLookState.Following;
			}
		}
		if (StartLookElasticRangeX > 0f)
		{
			float num = Mathf.Abs(angles.y) / StartLookElasticRangeX;
			angles.y = Mathf.Lerp(0f, angles.y, num);
		}
		if (StartLookElasticRangeY > 0f)
		{
			float num2 = Mathf.Abs(angles.x) / StartLookElasticRangeY;
			angles.x = Mathf.Lerp(0f, angles.x, num2);
		}
		if (HoldRotateToOppositeUntil > 0f)
		{
			int num3 = 0;
			if (_rememberSideLookHorizontalAngle > 0f && unclampedLookAngles.y < 0f)
			{
				num3 = 1;
			}
			else if (_rememberSideLookHorizontalAngle < 0f && unclampedLookAngles.y > 0f)
			{
				num3 = -1;
			}
			if (num3 != 0)
			{
				if (num3 < 0)
				{
					if (unclampedLookAngles.y < 180f - HoldRotateToOppositeUntil)
					{
						_rememberSideLookHorizontalAngle = angles.y;
					}
					else
					{
						angles.y = _rememberSideLookHorizontalAngle;
					}
				}
				else if (0f - unclampedLookAngles.y < 180f - HoldRotateToOppositeUntil)
				{
					_rememberSideLookHorizontalAngle = angles.y;
				}
				else
				{
					angles.y = _rememberSideLookHorizontalAngle;
				}
			}
			else
			{
				_rememberSideLookHorizontalAngle = angles.y;
			}
		}
		if (LookWhenAbove > 0f)
		{
			whenAboveGoBackAngles = angles;
			float num4 = Mathf.Abs(Mathf.DeltaAngle(_preLookAboveLookAngles.y, angles.y));
			if (num4 < animatedLookWhenAbove)
			{
				angles.y = _preLookAboveLookAngles.y;
			}
			else
			{
				angles.y = Mathf.LerpUnclamped(_preLookAboveLookAngles.y, angles.y, (num4 - animatedLookWhenAbove) / num4);
				_preLookAboveLookAngles.y = angles.y;
			}
			float num5 = ((animatedLookWhenAboveVertical > 0f) ? animatedLookWhenAboveVertical : animatedLookWhenAbove);
			num4 = Mathf.Abs(Mathf.DeltaAngle(_preLookAboveLookAngles.x, angles.x));
			if (num4 < num5)
			{
				angles.x = _preLookAboveLookAngles.x;
			}
			else
			{
				angles.x = Mathf.LerpUnclamped(_preLookAboveLookAngles.x, angles.x, (num4 - num5) / num4);
				_preLookAboveLookAngles.x = angles.x;
			}
		}
		return angles;
	}

	public Vector2 AnimateAnglesTowards(Vector2 angles)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_040e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0413: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		if (!usingAxisCorrection)
		{
			Quaternion val = BaseTransform.rotation * Quaternion.Inverse(lastBaseRotation);
			Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
			eulerAngles = WrapVector(eulerAngles) * BaseRotationCompensation;
			animatedLookAngles -= eulerAngles;
		}
		if (!instantRotation)
		{
			switch (AnimationStyle)
			{
			case EFAnimationStyle.SmoothDamp:
			{
				float num4 = ((RotationSpeed < 0.8f) ? Mathf.Lerp(0.4f, 0.18f, RotationSpeed / 0.8f) : ((RotationSpeed < 1.7f) ? Mathf.Lerp(0.18f, 0.1f, (RotationSpeed - 0.8f) / 0.90000004f) : ((!(RotationSpeed < 2.15f)) ? Mathf.Lerp(0.05f, 0.02f, (RotationSpeed - 2.15f) / 0.3499999f) : Mathf.Lerp(0.1f, 0.05f, (RotationSpeed - 1.7f) / 0.45000005f))));
				num4 *= smoothingEffect;
				float num5 = ((MaxRotationSpeed >= 2.5f) ? float.PositiveInfinity : ((MaxRotationSpeed < 0.8f) ? Mathf.Lerp(100f, 430f, MaxRotationSpeed / 0.8f) : ((!(MaxRotationSpeed < 1.7f)) ? Mathf.Lerp(685f, 1250f, (MaxRotationSpeed - 1.7f) / 0.79999995f) : Mathf.Lerp(430f, 685f, (MaxRotationSpeed - 0.8f) / 0.90000004f))));
				animatedLookAngles = Vector3.SmoothDamp(animatedLookAngles, Vector2.op_Implicit(angles), ref _velo_animatedLookAngles, num4, num5, delta);
				break;
			}
			case EFAnimationStyle.FastLerp:
			{
				float num = ((RotationSpeed < 0.8f) ? Mathf.Lerp(2.85f, 4.5f, RotationSpeed / 0.8f) : ((RotationSpeed < 1.7f) ? Mathf.Lerp(4.5f, 10f, (RotationSpeed - 0.8f) / 0.90000004f) : ((!(RotationSpeed < 2.15f)) ? Mathf.Lerp(14f, 25f, (RotationSpeed - 2.15f) / 0.3499999f) : Mathf.Lerp(10f, 14f, (RotationSpeed - 1.7f) / 0.45000005f))));
				num /= smoothingEffect;
				Vector3 val2 = Vector3.Lerp(animatedLookAngles, Vector2.op_Implicit(angles), num * delta);
				if (MaxRotationSpeed < 2.5f)
				{
					float num2 = ((MaxRotationSpeed < 1.1f) ? Mathf.Lerp(5f, 9f, MaxRotationSpeed / 1.1f) : ((!(MaxRotationSpeed < 1.7f)) ? Mathf.Lerp(20f, 45f, (MaxRotationSpeed - 1.7f) / 0.79999995f) : Mathf.Lerp(9f, 20f, (MaxRotationSpeed - 1.1f) / 0.6f)));
					float num3 = Vector3.Distance(val2, animatedLookAngles);
					if (num3 > num2)
					{
						num /= 1f + (num3 - num2) / 3f;
					}
					val2 = Vector3.Lerp(animatedLookAngles, Vector2.op_Implicit(angles), num * delta);
				}
				animatedLookAngles = val2;
				break;
			}
			case EFAnimationStyle.Linear:
				animatedLookAngles = Vector3.MoveTowards(animatedLookAngles, Vector2.op_Implicit(angles), delta * (0.2f + RotationSpeed) * 300f);
				break;
			}
		}
		else
		{
			animatedLookAngles = Vector2.op_Implicit(angles);
		}
		finalLookAngles = Vector3.LerpUnclamped(Vector3.zero, animatedLookAngles, finalMotionWeight);
		return Vector2.op_Implicit(finalLookAngles);
	}

	public Vector3 GetDistanceMeasurePosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return BaseTransform.position + BaseTransform.TransformVector(DistanceMeasurePoint);
	}

	public Vector3 GetLookStartMeasurePosition()
	{
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		_LOG_NoRefs();
		if (AnchorStartLookPoint)
		{
			if (usingAxisCorrection)
			{
				if (!Application.isPlaying)
				{
					UpdateCorrectionMatrix();
				}
				if (leadBoneInitLocalOffset == Vector3.zero)
				{
					return LeadBone.position + ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyVector(StartLookPointOffset);
				}
				return ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyPoint(leadBoneInitLocalOffset) + ((Matrix4x4)(ref axisCorrectionMatrix)).MultiplyVector(StartLookPointOffset);
			}
			if (leadBoneInitLocalOffset == Vector3.zero)
			{
				return LeadBone.position + BaseTransform.TransformVector(StartLookPointOffset);
			}
			return BaseTransform.TransformPoint(leadBoneInitLocalOffset) + BaseTransform.TransformVector(StartLookPointOffset);
		}
		if (!Application.isPlaying)
		{
			LookBones[0].finalRotation = ((Component)LeadBone).transform.rotation;
		}
		return LeadBone.position + LookBones[0].finalRotation * StartLookPointOffset;
	}

	public void RefreshLookStartPositionAnchor()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!usingAxisCorrection)
		{
			leadBoneInitLocalOffset = BaseTransform.InverseTransformPoint(LeadBone.position);
		}
		else
		{
			Matrix4x4 inverse = ((Matrix4x4)(ref axisCorrectionMatrix)).inverse;
			leadBoneInitLocalOffset = ((Matrix4x4)(ref inverse)).MultiplyPoint(LeadBone.position);
		}
		RefreshStartLookPoint = false;
	}

	private float GetDistanceMeasure(Vector3 targetPosition)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (Distance2D)
		{
			Vector3 distanceMeasurePosition = GetDistanceMeasurePosition();
			return Vector2.Distance(new Vector2(distanceMeasurePosition.x, distanceMeasurePosition.z), new Vector2(targetPosition.x, targetPosition.z));
		}
		return Vector3.Distance(GetDistanceMeasurePosition(), targetPosition);
	}

	private void UpdateLookAnimatorAmountWeight()
	{
		if (!_stopLooking && (LookState == EFHeadLookState.OutOfMaxDistance || LookState == EFHeadLookState.OutOfMaxRotation || LookState == EFHeadLookState.Null))
		{
			_stopLooking = true;
		}
		float num = (BirdMode ? RotationSpeed : 1f);
		if (_stopLooking)
		{
			animatedMotionWeight = Mathf.SmoothDamp(animatedMotionWeight, 0f, ref _velo_animatedMotionWeight, Mathf.Lerp(0.5f, 0.25f, RotationSpeed / 2.5f), float.PositiveInfinity, delta * num);
		}
		else
		{
			if (previousState == EFHeadLookState.OutOfMaxRotation)
			{
				OnRangeStateChanged();
			}
			animatedMotionWeight = Mathf.SmoothDamp(animatedMotionWeight, 1f, ref _velo_animatedMotionWeight, Mathf.Lerp(0.3f, 0.125f, RotationSpeed / 2.5f), float.PositiveInfinity, delta * num);
		}
		finalMotionWeight = animatedMotionWeight * LookAnimatorAmount;
		if (finalMotionWeight > 0.999f)
		{
			finalMotionWeight = 1f;
		}
	}

	private void EndUpdate()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		preActiveLookTarget = activeLookTarget;
		preWeightFaloff = FaloffValue;
		lastBaseRotation = BaseTransform.rotation;
		preLookDir = GetCurrentHeadForwardDirection();
	}

	private void LookPositionUpdate()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (LookAtPositionSmoother > 0f)
		{
			smoothLookPosition = Vector3.SmoothDamp(smoothLookPosition, activeLookPosition, ref _velo_smoothLookPosition, LookAtPositionSmoother / 2f, float.PositiveInfinity, delta);
		}
		else
		{
			smoothLookPosition = activeLookPosition;
		}
	}

	private void TargetingUpdate()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		activeLookTarget = GetLookAtTransform();
		activeLookPosition = GetLookAtPosition();
		if ((Object)(object)preActiveLookTarget != (Object)(object)activeLookTarget)
		{
			OnTargetChanged();
		}
	}

	public Vector3 GetLookAtPosition()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		_LOG_NoRefs();
		if (FollowMode == EFFollowMode.FollowJustPosition)
		{
			return FollowOffset;
		}
		Transform lookAtTransform = activeLookTarget;
		if ((Object)(object)lookAtTransform == (Object)null)
		{
			lookAtTransform = GetLookAtTransform();
		}
		if (!Object.op_Implicit((Object)(object)lookAtTransform))
		{
			return LeadBone.position + BaseTransform.TransformVector(ModelForwardAxis) * Vector3.Distance(LeadBone.position, BaseTransform.position);
		}
		if (FollowMode == EFFollowMode.ToFollowSpaceOffset)
		{
			return lookAtTransform.position + lookAtTransform.TransformVector(FollowOffset);
		}
		if (FollowMode == EFFollowMode.WorldOffset)
		{
			return lookAtTransform.position + FollowOffset;
		}
		if (FollowMode == EFFollowMode.LocalOffset)
		{
			return lookAtTransform.position + BaseTransform.TransformVector(FollowOffset);
		}
		return lookAtTransform.position;
	}

	public Transform GetLookAtTransform()
	{
		if (Object.op_Implicit((Object)(object)MomentLookTransform))
		{
			if (!wasMomentLookTransform)
			{
				OnTargetChanged();
				wasMomentLookTransform = true;
			}
			return MomentLookTransform;
		}
		if (!Object.op_Implicit((Object)(object)MomentLookTransform))
		{
			if (wasMomentLookTransform)
			{
				OnTargetChanged();
				wasMomentLookTransform = false;
			}
			if (Object.op_Implicit((Object)(object)ObjectToFollow))
			{
				return ObjectToFollow;
			}
		}
		return null;
	}

	public Vector3 GetForwardPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return LeadBone.position + BaseTransform.TransformDirection(ModelForwardAxis);
	}

	protected void TargetChangedMeasures()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentHeadForwardDirection = GetCurrentHeadForwardDirection();
		Vector3 normalized = ((Vector3)(ref preLookDir)).normalized;
		Quaternion val = Quaternion.LookRotation(currentHeadForwardDirection);
		Vector3 val2 = ((Quaternion)(ref val)).eulerAngles;
		Vector3 val3;
		if (!(normalized == Vector3.zero))
		{
			val = Quaternion.LookRotation(normalized);
			val3 = ((Quaternion)(ref val)).eulerAngles;
		}
		else
		{
			val3 = Vector3.zero;
		}
		Vector3 val4 = val3;
		val = Quaternion.LookRotation(((Component)this).transform.TransformVector(ModelForwardAxis));
		Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
		Vector2 val5 = Vector2.op_Implicit(new Vector3(Mathf.DeltaAngle(val2.x, eulerAngles.x), Mathf.DeltaAngle(val2.y, eulerAngles.y)));
		float num = StopLookingAbove;
		if (Mathf.Abs(XRotationLimits.x) > StopLookingAbove)
		{
			num = Mathf.Abs(XRotationLimits.x);
		}
		if (Mathf.Abs(val5.y) > num)
		{
			val2 = eulerAngles;
		}
		else
		{
			if (val5.y < XRotationLimits.x)
			{
				val2.y = eulerAngles.y + XRotationLimits.y;
			}
			if (val5.y > XRotationLimits.y)
			{
				val2.y = eulerAngles.y + XRotationLimits.x;
			}
			if (val5.x < YRotationLimits.x)
			{
				val2.x = eulerAngles.x + XRotationLimits.x;
			}
			if (val5.x > YRotationLimits.y)
			{
				val2.x = eulerAngles.x + XRotationLimits.y;
			}
		}
		Vector2 val6 = Vector2.op_Implicit(new Vector3(Mathf.DeltaAngle(val2.x, val4.x), Mathf.DeltaAngle(val2.y, val4.y)));
		float num2 = Mathf.Abs(val6.x) + Mathf.Abs(val6.y);
		if (ChangeTargetSmoothing > 0f && num2 > 20f)
		{
			SetRotationSmoothing(Mathf.Lerp(0.15f + ChangeTargetSmoothing * 0.25f, 0.4f + ChangeTargetSmoothing * 0.2f, Mathf.InverseLerp(20f, 180f, num2)), Mathf.Lerp(0.7f, 3f, ChangeTargetSmoothing));
		}
		NoddingChangeTargetCalculations(num2);
	}

	private void MaxDistanceCalculations()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (MaximumDistance > 0f)
		{
			if (isLooking)
			{
				if (GetDistanceMeasure(activeLookPosition) > MaximumDistance + MaximumDistance * MaxOutDistanceFactor)
				{
					LookState = EFHeadLookState.OutOfMaxDistance;
					OnRangeStateChanged();
					if (DestroyMomentTargetOnMaxDistance)
					{
						ForceDestroyMomentTarget();
					}
				}
			}
			else if (LookState == EFHeadLookState.OutOfMaxDistance && GetDistanceMeasure(activeLookPosition) <= MaximumDistance)
			{
				LookState = EFHeadLookState.Null;
				OnRangeStateChanged();
			}
		}
		else if (LookState == EFHeadLookState.OutOfMaxDistance)
		{
			LookState = EFHeadLookState.Null;
		}
	}

	protected virtual void OnTargetChanged()
	{
		TargetChangedMeasures();
	}

	protected virtual void OnRangeStateChanged()
	{
		TargetChangedMeasures();
	}

	private void BeginStateCheck()
	{
		if ((Object)(object)activeLookTarget == (Object)null)
		{
			LookState = EFHeadLookState.Null;
		}
		else if (LookState == EFHeadLookState.Null)
		{
			LookState = EFHeadLookState.Following;
		}
		previousState = LookState;
		isLooking = LookState != EFHeadLookState.OutOfMaxDistance && LookState != EFHeadLookState.OutOfMaxRotation;
	}

	private void LookWhenAboveGoBackCalculations()
	{
		if (whenAboveGoBackDuration > 0f)
		{
			if (WhenAboveGoBackAfter > 0f)
			{
				animatedLookWhenAbove = Mathf.SmoothDamp(animatedLookWhenAbove, 0f, ref _whenAboveGoBackVelo, whenAboveGoBackDuration, float.PositiveInfinity, delta);
				if (animatedLookWhenAbove <= 0.001f)
				{
					whenAboveGoBackDuration = 0f;
				}
				if (LookWhenAboveVertical <= 0f)
				{
					animatedLookWhenAboveVertical = animatedLookWhenAbove;
				}
				else
				{
					animatedLookWhenAboveVertical = Mathf.SmoothDamp(animatedLookWhenAboveVertical, 0f, ref _whenAboveGoBackVerticalVelo, whenAboveGoBackDuration, float.PositiveInfinity, delta);
				}
			}
			return;
		}
		if (animatedLookWhenAbove < LookWhenAbove)
		{
			animatedLookWhenAbove = Mathf.SmoothDamp(animatedLookWhenAbove, LookWhenAbove, ref _whenAboveGoBackVelo, whenAboveGoBackDuration, float.PositiveInfinity, delta);
		}
		if (LookWhenAboveVertical <= 0f)
		{
			animatedLookWhenAboveVertical = animatedLookWhenAbove;
		}
		else if (animatedLookWhenAboveVertical < LookWhenAboveVertical)
		{
			animatedLookWhenAboveVertical = Mathf.SmoothDamp(animatedLookWhenAboveVertical, LookWhenAboveVertical, ref _whenAboveGoBackVerticalVelo, whenAboveGoBackDuration, float.PositiveInfinity, delta);
		}
		if (WhenAboveGoBackAfter > 0f)
		{
			float num = Mathf.Abs(_preLookAboveLookAngles.x - whenAboveGoBackAngles.x) + Mathf.Abs(_preLookAboveLookAngles.y - whenAboveGoBackAngles.y);
			whenAboveGoBackTimer += delta * Mathf.Lerp(0f, 1f, Mathf.InverseLerp(LookWhenAbove / 5f, LookWhenAbove, num));
			if (whenAboveGoBackTimer > WhenAboveGoBackAfter)
			{
				whenAboveGoBackTimer = 0f;
				whenAboveGoBackDuration = WhenAboveGoBackDuration;
			}
		}
	}

	private void PreCalibrateBones()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (Calibration)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				LookBones[i].Transform.localRotation = LookBones[i].initLocalRot;
			}
		}
	}

	private void CalibrateBones()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (OverrideRotations > 0f)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				LookBones[i].Transform.localRotation = Quaternion.LerpUnclamped(LookBones[i].Transform.localRotation, LookBones[i].initLocalRot, OverrideRotations * LookAnimatorAmount);
			}
		}
		if (ConstantParentalAxisUpdate)
		{
			RefreshParentalLookReferenceAxis();
		}
		if (RotationSpeed >= 2.5f)
		{
			instantRotation = true;
		}
		else
		{
			instantRotation = false;
		}
		if (refreshReferencePose)
		{
			RefreshReferencePose();
		}
		if (_preBackBonesCount != BackBonesCount)
		{
			if (BackBonesCount > _preBackBonesCount)
			{
				for (int j = _preBackBonesCount; j < LookBones.Count; j++)
				{
					LookBones[j].RefreshStaticRotation();
				}
			}
			preWeightFaloff = FaloffValue - 0.001f;
			_preBackBonesCount = BackBonesCount;
		}
		for (int k = 0; k < CompensationBones.Count; k++)
		{
			if (!((Object)(object)CompensationBones[k].Transform == (Object)null))
			{
				CompensationBones[k].RefreshCompensationFrame();
				CompensationBones[k].CheckForZeroKeyframes();
			}
		}
		if (!BigAngleAutomation)
		{
			if (AutoBackbonesWeights)
			{
				if (FaloffValue != preWeightFaloff)
				{
					SetAutoWeightsDefault();
				}
			}
			else
			{
				RefreshBoneMotionWeights();
			}
			LookBones[0].motionWeight = LookBones[0].lookWeight;
		}
		else
		{
			UpdateAutomationWeights();
		}
		switch (DeltaType)
		{
		case EFDeltaType.DeltaTime:
			delta = Time.deltaTime;
			break;
		case EFDeltaType.SmoothDeltaTime:
			delta = Time.smoothDeltaTime;
			break;
		case EFDeltaType.UnscaledDeltaTime:
			delta = Time.unscaledDeltaTime;
			break;
		case EFDeltaType.FixedDeltaTime:
			delta = Time.fixedDeltaTime;
			break;
		}
		delta *= SimulationSpeed;
		if (RefreshStartLookPoint)
		{
			RefreshLookStartPositionAnchor();
		}
		changeTargetSmootherWeight = Mathf.Min(1f, changeTargetSmootherWeight + delta * 0.6f);
		changeTargetSmootherBones = Mathf.Min(1f, changeTargetSmootherBones + delta * 0.6f);
	}

	private void ChangeBonesRotations()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < LookBones.Count; i++)
		{
			LookBones[i].Transform.rotation = LookBones[i].finalRotation;
		}
		LookBones[0].Transform.rotation = LookBones[0].finalRotation;
		if (BigAngleAutomationCompensation)
		{
			float num = Mathf.InverseLerp(45f, 170f, Mathf.Abs(unclampedLookAngles.y));
			targetCompensationWeight = Mathf.Lerp(CompensationWeight, CompensationWeightB, num);
			targetCompensationPosWeight = Mathf.Lerp(CompensatePositions, CompensatePositionsB, num);
		}
		else
		{
			targetCompensationWeight = CompensationWeight;
			targetCompensationPosWeight = CompensatePositions;
		}
		for (int j = 0; j < CompensationBones.Count; j++)
		{
			if (!((Object)(object)CompensationBones[j].Transform == (Object)null))
			{
				CompensationBones[j].SetRotationCompensation(targetCompensationWeight);
				CompensationBones[j].SetPositionCompensation(targetCompensationPosWeight);
			}
		}
		if (UseBoneOffsetRotation)
		{
			for (int k = 0; k < LookBones.Count; k++)
			{
				LookBones[k].lastFinalLocalRotation = LookBones[k].Transform.localRotation;
			}
		}
	}

	private void CheckOverrideReference()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Expected O, but got Unknown
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!overrideRefInitialized)
		{
			GameObject val = new GameObject(((Object)LookBones[0].Transform).name + "-Overr");
			val.transform.SetParent(LookBones[0].Transform);
			val.transform.localRotation = Quaternion.identity;
			val.transform.localPosition = Vector3.zero;
			headOv = new UniRotateBone(val.transform, BaseTransform);
			headOv.RefreshCustomAxis(Vector3.up, Vector3.forward);
			overrideRefInitialized = true;
		}
	}

	private void PostAnimatingTweaks()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (OverrideHeadForPerfectLookDirection > 0f)
		{
			CheckOverrideReference();
			Quaternion rotation = LookBones[0].Transform.rotation;
			headOv.transform.localRotation = headOv.initialLocalRotation;
			Vector3 direction = activeLookPosition - headOv.transform.position;
			Vector2 customLookAngles = headOv.GetCustomLookAngles(direction, headOv);
			headOv.transform.rotation = headOv.RotateCustomAxis(customLookAngles.x + RotationOffset.x, customLookAngles.y + RotationOffset.y, headOv) * headOv.transform.rotation;
			LookBones[0].Transform.rotation = Quaternion.Lerp(rotation, headOv.transform.rotation, OverrideHeadForPerfectLookDirection);
		}
	}

	private void ResetBones(bool onlyIfNull = false)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		if (UseBoneOffsetRotation)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				LookBones[i].animatedTargetRotation = Quaternion.identity;
				LookBones[i].targetRotation = LookBones[i].animatedTargetRotation;
				LookBones[i].finalRotation = LookBones[i].animatedTargetRotation;
			}
		}
		else
		{
			for (int j = 0; j < LookBones.Count; j++)
			{
				LookBones[j].animatedTargetRotation = LookBones[j].Transform.rotation;
				LookBones[j].targetRotation = LookBones[j].animatedTargetRotation;
				LookBones[j].finalRotation = LookBones[j].animatedTargetRotation;
			}
		}
	}

	internal void RefreshLookBones()
	{
		if (LookBones == null)
		{
			LookBones = new List<LookBone>();
			LookBones.Add(new LookBone(null));
		}
		if (LookBones.Count == 0)
		{
			LookBones.Add(new LookBone(null));
		}
		if (LookBones.Count > BackBonesCount + 1)
		{
			LookBones.RemoveRange(BackBonesCount + 1, LookBones.Count - (BackBonesCount + 1));
		}
		if (Object.op_Implicit((Object)(object)LeadBone))
		{
			if ((Object)(object)LookBones[0].Transform != (Object)(object)LeadBone)
			{
				LookBones[0] = new LookBone(LeadBone);
				if (Object.op_Implicit((Object)(object)BaseTransform))
				{
					LookBones[0].RefreshBoneDirections(BaseTransform);
				}
			}
			for (int i = 1; i < 1 + BackBonesCount; i++)
			{
				if (i >= LookBones.Count)
				{
					LookBone lookBone = new LookBone(LookBones[i - 1].Transform.parent);
					LookBones.Add(lookBone);
					if (Object.op_Implicit((Object)(object)BaseTransform))
					{
						lookBone.RefreshBoneDirections(BaseTransform);
					}
				}
				else if (LookBones[i] == null || (Object)(object)LookBones[i].Transform == (Object)null)
				{
					LookBones[i] = new LookBone(LookBones[i - 1].Transform.parent);
					if (Object.op_Implicit((Object)(object)BaseTransform))
					{
						LookBones[i].RefreshBoneDirections(BaseTransform);
					}
				}
			}
		}
		else
		{
			while (LookBones.Count > 1)
			{
				LookBones.RemoveAt(LookBones.Count - 1);
			}
		}
	}

	private void RefreshReferencePose()
	{
		for (int i = 0; i < LookBones.Count; i++)
		{
			LookBones[i].RefreshStaticRotation(!MonitorAnimator);
		}
		if (MonitorAnimator)
		{
			((MonoBehaviour)this).StopCoroutine(CRefreshReferencePose());
			((MonoBehaviour)this).StartCoroutine(CRefreshReferencePose());
		}
		refreshReferencePose = false;
	}

	private IEnumerator CRefreshReferencePose()
	{
		yield return null;
		yield return CoroutineEx.waitForSecondsRealtime(0.05f);
		if (_monitorTransitionStart == null)
		{
			_monitorTransitionStart = new List<Quaternion>();
		}
		if (_monitorTransitionStart.Count != LookBones.Count)
		{
			for (int i = 0; i < LookBones.Count; i++)
			{
				_monitorTransitionStart.Add(LookBones[i].animatedStaticRotation);
			}
		}
		for (int j = 0; j < LookBones.Count; j++)
		{
			LookBones[j].RefreshStaticRotation(hard: false);
		}
		float elapsed = 0f;
		while (elapsed < monitorTransitionTime)
		{
			elapsed += delta;
			float num = FEasing.EaseInOutCubic(0f, 1f, elapsed / monitorTransitionTime);
			for (int k = 0; k < LookBones.Count; k++)
			{
				LookBones[k].animatedStaticRotation = Quaternion.Slerp(_monitorTransitionStart[k], LookBones[k].targetStaticRotation, num);
			}
			yield return null;
		}
		for (int l = 0; l < LookBones.Count; l++)
		{
			LookBones[l].animatedStaticRotation = LookBones[l].targetStaticRotation;
		}
	}

	public void InitializeBaseVariables()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		_LOG_NoRefs();
		LookState = EFHeadLookState.Null;
		if (AutoBackbonesWeights)
		{
			SetAutoWeightsDefault();
		}
		ComputeBonesRotationsFixVariables();
		InitBirdMode();
		ResetBones();
		smoothLookPosition = GetForwardPosition();
		lookFreezeFocusPoint = BaseTransform.InverseTransformPoint(smoothLookPosition);
		refreshReferencePose = true;
		RefreshStartLookPoint = true;
		rootStaticRotation = BaseTransform.rotation;
		_preBackBonesCount = BackBonesCount;
		lastBaseRotation = BaseTransform.rotation;
		for (int i = 0; i < LookBones.Count; i++)
		{
			if (LookBones[i].correctionOffset == Vector3.zero)
			{
				LookBones[i].correctionOffset = Vector3.zero;
			}
			LookBones[i].lastKeyframeRotation = LookBones[i].Transform.localRotation;
			LookBones[i].RefreshBoneDirections(BaseTransform);
		}
		CheckOverrideReference();
		if (UseEyes)
		{
			InitEyesModule();
		}
		initialized = true;
	}

	public void FindBaseTransform()
	{
		BaseTransform = ((Component)this).transform;
		if (!Object.op_Implicit((Object)(object)((Component)this).GetComponentInChildren<Animator>()) && !Object.op_Implicit((Object)(object)((Component)this).GetComponentInChildren<Animation>()))
		{
			Debug.LogWarning((object)(((Object)((Component)this).gameObject).name + " don't have animator. '" + ((Object)this).name + "' is it root transform for your character?"));
		}
	}

	public Vector3 TryFindHeadPositionInTarget(Transform other)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		FLookAnimator component = ((Component)other).GetComponent<FLookAnimator>();
		if (Object.op_Implicit((Object)(object)component) && Object.op_Implicit((Object)(object)component.LeadBone))
		{
			return component.GetLookStartMeasurePosition();
		}
		Animator componentInChildren = ((Component)other).GetComponentInChildren<Animator>();
		if (Object.op_Implicit((Object)(object)componentInChildren) && componentInChildren.isHuman)
		{
			if (Object.op_Implicit((Object)(object)componentInChildren.GetBoneTransform((HumanBodyBones)21)))
			{
				return componentInChildren.GetBoneTransform((HumanBodyBones)21).position;
			}
			if (Object.op_Implicit((Object)(object)componentInChildren.GetBoneTransform((HumanBodyBones)10)))
			{
				return componentInChildren.GetBoneTransform((HumanBodyBones)10).position;
			}
		}
		Renderer componentInChildren2 = ((Component)other).GetComponentInChildren<Renderer>();
		if (!Object.op_Implicit((Object)(object)componentInChildren2) && other.childCount > 0)
		{
			componentInChildren2 = ((Component)other.GetChild(0)).GetComponentInChildren<Renderer>();
		}
		if (Object.op_Implicit((Object)(object)componentInChildren2))
		{
			Vector3 position = other.position;
			Vector3 up = Vector3.up;
			Bounds bounds = componentInChildren2.bounds;
			Vector3 val = position + other.TransformVector(up * (((Bounds)(ref bounds)).max.y * 0.9f));
			Vector3 forward = Vector3.forward;
			bounds = componentInChildren2.bounds;
			return val + other.TransformVector(forward * (((Bounds)(ref bounds)).max.z * 0.75f));
		}
		return other.position;
	}

	public void OnDrop(PointerEventData data)
	{
	}

	private float GetClampedAngle(float current, float limit, float elastic, float sign = 1f)
	{
		if (elastic <= 0f)
		{
			return limit;
		}
		float num = 0f;
		if (elastic > 0f)
		{
			num = FEasing.EaseOutCubic(0f, elastic, (current * sign - limit * sign) / (180f + limit * sign));
		}
		return limit + num * sign;
	}

	private void ComputeBonesRotationsFixVariables()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)BaseTransform != (Object)null)
		{
			Quaternion rotation = BaseTransform.rotation;
			BaseTransform.rotation = Quaternion.identity;
			FromAuto = LeadBone.rotation * -Vector3.forward;
			float num = Quaternion.Angle(Quaternion.identity, LeadBone.rotation);
			Quaternion val = LeadBone.rotation * Quaternion.Inverse(Quaternion.FromToRotation(FromAuto, ModelForwardAxis));
			Vector3 eulerAngles = ((Quaternion)(ref val)).eulerAngles;
			Quaternion val2 = Quaternion.AngleAxis(num, ((Vector3)(ref eulerAngles)).normalized);
			OffsetAuto = ((Quaternion)(ref val2)).eulerAngles;
			BaseTransform.rotation = rotation;
			RefreshParentalLookReferenceAxis();
			headForward = Quaternion.FromToRotation(LeadBone.InverseTransformDirection(BaseTransform.TransformDirection(((Vector3)(ref ModelForwardAxis)).normalized)), Vector3.forward) * Vector3.forward;
		}
		else
		{
			Debug.LogWarning((object)"Base Transform isn't defined, so we can't use auto correction!");
		}
	}

	private void RefreshParentalLookReferenceAxis()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		parentalReferenceLookForward = Quaternion.Inverse(LeadBone.parent.rotation) * BaseTransform.rotation * ((Vector3)(ref ModelForwardAxis)).normalized;
		parentalReferenceUp = Quaternion.Inverse(LeadBone.parent.rotation) * BaseTransform.rotation * ((Vector3)(ref ModelUpAxis)).normalized;
	}

	public Vector3 GetCurrentHeadForwardDirection()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		return LeadBone.rotation * Quaternion.FromToRotation(headForward, Vector3.forward) * Vector3.forward;
	}

	private void _LOG_NoRefs()
	{
	}

	private void _Debug_Rays()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (DebugRays)
		{
			Debug.DrawRay(GetLookStartMeasurePosition() + Vector3.up * 0.01f, Quaternion.Euler(finalLookAngles) * BaseTransform.TransformDirection(ModelForwardAxis), Color.cyan);
		}
	}

	private Vector3 WrapVector(Vector3 v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(FLogicMethods.WrapAngle(v.x), FLogicMethods.WrapAngle(v.y), FLogicMethods.WrapAngle(v.z));
	}

	private Vector3 ConvertFlippedAxes(Vector3 rotations)
	{
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		if (FixingPreset != 0)
		{
			Quaternion val;
			if (FixingPreset == EFAxisFixOrder.FromBased)
			{
				rotations += OffsetAuto;
				val = Quaternion.Euler(rotations) * Quaternion.FromToRotation(FromAuto, ModelForwardAxis);
				rotations = ((Quaternion)(ref val)).eulerAngles;
			}
			else
			{
				if (FixingPreset == EFAxisFixOrder.FullManual)
				{
					rotations.x *= RotCorrectionMultiplier.x;
					rotations.y *= RotCorrectionMultiplier.y;
					rotations.z *= RotCorrectionMultiplier.z;
					val = Quaternion.Euler(rotations) * Quaternion.FromToRotation(ManualFromAxis, ManualToAxis);
					return ((Quaternion)(ref val)).eulerAngles;
				}
				if (FixingPreset == EFAxisFixOrder.ZYX)
				{
					val = Quaternion.Euler(rotations.z, rotations.y - 90f, 0f - rotations.x - 90f);
					return ((Quaternion)(ref val)).eulerAngles;
				}
			}
		}
		return rotations;
	}

	public static float AngleAroundAxis(Vector3 firstDirection, Vector3 secondDirection, Vector3 axis)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		firstDirection -= Vector3.Project(firstDirection, axis);
		secondDirection -= Vector3.Project(secondDirection, axis);
		return Vector3.Angle(firstDirection, secondDirection) * (float)((!(Vector3.Dot(axis, Vector3.Cross(firstDirection, secondDirection)) < 0f)) ? 1 : (-1));
	}

	private void Reset()
	{
		FindBaseTransform();
	}

	private void Awake()
	{
		_LOG_NoRefs();
	}

	protected virtual void Start()
	{
		initialized = false;
		if (!StartAfterTPose)
		{
			InitializeBaseVariables();
		}
		else
		{
			startAfterTPoseCounter = 0;
		}
	}

	private void OnDisable()
	{
		wasUpdating = false;
		animatePhysicsWorking = false;
	}

	public void ResetLook()
	{
		ResetBones();
		finalMotionWeight = 0f;
		_velo_animatedMotionWeight = 0f;
		animatedMotionWeight = 0f;
	}

	private void Update()
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FLookAnimator:Update", 0);
		try
		{
			if (!initialized)
			{
				if (StartAfterTPose)
				{
					startAfterTPoseCounter++;
					if (startAfterTPoseCounter > 6)
					{
						InitializeBaseVariables();
					}
				}
				updateLookAnimator = false;
				return;
			}
			if ((Object)(object)OptimizeWithMesh != (Object)null && !OptimizeWithMesh.isVisible)
			{
				updateLookAnimator = false;
				wasUpdating = false;
				return;
			}
			if (!wasUpdating)
			{
				ResetLook();
				wasUpdating = true;
			}
			if (AnimatePhysics)
			{
				if (!animatePhysicsWorking)
				{
					((MonoBehaviour)this).StartCoroutine(AnimatePhysicsClock());
				}
				if (!triggerAnimatePhysics)
				{
					updateLookAnimator = false;
					return;
				}
				triggerAnimatePhysics = false;
			}
			if (finalMotionWeight < 0.01f)
			{
				animatedLookAngles = Vector3.zero;
				if (LookAnimatorAmount <= 0f)
				{
					updateLookAnimator = false;
					return;
				}
			}
			UpdateCorrectionMatrix();
			updateLookAnimator = true;
			if (!AnimatePhysics)
			{
				PreCalibrateBones();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FixedUpdate()
	{
		TimeWarning val = TimeWarning.New("FLookAnimator:FixedUpdate", 0);
		try
		{
			if (updateLookAnimator && AnimatePhysics)
			{
				PreCalibrateBones();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void LateUpdate()
	{
		TimeWarning val = TimeWarning.New("FLookAnimator:LateUpdate", 0);
		try
		{
			if (updateLookAnimator)
			{
				CalibrateBones();
				TargetingUpdate();
				BeginStateCheck();
				UpdateSmoothing();
				MaxDistanceCalculations();
				NoddingCalculations();
				CalculateLookAnimation();
				UpdateLookAnimatorAmountWeight();
				ChangeBonesRotations();
				_Debug_Rays();
				if (BirdMode)
				{
					CalculateBirdMode();
				}
				if (UseEyes)
				{
					UpdateEyesLogics();
				}
				EndUpdate();
				PostAnimatingTweaks();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class CompensationBone
{
	public Transform Transform;

	private Vector3 compensatedPosition;

	private Quaternion compensatedRotation;

	private Quaternion lastFinalLocalRotation;

	private Quaternion lastKeyframeLocalRotation;

	private Vector3 lastFinalLocalPosition;

	private Vector3 lastKeyframeLocalPosition;

	public CompensationBone(Transform t)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Transform = t;
		if (Object.op_Implicit((Object)(object)t))
		{
			lastKeyframeLocalPosition = t.localPosition;
			lastKeyframeLocalRotation = t.localRotation;
		}
	}

	public void RefreshCompensationFrame()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		compensatedPosition = Transform.position;
		compensatedRotation = Transform.rotation;
	}

	public void CheckForZeroKeyframes()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if (lastFinalLocalRotation.QIsSame(Transform.localRotation))
		{
			Transform.localRotation = lastKeyframeLocalRotation;
			compensatedRotation = Transform.rotation;
		}
		else
		{
			lastKeyframeLocalRotation = Transform.localRotation;
		}
		if (lastFinalLocalPosition.VIsSame(Transform.localPosition))
		{
			Transform.localPosition = lastKeyframeLocalPosition;
			compensatedPosition = Transform.position;
		}
		else
		{
			lastKeyframeLocalPosition = Transform.localPosition;
		}
	}

	public void SetRotationCompensation(float weight)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (weight > 0f)
		{
			if (weight >= 1f)
			{
				Transform.rotation = compensatedRotation;
			}
			else
			{
				Transform.rotation = Quaternion.LerpUnclamped(Transform.rotation, compensatedRotation, weight);
			}
			lastFinalLocalRotation = Transform.localRotation;
		}
	}

	public void SetPositionCompensation(float weight)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (weight > 0f)
		{
			if (weight >= 1f)
			{
				Transform.position = compensatedPosition;
			}
			else
			{
				Transform.position = Vector3.LerpUnclamped(Transform.position, compensatedPosition, weight);
			}
			lastFinalLocalPosition = Transform.localPosition;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class LookBone
{
	public Transform Transform;

	public Quaternion animatedStaticRotation;

	public Quaternion targetStaticRotation;

	public Quaternion localStaticRotation;

	public Quaternion animatedTargetRotation;

	public Quaternion targetRotation;

	public Vector3 correctionOffset;

	public Quaternion finalRotation;

	public Quaternion lastKeyframeRotation;

	public Quaternion lastFinalLocalRotation;

	public Vector3 forward;

	public Vector3 right;

	public Vector3 up;

	public Vector3 initLocalPos = Vector3.zero;

	public Quaternion initLocalRot = Quaternion.identity;

	public Vector3 targetDelayPosition;

	public Vector3 animatedDelayPosition;

	public float lookWeight = 1f;

	public float lookWeightB = 1f;

	public float motionWeight = 1f;

	public Quaternion correctionOffsetQ => Quaternion.Euler(correctionOffset);

	public LookBone(Transform t)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Transform = t;
		correctionOffset = Vector3.zero;
		if ((Object)(object)t != (Object)null)
		{
			initLocalPos = t.localPosition;
			initLocalRot = t.localRotation;
		}
	}

	public void RefreshBoneDirections(Transform baseTransform)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)Transform == (Object)null))
		{
			forward = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.forward), Vector3.forward) * Vector3.forward;
			up = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.up), Vector3.up) * Vector3.up;
			right = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.right), Vector3.right) * Vector3.right;
		}
	}

	public void RefreshStaticRotation(bool hard = true)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		targetStaticRotation = Transform.rotation;
		if (initLocalPos == Vector3.zero)
		{
			initLocalPos = Transform.localPosition;
		}
		if (hard)
		{
			animatedStaticRotation = targetStaticRotation;
		}
		localStaticRotation = Transform.localRotation;
	}

	internal void CalculateMotion(Quaternion targetLook, float overallWeightMultiplier, float delta, float mainWeight)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		targetRotation = GetTargetRot(targetLook, motionWeight * overallWeightMultiplier);
		if (delta < 1f)
		{
			animatedTargetRotation = Quaternion.LerpUnclamped(animatedTargetRotation, targetRotation, delta);
		}
		else
		{
			animatedTargetRotation = targetRotation;
		}
		finalRotation = Quaternion.LerpUnclamped(Transform.rotation, animatedTargetRotation * Transform.rotation, mainWeight);
	}

	internal Quaternion GetTargetRot(Quaternion targetLook, float weight)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LerpUnclamped(Quaternion.identity, targetLook, weight);
	}
}


public enum EEditorLookCategory
{
	Setup,
	Tweak,
	Limit,
	Features,
	Corrections
}


public enum EFAxisFixOrder
{
	Parental,
	FromBased,
	FullManual,
	ZYX
}


public enum EFHeadLookState
{
	Null,
	Following,
	OutOfMaxRotation,
	ClampedAngle,
	OutOfMaxDistance
}


public enum EFFollowMode
{
	FollowObject,
	LocalOffset,
	WorldOffset,
	ToFollowSpaceOffset,
	FollowJustPosition
}


public enum EFDeltaType
{
	DeltaTime,
	SmoothDeltaTime,
	UnscaledDeltaTime,
	FixedDeltaTime
}


public enum EFAnimationStyle
{
	SmoothDamp,
	FastLerp,
	Linear
}


using FIMSpace.FLook;
using UnityEngine;

public class SM_SwitchLookAnimator : StateMachineBehaviour
{
	[Range(0f, 1f)]
	[Tooltip("Time of animation")]
	public float EnableBackAfter = 0.9f;

	public float TransitionDuration = 0.3f;

	private bool enableBackTriggered;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateEnter(animator, stateInfo, layerIndex);
		SwitchLook(animator, enable: false);
		enableBackTriggered = false;
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		if (!animator.IsInTransition(layerIndex) && ((AnimatorStateInfo)(ref stateInfo)).normalizedTime > EnableBackAfter && !enableBackTriggered)
		{
			SwitchLook(animator, enable: true);
			enableBackTriggered = true;
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateExit(animator, stateInfo, layerIndex);
		if (!enableBackTriggered)
		{
			SwitchLook(animator, enable: true);
			enableBackTriggered = true;
		}
	}

	private void SwitchLook(Animator animator, bool enable)
	{
		((Component)animator).GetComponentInChildren<FLookAnimator>().SwitchLooking(enable, TransitionDuration);
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "LA Leg Motion Settings", menuName = "FImpossible Creations/Legs Animator/Leg Motion Preset", order = 0)]
public class LegMotionSettingsPreset : ScriptableObject
{
	[Header("Settings for single leg - leg animation style")]
	public LegsAnimator.LegStepAnimatingParameters Settings;

	private void Reset()
	{
		Settings = new LegsAnimator.LegStepAnimatingParameters();
		Settings.RefreshDefaultCurves();
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using FIMSpace;
using FIMSpace.AnimationTools;
using FIMSpace.FProceduralAnimation;
using FIMSpace.FTools;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

[HelpURL("https://assetstore.unity.com/packages/tools/animation/legs-animator-154245")]
[AddComponentMenu("FImpossible Creations/Legs Animator")]
[DefaultExecutionOrder(-1301)]
public class LegsAnimator : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon
{
	private struct CalibrateTransform
	{
		public Transform Transform;

		private Quaternion initLocalRot;

		public CalibrateTransform(Transform t)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			Transform = t;
			initLocalRot = t.localRotation;
		}

		public void Calibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			Transform.localRotation = initLocalRot;
		}
	}

	public enum EStepType
	{
		IdleGluing,
		MovementGluing,
		OnLanding,
		OnStopping
	}

	public interface ILegStepReceiver
	{
		void LegAnimatorStepEvent(Leg leg, float power, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
	}

	public interface ILegRaiseReceiver
	{
		void LegAnimatorRaiseEvent(Leg leg, float predictedDistance, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
	}

	[Serializable]
	public class LegsAnimatorCustomModuleHelper
	{
		public bool Enabled = true;

		public LegsAnimator Parent;

		public LegsAnimatorControlModuleBase ModuleReference;

		[SerializeField]
		[HideInInspector]
		public List<string> customStringList;

		[SerializeField]
		[HideInInspector]
		public List<Object> customObjectList;

		[SerializeField]
		private List<Variable> variables = new List<Variable>();

		public LegsAnimatorControlModuleBase PlaymodeModule { get; private set; }

		public LegsAnimatorControlModuleBase CurrentModule => PlaymodeModule;

		public LegsAnimatorCustomModuleHelper(LegsAnimator get)
		{
			Parent = get;
		}

		public void PreparePlaymodeModule(LegsAnimator parent)
		{
			if (!((Object)(object)PlaymodeModule != (Object)null) && !((Object)(object)ModuleReference == (Object)null))
			{
				PlaymodeModule = Object.Instantiate<LegsAnimatorControlModuleBase>(ModuleReference);
				PlaymodeModule.Base_Init(parent, this);
			}
		}

		public void DisposeModule()
		{
			if ((Object)(object)PlaymodeModule != (Object)null)
			{
				Object.Destroy((Object)(object)PlaymodeModule);
			}
			PlaymodeModule = null;
		}

		public Variable RequestVariable(string name, object defaultValue)
		{
			if (variables == null)
			{
				variables = new List<Variable>();
			}
			int hashCode = name.GetHashCode();
			for (int i = 0; i < variables.Count; i++)
			{
				if (variables[i].GetNameHash == hashCode)
				{
					return variables[i];
				}
			}
			Variable variable = new Variable(name, defaultValue);
			variables.Add(variable);
			return variable;
		}
	}

	[Serializable]
	public class PelvisImpulseSettings
	{
		public string OptionalName = "Impulse";

		[Space(3f)]
		public float PowerMultiplier = 1f;

		[Tooltip("Duration of translation impulse in seconds")]
		public float ImpulseDuration = 0.5f;

		[Space(5f)]
		public Vector3 WorldTranslation = Vector3.zero;

		public Vector3 LocalTranslation = new Vector3(0f, -0.2f, 0.1f);

		[Space(5f)]
		public Vector3 HipsRotate = Vector3.zero;

		[Space(5f)]
		[Range(0f, 1f)]
		public float InheritElasticness = 0.75f;

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
		public AnimationCurve ImpulseCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
		public AnimationCurve YAxisMultiplyCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

		[Tooltip("Local Offset Z-forward will bo rotated to face the legs animator's current desired move direction value")]
		[Space(5f)]
		public bool AlignWithDesiredMoveDirection;

		public PelvisImpulseSettings Copy()
		{
			return (PelvisImpulseSettings)MemberwiseClone();
		}

		public PelvisImpulseSettings()
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			ImpulseCurve = GetDefaultCurveInstance();
		}

		public static AnimationCurve GetDefaultCurveInstance()
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			AnimationCurve obj = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);
			obj.AddKey(new Keyframe(0.2f, 1f));
			obj.SmoothTangents(1, 0.5f);
			return obj;
		}

		public PelvisImpulseSettings(Vector3 vector3, float duration, float power)
			: this()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			LocalTranslation = vector3;
			ImpulseDuration = duration;
			PowerMultiplier = power;
		}
	}

	public struct ImpulseExecutor
	{
		public float Elapsed;

		public float PowerMultiplier;

		public float ImpulseDuration;

		public Vector3 WorldTranslation;

		public Vector3 LocalTranslation;

		public float InheritElasticness;

		public Vector3 HipsRotation;

		public bool AlignDesired;

		public AnimationCurve ImpulseCurve;

		public AnimationCurve YAxisMultiplyCurve;

		private static AnimationCurve _defaultCurve;

		private static AnimationCurve _defaultCurve11;

		public static AnimationCurve DefaultCurve
		{
			get
			{
				if (_defaultCurve == null)
				{
					_defaultCurve = PelvisImpulseSettings.GetDefaultCurveInstance();
				}
				return _defaultCurve;
			}
		}

		public static AnimationCurve DefaultCurve11
		{
			get
			{
				if (_defaultCurve11 == null)
				{
					_defaultCurve11 = AnimationCurve.Linear(0f, 1f, 1f, 1f);
				}
				return _defaultCurve11;
			}
		}

		public bool Finished => Elapsed >= ImpulseDuration;

		public float Progress
		{
			get
			{
				if (ImpulseDuration != 0f)
				{
					return Elapsed / ImpulseDuration;
				}
				return 1f;
			}
		}

		public float Evaluation => ImpulseCurve.Evaluate(Progress);

		public float Elastic => InheritElasticness;

		public float Power => PowerMultiplier;

		public Vector3 CurrentLocalOffset => LocalTranslation * Evaluation * Power;

		public float CurrentLocalYAxisMultiplier => YAxisMultiplyCurve.Evaluate(Progress);

		public Vector3 CurrentWorldOffset => WorldTranslation * Evaluation * Power;

		public ImpulseExecutor(PelvisImpulseSettings settings, float powerMultiplier = 1f, float durationMultiplier = 1f)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			Elapsed = 0f;
			PowerMultiplier = settings.PowerMultiplier * powerMultiplier;
			ImpulseDuration = settings.ImpulseDuration * durationMultiplier;
			WorldTranslation = settings.WorldTranslation;
			LocalTranslation = settings.LocalTranslation;
			InheritElasticness = settings.InheritElasticness;
			HipsRotation = settings.HipsRotate;
			ImpulseCurve = settings.ImpulseCurve;
			YAxisMultiplyCurve = settings.YAxisMultiplyCurve;
			AlignDesired = settings.AlignWithDesiredMoveDirection;
		}

		public ImpulseExecutor(Vector3 localOffset, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = Vector3.zero;
			LocalTranslation = localOffset;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			HipsRotation = Vector3.zero;
			AlignDesired = alignWithDesiredDir;
		}

		public ImpulseExecutor(Vector3 localOffset, Vector3 hipsRotation, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = Vector3.zero;
			HipsRotation = hipsRotation;
			LocalTranslation = localOffset;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			AlignDesired = alignWithDesiredDir;
		}

		public ImpulseExecutor(float duration, Vector3 worldOffset, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = worldOffset;
			HipsRotation = Vector3.zero;
			LocalTranslation = Vector3.zero;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			AlignDesired = alignWithDesiredDir;
		}

		public void Update(float delta)
		{
			Elapsed += delta;
		}
	}

	public enum EHipsAdjustStyle
	{
		SmoothDamp,
		FollowLegHeight
	}

	public enum EHipsHubsHandling
	{
		[Tooltip("Applying hips movement offset to the selected hub, in order to fix disconnected hips bones (rare case)")]
		FixDisconnected,
		[Tooltip("Detailed mode is computing hips hub offsets individually, giving more realistic effect but costs a bit more")]
		Detailed
	}

	[Serializable]
	public class HipsReference
	{
		public class HipsHubBackbone
		{
			public Transform frontBone;

			private Vector3 _dir = Vector3.zero;

			private Vector3 _sd_dir = Vector3.zero;

			private FMuscle_Vector3 _FMuscle;

			public LegsAnimator Owner { get; private set; }

			public Transform bone { get; private set; }

			public Quaternion initialLocalRotation { get; private set; }

			public Vector3 keyframePosition { get; private set; }

			public Quaternion TargetRotation { get; internal set; }

			public HipsHubBackbone(LegsAnimator owner, Transform b)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Unknown result type (might be due to invalid IL or missing references)
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				Owner = owner;
				bone = b;
				initialLocalRotation = b.localRotation;
				_FMuscle = new FMuscle_Vector3();
				_FMuscle.Initialize(Vector3.zero);
			}

			public void PreCalibrate()
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				bone.localRotation = initialLocalRotation;
			}

			public void Calibrate()
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				keyframePosition = bone.position;
			}

			public Vector3 AnimateTargetDirection(Vector3 toHubNewB)
			{
				//IL_0012: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0074: Unknown result type (might be due to invalid IL or missing references)
				//IL_0075: Unknown result type (might be due to invalid IL or missing references)
				//IL_0085: Unknown result type (might be due to invalid IL or missing references)
				//IL_008a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0028: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0055: Unknown result type (might be due to invalid IL or missing references)
				//IL_005a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0090: Unknown result type (might be due to invalid IL or missing references)
				if (Owner.HubBackBonesElasticity < 0.0001f)
				{
					return toHubNewB;
				}
				if (Owner.HubBackBonesElasticity <= 0.1f)
				{
					_dir = Vector3.SmoothDamp(_dir, toHubNewB, ref _sd_dir, 0.001f + Owner.HubBackBonesElasticity, 10000000f, Owner.DeltaTime);
				}
				else
				{
					_dir = Vector3.LerpUnclamped(toHubNewB, _FMuscle.Update(Owner.DeltaTime, toHubNewB), Owner.HubBackBonesElasticity);
				}
				return _dir;
			}
		}

		[Tooltip("Applying elasticity algorithm on the pelvis bone align motion, to make it look more organic.")]
		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		public float HipsElasticityBlend = 1f;

		public FMuscle_Vector3 HipsMuscle;

		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		public float HipsRotElasticityBlend;

		public FMuscle_Quaternion HipsRotMuscle;

		[NonSerialized]
		public Vector3 LastKeyframePosition;

		[NonSerialized]
		public Vector3 LastKeyframeLocalPosition;

		[NonSerialized]
		public Quaternion LastKeyframeRotation;

		[NonSerialized]
		public Quaternion LastKeyframeLocalRotation;

		[NonSerialized]
		public Vector3 LastRootLocalPos;

		[NonSerialized]
		public float LastHipsHeightDiff;

		[NonSerialized]
		public Vector3 InitHipsPositionRootSpace;

		[NonSerialized]
		public float InitialHipsHeightLocal;

		[NonSerialized]
		internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

		private Transform root;

		private Vector3 initLocalPos;

		private Quaternion initLocalRot;

		private Vector3 _Hips_StabilityLocalAdjustement = Vector3.zero;

		private Vector3 _Hips_sd_StabilAdjustm = Vector3.zero;

		private Vector3 _stretchPreventerOff = Vector3.zero;

		private float _sd_Hips_StepHeightAdjustOffset;

		private int _h_lowestHitLeg = -1;

		private Vector3 _reAdjustLocal = Vector3.zero;

		private Vector3 _sd_readj = Vector3.zero;

		private Vector3 _pushSmoothed = Vector3.zero;

		private Vector3 _sd_pushSmoothed = Vector3.zero;

		public LegsAnimator Owner { get; private set; }

		public List<Leg> ChildLegs { get; private set; }

		public Transform bone { get; private set; }

		public UniRotateBone UniRotate { get; private set; }

		public List<HipsHubBackbone> HubBackBones { get; private set; }

		public Vector3 _Get_Hips_StabilityLocalAdjustement => _Hips_StabilityLocalAdjustement;

		public float _Hips_LastHipsOffset { get; private set; }

		public float _Hips_StepHeightAdjustOffset { get; private set; }

		public Vector3 ExtraNonElasticOffset { get; internal set; }

		public Vector3 _PreHipsAdjustPosition { get; internal set; }

		public void Initialize(LegsAnimator owner, Transform bone, Transform root)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			Owner = owner;
			this.bone = bone;
			this.root = root;
			initLocalPos = bone.localPosition;
			initLocalRot = bone.localRotation;
			ExtraNonElasticOffset = Vector3.zero;
			_Hips_StabilityLocalAdjustement = Vector3.zero;
			_Hips_sd_StabilAdjustm = Vector3.zero;
			InitHipsPositionRootSpace = root.InverseTransformPoint(bone.position);
			InitialHipsHeightLocal = InitHipsPositionRootSpace.y;
			if (HipsMuscle == null)
			{
				HipsMuscle = new FMuscle_Vector3();
			}
			if (HipsRotMuscle == null)
			{
				HipsRotMuscle = new FMuscle_Quaternion();
			}
			HipsMuscle.Initialize(Vector3.zero);
			HipsRotMuscle.Initialize(Quaternion.identity);
			UniRotate = new UniRotateBone(bone, root);
			Calibrate();
		}

		internal void PrepareLegs()
		{
			ChildLegs = new List<Leg>();
			if (!Owner._hipsHubs_using)
			{
				ChildLegs = Owner.Legs;
			}
			else
			{
				for (int i = 0; i < Owner.Legs.Count; i++)
				{
					bool? flag = IsFirstParent(Owner.Legs[i], bone);
					if (flag == true)
					{
						ChildLegs.Add(Owner.Legs[i]);
					}
					else if (!flag.HasValue && this == Owner.HipsSetup)
					{
						ChildLegs.Add(Owner.Legs[i]);
					}
				}
			}
			for (int j = 0; j < ChildLegs.Count; j++)
			{
				ChildLegs[j].AssignParentHub(this);
			}
		}

		internal void PrepareHubBones()
		{
			PrepareLegs();
			HubBackBones = new List<HipsHubBackbone>();
			Transform frontBone = bone;
			Transform parent = bone.parent;
			while ((Object)(object)parent != (Object)null)
			{
				bool flag = false;
				for (int i = 0; i < Owner.HipsHubs.Count; i++)
				{
					if ((Object)(object)parent == (Object)(object)Owner.HipsHubs[i].bone)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					HipsHubBackbone hipsHubBackbone = new HipsHubBackbone(Owner, parent);
					hipsHubBackbone.frontBone = frontBone;
					HubBackBones.Add(hipsHubBackbone);
					if (!((Object)(object)parent == (Object)(object)Owner.HipsSetup.bone))
					{
						frontBone = parent;
						parent = parent.parent;
						continue;
					}
					break;
				}
				break;
			}
		}

		private bool? IsFirstParent(Leg leg, Transform hub)
		{
			if ((Object)(object)leg.BoneStart == (Object)null)
			{
				return false;
			}
			Transform val = leg.BoneStart;
			while ((Object)(object)val != (Object)null)
			{
				if ((Object)(object)val == (Object)(object)hub)
				{
					return true;
				}
				if ((Object)(object)val == (Object)(object)Owner.Hips)
				{
					return false;
				}
				for (int i = 0; i < Owner.ExtraHipsHubs.Count; i++)
				{
					if ((Object)(object)val == (Object)(object)Owner.ExtraHipsHubs[i])
					{
						return false;
					}
				}
				val = val.parent;
			}
			return null;
		}

		public void Reset()
		{
			Calibrate();
			_Hips_LastHipsOffset = 0f;
		}

		public void PreCalibrate()
		{
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			UniRotate.PreCalibrate();
			if (Owner.Calibrate != ECalibrateMode.FixedCalibrate)
			{
				UniRotate.PreCalibrate();
			}
			else
			{
				bone.localPosition = LastKeyframeLocalPosition;
				bone.localRotation = LastKeyframeLocalRotation;
			}
			if (HubBackBones != null)
			{
				for (int i = 0; i < HubBackBones.Count; i++)
				{
					HubBackBones[i].PreCalibrate();
				}
			}
		}

		public void Calibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			LastKeyframePosition = bone.position;
			LastKeyframeLocalPosition = bone.localPosition;
			LastKeyframeLocalRotation = bone.localRotation;
			LastKeyframeRotation = bone.rotation;
			LastRootLocalPos = Owner.ToRootLocalSpace(LastKeyframePosition);
			LastHipsHeightDiff = GetHeightDiff(LastRootLocalPos.y);
			if (HubBackBones != null)
			{
				for (int i = 0; i < HubBackBones.Count; i++)
				{
					HubBackBones[i].Calibrate();
				}
			}
		}

		public float GetHeightDiff(float rootSpaceHeight)
		{
			return Mathf.InverseLerp(0f, InitialHipsHeightLocal, rootSpaceHeight);
		}

		public void CopyMuscleSettingsFrom(HipsReference hipsSetup)
		{
			HipsMuscle.Acceleration = hipsSetup.HipsMuscle.Acceleration;
			HipsMuscle.AccelerationLimit = hipsSetup.HipsMuscle.AccelerationLimit;
			HipsMuscle.Damping = hipsSetup.HipsMuscle.Damping;
			HipsMuscle.BrakePower = hipsSetup.HipsMuscle.BrakePower;
		}

		public Vector3 CalculateCenterOfMassStability(float stabilizingMultiplier)
		{
			//IL_0331: Unknown result type (might be due to invalid IL or missing references)
			//IL_0336: Unknown result type (might be due to invalid IL or missing references)
			//IL_033c: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_018c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0191: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0328: Unknown result type (might be due to invalid IL or missing references)
			//IL_0329: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0317: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_0109: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0112: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			//IL_0217: Unknown result type (might be due to invalid IL or missing references)
			//IL_021c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_021e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0220: Unknown result type (might be due to invalid IL or missing references)
			//IL_0222: Unknown result type (might be due to invalid IL or missing references)
			//IL_0227: Unknown result type (might be due to invalid IL or missing references)
			//IL_0231: Unknown result type (might be due to invalid IL or missing references)
			//IL_0236: Unknown result type (might be due to invalid IL or missing references)
			//IL_023b: Unknown result type (might be due to invalid IL or missing references)
			//IL_023d: Unknown result type (might be due to invalid IL or missing references)
			//IL_023f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0241: Unknown result type (might be due to invalid IL or missing references)
			//IL_0246: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Unknown result type (might be due to invalid IL or missing references)
			//IL_024a: Unknown result type (might be due to invalid IL or missing references)
			//IL_024c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0251: Unknown result type (might be due to invalid IL or missing references)
			//IL_0263: Unknown result type (might be due to invalid IL or missing references)
			//IL_0264: Unknown result type (might be due to invalid IL or missing references)
			//IL_026d: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0285: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_028f: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.StabilizeCenterOfMass > 0f)
			{
				Vector3 val = default(Vector3);
				((Vector3)(ref val))..ctor(0f, 0f, 0f);
				float num = ChildLegs.Count;
				if (Owner.StabilityAlgorithm == EStabilityMode.Biped_Deprecated)
				{
					for (int i = 0; i < ChildLegs.Count; i++)
					{
						Leg leg = ChildLegs[i];
						Vector3 val2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
						Vector3 previousFinalIKPosForStability = leg._PreviousFinalIKPosForStability;
						Vector3 val3 = Owner.ToRootLocalSpace(previousFinalIKPosForStability + val2);
						Vector3 initialPosInRootSpace = leg.InitialPosInRootSpace;
						initialPosInRootSpace.y += _Hips_LastHipsOffset;
						Vector3 val4 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace, leg.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace) : leg.AnkleH.LastKeyframeRootPos);
						Vector3 val5 = val3 - val4;
						val5.y *= 0.25f;
						val += val5 * leg.BlendWeight * 0.5f * (stabilizingMultiplier * Owner.StabilizeCenterOfMass);
					}
					val.y /= num;
				}
				else if (Owner.StabilityAlgorithm == EStabilityMode.Universal)
				{
					Vector3 lastRootLocalPos = LastRootLocalPos;
					for (int j = 0; j < ChildLegs.Count; j++)
					{
						Leg leg2 = ChildLegs[j];
						Vector3 initialPosInRootSpace2 = leg2.InitialPosInRootSpace;
						initialPosInRootSpace2.y += _Hips_LastHipsOffset;
						Vector3 val6 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace2, leg2.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace2) : leg2.AnkleH.LastKeyframeRootPos);
						Vector3 val7 = lastRootLocalPos - val6;
						Vector3 val8 = Owner.ToRootLocalSpace(leg2._PreviousFinalIKPosForStability);
						Vector3 val9 = lastRootLocalPos - val8;
						Vector3 val10 = val7 - val9;
						val10.y *= 0.25f;
						val += val10 * leg2.BlendWeight * (stabilizingMultiplier * Owner.StabilizeCenterOfMass) / num;
					}
				}
				if (val.y > 0f)
				{
					val.y = 0f;
				}
				if (Owner.StabilizingSpeed < 1f)
				{
					float duration = 0f;
					if (Owner.StabilizingSpeed < 1f)
					{
						duration = 0.001f + (1f - Owner.StabilizingSpeed) * 0.4f;
					}
					Owner.ValueTowards(ref _Hips_StabilityLocalAdjustement, val, ref _Hips_sd_StabilAdjustm, duration);
				}
				else
				{
					_Hips_StabilityLocalAdjustement = val;
				}
			}
			else
			{
				_Hips_StabilityLocalAdjustement = Vector3.zero;
			}
			return _Hips_StabilityLocalAdjustement;
		}

		public Vector3 CalculateStretchPreventerOffset()
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_0102: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_019b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0184: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.HipsStretchPreventer < 0.0001f)
			{
				return Vector3.zero;
			}
			Vector3 val = Vector3.zero;
			float num = 0f;
			Vector3 lastRootLocalPos = LastRootLocalPos;
			lastRootLocalPos.y = 0f;
			lastRootLocalPos = Owner.baseTransform.TransformPoint(lastRootLocalPos);
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				float stretchValue = leg.IKProcessor.GetStretchValue(leg._PreviousFinalIKPosForStability);
				if (stretchValue > Owner.LimitLegStretch * 0.975f)
				{
					num += 1f;
					float num2 = stretchValue - Owner.LimitLegStretch * 0.975f;
					Vector3 vec = lastRootLocalPos - leg._PreviousFinalIKPosForStability;
					vec = Owner.ToRootLocalSpaceVec(vec);
					if (vec.y > 0f)
					{
						vec.y = 0f;
					}
					vec.x *= -0.6f;
					vec.z *= -0.6f;
					val += vec * Mathf.Clamp(num2 * 3f, 0f, 0.5f);
				}
			}
			if (Owner.StretchPreventerSpeed < 1f)
			{
				float num3 = Mathf.Lerp(8f, 40f, Owner.StretchPreventerSpeed) * Owner.DeltaTime;
				if (num > 0f)
				{
					_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, val / num, num3);
				}
				else
				{
					_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, Vector3.zero, num3 * 0.7f);
				}
			}
			else
			{
				_stretchPreventerOff = val;
			}
			return _stretchPreventerOff;
		}

		public Vector3 CalculateGlueMovePush()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_0198: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3.zero;
			if (Owner.GlueBlend < 0.0001f)
			{
				return val;
			}
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				if ((leg.G_Attached || leg.G_DuringLegAdjustMovement) && leg.G_LastLegMoveDistanceFactor > 0.055f && leg.G_GlueInternalTransition > 0f && leg.G_GlueInternalTransition < 1f && leg.G_HandlerExecutingLegAnimationMode == EGlueMode.Idle)
				{
					Vector3 val2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd);
					Vector3 val3 = Owner.ToRootLocalSpace(leg._PreviousFinalIKPosForStability + val2);
					val3.z = 0f - val3.z;
					float num = Owner.BaseLegAnimating.PushHipsOnMoveCurve.Evaluate(leg.G_GlueInternalTransition);
					Vector3 val4 = -val3 * num * 1f;
					val4.y -= num * leg.G_LastLegMoveDistanceFactor * Owner.ScaleReferenceNoScale * 0.75f;
					Vector3 val5;
					if (Owner.NormalizePush)
					{
						float num2 = Mathf.Min(1f, ((Vector3)(ref val4)).magnitude / (Owner.ScaleReferenceNoScale * 0.33f));
						num2 *= num2;
						val5 = ((Vector3)(ref val4)).normalized * Owner.ScaleReferenceNoScale * 0.33f * num2;
					}
					else
					{
						val5 = val4;
					}
					val5.y *= Owner.PushYBlend;
					val += val5 * leg.BlendWeight;
				}
			}
			return val;
		}

		private void AnimateStepAdjustTo(float yOffset)
		{
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.HipsHeightStepSpeed >= 1f)
			{
				_Hips_StepHeightAdjustOffset = yOffset;
				return;
			}
			float landingBoost = Owner.GetLandingBoost();
			if (Owner.HipsAdjustStyle == EHipsAdjustStyle.FollowLegHeight && yOffset < _Hips_StepHeightAdjustOffset && _h_lowestHitLeg != -1)
			{
				Vector3 previousFinalIKPos = Owner.Legs[_h_lowestHitLeg]._PreviousFinalIKPos;
				previousFinalIKPos = Owner.ToRootLocalSpace(previousFinalIKPos);
				previousFinalIKPos.y -= Owner.ScaleReferenceNoScale * 0.325f;
				if (previousFinalIKPos.y > yOffset)
				{
					yOffset = previousFinalIKPos.y;
				}
			}
			_Hips_StepHeightAdjustOffset = Mathf.SmoothDamp(_Hips_StepHeightAdjustOffset, yOffset, ref _sd_Hips_StepHeightAdjustOffset, Mathf.LerpUnclamped(0.4f, 0.01f, landingBoost), 1000000f, Owner.DeltaTime);
			_h_lowestHitLeg = -1;
		}

		public float CalculateBodyAdjust()
		{
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0189: Unknown result type (might be due to invalid IL or missing references)
			//IL_0167: Unknown result type (might be due to invalid IL or missing references)
			//IL_011d: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			_Hips_LastHipsOffset = 0f;
			if (Owner.HipsHeightStepBlend <= 0f)
			{
				return 0f;
			}
			if (Owner.IsGrounded)
			{
				Vector3 val = default(Vector3);
				((Vector3)(ref val))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
				Vector3 val2 = default(Vector3);
				((Vector3)(ref val2))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
				for (int i = 0; i < ChildLegs.Count; i++)
				{
					Leg leg = ChildLegs[i];
					if (!leg.RaycastHitted)
					{
						continue;
					}
					RaycastHit lastGroundHit = leg.LastGroundHit;
					Vector3 point = ((RaycastHit)(ref lastGroundHit)).point;
					point = Owner.ToRootLocalSpace(point);
					if (point.y <= 0f)
					{
						if (0f - point.y < Owner.BodyStepDown * Owner.ScaleReferenceNoScale && point.y < val.y)
						{
							val = point;
							_h_lowestHitLeg = i;
						}
					}
					else if (point.y < Owner.MaxBodyStepUp * Owner.ScaleReferenceNoScale && point.y < val.y)
					{
						val2 = point;
					}
				}
				bool flag = false;
				if (val.x != float.MaxValue && Owner.BodyStepDown > 0f && val.y <= 0f)
				{
					AnimateStepAdjustTo(val.y);
					flag = true;
				}
				if (!flag && Owner.MaxBodyStepUp > 0f && val2.x != float.MaxValue)
				{
					AnimateStepAdjustTo(val2.y);
					flag = true;
				}
				if (!flag)
				{
					AnimateStepAdjustTo(0f);
				}
			}
			else
			{
				AnimateStepAdjustTo(0f);
			}
			float num = Owner.HipsBlendWeight * Owner._MainBlend * Owner.IsGroundedBlend * Owner.RagdolledDisablerBlend;
			_Hips_LastHipsOffset = _Hips_StepHeightAdjustOffset * Owner.baseTransform.lossyScale.y * num;
			return _Hips_LastHipsOffset;
		}

		public Vector3 CalculateStretchReadjust()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3.zero;
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				Vector3 val2 = leg._FinalIKPos - val;
				if (leg.IKProcessor.GetStretchValue(val2) > Owner.LimitLegStretch)
				{
					Vector3 notStretchedPositionTowards = leg.IKProcessor.GetNotStretchedPositionTowards(val2, Owner.LimitLegStretch);
					Vector3 val3 = val2 - notStretchedPositionTowards;
					val += val3;
				}
			}
			val = Owner.ToRootLocalSpaceVec(val);
			_reAdjustLocal = Vector3.SmoothDamp(_reAdjustLocal, val, ref _sd_readj, 0.1f, 10000000f, Owner.DeltaTime);
			return _reAdjustLocal;
		}

		public Vector3 SmoothPushOffset(Vector3 pushLocalOffset, float pushDuration)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			Owner.ValueTowards(ref _pushSmoothed, pushLocalOffset, ref _sd_pushSmoothed, pushDuration);
			return _pushSmoothed;
		}

		public Vector3 AnimateOffset(Vector3 hubOffset)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			return hubOffset;
		}
	}

	public enum EStabilityMode
	{
		Biped_Deprecated,
		Universal
	}

	[Serializable]
	public class Leg
	{
		private struct GlueAttachement
		{
			public RaycastHit AttachHit;

			public Transform AttachedTo;

			public Vector3 PosInAttachementLocal;

			public Vector3 NormalInAttachementLocal;

			public Quaternion RotInAttachementLocal;

			public bool NoTransform { get; private set; }

			public GlueAttachement(Leg leg, RaycastHit legGroundHit)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0067: Unknown result type (might be due to invalid IL or missing references)
				//IL_006c: Unknown result type (might be due to invalid IL or missing references)
				//IL_007b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0080: Unknown result type (might be due to invalid IL or missing references)
				//IL_0085: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				//IL_003a: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0046: Unknown result type (might be due to invalid IL or missing references)
				//IL_004b: Unknown result type (might be due to invalid IL or missing references)
				//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
				//IL_0098: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				AttachHit = legGroundHit;
				AttachedTo = ((RaycastHit)(ref legGroundHit)).transform;
				if ((Object)(object)((RaycastHit)(ref legGroundHit)).transform == (Object)null)
				{
					NoTransform = true;
					PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).point;
					NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).normal;
					RotInAttachementLocal = leg._PreviousFinalIKRot;
					return;
				}
				NoTransform = false;
				PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformPoint(((RaycastHit)(ref legGroundHit)).point);
				NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformDirection(((RaycastHit)(ref legGroundHit)).normal);
				if (!leg.Owner.AnimateFeet)
				{
					RotInAttachementLocal = Quaternion.identity;
				}
				else
				{
					RotInAttachementLocal = AttachedTo.rotation.QToLocal(leg.GetAlignedOnGroundHitRot(leg._SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal));
				}
			}

			internal Vector3 GetRelevantAlignedHitPoint(Leg leg)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				//IL_000a: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				Vector3 relevantHitPoint = GetRelevantHitPoint();
				return leg.GetAlignedOnGroundHitPos(leg.ToRootLocalSpace(relevantHitPoint), relevantHitPoint, GetRelevantNormal());
			}

			internal Vector3 GetRelevantHitPoint()
			{
				//IL_0017: Unknown result type (might be due to invalid IL or missing references)
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				if (NoTransform || (Object)(object)AttachedTo == (Object)null)
				{
					return PosInAttachementLocal;
				}
				return AttachedTo.TransformPoint(PosInAttachementLocal);
			}

			internal Vector3 GetRelevantNormal()
			{
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				if (NoTransform)
				{
					return NormalInAttachementLocal;
				}
				return AttachedTo.TransformDirection(NormalInAttachementLocal);
			}

			internal Quaternion GetRelevantAttachementRotation()
			{
				//IL_0015: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				if (NoTransform)
				{
					return RotInAttachementLocal;
				}
				return AttachedTo.rotation.QToWorld(RotInAttachementLocal);
			}

			internal void OverwritePosition(Vector3 legAnimPos)
			{
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_0028: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)AttachedTo == (Object)null)
				{
					PosInAttachementLocal = legAnimPos;
				}
				else
				{
					PosInAttachementLocal = ((Component)AttachedTo).transform.InverseTransformPoint(legAnimPos);
				}
			}
		}

		private class GlueAttachementHandler
		{
			public class LegTransitionAnimation
			{
				private enum EMoveType
				{
					FromAnimation,
					FromLastAttachement
				}

				private GlueAttachementHandler handler;

				public float LegAdjustementYOffset;

				public float LegAdjustementFootAngleOffset;

				private Vector3 _legSpherizeLocalVector = Vector3.zero;

				private float _legMoveDurMul = 1f;

				private Quaternion baseRotationOnStepUp;

				public float legMoveDistanceFactor;

				private float sd_trProgress;

				private Vector3 previousPositionLocal;

				private Vector3 previousPositionWorld;

				private Quaternion previousRotationWorld;

				private Vector3 lastAppliedGluePosition;

				private Vector3 lastAppliedGluePositionLocal;

				private Quaternion lastAppliedGlueRotation;

				private float lastSpeedup;

				private EMoveType animationMoveType;

				private bool _instantTransition;

				private bool _wasAnimatingLeg;

				private LegsAnimator Owner => handler.Owner;

				private Leg leg => handler.leg;

				public bool duringLegAdjustMovement { get; private set; }

				public bool wasAttaching { get; private set; }

				public bool attached { get; private set; }

				public float transitionProgress { get; private set; }

				public float lastAttachCompleteTime { get; private set; }

				public float transitionProgressLastFrame { get; private set; }

				public EGlueMode LastAnimationGlueMode
				{
					get
					{
						if (animationMoveType != 0)
						{
							return EGlueMode.Idle;
						}
						return EGlueMode.Moving;
					}
				}

				public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
				{
					//IL_0001: Unknown result type (might be due to invalid IL or missing references)
					//IL_0006: Unknown result type (might be due to invalid IL or missing references)
					handler = glueTransitionHelper;
					Reset();
				}

				public void Reset()
				{
					//IL_0029: Unknown result type (might be due to invalid IL or missing references)
					//IL_002e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0049: Unknown result type (might be due to invalid IL or missing references)
					//IL_004e: Unknown result type (might be due to invalid IL or missing references)
					animationMoveType = EMoveType.FromAnimation;
					transitionProgress = 0f;
					transitionProgressLastFrame = 0f;
					baseRotationOnStepUp = Owner.BaseTransform.rotation;
					duringLegAdjustMovement = false;
					wasAttaching = false;
					attached = false;
					_legSpherizeLocalVector = Vector3.zero;
					ReInitialize();
				}

				public void ReInitialize()
				{
					//IL_0007: Unknown result type (might be due to invalid IL or missing references)
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0018: Unknown result type (might be due to invalid IL or missing references)
					//IL_001d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0029: Unknown result type (might be due to invalid IL or missing references)
					//IL_002e: Unknown result type (might be due to invalid IL or missing references)
					//IL_003a: Unknown result type (might be due to invalid IL or missing references)
					//IL_003f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0051: Unknown result type (might be due to invalid IL or missing references)
					//IL_0056: Unknown result type (might be due to invalid IL or missing references)
					//IL_005b: Unknown result type (might be due to invalid IL or missing references)
					lastAppliedGluePosition = leg._SourceIKPos;
					lastAppliedGlueRotation = leg._SourceIKRot;
					previousPositionWorld = leg._SourceIKPos;
					previousRotationWorld = leg._SourceIKRot;
					previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
				}

				internal void ScheduleInstantTransition()
				{
					_instantTransition = true;
				}

				internal void DoAttaching(bool canAttach)
				{
					if (canAttach != wasAttaching)
					{
						wasAttaching = canAttach;
						if (canAttach)
						{
							OnChangeTargetPosition();
						}
						else
						{
							attached = false;
							if (transitionProgress != 0f)
							{
								OnChangeTargetPosition();
							}
						}
					}
					if (duringLegAdjustMovement && transitionProgress >= 1f)
					{
						duringLegAdjustMovement = false;
					}
				}

				internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
				{
					//IL_0099: Unknown result type (might be due to invalid IL or missing references)
					//IL_0023: Unknown result type (might be due to invalid IL or missing references)
					//IL_0024: Unknown result type (might be due to invalid IL or missing references)
					//IL_0029: Unknown result type (might be due to invalid IL or missing references)
					//IL_0042: Unknown result type (might be due to invalid IL or missing references)
					//IL_0047: Unknown result type (might be due to invalid IL or missing references)
					//IL_006a: Unknown result type (might be due to invalid IL or missing references)
					//IL_005d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0070: Unknown result type (might be due to invalid IL or missing references)
					//IL_0076: Unknown result type (might be due to invalid IL or missing references)
					//IL_006f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0080: Unknown result type (might be due to invalid IL or missing references)
					//IL_0091: Unknown result type (might be due to invalid IL or missing references)
					//IL_0092: Unknown result type (might be due to invalid IL or missing references)
					//IL_0097: Unknown result type (might be due to invalid IL or missing references)
					if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
					{
						Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
						Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
						if (val.y < val2.y)
						{
							val.y = val2.y;
							legAnimPos = Owner.RootToWorldSpace(val);
						}
					}
					return legAnimPos;
				}

				public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
				{
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_000d: Unknown result type (might be due to invalid IL or missing references)
					//IL_001f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0024: Unknown result type (might be due to invalid IL or missing references)
					//IL_0056: Unknown result type (might be due to invalid IL or missing references)
					//IL_0063: Unknown result type (might be due to invalid IL or missing references)
					//IL_006b: Unknown result type (might be due to invalid IL or missing references)
					//IL_0078: Unknown result type (might be due to invalid IL or missing references)
					//IL_007d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0082: Unknown result type (might be due to invalid IL or missing references)
					//IL_0087: Unknown result type (might be due to invalid IL or missing references)
					//IL_012a: Unknown result type (might be due to invalid IL or missing references)
					LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
					Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
					if (legAnimatingSettings.SpherizeTrack.length > 1)
					{
						float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
						val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
					}
					if (Owner.AnimateFeet)
					{
						LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
						LegAdjustementFootAngleOffset /= lastSpeedup;
					}
					float num2 = Owner.ScaleReferenceNoScale * 0.75f;
					float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
					num3 *= num2;
					LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
					_wasAnimatingLeg = true;
					return val;
				}

				internal Vector3 GetTargetPosition()
				{
					//IL_0122: Unknown result type (might be due to invalid IL or missing references)
					//IL_0127: Unknown result type (might be due to invalid IL or missing references)
					//IL_0107: Unknown result type (might be due to invalid IL or missing references)
					//IL_010c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0111: Unknown result type (might be due to invalid IL or missing references)
					//IL_0038: Unknown result type (might be due to invalid IL or missing references)
					//IL_003d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0042: Unknown result type (might be due to invalid IL or missing references)
					//IL_0026: Unknown result type (might be due to invalid IL or missing references)
					//IL_002b: Unknown result type (might be due to invalid IL or missing references)
					//IL_0138: Unknown result type (might be due to invalid IL or missing references)
					//IL_0144: Unknown result type (might be due to invalid IL or missing references)
					//IL_0149: Unknown result type (might be due to invalid IL or missing references)
					//IL_0154: Unknown result type (might be due to invalid IL or missing references)
					//IL_0159: Unknown result type (might be due to invalid IL or missing references)
					//IL_0135: Unknown result type (might be due to invalid IL or missing references)
					//IL_011f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0050: Unknown result type (might be due to invalid IL or missing references)
					//IL_0177: Unknown result type (might be due to invalid IL or missing references)
					//IL_017e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0183: Unknown result type (might be due to invalid IL or missing references)
					//IL_0188: Unknown result type (might be due to invalid IL or missing references)
					//IL_016d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0172: Unknown result type (might be due to invalid IL or missing references)
					//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
					//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
					//IL_0068: Unknown result type (might be due to invalid IL or missing references)
					//IL_006d: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
					//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
					//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
					//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
					//IL_0197: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
					//IL_00de: Unknown result type (might be due to invalid IL or missing references)
					//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
					//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
					//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
					//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
					//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
					//IL_008e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0093: Unknown result type (might be due to invalid IL or missing references)
					//IL_0098: Unknown result type (might be due to invalid IL or missing references)
					float glueAnimationBlend = handler.glueAnimationBlend;
					if (animationMoveType == EMoveType.FromAnimation)
					{
						if (glueAnimationBlend < 0.0001f)
						{
							return Owner.RootToWorldSpace(previousPositionLocal);
						}
						Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
						if (transitionProgress < 0.0001f)
						{
							return val;
						}
						Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
						if (transitionProgress > 0.9995f)
						{
							return val2;
						}
						return Vector3.LerpUnclamped(val, val2, transitionProgress);
					}
					Vector3 val3;
					if (leg.Owner.OnlyLocalAnimation)
					{
						val3 = Owner.RootToWorldSpace(previousPositionLocal);
						if (transitionProgress < 0.0001f)
						{
							return val3;
						}
					}
					else
					{
						val3 = previousPositionWorld;
						if (transitionProgress < 0.0001f)
						{
							return val3;
						}
						val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
					}
					Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
					if (transitionProgress >= 1f)
					{
						return val4;
					}
					float num = 1f - transitionProgress;
					return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
				}

				internal void RequireRepose()
				{
					if (attached)
					{
						attached = false;
						OnChangeTargetPosition();
					}
				}

				internal Quaternion GetTargetRotation()
				{
					//IL_0001: Unknown result type (might be due to invalid IL or missing references)
					//IL_0006: Unknown result type (might be due to invalid IL or missing references)
					//IL_0014: Unknown result type (might be due to invalid IL or missing references)
					//IL_0015: Unknown result type (might be due to invalid IL or missing references)
					//IL_0016: Unknown result type (might be due to invalid IL or missing references)
					//IL_0034: Unknown result type (might be due to invalid IL or missing references)
					//IL_0039: Unknown result type (might be due to invalid IL or missing references)
					//IL_0026: Unknown result type (might be due to invalid IL or missing references)
					//IL_002b: Unknown result type (might be due to invalid IL or missing references)
					//IL_004b: Unknown result type (might be due to invalid IL or missing references)
					//IL_004c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0053: Unknown result type (might be due to invalid IL or missing references)
					//IL_0058: Unknown result type (might be due to invalid IL or missing references)
					//IL_0047: Unknown result type (might be due to invalid IL or missing references)
					//IL_0048: Unknown result type (might be due to invalid IL or missing references)
					//IL_0059: Unknown result type (might be due to invalid IL or missing references)
					Quaternion val = previousRotationWorld;
					if (transitionProgress < 0.001f)
					{
						return val;
					}
					Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
					if (transitionProgress > 0.9995f)
					{
						return val2;
					}
					return Quaternion.LerpUnclamped(val, val2, transitionProgress);
				}

				internal void OnChangeTargetPosition()
				{
					//IL_0022: Unknown result type (might be due to invalid IL or missing references)
					//IL_0027: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
					//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
					//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
					//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
					//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
					//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
					//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
					//IL_0100: Unknown result type (might be due to invalid IL or missing references)
					//IL_0105: Unknown result type (might be due to invalid IL or missing references)
					//IL_010a: Unknown result type (might be due to invalid IL or missing references)
					//IL_0141: Unknown result type (might be due to invalid IL or missing references)
					//IL_0146: Unknown result type (might be due to invalid IL or missing references)
					//IL_014d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0152: Unknown result type (might be due to invalid IL or missing references)
					//IL_0153: Unknown result type (might be due to invalid IL or missing references)
					//IL_0158: Unknown result type (might be due to invalid IL or missing references)
					//IL_0197: Unknown result type (might be due to invalid IL or missing references)
					//IL_019c: Unknown result type (might be due to invalid IL or missing references)
					//IL_019d: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
					//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
					//IL_0247: Unknown result type (might be due to invalid IL or missing references)
					//IL_024c: Unknown result type (might be due to invalid IL or missing references)
					//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
					//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
					//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
					//IL_0201: Unknown result type (might be due to invalid IL or missing references)
					//IL_0211: Unknown result type (might be due to invalid IL or missing references)
					//IL_0213: Unknown result type (might be due to invalid IL or missing references)
					//IL_0223: Unknown result type (might be due to invalid IL or missing references)
					//IL_022d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0232: Unknown result type (might be due to invalid IL or missing references)
					handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
					baseRotationOnStepUp = Owner.BaseTransform.rotation;
					if (handler.glueAnimationBlend < 0.2f)
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					else if (animationMoveType == EMoveType.FromLastAttachement)
					{
						animationMoveType = EMoveType.FromLastAttachement;
					}
					else if (handler.glueAnimationBlend > 0.75f)
					{
						if (transitionProgress < 0.1f || transitionProgress > 0.9f)
						{
							animationMoveType = EMoveType.FromLastAttachement;
						}
						else
						{
							animationMoveType = EMoveType.FromAnimation;
						}
					}
					else
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					if (leg.Owner.OnlyLocalAnimation)
					{
						previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
					}
					else
					{
						previousPositionWorld = lastAppliedGluePosition;
					}
					previousRotationWorld = lastAppliedGlueRotation;
					previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
					if (animationMoveType == EMoveType.FromLastAttachement)
					{
						if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
						{
							transitionProgress = 0f;
						}
						Vector3 val = previousPositionWorld;
						Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
						float magnitude = ((Vector3)(ref val2)).magnitude;
						legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
						legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
						Vector3 val3 = ((Vector3)(ref val2)).normalized;
						val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
						((Vector3)(ref val3)).Normalize();
						leg.SendRaiseEvent(magnitude);
						if (legMoveDistanceFactor > 0.0401f)
						{
							_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
							Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
							((Vector3)(ref worldDir)).Normalize();
							_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
							duringLegAdjustMovement = true;
						}
						else
						{
							animationMoveType = EMoveType.FromAnimation;
							_legSpherizeLocalVector = Vector3.zero;
							duringLegAdjustMovement = false;
						}
					}
					else
					{
						duringLegAdjustMovement = false;
						transitionProgress = 0f;
					}
				}

				public void UpdateAnimation()
				{
					//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
					//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
					//IL_0201: Unknown result type (might be due to invalid IL or missing references)
					//IL_0211: Unknown result type (might be due to invalid IL or missing references)
					//IL_011a: Unknown result type (might be due to invalid IL or missing references)
					//IL_0107: Unknown result type (might be due to invalid IL or missing references)
					//IL_010c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0111: Unknown result type (might be due to invalid IL or missing references)
					//IL_0192: Unknown result type (might be due to invalid IL or missing references)
					//IL_0197: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
					//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
					//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
					float num = (Owner.JustGrounded ? 0.2f : 1f);
					float num2 = (Owner.JustGrounded ? 5f : 1f);
					transitionProgressLastFrame = transitionProgress;
					if (_instantTransition)
					{
						_instantTransition = false;
						transitionProgress = 1f;
						lastAttachCompleteTime = Time.time;
					}
					if (!Owner.IsGrounded)
					{
						return;
					}
					if (animationMoveType == EMoveType.FromLastAttachement)
					{
						float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
						float num4 = 1f;
						lastSpeedup = 1f;
						if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
						{
							if (leg.hasOppositeleg)
							{
								Leg oppositeLeg = leg.GetOppositeLeg();
								Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
								if (leg.Owner.OnlyLocalAnimation)
								{
									targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
								}
								float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
								if (stretchValue > leg.LegStretchLimit * 0.95f)
								{
									float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
									if (num5 < 0f)
									{
										num5 = 0f;
									}
									num4 += num5;
								}
								if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
								{
									Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
									float magnitude = ((Vector3)(ref val)).magnitude;
									float num6 = Owner.ScaleReference * 0.4f;
									if (magnitude > num6)
									{
										float num7 = magnitude - num6;
										num4 += num7 / num6 * 2f;
									}
								}
							}
							if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
							{
								float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
								if (num8 > 12f)
								{
									float num9 = Mathf.InverseLerp(30f, 135f, num8);
									num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
									transitionProgress += Owner.DeltaTime * num9 * num2;
								}
							}
							num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
						}
						lastSpeedup = num4;
						transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
						if (transitionProgress > 0.9995f && duringLegAdjustMovement)
						{
							TriggerAttach();
						}
					}
					else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
					{
						TriggerAttach();
					}
					else
					{
						transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
					}
				}

				private void TriggerAttach()
				{
					if (!attached)
					{
						transitionProgress = 1f;
						lastAttachCompleteTime = Time.time;
						attached = leg.Glue_TriggerFinalAttach();
						duringLegAdjustMovement = false;
					}
				}

				public void PostUpdate()
				{
					//IL_0007: Unknown result type (might be due to invalid IL or missing references)
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0019: Unknown result type (might be due to invalid IL or missing references)
					//IL_001e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0023: Unknown result type (might be due to invalid IL or missing references)
					//IL_002f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0034: Unknown result type (might be due to invalid IL or missing references)
					lastAppliedGluePosition = leg._GluePosition;
					lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
					lastAppliedGlueRotation = leg._GlueRotation;
					if (!_wasAnimatingLeg)
					{
						LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
						LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
					}
					else
					{
						_wasAnimatingLeg = false;
					}
				}
			}

			private LegsAnimator Owner;

			private Leg ParentLeg;

			private float _sd_glueAnimationBlend;

			private bool _instantTransition;

			private Vector3 lastGluePosition = Vector3.zero;

			private Quaternion lastGlueRotation = Quaternion.identity;

			public LegTransitionAnimation legMoveAnimation { get; private set; }

			private Leg leg => ParentLeg;

			public float glueAnimationBlend { get; private set; }

			public float attachTransitionProgress => legMoveAnimation.transitionProgress;

			public float attachTransitionProgressLastFrame => legMoveAnimation.transitionProgressLastFrame;

			public float legMoveDistanceFactor => legMoveAnimation.legMoveDistanceFactor;

			public EGlueMode lasGlueModeOnAttaching { get; private set; }

			public GlueAttachementHandler(Leg leg)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0011: Unknown result type (might be due to invalid IL or missing references)
				ParentLeg = leg;
				Owner = leg.Owner;
				legMoveAnimation = new LegTransitionAnimation(this);
				lasGlueModeOnAttaching = Owner._glueModeExecuted;
				Reset(initializing: true);
			}

			public void Reset(bool initializing)
			{
				//IL_0025: Unknown result type (might be due to invalid IL or missing references)
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0040: Unknown result type (might be due to invalid IL or missing references)
				glueAnimationBlend = 0f;
				_sd_glueAnimationBlend = 0f;
				if (initializing)
				{
					lastGluePosition = leg.BoneEnd.position;
					lastGlueRotation = leg.BoneEnd.rotation;
				}
				legMoveAnimation.Reset();
			}

			public void SheduleInstantTransition()
			{
				_instantTransition = true;
				legMoveAnimation.ScheduleInstantTransition();
			}

			public void TransitionToGlueAnimation()
			{
				legMoveAnimation.DoAttaching(canAttach: true);
				ChangeGlueAnimationBlendTo(1f, Owner.GlueFadeInSpeed);
			}

			public void TransitionToDisableGlueAnimation()
			{
				legMoveAnimation.DoAttaching(canAttach: false);
				ChangeGlueAnimationBlendTo(0f, Owner.GlueFadeOutSpeed);
			}

			public Vector3 GetGluePosition()
			{
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_0052: Unknown result type (might be due to invalid IL or missing references)
				//IL_005d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0039: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				if (glueAnimationBlend > 0.9995f)
				{
					lastGluePosition = legMoveAnimation.GetTargetPosition();
				}
				else if (glueAnimationBlend < 0.0001f)
				{
					lastGluePosition = leg.A_PreIKPosForGluing;
				}
				else
				{
					lastGluePosition = Vector3.LerpUnclamped(leg.A_PreIKPosForGluing, legMoveAnimation.GetTargetPosition(), glueAnimationBlend);
				}
				return lastGluePosition;
			}

			public Quaternion GetGlueRotation()
			{
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_0052: Unknown result type (might be due to invalid IL or missing references)
				//IL_005d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0039: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				if (glueAnimationBlend > 0.999f)
				{
					lastGlueRotation = legMoveAnimation.GetTargetRotation();
				}
				else if (glueAnimationBlend < 0f)
				{
					lastGlueRotation = leg._FinalIKRot;
				}
				else
				{
					lastGlueRotation = Quaternion.LerpUnclamped(leg._FinalIKRot, legMoveAnimation.GetTargetRotation(), glueAnimationBlend);
				}
				return lastGlueRotation;
			}

			public void UpdateTransitioning(bool attaching)
			{
				legMoveAnimation.UpdateAnimation();
			}

			public void PostUpdate()
			{
				legMoveAnimation.PostUpdate();
			}

			internal void OnLegRequireRepose()
			{
				legMoveAnimation.RequireRepose();
			}

			private void ChangeGlueAnimationBlendTo(float target, float speed)
			{
				if (Owner.GroundedTime < 0f)
				{
					speed = 0.99f;
				}
				if (_instantTransition && target > 0f)
				{
					glueAnimationBlend = target;
					_instantTransition = false;
					return;
				}
				if (speed >= 1f)
				{
					glueAnimationBlend = target;
					return;
				}
				if (leg.G_JustLanded)
				{
					glueAnimationBlend = Mathf.MoveTowards(glueAnimationBlend, target, Owner.DeltaTime * 3f);
				}
				glueAnimationBlend = Mathf.SmoothDamp(glueAnimationBlend, target, ref _sd_glueAnimationBlend, Mathf.LerpUnclamped(0.2f, 0.005f, speed), 100000f, Owner.DeltaTime);
				if (float.IsNaN(_sd_glueAnimationBlend))
				{
					_sd_glueAnimationBlend = 0f;
				}
			}
		}

		public enum GlueReposeRequest
		{
			None,
			Repose,
			ReposeIfFar
		}

		public class LegHelper
		{
			public Transform Bone;

			public LegHelper Child;

			public Vector3 InitPositionRootSpace;

			public Vector3 LastKeyframeRootPos;

			public LegHelper(Leg leg, Transform bone)
			{
				//IL_0010: Unknown result type (might be due to invalid IL or missing references)
				//IL_0015: Unknown result type (might be due to invalid IL or missing references)
				//IL_001a: Unknown result type (might be due to invalid IL or missing references)
				Bone = bone;
				InitPositionRootSpace = leg.ToRootLocalSpace(bone.position);
			}

			public void Calibrate(Leg leg, Vector3 wPos)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0003: Unknown result type (might be due to invalid IL or missing references)
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				LastKeyframeRootPos = leg.ToRootLocalSpace(wPos);
			}
		}

		private GlueAttachement G_Attachement;

		public bool G_CustomForceAttach;

		public bool G_CustomForceNOTDetach;

		public bool G_CustomForceDetach;

		public bool G_CustomForceNOTAttach;

		private float lastFootForwardAngleDiffABS;

		private GlueAttachementHandler G_AttachementHandler;

		private Vector3 A_PreviousRelevantAnklePos;

		private Vector3 A_LastApppliedAlignPos;

		private Vector3 A_LastApppliedAlignPosLocal;

		private Vector3 A_PreIKPosForGluing;

		private Quaternion A_LastApppliedAlignRot;

		private Quaternion A_LastTargetAlignRot;

		private bool A_WasFullAlign;

		private float A_aligningBlendByGluing = 1f;

		private Vector3 A_LastElevation;

		private float A_LastElevateH;

		private float _sd_A_Elev;

		[NonSerialized]
		public float Adj_A_ElevateLerpSpeedStart = 8f;

		[NonSerialized]
		public float Adj_A_ElevateLerpSpeedAfter = 5f;

		[NonSerialized]
		public float Adj_A_ElevateSpeedupMargin = 0.014f;

		private float A_AligningFor;

		private Vector3 A_LastAlignRootSpacePos;

		private Vector3 A_LastSmoothTargetedPosLocal;

		private float A_LastSuddenSmoothYOffset;

		private float A_SuddenSmoothing;

		private float A_lastSuddenSmoothingDiff;

		private bool A_WasSmoothing;

		private bool A_WasAligningFrameBack;

		private Vector3 A_SmoothedIKPos;

		[NonSerialized]
		public bool G_InstantReglue;

		private float _glueTargetBlend = 1f;

		private float _gluingCulldown;

		protected bool G_JustLanded;

		[NonSerialized]
		public float ExtraGluingBlend = 1f;

		private Vector3 _GlueLastAttachPosition;

		private Vector3 _GlueLastAttachPositionRootLocal;

		private Quaternion _GlueLastAttachRotation;

		private Vector3 _GluePosition;

		private Quaternion _GlueRotation;

		private Vector3 _G_LastPreGlueSourceLocalIKPos;

		private Vector3 _G_PreGlueSourceLocalIKPos;

		private Vector3 _G_sd_RefSwing = Vector3.zero;

		private bool _G_WasDisabled = true;

		[NonSerialized]
		public GlueReposeRequest G_RequestRepose;

		private bool _G_WasGrounded = true;

		private Vector3 _G_LasGroundedPosLocal;

		private Quaternion _G_LasGroundedRotLocal;

		private Vector3 G_GlueDragOffset = Vector3.zero;

		private LegHelper _h_boneStart;

		private LegHelper _h_boneMid;

		private LegHelper _h_boneEnd;

		private Vector3 C_AnkleToHeelRootSpace = Vector3.one;

		private Vector3 C_LastHeelWorldPos;

		private Vector3 C_LastHeelRootSpacePos;

		private Vector3 C_LastFootEndWorldPos;

		private Vector3 C_LastFootEndRootSpacePos;

		private Vector3 C_Local_AnkleToHeelRotated;

		private float _C_DynamicYScale = 1f;

		public LegsAnimator Owner;

		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		public float LegBlendWeight = 1f;

		internal float InternalModuleBlendWeight = 1f;

		private float finalBoneBlend = 1f;

		[Tooltip("Make idle glue animation motion faster for this single leg")]
		public float LegMoveSpeedMultiplier = 1f;

		public float LegRaiseMultiplier = 1f;

		[Space(3f)]
		public float GlueThresholdMultiplier = 1f;

		public Vector2 GluePointOffset = Vector2.zero;

		[Space(3f)]
		[Range(0f, 1f)]
		public float LegStretchMultiplier = 1f;

		[Tooltip("Motion preset for the leg to be animated with different character than the other legs ('Idle Glue Motion' settings)")]
		public LegMotionSettingsPreset CustomLegAnimating;

		[Range(-40f, 40f)]
		public float FootPitchOffset;

		public Transform BoneStart;

		public Transform BoneMid;

		public Transform BoneEnd;

		public ELegSide Side;

		public int OppositeLegIndex = -1;

		public ERaycastPrecision RaycastPrecision;

		[Tooltip("(Experimental) If you want to animate in additional feet bone which in some cases can add nice animation feeling")]
		public bool UseFeet;

		public Transform BoneFeet;

		[Tooltip("Defining how quick heel should get up if leg gets stretched (change max stretching param under IK tab to be lower value that 1.1)")]
		[Range(0f, 1f)]
		public float FeetSensitivity = 0.5f;

		private bool hasOppositeleg;

		private LegStepAnimatingParameters targetLegAnimating;

		[Tooltip("Apply IK hint inversion, in case leg is bending in wrong direction.")]
		public bool InverseHint;

		public Vector3 AnkleToHeel = Vector3.zero;

		public Vector3 AnkleToFeetEnd = Vector3.zero;

		public Vector3 AnkleRight = Vector3.right;

		public Vector3 AnkleUp = Vector3.up;

		public Vector3 AnkleForward = Vector3.forward;

		[Range(0f, 1.001f)]
		public float FootMiddlePosition = 0.5f;

		[FPD_Suffix(-45f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "°", true, 0)]
		[Space(5f)]
		public float AnkleYawCorrection;

		private bool _StepSent = true;

		private float _StepSentAt = -100f;

		private float _RaiseSentAt = -100f;

		private bool _OppositeLegStepped = true;

		private float _ToConfirmStepEvent;

		private Vector3 _SourceIKPosUnchangedY;

		private Vector3 _SourceIKPos;

		public Vector3 _FinalIKPos;

		private Quaternion _SourceIKRot;

		private Quaternion _FinalIKRot;

		private bool customOverwritingIKPos;

		private Vector3 customOverwritePos = Vector3.zero;

		private bool customOverwritingIKRot;

		private Quaternion customOverwriteRot = Quaternion.identity;

		private bool _wasFixedCalibrateAnimationCaptured;

		private bool _wasGrounded = true;

		private Vector3 _ungroundLocalIKCache;

		private bool _overwrittenSourceIKPos;

		public RaycastHit legGroundHit;

		public RaycastHit lastGroundHitWithTarget;

		private Vector3 previousAnkleAlignedOnGroundHitWorldPos;

		private Vector3 ankleAlignedOnGroundHitRootLocal;

		private Quaternion ankleAlignedOnGroundHitRotation;

		private RaycastHit replacementHit;

		private bool _UsingEmptyRaycast;

		private bool _UsingCustomRaycast;

		private bool _disableSourceRaycast;

		private float _CustomRaycastBlendIn;

		private RaycastHit _CustomRaycastHit;

		private Vector3 _PreviousCustomRaycastingStartIKPos;

		private Vector3 _PreviousCustomRaycastingIKPos;

		private bool _noRaycast_skipFeetCalcs;

		public bool G_AttachPossible
		{
			get
			{
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				if (RaycastHitted)
				{
					return C_Local_MidFootPosVsGroundHit.y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel;
				}
				return false;
			}
		}

		public bool _Glue_AskingForDetach { get; private set; }

		public float BelowFootRange => ScaleRef * _C_DynamicYScale * 0.2f;

		private GlueAttachementHandler.LegTransitionAnimation G_LegAnimation => G_AttachementHandler.legMoveAnimation;

		public Vector3 G_GluePosition => _GluePosition;

		public float G_GlueAnimationBlend => G_AttachementHandler.glueAnimationBlend;

		public float G_GlueInternalTransition => G_AttachementHandler.attachTransitionProgress;

		public float G_LastAttachCompleteTime => G_AttachementHandler.legMoveAnimation.lastAttachCompleteTime;

		public float G_GlueInternalTransitionLastFrame => G_AttachementHandler.attachTransitionProgressLastFrame;

		public float G_LastLegMoveDistanceFactor => G_AttachementHandler.legMoveDistanceFactor;

		public bool G_DuringLegAdjustMovement => G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement;

		public EGlueMode G_HandlerExecutingLegAnimationMode => G_AttachementHandler.legMoveAnimation.LastAnimationGlueMode;

		public bool A_PreWasAligning { get; private set; }

		public bool A_PreWasAligningNearGround { get; private set; }

		public bool A_WasAligning { get; private set; }

		public float A_AligningHelperBlend { get; private set; }

		public float A_LastAlignHeightDiff { get; private set; }

		public float A_LastAlignHeightCompareValue { get; private set; }

		public bool G_Attached { get; private set; }

		public bool G_DuringAttaching => G_LegAnimation.duringLegAdjustMovement;

		public bool G_FadingIn => G_LegAnimation.duringLegAdjustMovement;

		public Vector3 _G_RefernceSwing { get; private set; }

		private float G_GlueTesholdRange => Owner.ScaleReferenceNoScale * GlueThresholdMultiplier * Owner.GlueRangeThreshold * 0.5f;

		private Transform Root => Owner.BaseTransform;

		private float ScaleRef => Owner.ScaleReference;

		private float FloorLevel => Owner._glueingFloorLevel;

		private float DeltaTime => Owner.DeltaTime;

		public LegHelper ThighH => _h_boneStart;

		private FimpIK_Limb.IKBone ThighIK => IKProcessor.StartIKBone;

		public LegHelper LowerLegH => _h_boneMid;

		private FimpIK_Limb.IKBone LowerLegIK => IKProcessor.MiddleIKBone;

		public LegHelper AnkleH => _h_boneEnd;

		public FimpIK_Limb.IKBone AnkleIK => IKProcessor.EndIKBone;

		public Vector3 C_LastMidRefFootWorldPos { get; private set; }

		public Vector3 C_LastMidRefFootRootSpacePos { get; private set; }

		public Vector3 C_Local_MidFootPosVsGroundHit { get; private set; }

		public float C_Local_FootElevateInAnimation { get; private set; }

		public float C_AnkleToHeelWorldHeight { get; private set; }

		public float C_AnimatedAnkleFlatHeight { get; private set; }

		public int PlaymodeIndex { get; private set; }

		public float BlendWeight { get; private set; }

		[field: NonSerialized]
		public Leg NextLeg { get; private set; }

		[field: NonSerialized]
		public HipsReference ParentHub { get; private set; }

		public LegStepAnimatingParameters LegAnimatingSettings => targetLegAnimating;

		public float LegStretchLimit { get; private set; } = 1f;

		public FimpIK_Limb IKProcessor { get; private set; }

		public Vector3 _PreviousFinalIKPos { get; private set; }

		public Vector3 _PreviousFinalIKPosRootLocal { get; private set; }

		public Vector3 _PreviousFinalIKPosForStability { get; private set; }

		public Quaternion _PreviousFinalIKRot { get; private set; }

		public Vector3 _AnimatorStartBonePos { get; private set; }

		public Vector3 _AnimatorMidBonePos { get; private set; }

		public Vector3 _AnimatorEndBonePos { get; private set; }

		public Quaternion _AnimatorStartBoneLocRot { get; private set; }

		public Quaternion _AnimatorMidBoneLocRot { get; private set; }

		public Quaternion _AnimatorEndBoneLocRot { get; private set; }

		public bool RaycastHitted { get; private set; }

		public RaycastHit LastGroundHit => legGroundHit;

		public Vector3 groundHitRootSpacePos { get; private set; }

		public Vector3 lastRaycastingOrigin { get; private set; }

		public Vector3 lastRaycastingEndPoint { get; private set; }

		public Vector3 ankleAlignedOnGroundHitWorldPos { get; private set; }

		public bool User_RaycastHittedSource { get; private set; }

		public float raycastSlopeAngle { get; private set; }

		public Vector3 InitialPosInRootSpace { get; private set; }

		public List<Leg> Legs => Owner.Legs;

		public bool Glue_CheckDetachement()
		{
			bool flag = Glue_Conditions_Detach();
			if (!flag)
			{
				flag = Glue_Conditions_DetachForced();
			}
			_Glue_AskingForDetach = flag;
			return flag;
		}

		public bool Glue_CheckIdleDetachementConfirm()
		{
			if (Owner._glueModeExecuted != 0)
			{
				return true;
			}
			if (hasOppositeleg)
			{
				Leg oppositeLeg = GetOppositeLeg();
				if (Glue_CheckOppositeLegMovementRestriction(oppositeLeg))
				{
					return false;
				}
			}
			return true;
		}

		private bool Glue_Conditions_Attach()
		{
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			if (!Owner.IsGrounded)
			{
				return false;
			}
			if (_glueTargetBlend < 0.0001f)
			{
				return false;
			}
			if (!RaycastHitted)
			{
				return false;
			}
			if (G_CustomForceNOTDetach)
			{
				return true;
			}
			if (_gluingCulldown > 0f)
			{
				return false;
			}
			if (G_CustomForceAttach)
			{
				return true;
			}
			if (Owner.DontGlueAttachIfTooNearOppositeLeg > 0f && hasOppositeleg)
			{
				Vector3 val = ToRootLocalSpace(_PreviousFinalIKPos);
				Leg oppositeLeg = GetOppositeLeg();
				Vector3 val2 = ToRootLocalSpace(oppositeLeg._PreviousFinalIKPos);
				float num = Owner.DontGlueAttachIfTooNearOppositeLeg * Owner.ScaleReference;
				if (Vector2.Distance(new Vector2(val.x, val.z), new Vector2(val2.x, val2.z)) < num)
				{
					return false;
				}
			}
			if (G_HandlerExecutingLegAnimationMode == EGlueMode.Moving)
			{
				bool flag = false;
				float y = C_Local_MidFootPosVsGroundHit.y;
				if (y > FloorLevel)
				{
					if (y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel)
					{
						flag = true;
					}
				}
				else
				{
					flag = true;
				}
				if (!flag)
				{
					return false;
				}
			}
			if (G_CustomForceNOTAttach)
			{
				return false;
			}
			if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f && Owner.DesiredMovementDirection != Vector3.zero)
			{
				Vector3 val3 = ToRootLocalSpaceDir(Owner.DesiredMovementDirection);
				Vector3 g_RefernceSwing = _G_RefernceSwing;
				if (Vector3.Dot(((Vector3)(ref val3)).normalized, ((Vector3)(ref g_RefernceSwing)).normalized) > 1f - Owner.SwingHelper)
				{
					return false;
				}
			}
			return true;
		}

		private bool Glue_CheckOppositeLegMovementRestriction(Leg oppositeLeg)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			if (!RaycastHitted)
			{
				return false;
			}
			if (!Owner.IsGrounded)
			{
				return false;
			}
			if (C_Local_MidFootPosVsGroundHit.y > BelowFootRange)
			{
				return false;
			}
			if (G_CustomForceNOTDetach)
			{
				return true;
			}
			if (!oppositeLeg.RaycastHitted)
			{
				return false;
			}
			if (oppositeLeg.C_Local_MidFootPosVsGroundHit.y > oppositeLeg.BelowFootRange)
			{
				return false;
			}
			if (oppositeLeg.G_GlueInternalTransition < LegAnimatingSettings.AllowDetachBefore)
			{
				return true;
			}
			return false;
		}

		private Leg GetOppositeLeg()
		{
			if (OppositeLegIndex < 0)
			{
				return null;
			}
			if (OppositeLegIndex >= Owner.Legs.Count)
			{
				return null;
			}
			return Owner.Legs[OppositeLegIndex];
		}

		private void Gluing_SetCulldown(float minDuration = 0.01f)
		{
			_gluingCulldown = Mathf.Max(_gluingCulldown, minDuration + (0.02f - Owner.GlueFadeOutSpeed * 0.03f));
		}

		public bool Glue_Conditions_Detach()
		{
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			bool flag = false;
			if (G_CustomForceNOTDetach)
			{
				return flag;
			}
			if (G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement)
			{
				return false;
			}
			if (!Glue_Conditions_Attach())
			{
				flag = true;
			}
			if (Owner.AnimateFeet && lastFootForwardAngleDiffABS > Owner.UnglueOn && !G_JustLanded)
			{
				if (Owner._glueModeExecuted != 0)
				{
					Gluing_SetCulldown();
				}
				flag = true;
			}
			if (!flag && !G_JustLanded)
			{
				Vector3 val = Vector3.zero;
				if (GluePointOffset != Vector2.zero)
				{
					val = -GetGluePointOffset();
				}
				if (Vector3.Distance(ankleAlignedOnGroundHitRootLocal + val, _GlueLastAttachPositionRootLocal) > G_GlueTesholdRange)
				{
					if (Owner._glueModeExecuted != 0)
					{
						Gluing_SetCulldown();
					}
					flag = true;
				}
			}
			return flag;
		}

		public Vector3 GetGluePointOffset()
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			float num = Owner.ScaleReferenceNoScale * Owner.GlueRangeThreshold;
			return Owner.RootToWorldSpaceVec(new Vector3(GluePointOffset.x * num, 0f, GluePointOffset.y * num));
		}

		private bool Glue_Conditions_DetachForced()
		{
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			if (G_CustomForceDetach)
			{
				return true;
			}
			if (G_RequestRepose != 0)
			{
				if (G_RequestRepose != GlueReposeRequest.ReposeIfFar)
				{
					G_RequestRepose = GlueReposeRequest.None;
					return true;
				}
				G_RequestRepose = GlueReposeRequest.None;
				if (G_Attached && Vector3.Distance(_GluePosition, ankleAlignedOnGroundHitWorldPos) > ScaleRef * 0.1f)
				{
					return true;
				}
			}
			return false;
		}

		private void ExtraProcessingApply()
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			if (G_LegAnimation.LegAdjustementYOffset != 0f)
			{
				_FinalIKPos += RootSpaceToWorldVec(new Vector3(0f, G_LegAnimation.LegAdjustementYOffset * LegRaiseMultiplier * _glueTargetBlend, 0f));
			}
			if (Owner.AnimateFeet)
			{
				PostCalculate_LimitFootYaw();
			}
		}

		private void ExtraIKPostProcessingApply()
		{
			if (Owner._stepPointsOverlapRadius > 0f)
			{
				PostCalculate_FeetOverlapRadius();
			}
			if (Owner.FeetYOffset != 0f)
			{
				PostCalculate_FeetYOffset();
			}
		}

		public void PostCalculate_LimitFootYaw()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0116: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = ankleAlignedOnGroundHitRotation * AnkleIK.forward;
			val = ToRootLocalSpaceDir(val);
			val.y = 0f;
			val = RootSpaceToWorldVec(val);
			Vector3 worldDir = _FinalIKRot * AnkleIK.forward;
			val = ToRootLocalSpaceDir(val);
			val.y = 0f;
			worldDir = ToRootLocalSpaceDir(worldDir);
			worldDir.y = 0f;
			float num = (lastFootForwardAngleDiffABS = Mathf.Abs(Vector3.SignedAngle(((Vector3)(ref val)).normalized, ((Vector3)(ref worldDir)).normalized, Vector3.up)));
			if (Owner.LimitFeetYaw > 0f && Owner.LimitFeetYaw < 90f && num > Owner.LimitFeetYaw)
			{
				float num2 = num - Owner.LimitFeetYaw;
				Quaternion val2 = (A_WasAligning ? ankleAlignedOnGroundHitRotation : AnkleIK.srcRotation);
				_FinalIKRot = Quaternion.LerpUnclamped(val2, _FinalIKRot, 1f - num2 / (90f - Owner.LimitFeetYaw));
			}
		}

		private void PostCalculate_FeetOverlapRadius()
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			float num = Owner._stepPointsOverlapRadius * GlueThresholdMultiplier;
			Vector3 val = ToRootLocalSpace(IKProcessor.IKTargetPosition);
			Leg leg = Owner.Legs[0];
			while (leg != null)
			{
				if (leg == this)
				{
					leg = leg.NextLeg;
					continue;
				}
				Vector3 val2 = ToRootLocalSpace(leg.IKProcessor.IKTargetPosition);
				Vector2 val3 = new Vector2(val2.x, val2.z) - new Vector2(val.x, val.z);
				float magnitude = ((Vector2)(ref val3)).magnitude;
				if (magnitude < num)
				{
					Vector2 val4 = -val3 * (num - magnitude) * 2f;
					FimpIK_Limb iKProcessor = IKProcessor;
					iKProcessor.IKTargetPosition += RootSpaceToWorldVec(new Vector3(val4.x, 0f, val4.y));
				}
				leg = leg.NextLeg;
			}
		}

		private void PostCalculate_FeetYOffset()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			FimpIK_Limb iKProcessor = IKProcessor;
			iKProcessor.IKTargetPosition += _FinalIKRot * (Owner.FeetYOffset * Owner.Scale * A_AligningHelperBlend * AnkleIK.up);
		}

		private void AlignStep_Init()
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			A_PreWasAligning = false;
			A_PreWasAligningNearGround = false;
			A_WasAligning = false;
			A_AligningHelperBlend = 0f;
			A_LastTargetAlignRot = BoneEnd.rotation;
			A_LastApppliedAlignRot = BoneEnd.rotation;
			A_PreIKPosForGluing = _FinalIKPos;
		}

		private void AlignStep_CheckAlignStatePre()
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			//IL_0173: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_012e: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0140: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_0147: Unknown result type (might be due to invalid IL or missing references)
			A_PreIKPosForGluing = _FinalIKPos;
			if (_noRaycast_skipFeetCalcs)
			{
				return;
			}
			bool flag = false;
			A_PreWasAligningNearGround = false;
			if (RaycastHitted)
			{
				float hips_StepHeightAdjustOffset = ParentHub._Hips_StepHeightAdjustOffset;
				hips_StepHeightAdjustOffset = ((!(hips_StepHeightAdjustOffset < 0f)) ? 0f : (hips_StepHeightAdjustOffset * -0.03f));
				A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
				A_LastAlignHeightCompareValue = ScaleRef * (0.002f + Owner.AnimationFloorLevel) + hips_StepHeightAdjustOffset;
				if (Owner.FootAlignRapidity > 0.9999f)
				{
					if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
					{
						flag = true;
						A_PreWasAligningNearGround = true;
					}
				}
				else if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue + ScaleRef * (0.04f + (1f - Owner.FootAlignRapidity) * 0.04f))
				{
					A_PreWasAligningNearGround = true;
					if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
					{
						flag = true;
					}
				}
			}
			else
			{
				A_LastAlignHeightDiff = 100f;
			}
			A_PreWasAligning = flag;
			if (flag)
			{
				Vector3 val = ankleAlignedOnGroundHitWorldPos;
				if (A_AligningHelperBlend > 0.99f)
				{
					_FinalIKPos = val;
				}
				else
				{
					_FinalIKPos = Vector3.Lerp(_FinalIKPos, val, A_AligningHelperBlend * 8f);
				}
				A_PreIKPosForGluing = val;
			}
			else if (A_AligningHelperBlend > 0.01f)
			{
				_FinalIKPos = Vector3.Lerp(_FinalIKPos, RootSpaceToWorld(A_LastApppliedAlignPosLocal), A_AligningHelperBlend);
			}
		}

		private void AlignStep_ValidateFootRotation()
		{
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			if (!Owner.AnimateFeet || _noRaycast_skipFeetCalcs)
			{
				return;
			}
			if (A_PreWasAligningNearGround)
			{
				float num = Owner.FootRotationBlend * A_AligningHelperBlend;
				if (A_LastElevateH < 0.02f)
				{
					if (num >= 1f)
					{
						A_LastTargetAlignRot = ankleAlignedOnGroundHitRotation;
					}
					else
					{
						A_LastTargetAlignRot = Quaternion.LerpUnclamped(_FinalIKRot, ankleAlignedOnGroundHitRotation, num);
					}
				}
				else
				{
					float num2 = A_LastElevateH / (ScaleRef * 0.15f);
					if (A_LastElevateH > 1f)
					{
						A_LastElevateH = 1f;
					}
					A_LastTargetAlignRot = Quaternion.LerpUnclamped(ankleAlignedOnGroundHitRotation, _FinalIKRot, num2 * num);
				}
			}
			else if (A_AligningHelperBlend < 0.001f)
			{
				A_LastTargetAlignRot = _FinalIKRot;
			}
			else
			{
				A_LastTargetAlignRot = Quaternion.Lerp(_FinalIKRot, A_LastTargetAlignRot, A_AligningHelperBlend);
			}
			if (Owner.FootAlignRapidity >= 1f)
			{
				A_LastApppliedAlignRot = A_LastTargetAlignRot;
			}
			else
			{
				A_LastApppliedAlignRot = Quaternion.Lerp(A_LastApppliedAlignRot, A_LastTargetAlignRot, DeltaTime * (8f + Owner.FootAlignRapidity * 26f));
			}
			_FinalIKRot = A_LastApppliedAlignRot;
		}

		private void AlignStep_OnGroundAlign()
		{
			//IL_021a: Unknown result type (might be due to invalid IL or missing references)
			//IL_021f: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_016e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0174: Unknown result type (might be due to invalid IL or missing references)
			//IL_017a: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_0279: Unknown result type (might be due to invalid IL or missing references)
			//IL_027e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			//IL_020c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			if (_noRaycast_skipFeetCalcs)
			{
				A_WasAligning = A_PreWasAligning;
				if (A_PreWasAligning)
				{
					if (A_AligningHelperBlend < 0.05f)
					{
						A_AligningHelperBlend = 0.05f;
					}
					A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
					if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
					{
						A_WasFullAlign = true;
						if (!Owner.UseGluing)
						{
							SendStepEvent();
						}
					}
				}
				else
				{
					if (A_AligningHelperBlend > 0.5f)
					{
						A_AligningHelperBlend = 0.5f;
					}
					A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 14f);
				}
				if (A_AligningHelperBlend < 0.65f)
				{
					A_WasFullAlign = false;
				}
				return;
			}
			A_aligningBlendByGluing = 1f;
			if (Owner.UseGluing)
			{
				A_aligningBlendByGluing = 1f - _glueTargetBlend * G_GlueAnimationBlend;
			}
			if (A_PreWasAligning)
			{
				if (A_WasAligning)
				{
					A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
				}
				float num = A_aligningBlendByGluing * A_AligningHelperBlend;
				if (num >= 1f)
				{
					_FinalIKPos = ankleAlignedOnGroundHitWorldPos;
				}
				else
				{
					_FinalIKPos = Vector3.LerpUnclamped(_FinalIKPos, ankleAlignedOnGroundHitWorldPos, num);
				}
				if (A_AligningHelperBlend < 0.05f)
				{
					A_AligningHelperBlend = 0.05f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
				if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
				{
					A_WasFullAlign = true;
					if (!Owner.UseGluing)
					{
						SendStepEvent();
					}
				}
				A_LastApppliedAlignPosLocal = ToRootLocalSpace(_FinalIKPos);
			}
			else
			{
				A_PreviousRelevantAnklePos = _SourceIKPosUnchangedY;
				if (A_AligningHelperBlend > 0.75f)
				{
					A_AligningHelperBlend = 0.75f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 18f);
			}
			if (A_AligningHelperBlend < 0.6f)
			{
				A_WasFullAlign = false;
			}
			A_LastApppliedAlignPos = _FinalIKPos;
			A_WasAligning = A_PreWasAligning;
		}

		private void AlignStep_LegElevation()
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0281: Unknown result type (might be due to invalid IL or missing references)
			//IL_0286: Unknown result type (might be due to invalid IL or missing references)
			//IL_028b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0292: Unknown result type (might be due to invalid IL or missing references)
			//IL_0298: Unknown result type (might be due to invalid IL or missing references)
			//IL_029d: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0185: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.LegElevateBlend < 0.001f)
			{
				return;
			}
			if (_noRaycast_skipFeetCalcs)
			{
				A_LastElevation = Vector3.zero;
				return;
			}
			float scaleRef = ScaleRef;
			float num = groundHitRootSpacePos.y - A_LastSuddenSmoothYOffset - ParentHub._Hips_StepHeightAdjustOffset;
			float num2 = Owner.AnimationFloorLevel * scaleRef;
			float c_Local_FootElevateInAnimation = C_Local_FootElevateInAnimation;
			if (c_Local_FootElevateInAnimation > num2 && num > 0.001f * scaleRef + num2 + 0.1f)
			{
				c_Local_FootElevateInAnimation -= num2;
				float num3 = c_Local_FootElevateInAnimation;
				float num4 = c_Local_FootElevateInAnimation - num;
				float num5 = scaleRef * 0.015f;
				float num6 = scaleRef * 0.35f;
				float num7 = num4 / num6;
				num7 = Mathf.Clamp01(num7);
				if (num4 > num5)
				{
					num3 *= 1f - num7;
					if (A_AligningFor < 0f)
					{
						A_AligningFor = DeltaTime;
					}
					if (A_AligningFor < 0.3f)
					{
						A_AligningFor += DeltaTime;
					}
					else
					{
						A_AligningFor = 0.3f;
					}
				}
				else if (A_AligningFor > 0f)
				{
					A_AligningFor -= DeltaTime;
				}
				else
				{
					A_AligningFor = 0f;
				}
				float num8 = num3;
				float num9 = scaleRef * Mathf.LerpUnclamped(0.1f, 0.9f, Owner.LegElevateHeightLimit);
				if (num8 > num9)
				{
					num8 = num9;
				}
				if (groundHitRootSpacePos.y > 0f)
				{
					float num10 = ScaleRef * 0.2f;
					if (num10 > 0f)
					{
						float num11 = groundHitRootSpacePos.y / num10;
						if (num11 > 0.8f)
						{
							num8 = Mathf.LerpUnclamped(num8, 0f, Mathf.InverseLerp(0.8f, 1.1f, num11));
						}
					}
				}
				if (Mathf.Abs(num8 - A_LastElevateH) > scaleRef * Adj_A_ElevateSpeedupMargin)
				{
					A_LastElevateH = Mathf.Lerp(A_LastElevateH, num8, DeltaTime * Adj_A_ElevateLerpSpeedAfter);
				}
				else
				{
					A_LastElevateH = Mathf.Lerp(A_LastElevateH, num8, DeltaTime * Adj_A_ElevateLerpSpeedStart);
				}
				if (A_LastElevateH < 0f)
				{
					A_LastElevateH = 0f;
				}
			}
			else
			{
				A_LastElevateH = Mathf.SmoothDamp(A_LastElevateH, 0f, ref _sd_A_Elev, 0.02f, 100000f, DeltaTime);
			}
			A_LastElevation = RootSpaceToWorldVec(new Vector3(0f, A_LastElevateH * Owner.LegElevateBlend * A_aligningBlendByGluing, 0f));
			_FinalIKPos += A_LastElevation;
		}

		private void AlignStep_SmoothSuddenSteps()
		{
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0217: Unknown result type (might be due to invalid IL or missing references)
			//IL_021c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0221: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_0265: Unknown result type (might be due to invalid IL or missing references)
			//IL_0288: Unknown result type (might be due to invalid IL or missing references)
			//IL_029c: Unknown result type (might be due to invalid IL or missing references)
			//IL_029e: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.SmoothSuddenSteps < 0.0001f)
			{
				return;
			}
			if (_noRaycast_skipFeetCalcs || G_Attached)
			{
				A_WasAligningFrameBack = A_WasAligning;
				A_WasSmoothing = false;
				return;
			}
			float scaleRef = ScaleRef;
			if (A_WasAligning || A_WasAligningFrameBack)
			{
				if (!A_WasAligning)
				{
					A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
				}
				Vector3 val = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
				Vector3 val2 = ((!A_WasSmoothing) ? ToRootLocalSpace(A_PreviousRelevantAnklePos) : ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos));
				float num = val2.y - val.y;
				num = Mathf.Abs(num);
				float num2 = scaleRef * 0.006f;
				if ((raycastSlopeAngle < 17f || raycastSlopeAngle > 80f || Owner.RaycastShape == ERaycastMode.Spherecast) && num > num2)
				{
					float num3 = num / (scaleRef * 0.275f);
					if (num3 > 1f)
					{
						num3 = 1f;
					}
					if (num3 > Mathf.LerpUnclamped(0.25f, 0.1f, Owner.SmoothSuddenSteps))
					{
						float num4 = Mathf.LerpUnclamped(0.3f, 0.1f, Owner.SmoothSuddenSteps);
						if (A_lastSuddenSmoothingDiff == 0f || A_SuddenSmoothing < num3)
						{
							A_lastSuddenSmoothingDiff = num;
							A_LastAlignRootSpacePos = ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos);
							num4 *= 0.7f;
						}
						else if (Owner.SmoothSuddenSteps < 0.5f)
						{
							float num5 = Mathf.LerpUnclamped(0.5f, 0f, Owner.SmoothSuddenSteps);
							A_lastSuddenSmoothingDiff = Mathf.LerpUnclamped(A_lastSuddenSmoothingDiff, num, num5);
						}
						A_SuddenSmoothing += Mathf.Clamp01(A_lastSuddenSmoothingDiff / (scaleRef * num4));
						float num6 = 0.85f + Owner.SmoothSuddenSteps * 0.165f;
						if (A_SuddenSmoothing > num6)
						{
							A_SuddenSmoothing = num6;
						}
					}
				}
			}
			if (A_SuddenSmoothing > 0f)
			{
				Vector3 val3 = ToRootLocalSpace(_FinalIKPos);
				A_LastSuddenSmoothYOffset = val3.y;
				A_SuddenSmoothing -= Owner.DeltaTime * Mathf.LerpUnclamped(60f, 7.5f, Owner.SmoothSuddenSteps);
				val3.y = Mathf.Lerp(val3.y, A_LastAlignRootSpacePos.y, A_SuddenSmoothing);
				A_LastSuddenSmoothYOffset = val3.y - A_LastSuddenSmoothYOffset;
				A_LastSmoothTargetedPosLocal = val3;
				A_SmoothedIKPos = RootSpaceToWorld(val3);
				_FinalIKPos = A_SmoothedIKPos;
				if (A_SuddenSmoothing < 0f)
				{
					A_SuddenSmoothing = 0f;
				}
				A_WasSmoothing = true;
			}
			else
			{
				A_LastSuddenSmoothYOffset = 0f;
				A_WasSmoothing = false;
			}
		}

		private void AlignStep_Complete()
		{
			A_WasAligningFrameBack = A_WasAligning;
		}

		private void Gluing_Init()
		{
			G_AttachementHandler = new GlueAttachementHandler(this);
			Glue_Reset(initializing: true);
		}

		public void Glue_Reset(bool initializing)
		{
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			G_Attached = false;
			if (initializing)
			{
				_GlueLastAttachPosition = BoneEnd.position;
				_GlueLastAttachRotation = BoneEnd.rotation;
				_GluePosition = BoneEnd.position;
				_GlueLastAttachPositionRootLocal = ToRootLocalSpace(BoneEnd.position);
				_G_LastPreGlueSourceLocalIKPos = _GlueLastAttachPosition;
				_G_PreGlueSourceLocalIKPos = _SourceIKPos;
				A_PreIKPosForGluing = BoneEnd.position;
				_G_LasGroundedPosLocal = _GlueLastAttachPositionRootLocal;
			}
			GlueAttachement g_Attachement = default(GlueAttachement);
			g_Attachement.PosInAttachementLocal = _FinalIKPos;
			g_Attachement.RotInAttachementLocal = _FinalIKRot;
			G_Attachement = g_Attachement;
			_G_RefernceSwing = Vector3.zero;
			_G_WasDisabled = true;
			G_AttachementHandler.Reset(initializing);
		}

		private void Gluing_Update()
		{
			//IL_0257: Unknown result type (might be due to invalid IL or missing references)
			//IL_0262: Unknown result type (might be due to invalid IL or missing references)
			//IL_0267: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_019c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_015d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0162: Unknown result type (might be due to invalid IL or missing references)
			//IL_0169: Unknown result type (might be due to invalid IL or missing references)
			//IL_016e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01db: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0218: Unknown result type (might be due to invalid IL or missing references)
			//IL_021f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_022a: Unknown result type (might be due to invalid IL or missing references)
			//IL_024a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0202: Unknown result type (might be due to invalid IL or missing references)
			//IL_0207: Unknown result type (might be due to invalid IL or missing references)
			_glueTargetBlend = Owner.GlueBlend * ExtraGluingBlend * Owner.RagdolledDisablerBlend * Owner.NotSlidingBlend;
			if (Owner.GlueOnlyOnIdle)
			{
				_glueTargetBlend *= 1f - Owner.IsMovingBlend;
			}
			if (Owner.IsGrounded)
			{
				if (Owner.GroundedTime < 0.25f)
				{
					G_JustLanded = true;
					_glueTargetBlend *= 0.1f + Mathf.InverseLerp(0f, 0.25f, Owner.GroundedTime) * 0.9f;
				}
				else
				{
					G_JustLanded = false;
				}
			}
			else
			{
				G_JustLanded = false;
				_glueTargetBlend *= Owner.IsGroundedBlend;
			}
			if (_glueTargetBlend < 0.0001f)
			{
				_glueTargetBlend = 0f;
				_G_WasDisabled = true;
				return;
			}
			if (_G_WasDisabled)
			{
				Glue_Reset(initializing: false);
				_G_WasDisabled = false;
			}
			if (_gluingCulldown > 0f)
			{
				_gluingCulldown -= Owner.DeltaTime;
			}
			if (!Owner.IsGrounded)
			{
				if (_G_WasGrounded)
				{
					_G_WasGrounded = false;
					_G_LasGroundedPosLocal = ToRootLocalSpace(_GluePosition);
					_G_LasGroundedRotLocal = _GlueRotation;
					G_AttachementHandler.legMoveAnimation.Reset();
				}
				_GluePosition = RootSpaceToWorld(_G_LasGroundedPosLocal);
				_GlueRotation = _G_LasGroundedRotLocal;
				return;
			}
			_G_WasGrounded = true;
			if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f)
			{
				Vector3 val = AnkleH.LastKeyframeRootPos - _G_LastPreGlueSourceLocalIKPos;
				if (((Vector3)(ref val)).magnitude > Owner.ScaleReferenceNoScale * 0.001f)
				{
					_G_LastPreGlueSourceLocalIKPos = _G_PreGlueSourceLocalIKPos;
				}
				_G_PreGlueSourceLocalIKPos = AnkleH.LastKeyframeRootPos;
				_G_RefernceSwing = Vector3.SmoothDamp(_G_RefernceSwing, val * 2f, ref _G_sd_RefSwing, 0.04f, 100000f, Owner.DeltaTime);
			}
			else
			{
				_G_RefernceSwing = Vector3.zero;
				_G_sd_RefSwing = Vector3.zero;
			}
			_Glue_AskingForDetach = false;
			if (G_Attached)
			{
				bool flag = !Glue_CheckDetachement();
				if (!flag)
				{
					flag = !Glue_CheckIdleDetachementConfirm();
				}
				if (!flag)
				{
					G_Attached = flag;
					G_AttachementHandler.OnLegRequireRepose();
					flag = Glue_Conditions_Attach();
				}
				else if (!Glue_Conditions_Attach())
				{
					flag = false;
				}
				if (flag)
				{
					G_AttachementHandler.TransitionToGlueAnimation();
				}
				else
				{
					G_AttachementHandler.TransitionToDisableGlueAnimation();
				}
			}
			else if (Glue_Conditions_Attach())
			{
				G_AttachementHandler.TransitionToGlueAnimation();
			}
			else
			{
				G_AttachementHandler.TransitionToDisableGlueAnimation();
			}
			if (G_InstantReglue)
			{
				G_AttachementHandler.SheduleInstantTransition();
				G_InstantReglue = false;
			}
			G_AttachementHandler.UpdateTransitioning(G_DuringAttaching);
			Gluing_UpdateAttachement();
		}

		private bool Glue_TriggerFinalAttach()
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref legGroundHit)).transform) || _UsingEmptyRaycast)
			{
				G_Attached = true;
				G_Attachement = new GlueAttachement(this, legGroundHit);
				return true;
			}
			return false;
		}

		private void Gluing_UpdateAttachement()
		{
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			if (!G_Attachement.NoTransform && (Object)(object)G_Attachement.AttachedTo == (Object)null)
			{
				G_Attachement = default(GlueAttachement);
				G_AttachementHandler.OnLegRequireRepose();
				G_Attached = false;
			}
			if (!G_Attached)
			{
				_GluePosition = G_AttachementHandler.GetGluePosition();
				Gluing_DragStretchApply();
				if (Owner.AnimateFeet)
				{
					if (Owner.LimitFeetYaw > 0f)
					{
						_GlueRotation = G_AttachementHandler.GetGlueRotation();
					}
					else
					{
						_GlueRotation = A_LastApppliedAlignRot;
					}
				}
			}
			else
			{
				_GlueLastAttachPosition = G_Attachement.GetRelevantAlignedHitPoint(this);
				_GlueLastAttachPositionRootLocal = ToRootLocalSpace(_GlueLastAttachPosition);
				Quaternion relevantAttachementRotation = G_Attachement.GetRelevantAttachementRotation();
				_GlueLastAttachRotation = relevantAttachementRotation;
				_GluePosition = G_AttachementHandler.GetGluePosition();
				Gluing_DragStretchApply();
				if (Owner.AnimateFeet)
				{
					if (Owner.LimitFeetYaw > 0f)
					{
						_GlueRotation = G_AttachementHandler.GetGlueRotation();
					}
					else
					{
						_GlueRotation = A_LastApppliedAlignRot;
					}
				}
			}
			G_AttachementHandler.PostUpdate();
		}

		private void Gluing_DragStretchApply()
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0137: Unknown result type (might be due to invalid IL or missing references)
			//IL_013c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			//IL_00df: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.AllowGlueDrag > 0f)
			{
				float stretchValue = IKProcessor.GetStretchValue(_GluePosition - Owner._LastAppliedHipsStabilityOffset);
				float num = Mathf.LerpUnclamped(1f, 0.825f, Owner.AllowGlueDrag);
				float num2 = num * Mathf.LerpUnclamped(1f, LegStretchLimit, Owner.AllowGlueDrag);
				if (num2 > num)
				{
					num2 = num;
				}
				Vector3 val = _GluePosition;
				if (stretchValue > num2 * 1.1f)
				{
					float num3 = (stretchValue - num2 * 1.1f) * 2f * Mathf.Min(1f, Owner.AllowGlueDrag);
					val = ((!A_PreWasAligning) ? Vector3.Lerp(_GluePosition, A_PreIKPosForGluing, num3) : Vector3.Lerp(_GluePosition, ankleAlignedOnGroundHitWorldPos, num3));
				}
				Vector3 val2 = val - _GluePosition;
				G_GlueDragOffset = Vector3.Lerp(G_GlueDragOffset, val2, Owner.DeltaTime * 14f);
				if (float.IsNaN(G_GlueDragOffset.x) || float.IsNaN(G_GlueDragOffset.z))
				{
					G_GlueDragOffset = Vector3.zero;
				}
			}
		}

		private void Gluing_ApplyCoords()
		{
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			if (_glueTargetBlend < 0.0001f)
			{
				return;
			}
			float num = _glueTargetBlend * G_AttachementHandler.glueAnimationBlend;
			if (num >= 1f)
			{
				_FinalIKPos = _GluePosition + G_GlueDragOffset;
				if (Owner.AnimateFeet)
				{
					_FinalIKRot = _GlueRotation;
				}
			}
			else
			{
				_FinalIKPos = Vector3.LerpUnclamped(A_PreIKPosForGluing, _GluePosition + G_GlueDragOffset, num);
				if (Owner.AnimateFeet)
				{
					_FinalIKRot = Quaternion.LerpUnclamped(_FinalIKRot, _GlueRotation, num);
				}
			}
		}

		private void Controll_Init()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			C_AnkleToHeelRootSpace = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
			ThighH.Calibrate(this, ThighH.Bone.position);
			AnkleH.Calibrate(this, AnkleH.Bone.position);
		}

		private Vector3 TransformVectorAnkleWithAlignedRotation(Vector3 offset)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			return ankleAlignedOnGroundHitRotation * Vector3.Scale(offset, BoneEnd.lossyScale);
		}

		private void Controll_Calibrate()
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00df: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0116: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_015c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0161: Unknown result type (might be due to invalid IL or missing references)
			//IL_0166: Unknown result type (might be due to invalid IL or missing references)
			//IL_016b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			//IL_0187: Unknown result type (might be due to invalid IL or missing references)
			_C_DynamicYScale = Owner.DynamicYScale;
			ThighH.Calibrate(this, ThighH.Bone.position);
			AnkleH.Calibrate(this, _SourceIKPosUnchangedY);
			Vector3 ankleToHeel = AnkleToHeel;
			Vector3 val = TransformVectorAnkleWithAlignedRotation(AnkleToHeel);
			C_LastFootEndWorldPos = _SourceIKPosUnchangedY + TransformVectorAnkleWithAlignedRotation(ankleToHeel);
			C_LastFootEndRootSpacePos = ToRootLocalSpace(C_LastFootEndWorldPos);
			C_AnimatedAnkleFlatHeight = ToRootLocalSpaceDir(val).y;
			C_LastHeelWorldPos = _SourceIKPosUnchangedY + val;
			C_LastHeelRootSpacePos = ToRootLocalSpace(C_LastHeelWorldPos);
			if (Owner.AnimateFeet)
			{
				C_LastMidRefFootWorldPos = Vector3.LerpUnclamped(C_LastFootEndWorldPos, C_LastHeelWorldPos, FootMiddlePosition);
				C_LastMidRefFootRootSpacePos = Vector3.LerpUnclamped(C_LastFootEndRootSpacePos, C_LastHeelRootSpacePos, FootMiddlePosition);
			}
			else
			{
				C_LastMidRefFootRootSpacePos = C_LastHeelRootSpacePos;
				C_LastMidRefFootWorldPos = C_LastHeelWorldPos;
			}
			C_Local_MidFootPosVsGroundHit = C_LastMidRefFootRootSpacePos - groundHitRootSpacePos;
			C_Local_FootElevateInAnimation = C_LastMidRefFootRootSpacePos.y - ParentHub._Hips_LastHipsOffset;
			C_Local_AnkleToHeelRotated = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
			Vector3 val2 = BoneEnd.TransformVector(AnkleToHeel);
			C_AnkleToHeelWorldHeight = ((Vector3)(ref val2)).magnitude;
		}

		private Vector3 RootSpaceToWorldVec(Vector3 localVec)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Owner.RootToWorldSpaceVec(localVec);
		}

		private Vector3 RootSpaceToWorld(Vector3 rootLocal)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Owner.RootToWorldSpace(rootLocal);
		}

		private Vector3 ToRootLocalSpaceDir(Vector3 worldDir)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Owner.ToRootLocalSpaceVec(worldDir);
		}

		private Vector3 ToRootLocalSpace(Vector3 worldPos)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			return Owner.ToRootLocalSpace(worldPos);
		}

		private Vector3 ChangeLocalY(Vector3 worldPos, float targetLocalY)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			worldPos = ToRootLocalSpace(worldPos);
			worldPos.y = targetLocalY;
			return RootSpaceToWorld(worldPos);
		}

		private Vector3 ChangeLocalPosExceptY(Vector3 worldPos, Vector3 targetWorldPos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			worldPos = ToRootLocalSpace(worldPos);
			Vector3 val = ToRootLocalSpace(targetWorldPos);
			worldPos.x = val.x;
			worldPos.z = val.z;
			return RootSpaceToWorld(worldPos);
		}

		private void Control_StepEventCalcs()
		{
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			StepEventRestore();
			if (!Owner.UseGluing || _StepSent)
			{
				return;
			}
			if (Owner._glueModeExecuted == EGlueMode.Idle)
			{
				if (G_GlueInternalTransition >= 0.85f - Owner.EventExecuteSooner)
				{
					if (_ToConfirmStepEvent > 0.1f)
					{
						SendStepEvent(G_AttachementHandler.legMoveDistanceFactor);
						return;
					}
					float num = Mathf.InverseLerp(1f, 0f, LegAnimatingSettings.RaiseYAxisCurve.Evaluate(G_GlueInternalTransition));
					_ToConfirmStepEvent += DeltaTime * (3f + 3f * num);
				}
				else
				{
					_ToConfirmStepEvent = 0f;
				}
			}
			else
			{
				if (G_HandlerExecutingLegAnimationMode != EGlueMode.Moving || !Owner.SendOnMovingGlue || G_CustomForceNOTAttach)
				{
					return;
				}
				float num2 = FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.5f + A_LastAlignHeightCompareValue * (1.65f + Owner.EventExecuteSooner);
				if (G_CustomForceAttach)
				{
					_ToConfirmStepEvent += DeltaTime * 5f;
					num2 += ScaleRef * 0.1f;
				}
				if (A_LastAlignHeightDiff <= num2)
				{
					if (_ToConfirmStepEvent > 0.2f)
					{
						SendStepEvent(1f, EStepType.MovementGluing);
						_ToConfirmStepEvent = 0f;
						return;
					}
					_ToConfirmStepEvent += DeltaTime;
					if (A_LastAlignHeightDiff < num2 * 0.75f)
					{
						_ToConfirmStepEvent += DeltaTime * 1f;
					}
					if (A_LastAlignHeightDiff < num2 * 0.5f)
					{
						_ToConfirmStepEvent += DeltaTime * 1f;
					}
				}
				else
				{
					_ToConfirmStepEvent = 0f;
				}
			}
		}

		internal void StepEventSentInCustomWay()
		{
			_StepSent = true;
			_StepSentAt = Time.unscaledTime;
		}

		public void InitLegBasics(LegsAnimator creator, int index, Leg nextLeg)
		{
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)creator != (Object)null)
			{
				Owner = creator;
			}
			PlaymodeIndex = index;
			NextLeg = nextLeg;
			LegStretchLimit = 1f;
			BlendWeight = 1f;
			InternalModuleBlendWeight = 1f;
			EnsureAxesNormalization();
			_h_boneStart = new LegHelper(this, BoneStart);
			_h_boneMid = new LegHelper(this, BoneMid);
			_h_boneEnd = new LegHelper(this, BoneEnd);
			_h_boneStart.Child = _h_boneMid;
			_h_boneMid.Child = _h_boneEnd;
			Gluing_Init();
			Reset();
			Controll_Init();
			Raycasting_Init();
			Stability_Init();
			AlignStep_Init();
			RefreshHasOppositeLeg();
			targetLegAnimating = (Object.op_Implicit((Object)(object)CustomLegAnimating) ? CustomLegAnimating.Settings : creator.LegAnimatingSettings);
			ankleAlignedOnGroundHitWorldPos = _FinalIKPos;
		}

		public void RefreshHasOppositeLeg()
		{
			hasOppositeleg = false;
			if (GetOppositeLeg() != null)
			{
				hasOppositeleg = true;
			}
		}

		public void Leg_UpdateParams()
		{
			targetLegAnimating = (Object.op_Implicit((Object)(object)CustomLegAnimating) ? CustomLegAnimating.Settings : Owner.LegAnimatingSettings);
			IK_UpdateParams();
		}

		internal void AssignParentHub(HipsReference hipsReference)
		{
			ParentHub = hipsReference;
		}

		internal void Reset()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			_SourceIKPos = BoneEnd.position;
			_SourceIKRot = BoneEnd.rotation;
			_FinalIKPos = _SourceIKPos;
			_FinalIKRot = _SourceIKRot;
			_PreviousFinalIKPos = _FinalIKPos;
			_PreviousFinalIKRot = _FinalIKRot;
			legGroundHit = default(RaycastHit);
			((RaycastHit)(ref legGroundHit)).point = _FinalIKPos;
			((RaycastHit)(ref legGroundHit)).normal = Owner.Up;
			_PreviousFinalIKPosForStability = _SourceIKPos;
			ankleAlignedOnGroundHitRotation = _SourceIKRot;
			A_LastApppliedAlignRot = _SourceIKRot;
			A_LastTargetAlignRot = _SourceIKRot;
			groundHitRootSpacePos = ToRootLocalSpace(_SourceIKPos);
			_SourceIKPosUnchangedY = groundHitRootSpacePos;
			RaycastHit val = default(RaycastHit);
			((RaycastHit)(ref val)).point = _FinalIKPos;
			((RaycastHit)(ref val)).normal = Owner.Up;
			legGroundHit = val;
			Glue_Reset(initializing: true);
		}

		public void PreCalibrate()
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00df: Unknown result type (might be due to invalid IL or missing references)
			BlendWeight *= InternalModuleBlendWeight;
			finalBoneBlend = BlendWeight * Owner._MainBlend;
			if (finalBoneBlend < 0.0001f)
			{
				if (!_G_WasDisabled)
				{
					G_Attached = false;
					G_AttachementHandler.Reset(initializing: false);
					G_Attachement = default(GlueAttachement);
					_G_WasDisabled = true;
					legGroundHit = default(RaycastHit);
					RaycastHitted = false;
				}
			}
			else if (Owner.Calibrate == ECalibrateMode.Calibrate)
			{
				IKProcessor.PreCalibrate();
			}
			else if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
			{
				if (!_wasFixedCalibrateAnimationCaptured)
				{
					IKProcessor.PreCalibrate();
					return;
				}
				BoneStart.localRotation = _AnimatorStartBoneLocRot;
				BoneMid.localRotation = _AnimatorMidBoneLocRot;
				BoneEnd.localRotation = _AnimatorEndBoneLocRot;
			}
		}

		public void CheckAnimatorPose()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			_AnimatorStartBonePos = BoneStart.position;
			_AnimatorMidBonePos = BoneMid.position;
			_AnimatorEndBonePos = BoneEnd.position;
			if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
			{
				_wasFixedCalibrateAnimationCaptured = true;
				_AnimatorStartBoneLocRot = BoneStart.localRotation;
				_AnimatorMidBoneLocRot = BoneMid.localRotation;
				_AnimatorEndBoneLocRot = BoneEnd.localRotation;
			}
		}

		public void BeginLateUpdate()
		{
			if (!(finalBoneBlend < 0.0001f))
			{
				G_CustomForceAttach = false;
				G_CustomForceNOTDetach = false;
				G_CustomForceDetach = false;
				G_CustomForceNOTAttach = false;
				IK_PreUpdate();
				LegStretchLimit = Owner.LimitLegStretch * LegStretchMultiplier;
			}
		}

		public void PreLateUpdate()
		{
			if (!customOverwritingIKPos && (!_G_WasDisabled || !(finalBoneBlend < 0.0001f)))
			{
				Owner.Modules_LegBeforeRaycastingUpdate(this);
				Raycasting_PreLateUpdate();
				Controll_Calibrate();
			}
		}

		public void LateUpdate()
		{
			if (!(finalBoneBlend < 0.0001f) && !customOverwritingIKPos)
			{
				Owner.Modules_Leg_LateUpdate(this);
				AlignStep_CheckAlignStatePre();
				AlignStep_ValidateFootRotation();
				Gluing_Update();
				Gluing_ApplyCoords();
				AlignStep_OnGroundAlign();
				AlignStep_SmoothSuddenSteps();
				AlignStep_LegElevation();
				AlignStep_Complete();
				Control_StepEventCalcs();
				ExtraProcessingApply();
			}
		}

		public void LateUpdate_Apply()
		{
			IK_PostUpdate();
		}

		public void FixedUpdate()
		{
		}

		public float LegLimbLength()
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)BoneStart == (Object)null || (Object)(object)BoneMid == (Object)null || (Object)(object)BoneEnd == (Object)null)
			{
				return Owner.HipsToGroundDistance();
			}
			return 0f + Vector3.Distance(BoneStart.position, BoneMid.position) + Vector3.Distance(BoneEnd.position, BoneMid.position);
		}

		public bool HasAllBonesSet()
		{
			if ((Object)(object)BoneStart == (Object)null)
			{
				return false;
			}
			if ((Object)(object)BoneMid == (Object)null)
			{
				return false;
			}
			if ((Object)(object)BoneEnd == (Object)null)
			{
				return false;
			}
			return true;
		}

		public float R(float toRound, int digits = 2)
		{
			return (float)Math.Round(toRound, digits);
		}

		private void SendStepEvent(float factor = 1f, EStepType type = EStepType.IdleGluing)
		{
			if (!_StepSent)
			{
				if (Owner.GroundedTime < 0.1f)
				{
					type = EStepType.OnLanding;
				}
				else if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
				{
					type = EStepType.OnStopping;
				}
				Owner.Events_OnStep(this, factor, type);
				_StepSent = true;
				_StepSentAt = Time.unscaledTime;
				if (hasOppositeleg)
				{
					_OppositeLegStepped = true;
					GetOppositeLeg()._OppositeLegStepped = !Owner.IsMoving;
				}
			}
		}

		private void SendRaiseEvent(float distanceToNew = 1f)
		{
			if (!(Time.unscaledTime - _RaiseSentAt < 0.05f))
			{
				_RaiseSentAt = Time.unscaledTime;
				EStepType type = EStepType.IdleGluing;
				if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
				{
					type = EStepType.OnStopping;
				}
				Owner.Events_OnRaise(this, distanceToNew, type);
			}
		}

		private void StepEventRestore()
		{
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			if (!Owner.UseEvents || !_StepSent || Time.unscaledTime - _StepSentAt < 0.1f || Owner.GroundedTime < 0.1f)
			{
				return;
			}
			if (Owner.UseGluing)
			{
				if (G_AttachementHandler.glueAnimationBlend > 0.5f && G_GlueInternalTransition > 0.25f)
				{
					return;
				}
				if (Owner._glueModeExecuted == EGlueMode.Idle)
				{
					if (!G_DuringAttaching || (Owner.GlueMode == EGlueMode.Automatic && (Owner.IsMoving || Owner.Helper_WasMoving)) || (!Owner.SendOnStopping && Owner.StoppedTime < 0.155f) || G_AttachementHandler.lasGlueModeOnAttaching != 0 || G_AttachementHandler.legMoveDistanceFactor < 0.05f)
					{
						return;
					}
				}
				else
				{
					if ((Owner.GlueMode == EGlueMode.Automatic && !Owner.IsMoving) || Owner.MovingTime < 0.06f || A_PreWasAligning || A_AligningHelperBlend > 0.5f - Owner.EventExecuteSooner || (hasOppositeleg && !GetOppositeLeg()._OppositeLegStepped))
					{
						return;
					}
					float num = (0f - ScaleRef) * 0.2f + FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.75f + A_LastAlignHeightCompareValue * (3f + Owner.EventExecuteSooner);
					if (A_LastAlignHeightDiff < num)
					{
						return;
					}
				}
			}
			else
			{
				if (A_PreWasAligning || A_AligningHelperBlend > 0.05f)
				{
					return;
				}
				if (Owner.IsMovingBlend < 0.05f)
				{
					_StepSent = true;
					return;
				}
				if (!Owner.Helper_WasMoving)
				{
					_StepSent = true;
					return;
				}
				if (!Owner.IsMoving)
				{
					_StepSent = true;
					return;
				}
			}
			_StepSent = false;
		}

		public void IK_Initialize(bool generateNew = true)
		{
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_0142: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_017b: Unknown result type (might be due to invalid IL or missing references)
			if (generateNew)
			{
				IKProcessor = new FimpIK_Limb();
			}
			if (Object.op_Implicit((Object)(object)BoneFeet))
			{
				IKProcessor.SetLegWithFeet(BoneStart, BoneMid, BoneEnd, BoneFeet);
			}
			else
			{
				IKProcessor.SetBones(BoneStart, BoneMid, BoneEnd);
			}
			IKProcessor.Init(Owner.BaseTransform);
			IKProcessor.UseEndBoneMapping = false;
			IKProcessor.IKWeight = 1f;
			IKProcessor.IKPositionWeight = 1f;
			IKProcessor.FootRotationWeight = 1f;
			IKProcessor.ManualHintPositionWeight = 0f;
			IKProcessor.FeetStretchSensitivity = 0.9f;
			IKProcessor.FeetFadeQuicker = 1.1f;
			IKProcessor.FeetStretchLimit = 0.8f;
			IKProcessor.HumanoidAnimator = Owner.Mecanim;
			IKProcessor.IsRight = Side == ELegSide.Right;
			_FinalIKPos = IKProcessor.EndIKBone.transform.position;
			_PreviousFinalIKPos = _FinalIKPos;
			_PreviousFinalIKPosForStability = _FinalIKPos;
			_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_FinalIKPos);
			IKProcessor.IKTargetPosition = _FinalIKPos;
			IKProcessor.IKTargetRotation = _FinalIKRot;
		}

		public void AssignCustomIKProcessor(FimpIK_Limb ik)
		{
			IKProcessor = ik;
			IK_Initialize(generateNew: false);
		}

		public void OverrideTargetIKPosition(Vector3? targetIKPos)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			if (!targetIKPos.HasValue)
			{
				customOverwritingIKPos = false;
				return;
			}
			customOverwritingIKPos = true;
			customOverwritePos = targetIKPos.Value;
		}

		public void OverrideTargetIKRotation(Quaternion? targetIKRot)
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			if (!targetIKRot.HasValue)
			{
				if (customOverwritingIKRot)
				{
					IKProcessor.FootRotationWeight = 1f;
				}
				customOverwritingIKRot = false;
			}
			else
			{
				customOverwritingIKRot = true;
				customOverwriteRot = targetIKRot.Value;
			}
		}

		public void OverrideFinalIKPos(Vector3 pos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_FinalIKPos = pos;
		}

		public void OverrideFinalAndSourceIKPos(Vector3 pos)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			_FinalIKPos = pos;
			_SourceIKPos = pos;
		}

		public Vector3 GetFinalIKPos()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _FinalIKPos;
		}

		public Vector3 GetSourceIKPos()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _SourceIKPos;
		}

		public Quaternion GetFinalIKRot()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _FinalIKRot;
		}

		public Quaternion GetSourceIKRot()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _SourceIKRot;
		}

		public void OverrideFinalIKRot(Quaternion rot)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_FinalIKRot = rot;
		}

		public void IK_PreUpdate()
		{
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			IKProcessor.CallPreCalibrate = Owner.Calibrate == ECalibrateMode.Calibrate;
			if (!Owner.IsGrounded)
			{
				if (_wasGrounded)
				{
					_ungroundLocalIKCache = ToRootLocalSpace(_PreviousFinalIKPos);
					_wasGrounded = false;
				}
				_SourceIKPos = RootSpaceToWorld(_ungroundLocalIKCache);
				_SourceIKPos = Vector3.Lerp(_SourceIKPos, IKProcessor.EndIKBone.transform.position, 1f - Owner.IsGroundedBlend);
				_ungroundLocalIKCache = ToRootLocalSpace(_SourceIKPos);
				_SourceIKRot = BoneEnd.rotation;
				_SourceIKPosUnchangedY = _SourceIKPos;
				_FinalIKPos = _SourceIKPos;
				_FinalIKRot = _SourceIKRot;
			}
			else
			{
				_wasGrounded = true;
				if (!_overwrittenSourceIKPos)
				{
					_SourceIKPos = IKProcessor.EndIKBone.transform.position;
				}
				else
				{
					_overwrittenSourceIKPos = false;
				}
				_SourceIKRot = BoneEnd.rotation;
				_SourceIKPosUnchangedY = _SourceIKPos;
				_FinalIKPos = _SourceIKPos;
				_FinalIKRot = _SourceIKRot;
			}
		}

		public void IK_PostUpdate()
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_0115: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0126: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
			if (customOverwritingIKPos)
			{
				_FinalIKPos = customOverwritePos;
				if (customOverwritingIKRot)
				{
					IKProcessor.FootRotationWeight = 1f;
					_FinalIKRot = customOverwriteRot;
				}
				else
				{
					IKProcessor.FootRotationWeight = 0f;
				}
			}
			else if (G_LegAnimation.LegAdjustementFootAngleOffset != 0f || FootPitchOffset != 0f)
			{
				_FinalIKRot = Quaternion.AngleAxis(G_LegAnimation.LegAdjustementFootAngleOffset + FootPitchOffset, _SourceIKRot * AnkleIK.right) * _FinalIKRot;
			}
			if (float.IsNaN(_FinalIKPos.x) || float.IsNaN(_FinalIKPos.y) || float.IsNaN(_FinalIKPos.z))
			{
				Reset();
				_FinalIKPos = RootSpaceToWorld(InitialPosInRootSpace);
				Gluing_Init();
			}
			_PreviousFinalIKPosForStability = _FinalIKPos;
			IKProcessor.IKTargetPosition = _FinalIKPos;
			IKProcessor.IKTargetRotation = _FinalIKRot;
			if (IKProcessor.IKWeight > 0f)
			{
				if (!Owner.UseCustomIK && LegStretchLimit < 1.1f)
				{
					IKProcessor.ApplyMaxStretchingPreprocessing(LegStretchLimit, 3f);
				}
				ExtraIKPostProcessingApply();
				if (!Owner.UseCustomIK)
				{
					IKProcessor.Update();
				}
			}
			_PreviousFinalIKPos = IKProcessor.IKTargetPosition;
			_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_PreviousFinalIKPos);
			if (Owner.AnimateFeet)
			{
				_PreviousFinalIKRot = IKProcessor.IKTargetRotation;
			}
		}

		public void IK_UpdateParamsBase()
		{
			IKProcessor.IKWeight = Owner._MainBlend * LegBlendWeight * InternalModuleBlendWeight;
			BlendWeight = IKProcessor.IKWeight;
			IKProcessor.InverseHint = InverseHint;
		}

		public void IK_UpdateParams()
		{
			IK_UpdateParamsBase();
			IKProcessor.AutoHintMode = Owner.IKHintMode;
			IKProcessor.FeetStretchSensitivity = 0.7f + 0.6f * FeetSensitivity;
			IKProcessor.FeetFadeQuicker = 0.95f + 0.35f * FeetSensitivity;
			IKProcessor.FeetStretchLimit = 0.8f + 0.2f * FeetSensitivity;
			IKProcessor.disableFeet = !UseFeet;
		}

		public void RandomizeIndividualSettings(float from, float to)
		{
			GlueThresholdMultiplier = Random.Range(Mathf.Lerp(from, to, 0.4f), to);
			LegMoveSpeedMultiplier = Random.Range(from, to);
			LegRaiseMultiplier = Random.Range(from, to);
		}

		public void OverrideAnimatorAnklePosition(Vector3 targetPos)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			_overwrittenSourceIKPos = true;
			_AnimatorEndBonePos = targetPos + (Owner._LastAppliedHipsFinalPosition - ParentHub.LastKeyframePosition);
			_SourceIKPos = _AnimatorEndBonePos;
		}

		public void User_OverrideRaycastHit(Transform tr, bool disableSourceRaycast = true)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			if (!_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 0f;
				_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
			}
			_disableSourceRaycast = disableSourceRaycast;
			_UsingCustomRaycast = true;
			RaycastHit hit = default(RaycastHit);
			((RaycastHit)(ref hit)).point = tr.position;
			((RaycastHit)(ref hit)).normal = tr.up;
			_CustomRaycastOnBlendIn(hit);
		}

		public void User_OverrideRaycastHit(RaycastHit hit, bool disableSourceRaycast = true)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			if (!_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 0f;
				_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
			}
			_disableSourceRaycast = disableSourceRaycast;
			_UsingCustomRaycast = true;
			_CustomRaycastOnBlendIn(hit);
		}

		public void User_RestoreRaycasting()
		{
			if (_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 1f;
			}
			_UsingCustomRaycast = false;
			_disableSourceRaycast = false;
		}

		private void _CustomRaycastOnBlendIn(RaycastHit hit)
		{
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			_CustomRaycastBlendIn += Owner.DeltaTime * 6f;
			if (_CustomRaycastBlendIn > 1f)
			{
				_CustomRaycastBlendIn = 1f;
			}
			((RaycastHit)(ref hit)).point = Vector3.LerpUnclamped(_PreviousCustomRaycastingStartIKPos, ((RaycastHit)(ref hit)).point, _CustomRaycastBlendIn);
			_CustomRaycastHit = hit;
			_PreviousCustomRaycastingIKPos = ((RaycastHit)(ref hit)).point;
		}

		private void _CustomRaycastOnBlendOut()
		{
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			if (!_UsingCustomRaycast && !(_CustomRaycastBlendIn <= 0f))
			{
				_CustomRaycastBlendIn -= Owner.DeltaTime * 8f;
				if (_CustomRaycastBlendIn < 0f)
				{
					_CustomRaycastBlendIn = 0f;
				}
				if (!RaycastHitted)
				{
					legGroundHit = _CustomRaycastHit;
					return;
				}
				RaycastHit val = legGroundHit;
				((RaycastHit)(ref val)).point = Vector3.LerpUnclamped(((RaycastHit)(ref val)).point, _PreviousCustomRaycastingIKPos, _CustomRaycastBlendIn);
				((RaycastHit)(ref val)).normal = Vector3.SlerpUnclamped(((RaycastHit)(ref val)).normal, ((RaycastHit)(ref _CustomRaycastHit)).normal, _CustomRaycastBlendIn);
				legGroundHit = val;
			}
		}

		private void Raycasting_Init()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			ankleAlignedOnGroundHitWorldPos = BoneEnd.position;
			raycastSlopeAngle = 0f;
		}

		public void OverrideControlPositionsWithCurrentIKState()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			AnkleH.LastKeyframeRootPos = ToRootLocalSpace(_FinalIKPos);
			_AnimatorEndBonePos = _FinalIKPos;
		}

		public void OverrideSourceIKPos()
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			OverrideSourceIKPos(_FinalIKPos);
		}

		public void OverrideSourceIKPos(Vector3 newSrc)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_SourceIKPos = newSrc;
		}

		public void Raycasting_PreLateUpdate()
		{
			//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0112: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0143: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0160: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			//IL_017d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0182: Unknown result type (might be due to invalid IL or missing references)
			RaycastHitted = false;
			_noRaycast_skipFeetCalcs = false;
			if (!_disableSourceRaycast)
			{
				if (Owner.RaycastStyle == ERaycastStyle.NoRaycasting)
				{
					GenerateZeroFloorRaycastHit();
					CustomRaycastValidate();
					_noRaycast_skipFeetCalcs = true;
					_UsingEmptyRaycast = true;
					ankleAlignedOnGroundHitRotation = _SourceIKRot;
				}
				else
				{
					_UsingEmptyRaycast = false;
					if (Owner.RaycastStyle == ERaycastStyle.StraightDown)
					{
						Raycast_StraightDown();
					}
					else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot)
					{
						Raycast_OriginToFoot();
					}
					else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot_DownOnNeed)
					{
						Raycast_OriginToFoot();
						if (!RaycastHitted)
						{
							Raycast_StraightDown();
						}
					}
					else if (Owner.RaycastStyle == ERaycastStyle.AlongBones)
					{
						Raycast_AlongBones();
						if (!RaycastHitted)
						{
							Raycast_StraightDown();
						}
					}
					if (!RaycastHitted)
					{
						NoRaycastBehaviour();
					}
				}
				User_RaycastHittedSource = RaycastHitted;
				_CustomRaycastOnBlendOut();
			}
			if (_UsingCustomRaycast)
			{
				RaycastHitted = true;
				legGroundHit = _CustomRaycastHit;
				groundHitRootSpacePos = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
				_UsingEmptyRaycast = true;
				_noRaycast_skipFeetCalcs = true;
				_Raycasting_CalculateBasis();
				ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal);
			}
			if (!_noRaycast_skipFeetCalcs)
			{
				if (RaycastHitted)
				{
					lastGroundHitWithTarget = legGroundHit;
					ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal);
				}
				else
				{
					ankleAlignedOnGroundHitRotation = _SourceIKRot;
				}
			}
		}

		private void NoRaycastBehaviour()
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.Detach)
			{
				return;
			}
			if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.ZeroFloorSteps)
			{
				_noRaycast_skipFeetCalcs = true;
				_UsingEmptyRaycast = true;
				GenerateZeroFloorRaycastHit();
				ankleAlignedOnGroundHitRotation = _SourceIKRot;
			}
			else if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.KeepAttached)
			{
				if (IKProcessor.GetStretchValue(_PreviousFinalIKPos) > Owner.NoRaycast_KeepAttachedUntilStretch)
				{
					lastGroundHitWithTarget = default(RaycastHit);
				}
				else if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastGroundHitWithTarget)).transform))
				{
					_noRaycast_skipFeetCalcs = true;
					legGroundHit = lastGroundHitWithTarget;
					RaycastHitted = true;
					_Raycasting_CalculateBasis();
					Vector3 val = ToRootLocalSpace(((RaycastHit)(ref lastGroundHitWithTarget)).point);
					val.y = 0f;
					groundHitRootSpacePos = val;
				}
			}
		}

		private void GenerateZeroFloorRaycastHit()
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			RaycastHit val = default(RaycastHit);
			Vector3 rootLocal = (ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(_SourceIKPos));
			rootLocal.y = 0f;
			Vector3 point = RootSpaceToWorld(rootLocal);
			((RaycastHit)(ref val)).point = point;
			((RaycastHit)(ref val)).normal = Owner.Up;
			legGroundHit = val;
			RaycastHitted = true;
			groundHitRootSpacePos = rootLocal;
		}

		private void CustomRaycastValidate()
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			_Raycasting_CalculateBasis();
			raycastSlopeAngle = 0f;
			A_WasAligning = true;
			A_WasAligningFrameBack = true;
			A_LastTargetAlignRot = _SourceIKRot;
			A_LastApppliedAlignRot = _SourceIKRot;
			A_PreviousRelevantAnklePos = _SourceIKPos;
			A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
			A_LastAlignHeightCompareValue = ScaleRef * 0.002f + ParentHub._Hips_StepHeightAdjustOffset;
		}

		private Vector3 Raycast_RefreshOrigin()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
			return lastRaycastingOrigin = RootSpaceToWorld(lastRootLocalPos);
		}

		private void Raycast_OriginToFoot()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Raycast_RefreshOrigin();
			Vector3 val2 = RootSpaceToWorld(AnkleH.LastKeyframeRootPos) - Owner.Up * C_AnkleToHeelWorldHeight - val;
			float num = ((Vector3)(ref val2)).magnitude * 1.05f;
			((Vector3)(ref val2)).Normalize();
			Vector3 val3 = val + val2 * num;
			if (Physics.Linecast(val, val3, ref legGroundHit, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		private void Raycast_AlongBones()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			Raycast_RefreshOrigin();
			if (DoRaycasting(_AnimatorStartBonePos, _AnimatorMidBonePos))
			{
				CaptureRaycastHitForLeg();
				return;
			}
			Vector3 rayEnd = _AnimatorEndBonePos + (_AnimatorEndBonePos - _AnimatorMidBonePos) * 0.1f;
			if (DoRaycasting(_AnimatorMidBonePos, rayEnd))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		private void Raycast_StraightDown()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00da: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			Vector3 lastKeyframeRootPos = AnkleH.LastKeyframeRootPos;
			Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
			float num;
			if (Owner.RaycastStartHeight == ERaycastStartHeight.FirstBone)
			{
				lastRootLocalPos = BoneStart.position;
				num = IKProcessor.fullLength;
			}
			else
			{
				lastRootLocalPos.x = lastKeyframeRootPos.x;
				lastRootLocalPos.z = lastKeyframeRootPos.z;
				num = Owner.ScaleReference * (Owner.RaycastStartHeightMul / Root.lossyScale.y);
				if (Owner.RaycastStartHeight == ERaycastStartHeight.StaticScaleReference)
				{
					lastRootLocalPos.y = num;
				}
				lastRootLocalPos = RootSpaceToWorld(lastRootLocalPos);
			}
			lastRaycastingOrigin = lastRootLocalPos;
			Vector3 val = -Owner.Up;
			Vector3 val2 = lastRootLocalPos + val * num;
			float num2 = ScaleRef * Owner.CastDistance;
			Vector3 rayEnd = (lastRaycastingEndPoint = val2 + val * num2);
			if (DoRaycasting(lastRootLocalPos, rayEnd))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		internal bool DoRaycasting(Vector3 origin, Vector3 rayEnd)
		{
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			bool flag;
			if (Owner.RaycastShape == ERaycastMode.Linecast)
			{
				flag = Physics.Linecast(origin, rayEnd, ref legGroundHit, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger);
			}
			else
			{
				float num = Owner.ScaleReference * 0.065f * Owner.SpherecastResize;
				Vector3 val = rayEnd - origin;
				float num2 = ((Vector3)(ref val)).magnitude - num;
				flag = Physics.SphereCast(origin, num, ((Vector3)(ref val)).normalized, ref legGroundHit, num2 - num, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger);
				if (flag && Owner.SpherecastRealign > 0f)
				{
					Vector3 val2 = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
					val2.x = Mathf.LerpUnclamped(val2.x, AnkleH.LastKeyframeRootPos.x, Owner.SpherecastRealign);
					val2.z = Mathf.LerpUnclamped(val2.z, AnkleH.LastKeyframeRootPos.z, Owner.SpherecastRealign);
					((RaycastHit)(ref legGroundHit)).point = RootSpaceToWorld(val2);
				}
			}
			return flag;
		}

		private void CaptureRaycastHitForLeg()
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			RaycastHitted = true;
			groundHitRootSpacePos = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
			raycastSlopeAngle = Vector3.Angle(Owner.Up, ((RaycastHit)(ref legGroundHit)).normal);
			if (raycastSlopeAngle > 45f)
			{
				RaycastHit val = legGroundHit;
				((RaycastHit)(ref val)).normal = Vector3.Slerp(((RaycastHit)(ref legGroundHit)).normal, Owner.Up, Mathf.InverseLerp(45f, 90f, raycastSlopeAngle) * 0.5f);
				legGroundHit = val;
			}
			_Raycasting_CalculateBasis();
		}

		private void _Raycasting_CalculateBasis()
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			previousAnkleAlignedOnGroundHitWorldPos = ankleAlignedOnGroundHitWorldPos;
			ankleAlignedOnGroundHitWorldPos = GetAlignedOnGroundHitPos(groundHitRootSpacePos, ((RaycastHit)(ref legGroundHit)).point, ((RaycastHit)(ref legGroundHit)).normal);
			ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
		}

		private Vector3 GetAlignedOnGroundHitPos(Vector3 rootSpaceHitPos, Vector3 worldHit, Vector3 normal)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			Vector3 rootLocal = rootSpaceHitPos;
			rootLocal.y = ToRootLocalSpace(worldHit + normal * C_AnkleToHeelWorldHeight).y;
			return RootSpaceToWorld(rootLocal);
		}

		private Quaternion GetAlignedOnGroundHitRot(Quaternion sourceRotation, Vector3 normal)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			return Quaternion.FromToRotation(sourceRotation * AnkleIK.up, normal) * sourceRotation;
		}

		private void Stability_Init()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			Vector3 initialPosInRootSpace = ToRootLocalSpace(BoneEnd.position);
			InitialPosInRootSpace = initialPosInRootSpace;
		}

		public void DefineLegSide(LegsAnimator get, Leg knownOppositeLeg = null)
		{
			if (knownOppositeLeg != null && knownOppositeLeg.Side != 0)
			{
				if (knownOppositeLeg.Side == ELegSide.Left)
				{
					Side = ELegSide.Right;
				}
				else
				{
					Side = ELegSide.Left;
				}
			}
			else if ((Object)(object)BoneStart != (Object)null)
			{
				if (get.Util_OnLeftSide(BoneStart))
				{
					Side = ELegSide.Left;
				}
				else
				{
					Side = ELegSide.Right;
				}
			}
		}

		public void AssignOppositeLegIndex(int oppositeIndex)
		{
			if (oppositeIndex != OppositeLegIndex)
			{
				if (Object.op_Implicit((Object)(object)Owner) && Owner.Legs.ContainsIndex(oppositeIndex, falseIfNull: true))
				{
					Owner.Legs[oppositeIndex].OppositeLegIndex = Owner.Leg_GetIndex(this);
				}
				OppositeLegIndex = oppositeIndex;
			}
		}

		public Leg GetOppositeLegReference(LegsAnimator legs)
		{
			if (OppositeLegIndex < 0)
			{
				return null;
			}
			if (!legs.Legs.ContainsIndex(OppositeLegIndex, falseIfNull: true))
			{
				return null;
			}
			return legs.Legs[OppositeLegIndex];
		}

		public void RefreshLegAnkleToHeelAndFeetAndAxes(Transform baseT)
		{
			RefreshLegAnkleToHeelAndFeet(baseT);
			RefreshLegAnkleAxes(baseT);
		}

		public void RefreshLegAnkleToHeelAndFeet(Transform baseT)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)BoneEnd == (Object)null))
			{
				Vector3 position = BoneEnd.position;
				position.y = baseT.position.y;
				AnkleToHeel = BoneEnd.InverseTransformPoint(position);
				AnkleToFeetEnd = BoneEnd.InverseTransformPoint(position + baseT.forward * ScaleRef * 0.15f);
			}
		}

		public void RefreshLegAnkleAxes(Transform baseT)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)BoneEnd))
			{
				Quaternion val = baseT.rotation * Quaternion.Euler(0f, AnkleYawCorrection, 0f);
				AnkleForward = BoneEnd.InverseTransformDirection(val * Vector3.forward);
				AnkleUp = BoneEnd.InverseTransformDirection(val * Vector3.up);
				AnkleRight = BoneEnd.InverseTransformDirection(val * Vector3.right);
			}
		}

		private void EnsureAxesNormalization()
		{
			((Vector3)(ref AnkleRight)).Normalize();
			((Vector3)(ref AnkleUp)).Normalize();
			((Vector3)(ref AnkleForward)).Normalize();
		}
	}

	public enum ELegSide
	{
		Undefined,
		Left,
		Right
	}

	[Serializable]
	public class LegStepAnimatingParameters
	{
		[Tooltip("Average duration of the automatic leg animation")]
		[Range(0.1f, 1f)]
		public float StepMoveDuration = 0.375f;

		[Tooltip("Curve of ik point going towards desired position (just XZ movement, to Y - no leg rise curve)")]
		[FPD_FixedCurveWindow(0f, 0f, 1f, 1.25f, 0.4f, 0.5f, 1f, 1f)]
		public AnimationCurve MoveToGoalCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

		[Tooltip("Making foot motion move towards target not in full linear straight towards target motion but adding a bit curve back (positive value) or forward (negative values) making movement a bit more natural")]
		[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0.4f, 0.6f, 0.9f, 1f)]
		public AnimationCurve SpherizeTrack = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);

		[Range(0f, 2f)]
		public float SpherizePower = 0.3f;

		[Range(0f, 1f)]
		[Tooltip("Minimum leg raise height. If distance of target step animation is small, then foot raise is smaller - down to this minimum raise value.")]
		public float MinFootRaise = 0.1f;

		[Tooltip("Maximum leg raise height. If distance of target step animation is very big, then foot raise is bigger - up to this maximum raise value.")]
		[Range(0f, 1f)]
		public float MaxFootRaise = 0.4f;

		[Tooltip("Raise height step animation curve evaluated on step animation duration.")]
		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.5f, 1f, 0.5f, 1f)]
		public AnimationCurve RaiseYAxisCurve;

		[Space(3f)]
		[Tooltip("Allowing to speed up leg adjusting animation when leg is getting stretched, when opposite leg is requesting adjustement or when main character is rotating in place quickly")]
		[Range(0f, 1f)]
		public float AllowSpeedups = 0.4f;

		[Tooltip("You can allow to use opposite leg before idle glue leg adjustement finishes")]
		[Range(0.1f, 1f)]
		public float AllowDetachBefore = 1f;

		[Tooltip("Extra hips push power animation curve evaluated on step animation duration.")]
		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 1f, 0.6f, 0.6f, 1f)]
		public AnimationCurve PushHipsOnMoveCurve;

		[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0f, 1f, 1f, 1f)]
		[Tooltip("Extra foot ankle rotation animation curve evaluated on step animation duration.")]
		public AnimationCurve FootRotationCurve;

		public void RefreshDefaultCurves()
		{
			Curves_RefreshMoveToGoalCurve();
			Curves_RefreshRaiseYAxisCurve();
			Curves_RefreshSpherizeTrack();
			Curves_RefreshFootRotationCurve();
			Curves_RefreshPushHipsOnMoveCurve();
		}

		public void Curves_RefreshRaiseYAxisCurve()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			RaiseYAxisCurve = new AnimationCurve();
			RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.505118f, 0.5f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.9110107f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
		}

		public void Curves_RefreshRaiseYAxisCurveSpiderPreset()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			RaiseYAxisCurve = new AnimationCurve();
			RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.5943514f, 0.7946472f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
			RaiseYAxisCurve.AddKey(new Keyframe(1f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
		}

		public void Curves_RefreshMoveToGoalCurve()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			MoveToGoalCurve = new AnimationCurve();
			MoveToGoalCurve.AddKey(new Keyframe(0f, 0f, 0f, 0f, 0f, 0.1842105f));
			MoveToGoalCurve.AddKey(new Keyframe(0.4885197f, 0.8972011f, 1.38764f, 1.38764f, 0.3333333f, 0.3333333f));
			MoveToGoalCurve.AddKey(new Keyframe(1f, 1f, 0f, 0f, 0f, 0f));
		}

		public void Curves_RefreshFootRotationCurve()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			FootRotationCurve = new AnimationCurve();
			FootRotationCurve.AddKey(new Keyframe(0f, 0f, 0.5764588f, 0.5764588f, 0f, 0.4956417f));
			FootRotationCurve.AddKey(new Keyframe(0.4378169f, 0.2035736f, -0.2411275f, -0.2411275f, 0.3333333f, 0.4033037f));
			FootRotationCurve.AddKey(new Keyframe(0.7841034f, -0.1339308f, 0.3331003f, 0.3331003f, 0.3333333f, 0.3333333f));
			FootRotationCurve.AddKey(new Keyframe(1f, 0f, 0.3498169f, 0.3498169f, 0.5534658f, 0f));
		}

		public void Curves_RefreshPushHipsOnMoveCurve()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			PushHipsOnMoveCurve = new AnimationCurve();
			PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.383f, 0.3733972f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.7075226f, 0.1460427f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
		}

		public void Curves_RefreshPushHipsOnMoveCurveSpiderPreset()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			PushHipsOnMoveCurve = new AnimationCurve();
			PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.320017f, 0.654645f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.6681702f, 0.2174691f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
		}

		public void Curves_RefreshSpherizeTrack()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Expected O, but got Unknown
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			SpherizeTrack = new AnimationCurve();
			SpherizeTrack.AddKey(new Keyframe(0f, 0f, 0.6958197f, 0.6958197f, 0f, 0.460011f));
			SpherizeTrack.AddKey(new Keyframe(0.4f, 0.3f, -0.04204308f, -0.04204308f, 0.333f, 0.3410656f));
			SpherizeTrack.AddKey(new Keyframe(0.85f, 0f, -0.2721428f, -0.2721428f, 0.3953607f, 0f));
		}

		public void LogCurve(string name, AnimationCurve c)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			string text = "";
			IFormatProvider invariantCulture = CultureInfo.InvariantCulture;
			for (int i = 0; i < c.keys.Length; i++)
			{
				Keyframe val = c.keys[i];
				text = text + "\n" + name + ".AddKey(new Keyframe(" + ((Keyframe)(ref val)).time.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).value.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inWeight.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outWeight.ToString(invariantCulture) + "f));";
			}
			Debug.Log((object)text);
		}
	}

	public enum EGlueMode
	{
		[Tooltip("Idle Mode is applying leg animation with extra motion and is checking some extra conditions like opposite leg grounded state etc.")]
		Idle,
		[Tooltip("Moving Mode is dedicated to be applied during playing animations with dynamic legs, it's checking less conditions than Idle Mode and is snapping glue points in a more straight forward slide animation.")]
		Moving,
		[Tooltip("Automatic mode is syncing with IsMoving/IsIdling LegsAnimator flags.")]
		Automatic
	}

	[Serializable]
	public class Variable
	{
		public enum EVariableType
		{
			Number,
			Bool,
			Vector2,
			Vector3,
			String,
			Curve,
			UnityObject,
			CustomObject
		}

		public string VariableName = "Variable";

		[SerializeField]
		private string Tooltip = "";

		private bool _tooltipWasSet;

		[SerializeField]
		private Vector4 _value = Vector4.zero;

		[SerializeField]
		private string _string = "";

		[SerializeField]
		private AnimationCurve _curve;

		[SerializeField]
		private Object _uObject;

		[SerializeField]
		private object _object;

		[NonSerialized]
		private int nameHash;

		public EVariableType VariableType;

		[SerializeField]
		private Vector4 _rangeHelper = Vector4.zero;

		public bool TooltipAssigned => _tooltipWasSet;

		public int GetNameHash
		{
			get
			{
				if (nameHash == 0)
				{
					nameHash = VariableName.GetHashCode();
				}
				return nameHash;
			}
		}

		public void AssignTooltip(string tooltip)
		{
			if (!_tooltipWasSet)
			{
				Tooltip = tooltip;
				_tooltipWasSet = true;
			}
		}

		public Variable(string name, object value)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			VariableName = name;
			SetValue(value);
		}

		public void SetValue(object o)
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			if (o is int)
			{
				_value = new Vector4((float)(int)o, 0f, 0f, 1f);
				VariableType = EVariableType.Number;
			}
			else if (o is float)
			{
				_value = new Vector4((float)o, 0f, 0f, 0f);
				VariableType = EVariableType.Number;
			}
			else if (o is bool)
			{
				if ((bool)o)
				{
					_value.x = 1f;
				}
				else
				{
					_value.x = 0f;
				}
				VariableType = EVariableType.Bool;
			}
			else if (o is Vector2 val)
			{
				_value = Vector4.op_Implicit(val);
				VariableType = EVariableType.Vector2;
			}
			else if (o is Vector3 val2)
			{
				_value = Vector4.op_Implicit(val2);
				VariableType = EVariableType.Vector3;
			}
			else if (o is string)
			{
				_string = o as string;
				VariableType = EVariableType.String;
			}
			else if (o is AnimationCurve)
			{
				_curve = (AnimationCurve)((o is AnimationCurve) ? o : null);
				VariableType = EVariableType.Curve;
			}
			else if (o is Object)
			{
				_uObject = (Object)((o is Object) ? o : null);
				VariableType = EVariableType.UnityObject;
			}
			else
			{
				_object = o;
				VariableType = EVariableType.CustomObject;
			}
		}

		public int GetInt()
		{
			return (int)_value.x;
		}

		public float GetFloat()
		{
			return _value.x;
		}

		public bool GetBool()
		{
			return _value.x == 1f;
		}

		public Vector2 GetVector2()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			return new Vector2(_value.x, _value.y);
		}

		public Vector3 GetVector3()
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3(_value.x, _value.y, _value.z);
		}

		public string GetString()
		{
			return _string;
		}

		public AnimationCurve GetCurve()
		{
			return _curve;
		}

		public Object GetUnityObject()
		{
			return _uObject;
		}

		public object GetObject()
		{
			return _object;
		}

		public void SetMinMaxSlider(float min, float max)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			_rangeHelper = new Vector4(min, max, 0f, 0f);
		}

		public void SetCurveFixedRange(float startTime, float startValue, float endTime, float endValue)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			_rangeHelper = new Vector4(startTime, startValue, endTime, endValue);
		}

		public bool Editor_DisplayVariableGUI()
		{
			return false;
		}
	}

	[Serializable]
	public class ReferencePose
	{
		[Serializable]
		public class LegPoseReference
		{
			public BonePoseReference UpperLegPose = new BonePoseReference();

			public BonePoseReference LowerLegPose = new BonePoseReference();

			public BonePoseReference AnklePose = new BonePoseReference();

			public BonePoseReference FeetPose = new BonePoseReference();

			public void SaveLegPose(Leg leg, LegsAnimator animator)
			{
				UpperLegPose.SavePose(leg.BoneStart, animator);
				LowerLegPose.SavePose(leg.BoneMid, animator);
				AnklePose.SavePose(leg.BoneEnd, animator);
				FeetPose.SavePose(leg.BoneFeet, animator);
			}

			public void RestoreLegPose(LegsAnimator animator)
			{
				UpperLegPose.RestorePose(animator);
				LowerLegPose.RestorePose(animator);
				AnklePose.RestorePose(animator);
				FeetPose.RestorePose(animator);
			}
		}

		[Serializable]
		public class BonePoseReference
		{
			public Transform SourceTransform;

			public Quaternion RotationInRoot;

			public Vector3 PositionInRoot;

			public void SavePose(Transform transform, LegsAnimator animator)
			{
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_0028: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0039: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				//IL_0049: Unknown result type (might be due to invalid IL or missing references)
				if (!((Object)(object)animator == (Object)null) && !((Object)(object)transform == (Object)null))
				{
					SourceTransform = transform;
					PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
					RotationInRoot = animator.BaseTransform.rotation.QToLocal(transform.rotation);
				}
			}

			public void RestorePose(LegsAnimator animator)
			{
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_004c: Unknown result type (might be due to invalid IL or missing references)
				if (!((Object)(object)animator == (Object)null) && !((Object)(object)SourceTransform == (Object)null))
				{
					SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
					SourceTransform.rotation = animator.BaseTransform.rotation.QToWorld(RotationInRoot);
				}
			}
		}

		public BonePoseReference MainHipsPose = new BonePoseReference();

		public List<BonePoseReference> HipsPoses = new List<BonePoseReference>();

		public List<LegPoseReference> LegPoses = new List<LegPoseReference>();

		public bool IsSet(LegsAnimator animator)
		{
			if ((Object)(object)MainHipsPose.SourceTransform != (Object)null && HipsPoses.Count == animator.ExtraHipsHubs.Count)
			{
				return LegPoses.Count == animator.Legs.Count;
			}
			return false;
		}

		public void TweakListsFor(LegsAnimator animator)
		{
			while (HipsPoses.Count > animator.ExtraHipsHubs.Count)
			{
				HipsPoses.RemoveAt(HipsPoses.Count - 1);
			}
			while (HipsPoses.Count < animator.ExtraHipsHubs.Count)
			{
				HipsPoses.Add(new BonePoseReference());
			}
			while (LegPoses.Count > animator.Legs.Count)
			{
				LegPoses.RemoveAt(LegPoses.Count - 1);
			}
			while (LegPoses.Count < animator.Legs.Count)
			{
				LegPoses.Add(new LegPoseReference());
			}
		}

		public void Clear()
		{
			MainHipsPose.SourceTransform = null;
			HipsPoses.Clear();
			LegPoses.Clear();
		}
	}

	public enum ELegsScaleReference
	{
		PelvisToGroundDistance,
		FirstLegLength,
		Custom,
		PelvisLegAverage
	}

	public enum ECalibrateMode
	{
		[Tooltip("No Extra overhead")]
		None,
		[Tooltip("Resetting bones local rotations to the initialized state")]
		Calibrate,
		[Tooltip("Resetting bones local rotations to the captured animator state (can fix trigger colliders detection when colliders added on legs)")]
		FixedCalibrate
	}

	public enum ERaycastPrecision
	{
		Linecast,
		BoxcastPrecision
	}

	public enum ERaycastStartHeight
	{
		[Tooltip("Casting ray starting from current hips height position of the character. Can be bad for insect creatures!")]
		Hips,
		[Tooltip("Good for spiders! Casting raycast on defined height of the character")]
		StaticScaleReference,
		[Tooltip("Casting ray starting from first bone of the leg (it's affecting height + start raycast position).")]
		FirstBone
	}

	public enum ERaycastStyle
	{
		[Tooltip("Launching raycast from foot above origin point. Good for bipeds with whole body step down/up features.")]
		StraightDown,
		[Tooltip("Launching raycast from pelvis towards foot, good for spider like creatures to detect steep ground more effectively. Body step down/up will not work as precise with this option.")]
		OriginToFoot,
		[Tooltip("Doing raycast like OriginToFoot : but if no ground is found - using another raycast in StraightDown style to find ground below and allow to execute body step down/up feature.")]
		OriginToFoot_DownOnNeed,
		[Tooltip("Doing raycasts per bone : from start bone towards mid bone, mid bone towards end bone, then down. Best precision for insect creatures.")]
		AlongBones,
		[Tooltip("No Raycasting : provide raycast hits custom using code, or leave it custom for just gluing legs animation.")]
		NoRaycasting
	}

	public enum ERaycastMode
	{
		Linecast,
		Spherecast
	}

	public enum ENoRaycastBehviour
	{
		[Tooltip("If ground raycast is lost, leg will detach and switch to ungrounded state")]
		Detach,
		[Tooltip("If no raycast hit detected, should character still animate leg steps in air on zero height floor level? (fake floor)")]
		ZeroFloorSteps,
		[Tooltip("If ground raycast is lost, leg will stick to lastest found raycast hit until leg get stretched")]
		KeepAttached
	}

	[Tooltip("Optional reference to unity's Animator. Legs Animator can use animator's variables to read state of your character movement, like IsGrounded or IsMoving + other extra helpers for custom modules and special calculations.")]
	public Animator Mecanim;

	[Tooltip("Animator parameter to read value for auto-define grounded state of the character (you can use LegAnimator.User_SetIsGrounded() through code instead)")]
	public string GroundedParameter = "";

	[Tooltip("Animator parameter (bool or float - Bool recommended for quicker Not-Moving reaction) to read value for auto-define movement state of the character (you can use LegAnimator.User_SetIsMoving() through code instead)")]
	public string MovingParameter = "";

	private int _hash_Grounded = -1;

	private int _hash_Moving = -1;

	private bool _hash_MovingIsFloat;

	[Range(0f, 0.5f)]
	[HideInInspector]
	public float User_IsMovingMecanim_NotMovingFloat_Threshold = 0.1f;

	private int _hash_Sliding = -1;

	[Tooltip("Optional Rigidbody which is used for few helper calculations. If rigidbody is assigned, then rigidbody velocity will drive 'Desired Move Direction' value (! only if .IsMoving is true !), unless you use 'User_SetDesiredMovementDirection'")]
	public Rigidbody Rigidbody;

	[Tooltip("Use rigidboy velocity state to automatically drive Leg Animator's helper 'IsMoving' flag")]
	public bool UseRigidbodyVelocityForIsMoving;

	[Tooltip("Use leg raycasts to automatically define Leg Animator's helper 'IsGrounded' flag")]
	public bool UseRaycastsForIsGrounded;

	[Tooltip("Animator parameter to read value for auto-define sliding state of the character - auto fading off gluing (you can use LegAnimator.User_SetIsSliding() through code instead)")]
	public string SlidingParameter = "";

	[Tooltip("Optional bone for modules if needed")]
	public Transform SpineBone;

	[Tooltip("Optional bone for modules if needed")]
	public Transform ChestBone;

	private CalibrateTransform _spineBoneCalibrate;

	private CalibrateTransform _ChestBoneCalibrate;

	[Tooltip("Animator parameter to read value for auto-define calculations state of the character. The ragdolled parameter is disabling legs, and other algorithms which can conflict with physical animations. (you can use LegAnimator.User_SetIsRagdolled() through code instead)")]
	public string RagdolledParameter = "";

	private int _hash_Ragdolled = -1;

	private bool _ragdolled;

	[NonSerialized]
	public float MinNonRagdolledForBlendOut;

	[Space(5f)]
	[Tooltip("Calculating leg swing velocity in order to prevent gluing foot when swinging forward during movement forward (during forward swing, foot sometimes is touching ground which can result in gluing foot too soon, especially with ground level increased)\nWhen this value is high, foot will detect gluing less oftem.")]
	[Range(0f, 1f)]
	public float SwingHelper;

	[Tooltip("Local height value for the glue algorithm. You can try adjusting it's value during character movement and idling, to detect glue more effectively.")]
	public float GluingFloorLevel = 0.05f;

	public bool GluingFloorLevelUseOnMoving;

	public float GluingFloorLevelOnMoving;

	private float _glueingFloorLevel;

	[Tooltip("If you want to push out legs out of each other if their IK points are overlapping in one placement")]
	[Space(5f)]
	public float StepPointsOverlapRadius;

	public bool UseStepPointsOverlapRadiusOnMoving;

	public float StepPointsOverlapRadiusOnMoving;

	public MotionInfluenceProcessor MotionInfluence = new MotionInfluenceProcessor();

	public UnityEvent Event_OnStep = new UnityEvent();

	[Range(0f, 0.3f)]
	[Tooltip("Increase to execute step event sooner (speed up step confirmation). Useful if step events are executed too late.")]
	public float EventExecuteSooner = 0.05f;

	[Tooltip("If you want to send step events also during movement idle (in case you already use animation clip events for it)")]
	public bool SendOnMovingGlue;

	[Tooltip("When false, it will not allow to send step event when character is stopped")]
	public bool SendOnStopping;

	[Tooltip("Enabling triggering step events when character just switched grounded state")]
	public bool StepEventOnLanding;

	[Tooltip("Game Object with attached component implementing LegsAnimator.ILegStepInfoReceiver interface to receiver detailed info about leg step")]
	[Space(5f)]
	public Transform StepInfoReceiver;

	private ILegStepReceiver _StepReceiver;

	private ILegRaiseReceiver _RaiseReceiver;

	[Tooltip("Additional pelvis position push in local space. Can be accesed for custom pelvis offset animation or for constant model pose correction.")]
	public Vector3 ExtraPelvisOffset = Vector3.zero;

	[Tooltip("Time which needs to elapse after character stop, to trigger legs repose to most relevant pose in comparison to played idle animation")]
	[FPD_Suffix(0f, 2f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	public float ReposeGluingAfter;

	[Tooltip("Enable if you want to use gluing only when character is idling. Useful when it's too much work needed to setup dynamic gluing during movement for your character. (it will still use feet ground align)")]
	public bool GlueOnlyOnIdle;

	[Tooltip("Raycasting down direction will be synced with base transform up axis when this feature is enabled.")]
	public bool LocalWorldUp = true;

	private float reposeGluingTimer;

	private bool reposedGluing;

	private Quaternion IK_UseIKRotatorQuat = Quaternion.identity;

	[Tooltip("Completely turning off all custom modules scripts execution.")]
	public bool DisableCustomModules;

	[Tooltip("Custom coded legs animator modules to change component behaviour without affecting core code")]
	public List<LegsAnimatorCustomModuleHelper> CustomModules = new List<LegsAnimatorCustomModuleHelper>();

	private bool UsingControlModules;

	[Tooltip("Power multiplier for pelvis push events")]
	public float ImpulsesPowerMultiplier = 1f;

	public float ImpulsesDurationMultiplier = 1f;

	[Tooltip("Damping impulses which are pushing body above ground level")]
	[Range(0f, 1f)]
	public float ImpulsesDampUpPushes;

	public PelvisImpulseSettings DebugPushHipsImpulse = new PelvisImpulseSettings(Vector3.down, 0.6f, 1f);

	protected List<ImpulseExecutor> Impulses = new List<ImpulseExecutor>();

	private bool _ImpulsesDoWorld;

	private bool _ImpulsesDoLocal;

	private bool _ImpulsesDoHips;

	private Vector3 _ImpulsesWorldPush = Vector3.zero;

	private Vector3 _ImpulsesWorldPushInherit = Vector3.zero;

	private Vector3 _ImpulsesLocalPush = Vector3.zero;

	private Vector3 _ImpulsesLocalPushInherit = Vector3.zero;

	private Vector3 _ImpulsesHipsRotation = Vector3.zero;

	private Vector3 _ImpulsesRotationElastic = Vector3.zero;

	private Vector3 _Hips_RotationElasticLocalOffset = Vector3.zero;

	[Tooltip("Use hips step adjustements and the stability algorithms")]
	public bool UseHips = true;

	[Tooltip("Whole body lift effect blend")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float HipsHeightStepBlend = 1f;

	[Tooltip("How fast body should adjust up/down")]
	[Range(0f, 1f)]
	public float HipsHeightStepSpeed = 0.7f;

	public EHipsAdjustStyle HipsAdjustStyle;

	[Tooltip("Adjusting hips to keep body balance pose")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float StabilizeCenterOfMass = 0.45f;

	[Range(0f, 1f)]
	[Tooltip("Blend stability pose reference from: initial pose to: current animator pose")]
	public float AnimationIsStablePose = 0.75f;

	[Range(0f, 1f)]
	[Tooltip("How fast body should adjust to the stability pose / to stretch preventer pose")]
	public float StabilizingSpeed = 0.375f;

	[Range(0f, 1f)]
	[Tooltip("Simulating body behaviour when doing leg steps")]
	public float PushHipsOnLegMove = 0.1f;

	[Tooltip("If your setup contains more than 2 legs it can be helpful to prevent overlapping pushes of multiple legs")]
	public bool NormalizePush;

	[Tooltip("Related with 'Push Hips On Leg Move' parameter above. How rapidly the pelvis push effect should be animated.")]
	[Range(0f, 1f)]
	public float PushReactionSpeed = 0.3f;

	[Tooltip("If Push in Y axis seems to be too strong, you can calm it down with this parameter")]
	[Range(0f, 2f)]
	public float PushYBlend = 1f;

	[Space(3f)]
	[Tooltip("Auto adjust hips to prevent leg stretching poses")]
	[Range(0f, 1f)]
	public float HipsStretchPreventer = 0.15f;

	public float StretchPreventerSpeed = 0.8f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Some of the stabilizing features may be not wanted when your character is running, you can blend them automatically to desired amount with this slider (you need to implement IsGrounded/IsMoving controls to give Legs Animator information about your character movement state)")]
	[Space(7f)]
	public float StabilizeOnIsMoving = 0.5f;

	private Vector3 _LastAppliedHipsStabilityOffset = Vector3.zero;

	internal Vector3 _LastAppliedHipsFinalPosition = Vector3.zero;

	internal Vector3 _LastAppliedHipsFinalOffset = Vector3.zero;

	internal Quaternion _LastAppliedHipsFinalRotationOffset = Quaternion.identity;

	internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

	public Vector3 _Hips_Modules_ExtraWOffset = Vector3.zero;

	public Vector3 _Hips_Modules_ExtraRotOffset = Vector3.zero;

	private bool _updateHipsAdjustements = true;

	[Tooltip("If this model is created out of multiple leg bones hubs, you can define it here")]
	public List<Transform> ExtraHipsHubs = new List<Transform>();

	[Tooltip("Enter on the selected option on the right to see description")]
	public EHipsHubsHandling HipsHubsHandling = EHipsHubsHandling.Detailed;

	[Range(0f, 1f)]
	public float HipsHubsBlend = 1f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 3f, 0f, 1f, 1f, 1f)]
	[Tooltip("If leg hub is having backbones to compensate target rotation, you can controll the spine bend style with this curve")]
	public AnimationCurve HubsBackBonesBlend = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	[Tooltip("Adding elasticity effect to the hub spine backbones adjustement animation")]
	[Range(0f, 1f)]
	public float HubBackBonesElasticity = 0.1f;

	private bool _hipsHubs_using;

	public HipsReference HipsSetup = new HipsReference();

	public EStabilityMode StabilityAlgorithm = EStabilityMode.Universal;

	private Vector3 _Hips_StabilityLocalOffset = Vector3.zero;

	private FMuscle_Eulers _Hips_RotationMuscle;

	private Vector3 _Hips_FinalStabilityOffset = Vector3.zero;

	public List<Leg> Legs = new List<Leg>();

	public LegStepAnimatingParameters BaseLegAnimating = new LegStepAnimatingParameters();

	[Tooltip("Using algorithm responsive for attaching feet to the ground when detected grounded foot in the played animation.")]
	public bool UseGluing = true;

	[Tooltip("You can smoothly change Glue Blend down to transition into sliding if your character is walking on ice or sliding on steep ground.")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float MainGlueBlend = 1f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float AdditionalGlueBlend = 1f;

	[Tooltip("If distance from the last attach point exceeds this distance (check scene gizmos) the leg will be detached.")]
	[Range(0f, 1f)]
	[Space(3f)]
	public float GlueRangeThreshold = 0.375f;

	[Range(0f, 1f)]
	[Tooltip("How quickly leg attachement transition should be proceeded.")]
	public float GlueFadeInSpeed = 0.85f;

	[Range(0f, 1f)]
	[Tooltip("If foot animation in original played clip is not reaching floor soon enough, increase it to attach for position slightly below current foot positioning.")]
	public float AllowGlueBelowFoot = 0.2f;

	[Range(0f, 1f)]
	[Tooltip("How quickly leg detachement transition should be proceeded.")]
	public float GlueFadeOutSpeed = 0.5f;

	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	[Tooltip("If leg rotation exceeds this angle during being attach, the leg will be detached.")]
	[Space(5f)]
	public float UnglueOn = 30f;

	[Space(1f)]
	[Range(0f, 1f)]
	[Tooltip("When leg glue target position is stretching leg too much it will shift leg target towards source animation leg position.")]
	public float AllowGlueDrag = 0.7f;

	[NonSerialized]
	public float DontGlueAttachIfTooNearOppositeLeg;

	[Tooltip("Enter on the value field on the right to see tooltip.")]
	public EGlueMode GlueMode = EGlueMode.Automatic;

	[Tooltip("Making Gluing animations only local space, which can be helpful when character is standing on the moving platform.")]
	public bool OnlyLocalAnimation;

	[Tooltip("Smoothing leg align motion when sudden uneven terrain step occurs")]
	[Range(0f, 1f)]
	public float SmoothSuddenSteps = 0.85f;

	[Space(3f)]
	[Tooltip("Making leg rise a bit over ground when character leg overlaps collision (it's mostly visible on steep slopes)")]
	[Range(0f, 2f)]
	public float LegElevateBlend = 0.7f;

	[Range(0f, 1f)]
	public float LegElevateHeightLimit = 0.6f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Overall foot rotation blend on the slope step align.")]
	[Space(6f)]
	public float FootRotationBlend = 1f;

	[Space(4f)]
	[Tooltip("How quickly foot should align it's rotation to the slopes")]
	[Range(0f, 1f)]
	public float FootAlignRapidity = 0.75f;

	[Tooltip("If it's human leg limb with foot, then turn it on for the foot bone animation and alignments. But if it's something like spider leg, then disable it")]
	public bool AnimateFeet = true;

	[Tooltip("If feet rotation is above this value, feet rotation will be limited to avoid weird foot rotation pose")]
	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "°", true, 0)]
	public float LimitFeetYaw = 30f;

	[Tooltip("Local space ANKLE-step height detection level. It's detail parameter to adjust feet aligning sooner/later when foot is near to ground.")]
	[Range(-0.05f, 0.15f)]
	public float AnimationFloorLevel = 0.001f;

	public static LegsAnimator _Editor_LastSelectedLA;

	private bool _wasInstantTriggered = true;

	[SerializeField]
	[HideInInspector]
	private ReferencePose setupPose = new ReferencePose();

	[HideInInspector]
	[SerializeField]
	public List<ReferencePose> ExtraSetupPoses = new List<ReferencePose>();

	private bool _grounded = true;

	private bool _moving;

	private bool _sliding;

	protected float NotSlidingBlend = 1f;

	private bool? _wasFadingOn;

	protected bool legsWasDisabled;

	[Tooltip("Algorithm selector which controls how leg is bent - knee hint.")]
	public FimpIK_Limb.FIK_HintMode IKHintMode;

	[Tooltip("Dragging Leg if stretched too much, for humanoids this vlaue should be high (around 0.9 - 1.1) for spider or similar creatures it should be lower.\nUsing feet bones can be really helpful to enchance the leg stretch length range!")]
	[Range(0.4f, 1.1f)]
	public float LimitLegStretch = 0.99f;

	[Tooltip("Pushing feet up/down if required for model correction.")]
	public float FeetYOffset;

	[Tooltip("Adjust the visual size of feet in order to make foot aligning calculations more precise.")]
	[Range(-1f, 1f)]
	public float FeetLengthAdjust;

	[SerializeField]
	[Tooltip("When not assigned, component will use this transform as 'Base Transform', but if your movement controller core is located in different transform, assign it here to be fully synchronized.")]
	private Transform baseTransform;

	[Tooltip("The anchor bone for all other limbs.\n! It needs to be parent of Leg Bones !")]
	public Transform Hips;

	private Vector3 InitialBaseScale = Vector3.one;

	[Tooltip("Define helper value for the algorithm, to define raycasting distance - scale for the algorithms to animate model in the correct way.\n\nCheck scene gizmos to adjust this value.")]
	public ELegsScaleReference ScaleReferenceMode = ELegsScaleReference.PelvisLegAverage;

	[SerializeField]
	private float finalScaleReference = 0.5f;

	[SerializeField]
	private float finalScaleReferenceSqrt = 0.1f;

	[SerializeField]
	private float customScaleReferenceValue = 0.5f;

	[Tooltip("Do component init after few frames of the game (can be useful when waiting for some of the components to be generated, or to initialize component not during T-pose)")]
	public bool DelayedInitialization;

	[Tooltip("Hard refresh bones on update: it's required when any of procedurally animated bones is not handled by keyframe animation.\nIf you're sure, your animations are always keyframe animated, you can disable this feature for small performance boost.")]
	public ECalibrateMode Calibrate = ECalibrateMode.Calibrate;

	[Tooltip("If your Unity Animator is using 'Animate Physics' update mode, you should enable this parameter.")]
	public bool AnimatePhysics;

	[Tooltip("If time.scale should or shouldn't affect legs animation")]
	public bool UnscaledDeltaTime;

	[Tooltip("Disable Legs Animator calculations when this renderer is not seen by any camera (including scene view camera!)")]
	public Renderer DisableIfInvisible;

	public List<Renderer> DisableIfInvisibleExtraRenderers = new List<Renderer>();

	[Tooltip("Smoothly fade out Legs Animator when far from the camera")]
	public float FadeOffAtDistance;

	[NonSerialized]
	public Transform FadeOff_DistanceToCamera;

	private Vector3 _worldUpAxisVector = Vector3.up;

	[Tooltip("Physics layer mask for leg raycasting. Which objects should be considered as steps.")]
	public LayerMask GroundMask = LayerMask.op_Implicit(1);

	public QueryTriggerInteraction RaycastHitTrigger = (QueryTriggerInteraction)1;

	[Range(0f, 2f)]
	[Tooltip("Maximum raycasting check range. Check Gizmos on the scene view")]
	public float CastDistance = 1f;

	public ERaycastStartHeight RaycastStartHeight;

	[Range(0.5f, 2.5f)]
	[Tooltip("Origin height point for raycasts. Check Gizmos on the scene view")]
	public float RaycastStartHeightMul = 1f;

	[Tooltip("How physical raycasting should be done. Enter on the selected style to see tooltip.")]
	public ERaycastStyle RaycastStyle;

	[Tooltip("Physics detection ray volume size. Sphere Cast can provide more smooth transitions on the edges but costs a bit more.")]
	public ERaycastMode RaycastShape;

	[Tooltip("Shift spherecast hit point result towards original XZ position instead of hit position. Can be helpful to prevent spider legs from being bent too much in narrow spaces.")]
	[Range(0f, 1f)]
	public float SpherecastRealign;

	[Tooltip("Shift spherecast hit point result towards original XZ position instead of hit position. Can be helpful to prevent spider legs from being bent too much in narrow spaces.")]
	public float SpherecastResize = 1f;

	[Tooltip("If foot will not find ground beneath, you can trigger different leg behavior in such scenario")]
	public ENoRaycastBehviour NoRaycastGroundBehaviour;

	[Tooltip("DEPRECATED - Used just for back compatibility - if true, switching NoRaycastGroundBehaviour to ZeroFloorSteps and changing this value to false.")]
	public bool ZeroStepsOnNoRaycast;

	public float NoRaycast_KeepAttachedUntilStretch = 1.1f;

	[Range(0f, 1f)]
	[Tooltip("How low whole body can be pulled down when one of the legs raycast hit is lower than default object position.")]
	public float BodyStepDown = 0.5f;

	[Range(0f, 1f)]
	[Tooltip("How high whole body can be pulled up when all legs raycast hits are higher than default object position. (rare case for special character controllers).\nIt can also help out extra spine hubs to adjust on higher steps (for quadrupeds).")]
	[Space(3f)]
	public float MaxBodyStepUp;

	[Space(3f)]
	[Tooltip("How fast should be applied fade-out when character starts being ungrounded. (jumping/falling)")]
	[Range(0f, 1f)]
	public float UngroundFadeSpeed = 0.1f;

	[Range(0f, 1f)]
	public float IsMovingFadeSpeed = 0.4f;

	private float _calc_rayGrounding;

	private float _calc_lastGrounded = -1f;

	private float _lastMainBlend = 1f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("Total blend of the plugin effects. When zero it disables most of the calculations (but not all)")]
	public float LegsAnimatorBlend = 1f;

	protected float cullingBlend = 1f;

	protected float protectedBlend = 1f;

	protected bool AllowUpdate;

	protected bool _started;

	private bool _fixedUpdated;

	public Vector3 DesiredMovementDirection { get; private set; }

	public bool usingCustomDesiredMovementDirection { get; private set; }

	public bool IsRagdolled => _ragdolled;

	public float RagdolledTime { get; private set; }

	public bool Helper_WasMoving { get; private set; }

	public float _stepPointsOverlapRadius { get; private set; }

	protected bool UseEvents { get; private set; }

	public bool JustGrounded { get; private set; }

	public Vector3 IK_CustomIKRotatorVector { get; private set; } = Vector3.zero;

	private float HipsBlendWeight => _MainBlend * HipsAdjustingBlend * HipsHeightStepBlend;

	public float HipsAdjustingBlend
	{
		get
		{
			if (!UseHips)
			{
				return 0f;
			}
			return 1f;
		}
	}

	public List<HipsReference> HipsHubs { get; private set; }

	public Vector3 _Get_Hips_StabilityLocalOffset => _Hips_StabilityLocalOffset;

	public Vector3 _Get_Hips_StabilityLocalAdjustement => HipsSetup._Get_Hips_StabilityLocalAdjustement;

	public LegStepAnimatingParameters LegAnimatingSettings => BaseLegAnimating;

	public float GlueBlend
	{
		get
		{
			if (!UseGluing)
			{
				return 0f;
			}
			return _MainBlend * MainGlueBlend * AdditionalGlueBlend;
		}
	}

	public EGlueMode _glueModeExecuted { get; set; }

	protected virtual bool UseCustomIK => false;

	public virtual string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Legs Animator/SPR_LegsCrop";
		}
	}

	public bool LegsInitialized { get; private set; }

	public ReferencePose SetupPose => setupPose;

	public bool IsGrounded => _grounded;

	public bool IsInAir => !_grounded;

	public float IsGroundedBlend { get; private set; }

	public float RagdolledDisablerBlend { get; protected set; } = 1f;

	public bool IsMoving => _moving;

	public bool IsIdling => !_moving;

	public float IsMovingBlend { get; private set; }

	public bool IsSliding => _sliding;

	public float IsSlidingBlend => 1f - NotSlidingBlend;

	public float DeltaTime { get; private set; }

	public float Scale { get; private set; }

	public Matrix4x4 CastMx { get; private set; }

	public Matrix4x4 InvCastMx { get; private set; }

	public float DynamicYScale => BaseTransform.lossyScale.y / InitialBaseScale.y;

	public float ScaleReference => finalScaleReference * BaseTransform.lossyScale.x;

	public float ScaleReferenceNoScale => finalScaleReference;

	public float ScaleReferenceSqrt => finalScaleReferenceSqrt;

	public float FadeOff_lastCameraDistance { get; protected set; }

	public Vector3 Up
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return _worldUpAxisVector;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_worldUpAxisVector = value;
		}
	}

	public float GroundedTime { get; private set; }

	public float InAirTime => 0f - GroundedTime;

	public float MovingTime { get; private set; }

	public float StoppedTime => 0f - MovingTime;

	public Transform BaseTransform => baseTransform;

	public float _MainBlend { get; protected set; }

	protected bool _lastMainBlendChanged { get; private set; }

	public float _MainBlendNoRagdolling { get; protected set; }

	public float _MainBlendPlusGrounded { get; protected set; }

	public void User_SetIsRagdolled(bool isRagdolled)
	{
		if (isRagdolled != _ragdolled)
		{
			if (_ragdolled)
			{
				OnLegsReactivate();
			}
			_ragdolled = isRagdolled;
		}
	}

	public void User_SetDesiredMovementDirection(Vector3 worldDirection)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		usingCustomDesiredMovementDirection = true;
		DesiredMovementDirection = worldDirection;
	}

	public void User_SetDesiredMovementDirection(Vector3 worldDirection, bool removeYspeed)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (removeYspeed)
		{
			worldDirection = ToRootLocalSpaceVec(worldDirection);
			worldDirection.y = 0f;
			worldDirection = RootToWorldSpaceVec(worldDirection);
		}
		User_SetDesiredMovementDirection(worldDirection);
	}

	public void User_SetDesiredMovementDirectionOff()
	{
		usingCustomDesiredMovementDirection = false;
	}

	public virtual void Controll_DefineHashes()
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Invalid comparison between Unknown and I4
		if ((Object)(object)Mecanim == (Object)null)
		{
			return;
		}
		if (!string.IsNullOrWhiteSpace(GroundedParameter))
		{
			_hash_Grounded = Animator.StringToHash(GroundedParameter);
		}
		else
		{
			_hash_Grounded = -1;
		}
		if (!string.IsNullOrWhiteSpace(MovingParameter))
		{
			_hash_Moving = Animator.StringToHash(MovingParameter);
			if ((Object)(object)Mecanim.runtimeAnimatorController != (Object)null)
			{
				for (int i = 0; i < Mecanim.parameterCount; i++)
				{
					if (Mecanim.GetParameter(i).nameHash == _hash_Moving && (int)Mecanim.GetParameter(i).type == 1)
					{
						_hash_MovingIsFloat = true;
						break;
					}
				}
			}
		}
		else
		{
			_hash_Moving = -1;
		}
		if (!string.IsNullOrWhiteSpace(SlidingParameter))
		{
			_hash_Sliding = Animator.StringToHash(SlidingParameter);
		}
		else
		{
			_hash_Sliding = -1;
		}
		if (!string.IsNullOrWhiteSpace(RagdolledParameter))
		{
			_hash_Ragdolled = Animator.StringToHash(RagdolledParameter);
		}
		else
		{
			_hash_Ragdolled = -1;
		}
	}

	protected virtual void Controll_Update()
	{
		if (_hash_Ragdolled != -1)
		{
			User_SetIsRagdolled(Mecanim.GetBool(_hash_Ragdolled));
		}
		if (IsRagdolled)
		{
			if (RagdolledTime < 0f)
			{
				RagdolledTime = 0f;
			}
			RagdolledTime += DeltaTime;
			RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 0f, DeltaTime * 6f);
			UpdateBeingRagdolled();
		}
		else
		{
			if (RagdolledTime > 0f)
			{
				RagdolledTime = 0f;
			}
			RagdolledTime -= DeltaTime;
			bool flag = false;
			if (MinNonRagdolledForBlendOut > 0f)
			{
				if (0f - RagdolledTime > MinNonRagdolledForBlendOut)
				{
					flag = true;
				}
			}
			else
			{
				flag = true;
			}
			if (flag)
			{
				float ragdolledDisablerBlend = RagdolledDisablerBlend;
				RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 1f, DeltaTime * 4f);
				if (ragdolledDisablerBlend != RagdolledDisablerBlend)
				{
					UpdateBeingRagdolled();
				}
			}
			else
			{
				RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 0f, DeltaTime * 6f);
			}
		}
		if (IsMoving || IsMovingBlend > 0.5f)
		{
			Helper_WasMoving = true;
		}
		else
		{
			Helper_WasMoving = false;
		}
		if (_hash_Grounded != -1)
		{
			User_SetIsGrounded(Mecanim.GetBool(_hash_Grounded));
		}
		if (_hash_Moving != -1)
		{
			if (_hash_MovingIsFloat)
			{
				User_SetIsMoving(Mecanim.GetFloat(_hash_Moving) > ScaleReference * User_IsMovingMecanim_NotMovingFloat_Threshold);
			}
			else
			{
				User_SetIsMoving(Mecanim.GetBool(_hash_Moving));
			}
		}
		if (_hash_Sliding != -1)
		{
			User_SetIsSliding(Mecanim.GetBool(_hash_Sliding));
		}
		if (GlueMode == EGlueMode.Automatic)
		{
			if (GroundedTime < 0.1f)
			{
				_glueModeExecuted = EGlueMode.Moving;
			}
			else if (IsMoving)
			{
				_glueModeExecuted = EGlueMode.Moving;
			}
			else
			{
				_glueModeExecuted = EGlueMode.Idle;
			}
		}
		else
		{
			_glueModeExecuted = GlueMode;
		}
		if (IsGrounded && GroundedTime < 0.2f)
		{
			_glueModeExecuted = EGlueMode.Moving;
		}
		if (IsGrounded)
		{
			if (GroundedTime < 0f)
			{
				GroundedTime = 0f;
			}
			GroundedTime += DeltaTime;
		}
		else
		{
			if (GroundedTime > 0f)
			{
				GroundedTime = 0f;
			}
			GroundedTime -= DeltaTime;
		}
		if (IsMoving)
		{
			if (MovingTime < 0f)
			{
				MovingTime = 0f;
			}
			MovingTime += DeltaTime;
		}
		else
		{
			if (MovingTime > 0f)
			{
				MovingTime = 0f;
			}
			MovingTime -= DeltaTime;
		}
		if (GluingFloorLevelUseOnMoving)
		{
			_glueingFloorLevel = Mathf.LerpUnclamped(GluingFloorLevel, GluingFloorLevelOnMoving, IsMovingBlend);
		}
		else
		{
			_glueingFloorLevel = GluingFloorLevel;
		}
		if (UseStepPointsOverlapRadiusOnMoving)
		{
			_stepPointsOverlapRadius = Mathf.LerpUnclamped(StepPointsOverlapRadius, StepPointsOverlapRadiusOnMoving, IsMovingBlend);
		}
		else
		{
			_stepPointsOverlapRadius = StepPointsOverlapRadius;
		}
	}

	private void BaseObject_MotionUpdate()
	{
		MotionInfluence.Update();
	}

	private void MotionInfluence_Init()
	{
		MotionInfluence.Init(BaseTransform);
	}

	protected virtual void Control_OnLand()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (!StepEventOnLanding)
		{
			return;
		}
		float num = float.MaxValue;
		Leg leg = null;
		for (int i = 0; i < Legs.Count; i++)
		{
			float y = ToRootLocalSpace(Legs[i]._PreviousFinalIKPos).y;
			if (y < num)
			{
				num = y;
				leg = Legs[i];
				Legs[i].StepEventSentInCustomWay();
			}
		}
		if (leg != null)
		{
			Events_OnStep(leg, 1f, EStepType.OnLanding);
		}
	}

	protected virtual void Control_OnLooseGround()
	{
	}

	protected virtual void Control_OnStopMoving()
	{
	}

	protected virtual void Control_OnStartMoving()
	{
	}

	private void RefreshTargetMovementDirectionHelper()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (usingCustomDesiredMovementDirection)
		{
			return;
		}
		if (!IsMoving)
		{
			DesiredMovementDirection = Vector3.zero;
		}
		else if (Object.op_Implicit((Object)(object)Rigidbody))
		{
			Vector3 velocity = Rigidbody.velocity;
			if (((Vector3)(ref velocity)).magnitude < ScaleReference * 0.1f)
			{
				DesiredMovementDirection = Vector3.zero;
				return;
			}
			velocity = Rigidbody.velocity;
			DesiredMovementDirection = ((Vector3)(ref velocity)).normalized;
		}
	}

	private void UpdateBeingRagdolled()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Leg_UpdateParams();
		}
	}

	private void Events_TriggerStepUnityEvent()
	{
		Event_OnStep.Invoke();
	}

	private void Events_OnStep(Leg leg, float stepFactor = 1f, EStepType type = EStepType.IdleGluing)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		if (StepEventOnLanding || !(IsGroundedBlend * RagdolledDisablerBlend < 0.99f))
		{
			Events_TriggerStepUnityEvent();
			if (_StepReceiver != null)
			{
				Vector3 position = leg._PreviousFinalIKPos + leg.BoneEnd.TransformVector((leg.AnkleToFeetEnd + leg.AnkleToHeel) * 0.5f);
				Quaternion rotation = Quaternion.LookRotation(leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.forward, leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.up);
				_StepReceiver.LegAnimatorStepEvent(leg, stepFactor, leg.Side == ELegSide.Right, position, rotation, type);
			}
		}
	}

	private void Events_OnRaise(Leg leg, float distanceToNewLegPosition = 1f, EStepType type = EStepType.IdleGluing)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if ((StepEventOnLanding || !(IsGroundedBlend * RagdolledDisablerBlend < 0.99f)) && _RaiseReceiver != null)
		{
			Vector3 position = leg._PreviousFinalIKPos + leg.BoneEnd.TransformVector((leg.AnkleToFeetEnd + leg.AnkleToHeel) * 0.5f);
			Quaternion rotation = Quaternion.LookRotation(leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.forward, leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.up);
			_RaiseReceiver.LegAnimatorRaiseEvent(leg, distanceToNewLegPosition, leg.Side == ELegSide.Right, position, rotation, type);
		}
	}

	private void ExtraControls_Update()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (IsGrounded && GroundedTime < 0.2f)
		{
			JustGrounded = true;
		}
		else
		{
			JustGrounded = false;
		}
		if (ReposeGluingAfter > 0f)
		{
			Vector3 rootOffset = MotionInfluence.rootOffset;
			if (((Vector3)(ref rootOffset)).magnitude > ScaleReference * 0.05f || IsMoving)
			{
				reposeGluingTimer = 0f;
				reposedGluing = false;
			}
			else
			{
				reposeGluingTimer += DeltaTime;
			}
			if (!reposedGluing && reposeGluingTimer > ReposeGluingAfter)
			{
				IK_TriggerReglue();
				reposedGluing = true;
			}
		}
	}

	public void DisableCustomIKRotatorVector()
	{
	}

	public void SetCustomIKRotatorVector(Vector3 localVector)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		IK_CustomIKRotatorVector = localVector;
	}

	private void InitializeModules()
	{
		bool usingControlModules = false;
		if (CustomModules == null)
		{
			return;
		}
		for (int num = CustomModules.Count - 1; num >= 0; num--)
		{
			if (CustomModules[num] == null)
			{
				CustomModules.RemoveAt(num);
			}
			else if ((Object)(object)CustomModules[num].ModuleReference == (Object)null)
			{
				CustomModules.RemoveAt(num);
			}
			else
			{
				CustomModules[num].PreparePlaymodeModule(this);
				usingControlModules = true;
			}
		}
		UsingControlModules = usingControlModules;
	}

	private void DisposeModules()
	{
		if (CustomModules == null)
		{
			return;
		}
		for (int num = CustomModules.Count - 1; num >= 0; num--)
		{
			if (CustomModules[num] == null)
			{
				CustomModules.RemoveAt(num);
			}
			else if ((Object)(object)CustomModules[num].ModuleReference == (Object)null)
			{
				CustomModules.RemoveAt(num);
			}
			else
			{
				CustomModules[num].DisposeModule();
			}
		}
	}

	public T GetModule<T>() where T : LegsAnimatorControlModuleBase
	{
		if (CustomModules == null)
		{
			return null;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].ModuleReference is T)
			{
				return CustomModules[i].PlaymodeModule as T;
			}
		}
		return null;
	}

	public LegsAnimatorCustomModuleHelper GetModuleHelper<T>() where T : LegsAnimatorControlModuleBase
	{
		if (CustomModules == null)
		{
			return null;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].ModuleReference is T)
			{
				return CustomModules[i];
			}
		}
		return null;
	}

	private void Modules_OnReInitialize()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnReInitialize(CustomModules[i]);
			}
		}
	}

	private void Modules_Update()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_UpdateAfterManualChanges()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnValidateAfterManualChanges(CustomModules[i]);
			}
		}
	}

	private void Modules_LegBeforeRaycastingUpdate(Leg leg)
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.Leg_LatePreRaycastingUpdate(CustomModules[i], leg);
			}
		}
	}

	private void Modules_AfterAnimatorCaptureUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnAfterAnimatorCaptureUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_PreLateUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnPreLateUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_LateUpdatePreApply()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnLateUpdatePreApply(CustomModules[i]);
			}
		}
	}

	private void Modules_PostLateUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnPostLateUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_Leg_LateUpdate(Leg leg)
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.Leg_LateUpdate(CustomModules[i], leg);
			}
		}
	}

	private void Hips_Calc_UpdateImpulses()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0424: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0436: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		_ImpulsesDoLocal = false;
		_ImpulsesDoWorld = false;
		_ImpulsesDoHips = false;
		if (Impulses.Count == 0)
		{
			return;
		}
		if ((double)ImpulsesDurationMultiplier < 0.001)
		{
			ImpulsesDurationMultiplier = 1f;
		}
		_ImpulsesWorldPush = Vector3.zero;
		_ImpulsesWorldPushInherit = Vector3.zero;
		_ImpulsesLocalPush = Vector3.zero;
		_ImpulsesLocalPushInherit = Vector3.zero;
		_ImpulsesHipsRotation = Vector3.zero;
		Vector3 val = DesiredMovementDirection;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		for (int i = 0; i < Impulses.Count; i++)
		{
			ImpulseExecutor value = Impulses[i];
			value.Update(DeltaTime / ImpulsesDurationMultiplier);
			if (value.WorldTranslation != Vector3.zero)
			{
				Vector3 val2 = value.CurrentWorldOffset * ImpulsesPowerMultiplier;
				if (value.Elastic <= 0f)
				{
					_ImpulsesWorldPush += val2;
				}
				else if (value.Elastic >= 1f)
				{
					_ImpulsesWorldPushInherit += val2;
				}
				else
				{
					_ImpulsesWorldPush += (1f - value.Elastic) * val2;
					_ImpulsesWorldPushInherit += value.Elastic * val2;
				}
			}
			if (value.LocalTranslation != Vector3.zero)
			{
				Vector3 val3 = value.CurrentLocalOffset * (ImpulsesPowerMultiplier * ScaleReferenceNoScale);
				val3.y *= value.CurrentLocalYAxisMultiplier;
				bool flag = true;
				if (value.AlignDesired && DesiredMovementDirection != Vector3.zero)
				{
					flag = false;
					Quaternion rotation = BaseTransform.rotation;
					val = BaseTransform.forward;
					val3 = rotation * Quaternion.FromToRotation(((Vector3)(ref val)).normalized, normalized) * val3;
					if (value.Elastic <= 0f)
					{
						_ImpulsesWorldPush += val3;
					}
					else if (value.Elastic >= 1f)
					{
						_ImpulsesWorldPushInherit += val3;
					}
					else
					{
						_ImpulsesWorldPush += (1f - value.Elastic) * val3;
						_ImpulsesWorldPushInherit += value.Elastic * val3;
					}
				}
				if (flag)
				{
					if (value.Elastic <= 0f)
					{
						_ImpulsesLocalPush += val3;
					}
					else if (value.Elastic >= 1f)
					{
						_ImpulsesLocalPushInherit += val3;
					}
					else
					{
						_ImpulsesLocalPush += (1f - value.Elastic) * val3;
						_ImpulsesLocalPushInherit += value.Elastic * val3;
					}
				}
			}
			if (value.HipsRotation != Vector3.zero)
			{
				Vector3 hipsRotation = value.HipsRotation;
				if (value.AlignDesired)
				{
					val = BaseTransform.forward;
					if (Vector3.Dot(((Vector3)(ref val)).normalized, normalized) < 0f)
					{
						hipsRotation.z = 0f - hipsRotation.z;
					}
				}
				_ImpulsesHipsRotation += hipsRotation * (ImpulsesPowerMultiplier * value.Evaluation * value.Power);
			}
			Impulses[i] = value;
		}
		for (int num = Impulses.Count - 1; num >= 0; num--)
		{
			if (Impulses[num].Finished)
			{
				Impulses.RemoveAt(num);
			}
		}
		if (_ImpulsesWorldPush != Vector3.zero || _ImpulsesWorldPushInherit != Vector3.zero)
		{
			_ImpulsesDoWorld = true;
		}
		if (_ImpulsesLocalPush != Vector3.zero || _ImpulsesLocalPushInherit != Vector3.zero)
		{
			_ImpulsesDoLocal = true;
		}
		if (_ImpulsesHipsRotation != Vector3.zero)
		{
			_ImpulsesDoHips = true;
		}
	}

	private void Hips_Calc_ApplyImpulsesInherit()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (_ImpulsesDoLocal)
		{
			_Hips_StabilityLocalOffset += _ImpulsesLocalPushInherit * _MainBlend;
		}
		if (_ImpulsesDoWorld)
		{
			_Hips_StabilityLocalOffset += ToRootLocalSpaceVec(_ImpulsesWorldPushInherit * _MainBlend);
		}
		if (_ImpulsesDoHips || _ImpulsesRotationElastic != Vector3.zero)
		{
			_Hips_RotationMuscle.Update(DeltaTime, _ImpulsesHipsRotation);
			_ImpulsesRotationElastic = _Hips_RotationMuscle.ProceduralEulerAngles;
			_Hips_Modules_ExtraRotOffset += _ImpulsesRotationElastic;
		}
	}

	private void Hips_Calc_ApplyImpulses()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (_ImpulsesDoLocal)
		{
			_LastAppliedHipsFinalPosition += RootToWorldSpaceVec(_ImpulsesLocalPush * _MainBlend);
		}
		if (_ImpulsesDoWorld)
		{
			_LastAppliedHipsFinalPosition += _ImpulsesWorldPush * _MainBlend;
		}
	}

	public float GetLandingBoost()
	{
		float result = HipsHeightStepSpeed;
		if (IsGrounded && GroundedTime < 0.2f)
		{
			result = Mathf.Max(HipsHeightStepSpeed, Mathf.LerpUnclamped(HipsHeightStepSpeed, 0.95f, 0.9f));
		}
		return result;
	}

	private void Hips_Calc_BodyAdjust()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		if (HipsHeightStepBlend <= 0f)
		{
			return;
		}
		float num = HipsSetup.CalculateBodyAdjust();
		Vector3 val = Vector3.zero;
		if (num != 0f && !float.IsNaN(num))
		{
			val = Up * num;
			Transform hips = Hips;
			hips.position += val;
		}
		if (!_hipsHubs_using || HipsHubsBlend < 0.0001f)
		{
			return;
		}
		for (int i = 0; i < HipsHubs.Count; i++)
		{
			HipsHubs[i]._PreHipsAdjustPosition = HipsHubs[i].bone.position;
			float num2 = HipsHubs[i].CalculateBodyAdjust();
			if (num2 != 0f && !float.IsNaN(num2))
			{
				Vector3 val2 = Up * num2;
				val2 -= val;
				Transform bone = HipsHubs[i].bone;
				bone.position += val2;
			}
		}
	}

	public void Hips_PreLateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			HipsSetup.Calibrate();
			HipsHubs_CaptureAnimation();
		}
	}

	public void Hips_LateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			Hips_Calc_BodyAdjust();
		}
	}

	public void Hips_PostLateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			Hips_Calc_Stabilize();
			Hips_Calc_UpdateImpulses();
			Hips_Calc_ApplyImpulsesInherit();
			Hips_Calc_Elasticity();
			Hips_Calc_Apply();
			Hips_Calc_ApplyImpulses();
			Hips_ApplyTransformations();
		}
	}

	protected virtual void Hips_ApplyTransformations()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		if (float.IsNaN(_LastAppliedHipsFinalPosition.x) || float.IsNaN(_LastAppliedHipsFinalPosition.y) || float.IsNaN(_LastAppliedHipsFinalPosition.z))
		{
			_LastAppliedHipsFinalPosition = RootToWorldSpace(HipsSetup.InitHipsPositionRootSpace);
			if (float.IsNaN(_LastAppliedHipsFinalPosition.x) || float.IsNaN(_LastAppliedHipsFinalPosition.y) || float.IsNaN(_LastAppliedHipsFinalPosition.z))
			{
				_LastAppliedHipsFinalPosition = Vector3.zero;
			}
		}
		if (_Hips_Modules_ExtraRotOffset != Vector3.zero)
		{
			float num = _MainBlend * ImpulsesPowerMultiplier;
			Vector3 hips_Modules_ExtraRotOffset = _Hips_Modules_ExtraRotOffset;
			Quaternion val = Quaternion.identity;
			if (hips_Modules_ExtraRotOffset.z != 0f)
			{
				val *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.z * num, BaseTransform.right);
			}
			if (hips_Modules_ExtraRotOffset.x != 0f)
			{
				val *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.x * num, BaseTransform.forward);
			}
			if (hips_Modules_ExtraRotOffset.y != 0f)
			{
				val *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.y * num, BaseTransform.up);
			}
			_LastAppliedHipsFinalRotationOffset = val;
			Quaternion val2 = val * Hips.rotation;
			Hips.SetPositionAndRotation(_LastAppliedHipsFinalPosition, val2);
		}
		else
		{
			Hips.position = _LastAppliedHipsFinalPosition;
		}
		_LastAppliedHipsFinalOffset = _LastAppliedHipsFinalPosition - HipsSetup.LastKeyframePosition;
		HipsHubs_ApplyTransformations();
		Hips_Finalize();
	}

	protected virtual void Hips_Finalize()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		_LastHipsRotationOffsetOutsideInfo = Quaternion.identity;
	}

	private void Hips_Calc_Apply()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		_LastAppliedHipsFinalOffset = Vector3.zero;
		_LastAppliedHipsFinalRotationOffset = Quaternion.identity;
		_LastAppliedHipsFinalPosition = Hips.position;
		_LastAppliedHipsStabilityOffset = _Hips_FinalStabilityOffset * _MainBlendPlusGrounded * HipsAdjustingBlend;
		_LastAppliedHipsFinalPosition += _LastAppliedHipsStabilityOffset;
		_LastAppliedHipsFinalPosition += _Hips_Modules_ExtraWOffset;
		_Hips_Modules_ExtraWOffset = Vector3.zero;
	}

	protected void Hips_PreCalibrate()
	{
		_updateHipsAdjustements = true;
		HipsSetup.PreCalibrate();
		if (Calibrate != 0 && (Object)(object)SpineBone != (Object)null)
		{
			if ((Object)(object)_spineBoneCalibrate.Transform == (Object)null)
			{
				_spineBoneCalibrate = new CalibrateTransform(SpineBone);
			}
			_spineBoneCalibrate.Calibrate();
			if ((Object)(object)ChestBone != (Object)null)
			{
				if ((Object)(object)_ChestBoneCalibrate.Transform == (Object)null)
				{
					_ChestBoneCalibrate = new CalibrateTransform(ChestBone);
				}
				_ChestBoneCalibrate.Calibrate();
			}
		}
		Hips_Calc_PreRefreshVariables();
		HipsHubs_PreCalibrate();
	}

	private void Hips_Calc_Elasticity()
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if (HipsSetup.HipsElasticityBlend > 0f)
		{
			Vector3 val = HipsSetup.HipsMuscle.Update(DeltaTime, _Hips_StabilityLocalOffset);
			if (val.y > 0f)
			{
				val.y *= 1f - ImpulsesDampUpPushes;
			}
			if (HipsSetup.HipsElasticityBlend < 1f)
			{
				_Hips_FinalStabilityOffset = Vector3.LerpUnclamped(_Hips_StabilityLocalOffset, val, HipsSetup.HipsElasticityBlend);
			}
			else
			{
				_Hips_FinalStabilityOffset = val;
			}
		}
		else
		{
			_Hips_FinalStabilityOffset = _Hips_StabilityLocalOffset;
		}
		_Hips_FinalStabilityOffset = RootToWorldSpaceVec(_Hips_FinalStabilityOffset);
	}

	private void HipsHubs_Init()
	{
		_hipsHubs_using = false;
		HipsHubs = new List<HipsReference>();
		for (int i = 0; i < ExtraHipsHubs.Count; i++)
		{
			if (!((Object)(object)ExtraHipsHubs[i] == (Object)null))
			{
				HipsReference hipsReference = new HipsReference();
				hipsReference.Initialize(this, ExtraHipsHubs[i], BaseTransform);
				hipsReference.CopyMuscleSettingsFrom(HipsSetup);
				HipsHubs.Add(hipsReference);
			}
		}
		if (ExtraHipsHubs.Count > 0)
		{
			_hipsHubs_using = true;
		}
		HipsSetup.PrepareLegs();
		for (int j = 0; j < HipsHubs.Count; j++)
		{
			HipsHubs[j].PrepareHubBones();
		}
	}

	private void HipsHubs_PreCalibrate()
	{
		if (_hipsHubs_using)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs[i].PreCalibrate();
			}
		}
	}

	private void HipsHubs_CaptureAnimation()
	{
		if (_hipsHubs_using)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs[i].Calibrate();
			}
		}
	}

	private void HipsHubs_ApplyTransformations()
	{
		if (!_hipsHubs_using)
		{
			return;
		}
		if (HipsHubsHandling == EHipsHubsHandling.FixDisconnected)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs_ApplyBasic(HipsHubs[i]);
			}
		}
		else
		{
			for (int j = 0; j < HipsHubs.Count; j++)
			{
				HipsHubs_ApplyDetailed(HipsHubs[j]);
			}
		}
	}

	private void HipsHubs_ApplyBasic(HipsReference hub)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		Transform bone = hub.bone;
		bone.position += _LastAppliedHipsFinalOffset * HipsHubsBlend;
		Quaternion val = _LastAppliedHipsFinalRotationOffset * _LastHipsRotationOffsetOutsideInfo * hub.bone.rotation;
		if (HipsHubsBlend > 0.999f)
		{
			hub.bone.rotation = val;
		}
		else
		{
			hub.bone.rotation = Quaternion.Lerp(hub.bone.rotation, val, HipsHubsBlend);
		}
	}

	private void HipsHubs_ApplyDetailed(HipsReference hub)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_032a: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0333: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f8: Unknown result type (might be due to invalid IL or missing references)
		if (HipsHubsBlend < 0.0001f)
		{
			return;
		}
		float num = HipsHubsBlend * _MainBlend * IsGroundedBlend;
		float num2 = Mathf.LerpUnclamped(1f, StabilizeOnIsMoving, IsMovingBlend);
		Vector3 zero = Vector3.zero;
		zero += hub.CalculateCenterOfMassStability(num2);
		Vector3 pushLocalOffset = hub.CalculateGlueMovePush() * PushHipsOnLegMove;
		pushLocalOffset = hub.SmoothPushOffset(pushLocalOffset, Mathf.LerpUnclamped(0.125f, 0.025f, PushReactionSpeed));
		zero += _MainBlendPlusGrounded * RootToWorldSpaceVec(pushLocalOffset);
		Vector3 val = hub.CalculateStretchPreventerOffset();
		zero += _MainBlendPlusGrounded * val * HipsStretchPreventer * num2;
		zero = hub.AnimateOffset(zero);
		hub.HipsMuscle.Update(DeltaTime, zero);
		zero = hub.HipsMuscle.ProceduralPosition;
		zero += hub.ExtraNonElasticOffset;
		hub.ExtraNonElasticOffset = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		if (HipsSetup._Hips_LastHipsOffset > 0f)
		{
			zero2.y -= HipsSetup._Hips_LastHipsOffset * 0.1f;
		}
		if (hub._Hips_LastHipsOffset < 0f)
		{
			zero2.y += hub._Hips_LastHipsOffset * 0.1f;
		}
		Vector3 val2 = hub.CalculateStretchReadjust();
		Vector3 val3 = RootToWorldSpaceVec(zero + zero2 + val2);
		Vector3 val4 = hub.bone.position + val3;
		hub.bone.localPosition = hub.LastKeyframeLocalPosition;
		Transform bone = hub.bone;
		bone.position += RootToWorldSpaceVec(zero2);
		Quaternion rotation = hub.bone.rotation;
		float num3 = 1f;
		if (num3 > 0f && hub.HubBackBones.Count > 0)
		{
			float num4 = (float)hub.HubBackBones.Count - 1f;
			if (num4 == 0f)
			{
				num4 = 1f;
			}
			float num5 = 0f;
			for (int num6 = hub.HubBackBones.Count - 1; num6 >= 0; num6--)
			{
				HipsReference.HipsHubBackbone hipsHubBackbone = hub.HubBackBones[num6];
				Vector3 val5 = hipsHubBackbone.frontBone.position - hipsHubBackbone.bone.position;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				val5 = val4 - hipsHubBackbone.bone.position;
				Vector3 val6 = ((Vector3)(ref val5)).normalized;
				float num7 = Vector3.Dot(normalized, val6);
				float num8 = 0f;
				if (num7 < 0.985f)
				{
					Vector3 val7 = ToRootLocalSpaceVec(normalized);
					Vector3 val8 = ToRootLocalSpaceVec(val6);
					val7.y = 0f;
					val8.y = 0f;
					float num9 = Vector3.Dot(((Vector3)(ref val7)).normalized, ((Vector3)(ref val8)).normalized);
					num8 = Mathf.InverseLerp(0.985f, 0.5f, num9);
					val6 = Vector3.Slerp(val6, normalized, num8);
				}
				val6 = hipsHubBackbone.AnimateTargetDirection(val6);
				Vector3 val9 = Vector3.LerpUnclamped(normalized, val6, num3 * num / num4 * HubsBackBonesBlend.Evaluate(num5 / num4) * (1f - num8));
				Quaternion val10 = Quaternion.FromToRotation(normalized, val9);
				hipsHubBackbone.bone.rotation = val10 * hipsHubBackbone.bone.rotation;
				num5 += 1f;
			}
		}
		Quaternion val11 = Quaternion.Inverse(hub._LastHipsRotationOffsetOutsideInfo);
		hub.bone.rotation = val11 * Quaternion.SlerpUnclamped(hub.bone.rotation, rotation, 0.75f * HipsHubsBlend);
		hub._LastHipsRotationOffsetOutsideInfo = Quaternion.identity;
	}

	private void Initialize_Stability()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_Hips_RotationMuscle = new FMuscle_Eulers();
		_Hips_RotationMuscle.Initialize(Vector3.zero);
	}

	private void Hips_Calc_PreRefreshVariables()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_Hips_StabilityLocalOffset = Vector3.zero;
		_Hips_Modules_ExtraRotOffset = Vector3.zero;
	}

	private void Hips_Calc_Stabilize()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		float mainBlendPlusGrounded = _MainBlendPlusGrounded;
		float num = Mathf.LerpUnclamped(1f, StabilizeOnIsMoving, IsMovingBlend);
		HipsSetup.CalculateCenterOfMassStability(num);
		float pushDuration = 0f;
		if (PushReactionSpeed < 1f)
		{
			pushDuration = Mathf.LerpUnclamped(0.125f, 0.025f, PushReactionSpeed);
		}
		Vector3 pushLocalOffset = HipsSetup.CalculateGlueMovePush();
		Vector3 val = HipsSetup.SmoothPushOffset(pushLocalOffset, pushDuration);
		if (HipsStretchPreventer > 0f)
		{
			Vector3 val2 = HipsSetup.CalculateStretchPreventerOffset();
			_Hips_StabilityLocalOffset += _MainBlendPlusGrounded * val2 * HipsStretchPreventer * num;
		}
		if (MotionInfluence.AdvancedInfluence || MotionInfluence.AxisMotionInfluence.x > 0f)
		{
			_Hips_StabilityLocalOffset += MotionInfluence.CalculateInversedInfluence();
		}
		_Hips_StabilityLocalOffset += _Get_Hips_StabilityLocalAdjustement;
		_Hips_StabilityLocalOffset += val * PushHipsOnLegMove;
		if (ExtraPelvisOffset != Vector3.zero && IsGroundedBlend > 0f)
		{
			Transform hips = Hips;
			hips.position += RootToWorldSpaceVec(ExtraPelvisOffset * mainBlendPlusGrounded);
		}
	}

	private void ValueTowards(ref Vector3 value, Vector3 target, ref Vector3 sd, float duration)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ValueTowards(ref value, target, ref sd, duration, DeltaTime);
	}

	private void ValueTowards(ref Vector3 value, Vector3 target, ref Vector3 sd, float duration, float delta)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (duration < 1f)
		{
			value = Vector3.SmoothDamp(value, target, ref sd, duration, 10000000f, delta);
		}
		else
		{
			value = target;
		}
	}

	public Leg Setup_TryAutoLegSetup(Leg scheme, Transform toSetup, bool apply = true)
	{
		if (scheme == null)
		{
			return null;
		}
		if ((Object)(object)toSetup == (Object)null)
		{
			return null;
		}
		Transform bottomMostChildTransform = SkeletonRecognize.GetBottomMostChildTransform(scheme.BoneStart);
		int depth = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneStart);
		Transform bottomMostChildTransform2 = SkeletonRecognize.GetBottomMostChildTransform(toSetup);
		int depth2 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform2, toSetup);
		if ((Object)(object)bottomMostChildTransform2 == (Object)null)
		{
			return null;
		}
		if ((Object)(object)bottomMostChildTransform == (Object)null)
		{
			return null;
		}
		if (depth2 != depth)
		{
			return null;
		}
		if (depth == 0)
		{
			return null;
		}
		if (depth2 == 0)
		{
			return null;
		}
		int depth3 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneEnd);
		Transform val = bottomMostChildTransform2;
		for (int i = 0; i < depth3; i++)
		{
			if ((Object)(object)val.parent == (Object)null)
			{
				return null;
			}
			val = val.parent;
		}
		depth3 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneMid);
		Transform val2 = bottomMostChildTransform2;
		for (int j = 0; j < depth3; j++)
		{
			if ((Object)(object)val.parent == (Object)null)
			{
				return null;
			}
			val2 = val2.parent;
		}
		if ((Object)(object)toSetup == (Object)(object)val2)
		{
			return null;
		}
		if ((Object)(object)toSetup == (Object)(object)val)
		{
			return null;
		}
		if ((Object)(object)val2 == (Object)(object)val)
		{
			return null;
		}
		float num = scheme.LegLimbLength();
		Leg leg = new Leg();
		leg.BoneStart = toSetup;
		leg.BoneMid = val2;
		leg.BoneEnd = val;
		leg.Owner = this;
		if (leg.LegLimbLength() < num * 0.2f)
		{
			return null;
		}
		bool flag = true;
		for (int k = 0; k < Legs.Count; k++)
		{
			if ((Object)(object)Legs[k].BoneStart == (Object)(object)leg.BoneStart)
			{
				flag = false;
				break;
			}
			if ((Object)(object)Legs[k].BoneStart == (Object)(object)leg.BoneMid)
			{
				flag = false;
				break;
			}
			if ((Object)(object)Legs[k].BoneMid == (Object)(object)leg.BoneStart)
			{
				flag = false;
				break;
			}
			if ((Object)(object)Legs[k].BoneMid == (Object)(object)leg.BoneMid)
			{
				flag = false;
				break;
			}
		}
		if (!flag)
		{
			return null;
		}
		if (apply)
		{
			Legs.Add(leg);
			leg.DefineLegSide(this);
			leg.RefreshLegAnkleToHeelAndFeetAndAxes(BaseTransform);
		}
		return leg;
	}

	public void Setup_TryAutoLegsSetup(Leg scheme, Transform parentOfLegs)
	{
		if (!((Object)(object)parentOfLegs == (Object)null))
		{
			for (int i = 0; i < parentOfLegs.childCount; i++)
			{
				Setup_TryAutoLegSetup(scheme, parentOfLegs.GetChild(i));
			}
		}
	}

	public void Legs_AddNewLeg()
	{
		Leg leg = new Leg();
		leg.Owner = this;
		Legs.Add(leg);
	}

	public void Legs_RefreshLegsOwner()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Owner = this;
		}
	}

	public int Leg_GetIndex(Leg leg)
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			if (leg == Legs[i])
			{
				return i;
			}
		}
		return -1;
	}

	public Leg Leg_GetLeg(int index)
	{
		if (index < 0)
		{
			return null;
		}
		if (index >= Legs.Count)
		{
			return null;
		}
		return Legs[index];
	}

	protected virtual void Finder_EnsureLegsCount(int legsCount)
	{
		for (int i = 0; i < legsCount; i++)
		{
			if (Legs.Count <= i)
			{
				Legs_AddNewLeg();
			}
		}
	}

	public virtual void Finder_AutoFindLegsIfHuman(Animator anim)
	{
		if (Object.op_Implicit((Object)(object)anim) && anim.isHuman)
		{
			Finder_EnsureLegsCount(2);
			if ((Object)(object)Legs[0].BoneStart == (Object)null)
			{
				Legs[0].BoneStart = anim.GetBoneTransform((HumanBodyBones)1);
				Legs[0].Side = ELegSide.Left;
			}
			if ((Object)(object)Legs[0].BoneMid == (Object)null)
			{
				Legs[0].BoneMid = anim.GetBoneTransform((HumanBodyBones)3);
			}
			if ((Object)(object)Legs[0].BoneEnd == (Object)null)
			{
				Legs[0].BoneEnd = anim.GetBoneTransform((HumanBodyBones)5);
			}
			if ((Object)(object)Legs[1].BoneStart == (Object)null)
			{
				Legs[1].BoneStart = anim.GetBoneTransform((HumanBodyBones)2);
				Legs[1].Side = ELegSide.Right;
			}
			if ((Object)(object)Legs[1].BoneMid == (Object)null)
			{
				Legs[1].BoneMid = anim.GetBoneTransform((HumanBodyBones)4);
			}
			if ((Object)(object)Legs[1].BoneEnd == (Object)null)
			{
				Legs[1].BoneEnd = anim.GetBoneTransform((HumanBodyBones)6);
			}
			if (Legs[0].OppositeLegIndex < 0)
			{
				Legs[1].AssignOppositeLegIndex(0);
			}
			if (Legs[0].Side == ELegSide.Undefined)
			{
				Legs[0].Side = ELegSide.Left;
			}
			if (Legs[1].Side == ELegSide.Undefined)
			{
				Legs[1].Side = ELegSide.Right;
			}
			if ((Object)(object)SpineBone == (Object)null)
			{
				SpineBone = anim.GetBoneTransform((HumanBodyBones)7);
			}
			Finders_RefreshAllLegsAnkleAxes();
			User_RefreshHelperVariablesOnParametersChange();
		}
	}

	public Animator Finding_TryFindMecanim()
	{
		if (!Object.op_Implicit((Object)(object)Mecanim))
		{
			Mecanim = FTransformMethods.FindComponentInAllChildren<Animator>(BaseTransform);
			if (!Object.op_Implicit((Object)(object)Mecanim))
			{
				Mecanim = ((Component)BaseTransform).GetComponentInParent<Animator>();
			}
		}
		return Mecanim;
	}

	public virtual void Finder_AutoDefineOppositeLegs()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < Legs.Count; i++)
		{
			if ((Object)(object)Legs[i].BoneEnd == (Object)null)
			{
				return;
			}
			list.Add(BaseTransform.InverseTransformPoint(Legs[i].BoneEnd.position));
		}
		for (int j = 0; j < Legs.Count; j++)
		{
			if (Legs[j].OppositeLegIndex > -1)
			{
				continue;
			}
			int num = -1;
			float num2 = float.MaxValue;
			for (int k = 0; k < Legs.Count; k++)
			{
				if (j == k || Mathf.Sign(list[j].x) == Mathf.Sign(list[k].x))
				{
					continue;
				}
				float num3 = Mathf.Abs(list[j].z - list[k].z);
				if (Legs[k].Side == ELegSide.Undefined)
				{
					if (list[k].x < 0f)
					{
						Legs[k].Side = ELegSide.Left;
					}
					else
					{
						Legs[k].Side = ELegSide.Right;
					}
				}
				if (num3 < num2)
				{
					num2 = num3;
					num = k;
				}
			}
			if (num != -1)
			{
				Legs[j].AssignOppositeLegIndex(num);
			}
		}
	}

	public virtual void Finding_LegBonesByNamesAndParenting()
	{
		Finding_TryFindMecanim();
		if (Legs == null)
		{
			Legs = new List<Leg>();
		}
		if (Object.op_Implicit((Object)(object)Mecanim) && Mecanim.isHuman)
		{
			Finder_AutoFindLegsIfHuman(Mecanim);
		}
		else if (Legs.Count < 2)
		{
			Finder_EnsureLegsCount(2);
		}
	}

	public virtual void Finding_SearchForHips()
	{
		if (!Object.op_Implicit((Object)(object)Hips))
		{
			Finding_TryFindMecanim();
			if (Object.op_Implicit((Object)(object)Mecanim) && Mecanim.isHuman)
			{
				Hips = Mecanim.GetBoneTransform((HumanBodyBones)0);
			}
		}
	}

	public Transform Finders_QuickHipsSearch()
	{
		Transform val = BaseTransform;
		Animator val2 = FTransformMethods.FindComponentInAllChildren<Animator>(val);
		if (Object.op_Implicit((Object)(object)val2) && val2.isHuman)
		{
			Finder_AutoFindLegsIfHuman(val2);
			return val2.GetBoneTransform((HumanBodyBones)0);
		}
		Transform val3 = FTransformMethods.FindChildByNameInDepth("pelv", val);
		if (Object.op_Implicit((Object)(object)val3))
		{
			SkinnedMeshRenderer componentInChildren = ((Component)val).GetComponentInChildren<SkinnedMeshRenderer>();
			if (!Object.op_Implicit((Object)(object)componentInChildren))
			{
				return val3;
			}
			if ((Object)(object)val3 == (Object)(object)componentInChildren.rootBone || componentInChildren.bones.Contains(val3) || val3.childCount >= 3)
			{
				return val3;
			}
		}
		val3 = FTransformMethods.FindChildByNameInDepth("hips", val);
		if (Object.op_Implicit((Object)(object)val3))
		{
			if (val3.childCount >= 3)
			{
				return val3;
			}
			if ((Object)(object)val3.parent != (Object)null)
			{
				val3 = val3.parent;
				if (val3.childCount >= 3)
				{
					return val3;
				}
				if ((Object)(object)val3.parent != (Object)null)
				{
					val3 = val3.parent;
					if (val3.childCount >= 3)
					{
						return val3;
					}
				}
			}
		}
		return null;
	}

	private void Finding_UpperLegsWithPelvis()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)Hips))
		{
			return;
		}
		Finder_EnsureLegsCount(2);
		Leg leg = Legs[0];
		Leg leg2 = Legs[1];
		if (Legs[0].Side == ELegSide.Right)
		{
			leg = Legs[1];
			leg2 = Legs[0];
		}
		if (leg == null)
		{
			return;
		}
		if ((Object)(object)leg.BoneStart == (Object)null)
		{
			Transform val = null;
			Vector3 val2 = BaseTransform.InverseTransformPoint(Hips.position);
			for (int i = 0; i < Hips.childCount; i++)
			{
				if (Object.op_Implicit((Object)(object)val))
				{
					break;
				}
				Vector3 val3 = BaseTransform.InverseTransformPoint(Hips.GetChild(i).position);
				if (val3.x < val2.x && val3.y < val2.y)
				{
					val = Hips.GetChild(i);
				}
			}
			leg.BoneStart = val;
		}
		if (leg2 == null || !((Object)(object)leg2.BoneStart == (Object)null))
		{
			return;
		}
		Transform val4 = null;
		Vector3 val5 = BaseTransform.InverseTransformPoint(Hips.position);
		for (int j = 0; j < Hips.childCount; j++)
		{
			if (Object.op_Implicit((Object)(object)val4))
			{
				break;
			}
			Vector3 val6 = BaseTransform.InverseTransformPoint(Hips.GetChild(j).position);
			if (val6.x > val5.x && val6.y < val5.y)
			{
				val4 = Hips.GetChild(j);
			}
		}
		leg2.BoneStart = val4;
	}

	private Transform Finding_FindUpperLeg(Transform foot)
	{
		Transform result = null;
		if (!Object.op_Implicit((Object)(object)Hips))
		{
			Transform val = null;
			Transform parent = foot.parent;
			if (Object.op_Implicit((Object)(object)parent) && Object.op_Implicit((Object)(object)parent.parent))
			{
				parent = parent.parent;
				if (Object.op_Implicit((Object)(object)parent))
				{
					if (parent.childCount > 2)
					{
						val = parent;
					}
					if (!Object.op_Implicit((Object)(object)val) && Object.op_Implicit((Object)(object)parent.parent))
					{
						parent = parent.parent;
						if (parent.childCount > 2)
						{
							val = parent;
						}
						if (!Object.op_Implicit((Object)(object)val) && Object.op_Implicit((Object)(object)parent.parent))
						{
							parent = parent.parent;
							if (parent.childCount > 2)
							{
								val = parent;
							}
							if (!Object.op_Implicit((Object)(object)val) && Object.op_Implicit((Object)(object)parent.parent))
							{
								parent = parent.parent;
								if (parent.childCount > 2)
								{
									val = parent;
								}
							}
						}
					}
				}
			}
			result = parent;
			if (Object.op_Implicit((Object)(object)val))
			{
				Hips = val;
			}
		}
		return result;
	}

	private void Finding_FindLowerLegsWithUpper()
	{
		Finder_EnsureLegsCount(2);
		Leg leg = Legs[0];
		Leg leg2 = Legs[1];
		if (Legs[0].Side == ELegSide.Right)
		{
			leg = Legs[1];
			leg2 = Legs[0];
		}
		if ((Object)(object)leg.BoneStart != (Object)null)
		{
			if (leg.BoneStart.childCount > 0 && !Object.op_Implicit((Object)(object)leg.BoneMid))
			{
				leg.BoneMid = Finders_GetRelevantChildOf(leg.BoneStart);
			}
			if (Object.op_Implicit((Object)(object)leg.BoneMid) && leg.BoneMid.childCount > 0 && (Object)(object)leg.BoneEnd == (Object)null)
			{
				leg.BoneEnd = Finders_GetRelevantChildOf(leg.BoneMid);
			}
		}
		if ((Object)(object)leg2.BoneStart != (Object)null)
		{
			if (leg2.BoneStart.childCount > 0 && !Object.op_Implicit((Object)(object)leg2.BoneMid))
			{
				leg2.BoneMid = Finders_GetRelevantChildOf(leg2.BoneStart);
			}
			if (Object.op_Implicit((Object)(object)leg2.BoneMid) && leg2.BoneMid.childCount > 0 && (Object)(object)leg2.BoneEnd == (Object)null)
			{
				leg2.BoneEnd = Finders_GetRelevantChildOf(leg2.BoneMid);
			}
		}
	}

	public Transform Finders_GetRelevantChildOf(Transform parent)
	{
		Transform val = null;
		for (int i = 0; i < parent.childCount; i++)
		{
			Transform child = parent.GetChild(i);
			if ((Object)(object)val == (Object)null)
			{
				val = child;
			}
			else if (child.childCount > val.childCount)
			{
				val = child;
			}
		}
		return val;
	}

	protected static bool? Finders_IsRightOrLeft(Transform child, Transform itsRoot)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = itsRoot.InverseTransformPoint(child.position);
		if (val.x < 0f)
		{
			return false;
		}
		if (val.x > 0f)
		{
			return true;
		}
		return null;
	}

	public void Finders_RefreshAllLegsAnkleAxes()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].RefreshLegAnkleToHeelAndFeetAndAxes(BaseTransform);
		}
	}

	protected virtual void CustomIK_Initialize()
	{
	}

	protected virtual void CustomIK_ApplyIK()
	{
	}

	public void OnDrop(PointerEventData data)
	{
	}

	private void MeasurePerformanceUpdate(bool start)
	{
	}

	private void MeasurePerformancePreLateUpdate(bool start)
	{
	}

	private void MeasurePerformanceMain(bool start)
	{
	}

	protected virtual void Initialize()
	{
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Invalid comparison between Unknown and I4
		if (LegsInitialized)
		{
			return;
		}
		ReferencePose referencePose = null;
		if (SetupPose != null && SetupPose.IsSet(this))
		{
			referencePose = new ReferencePose();
			StoreSetupPose(referencePose);
			RestoreSetupPose(SetupPose);
		}
		GroundedTime = 0f;
		MovingTime = 0f;
		IsMovingBlend = 0f;
		IsGroundedBlend = 1f;
		RagdolledDisablerBlend = 1f;
		_MainBlendNoRagdolling = 1f;
		DeltaTime = 0.05f;
		usingCustomDesiredMovementDirection = false;
		RagdolledDisablerBlend = 1f;
		RagdolledTime = -100f;
		DoBackCompatibilityChecks();
		Initialize_BaseTransform();
		RefreshMatrices();
		_wasInstantTriggered = true;
		Legs_RefreshLegsOwner();
		User_RefreshHelperVariablesOnParametersChange();
		Controll_DefineHashes();
		Initialize_Stability();
		finalScaleReferenceSqrt = ScaleReference * ScaleReference;
		HipsSetup.Initialize(this, Hips, BaseTransform);
		_LastAppliedHipsFinalPosition = Hips.position;
		HipsHubs_Init();
		if (CheckIfSomeOfTheLegsHasNullBone())
		{
			Debug.LogError((object)("[Legs Animator] One of the legs has unassigned bone! (" + ((Object)this).name + ")"));
			AllowUpdate = false;
			LegsInitialized = false;
			return;
		}
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].InitLegBasics(this, i, (i + 1 < Legs.Count) ? Legs[i + 1] : null);
		}
		IK_Initialize();
		LegsInitialized = true;
		AllowUpdate = true;
		InitializeGetStepInfoReceiver();
		if (Object.op_Implicit((Object)(object)Mecanim))
		{
			AnimatePhysics = (int)Mecanim.updateMode == 1;
		}
		InitializeModules();
		PrepareValues(Time.deltaTime);
		User_UpdateParametersAfterManualChange();
		User_RefreshHelperVariablesOnParametersChange();
		if (referencePose != null)
		{
			RestoreSetupPose(referencePose);
		}
	}

	public void InitializeGetStepInfoReceiver()
	{
		if ((Object)(object)StepInfoReceiver != (Object)null)
		{
			_StepReceiver = ((Component)StepInfoReceiver).GetComponent<ILegStepReceiver>();
			_RaiseReceiver = ((Component)StepInfoReceiver).GetComponent<ILegRaiseReceiver>();
		}
	}

	public void Initialize_BaseTransform()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)baseTransform == (Object)null)
		{
			baseTransform = ((Component)this).transform;
		}
		InitialBaseScale = baseTransform.lossyScale;
		if (InitialBaseScale.y == 0f)
		{
			InitialBaseScale = Vector3.one;
		}
		User_RefreshHelperVariablesOnParametersChange();
		MotionInfluence_Init();
	}

	public void Initialize_BaseTransform(Transform newTransform)
	{
		baseTransform = newTransform;
		Initialize_BaseTransform();
	}

	public bool IsSetupValid()
	{
		if (Legs.Count == 0)
		{
			return false;
		}
		if ((Object)(object)Hips == (Object)null)
		{
			return false;
		}
		bool result = true;
		for (int i = 0; i < Legs.Count; i++)
		{
			if ((Object)(object)Legs[i].BoneStart == (Object)null)
			{
				result = false;
				break;
			}
			if ((Object)(object)Legs[i].BoneEnd == (Object)null)
			{
				result = false;
				break;
			}
		}
		return result;
	}

	protected virtual void OnLegsReactivate()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		RefreshMatrices();
		MotionInfluence.Reset();
		Modules_OnReInitialize();
		HipsSetup.HipsMuscle.OverrideProceduralPosition(Vector3.zero);
		HipsSetup.HipsRotMuscle.OverrideProceduralRotation(Quaternion.identity);
		_LastAppliedHipsStabilityOffset = Vector3.zero;
		_LastAppliedHipsFinalPosition = Hips.position;
		_Hips_StabilityLocalOffset = Vector3.zero;
		_Hips_FinalStabilityOffset = Vector3.zero;
		HipsSetup.Reset();
		_glueModeExecuted = EGlueMode.Moving;
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Reset();
		}
	}

	public void StoreSetupPose()
	{
		StoreSetupPose(setupPose);
	}

	public void StoreSetupPose(ReferencePose referencePose)
	{
		referencePose.TweakListsFor(this);
		referencePose.MainHipsPose.SavePose(((Component)Hips).transform, this);
		for (int i = 0; i < referencePose.HipsPoses.Count; i++)
		{
			referencePose.HipsPoses[i].SavePose(ExtraHipsHubs[i], this);
		}
		for (int j = 0; j < referencePose.LegPoses.Count; j++)
		{
			referencePose.LegPoses[j].SaveLegPose(Legs[j], this);
		}
	}

	public void RestoreSetupPose()
	{
		RestoreSetupPose(setupPose);
	}

	public void RestoreSetupPose(ReferencePose referencePose)
	{
		referencePose.MainHipsPose.RestorePose(this);
		for (int i = 0; i < referencePose.HipsPoses.Count; i++)
		{
			referencePose.HipsPoses[i].RestorePose(this);
		}
		for (int j = 0; j < referencePose.LegPoses.Count; j++)
		{
			referencePose.LegPoses[j].RestoreLegPose(this);
		}
	}

	public void ApplyCustomReferencePose(ReferencePose pose)
	{
		if (pose != null && pose.IsSet(this))
		{
			ReferencePose referencePose = new ReferencePose();
			StoreSetupPose(referencePose);
			RestoreSetupPose(pose);
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].IKProcessor.Init(BaseTransform);
			}
			RestoreSetupPose(referencePose);
		}
	}

	public void User_SetIsGrounded(bool grounded)
	{
		if (grounded != _grounded)
		{
			if (grounded)
			{
				Control_OnLand();
			}
			else
			{
				Control_OnLooseGround();
			}
		}
		_grounded = grounded;
	}

	public void User_SetIsMoving(bool moving)
	{
		if (moving != _moving)
		{
			if (moving)
			{
				Control_OnStartMoving();
			}
			else
			{
				Control_OnStopMoving();
			}
		}
		_moving = moving;
	}

	public void User_SetIsSliding(bool moving)
	{
		_sliding = moving;
	}

	public void User_FadeLeg(int legIndex, float blend, float duration)
	{
		if (Legs.ContainsIndex(legIndex, falseIfNull: true))
		{
			((MonoBehaviour)this).StartCoroutine(IEFadeLegTo(Legs[legIndex], 0f, duration));
		}
	}

	public void User_FadeToDisabled(float duration)
	{
		((MonoBehaviour)this).StopAllCoroutines();
		if (duration <= 0f)
		{
			LegsAnimatorBlend = 0f;
			((Behaviour)this).enabled = false;
		}
		else
		{
			_wasFadingOn = false;
			((MonoBehaviour)this).StartCoroutine(IEFadeLegsAnimatorTo(0f, duration));
		}
	}

	public void User_FadeEnabled(float duration)
	{
		if (!((Behaviour)this).enabled)
		{
			((Behaviour)this).enabled = true;
		}
		((MonoBehaviour)this).StopAllCoroutines();
		if (duration <= 0f)
		{
			LegsAnimatorBlend = 1f;
		}
		else
		{
			_wasFadingOn = true;
			((MonoBehaviour)this).StartCoroutine(IEFadeLegsAnimatorTo(1f, duration));
		}
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].LegBlendWeight = 1f;
		}
	}

	public void User_MoveLegTo(int legIndex, Transform transform)
	{
		if (Legs.ContainsIndex(legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_OverrideRaycastHit(transform);
		}
	}

	public void User_MoveLegTo(int legIndex, Vector3 position, Vector3 normal)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit hit = default(RaycastHit);
		((RaycastHit)(ref hit)).point = position;
		((RaycastHit)(ref hit)).normal = normal;
		User_MoveLegTo(legIndex, hit);
	}

	public void User_MoveLegTo(int legIndex, RaycastHit hit)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (Legs.ContainsIndex(legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_OverrideRaycastHit(hit);
		}
	}

	public void User_MoveLegTo_Restore(int legIndex)
	{
		if (Legs.ContainsIndex(legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_RestoreRaycasting();
		}
	}

	protected IEnumerator IEFadeLegsAnimatorTo(float blend, float duration)
	{
		float startBlend = LegsAnimatorBlend;
		float elapsed = 0f;
		while (elapsed < duration)
		{
			elapsed += DeltaTime;
			LegsAnimatorBlend = Mathf.Lerp(startBlend, blend, elapsed / duration);
			yield return null;
			if (blend == 0f)
			{
				if (_wasFadingOn == true)
				{
					_wasFadingOn = null;
					yield break;
				}
			}
			else if (blend == 1f && _wasFadingOn == false)
			{
				_wasFadingOn = null;
				yield break;
			}
		}
		LegsAnimatorBlend = blend;
		if (blend <= 0f)
		{
			((Behaviour)this).enabled = false;
		}
	}

	protected IEnumerator IEFadeLegTo(Leg leg, float blend, float duration)
	{
		float startBlend = leg.LegBlendWeight;
		float elapsed = 0f;
		while (elapsed < duration)
		{
			elapsed += DeltaTime;
			leg.LegBlendWeight = Mathf.Lerp(startBlend, blend, elapsed / duration);
			yield return null;
		}
		leg.LegBlendWeight = blend;
	}

	public void User_Teleport(Vector3 toPosition)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		((Behaviour)this).enabled = false;
		((Component)this).transform.position = toPosition;
		((Behaviour)this).enabled = true;
		CheckActivation();
		PrepareValues(1f);
		UpdateStack(1f);
	}

	public void User_HipsPushDown(float power)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		User_AddImpulse(new ImpulseExecutor(Vector3.down * power, 0.3f + power * 0.3f));
	}

	public void User_HipsPushDownLong(float power)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		User_AddImpulse(new ImpulseExecutor(Vector3.down * power, 0.5f + power * 0.5f));
	}

	protected void OnDisable()
	{
		legsWasDisabled = true;
	}

	public void User_OverwriteCastMatrix(Matrix4x4 mx)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Matrix4x4)(ref mx)).MultiplyVector(Vector3.up);
		Up = ((Vector3)(ref val)).normalized;
		CastMx = mx;
		InvCastMx = ((Matrix4x4)(ref mx)).inverse;
	}

	private void RefreshMatrices()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (LocalWorldUp)
		{
			Up = BaseTransform.up;
			CastMx = baseTransform.localToWorldMatrix;
			InvCastMx = baseTransform.worldToLocalMatrix;
		}
		else
		{
			Quaternion val = Quaternion.FromToRotation(Vector3.ProjectOnPlane(baseTransform.forward, Up), Vector3.forward);
			CastMx = Matrix4x4.TRS(BaseTransform.position, val, BaseTransform.lossyScale);
			Matrix4x4 castMx = CastMx;
			InvCastMx = ((Matrix4x4)(ref castMx)).inverse;
		}
	}

	public bool Util_OnLeftSide(Transform t)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return BaseTransform.InverseTransformPoint(t.position).x < 0f;
	}

	public float Util_SideMul(Transform t)
	{
		if (!Util_OnLeftSide(t))
		{
			return 1f;
		}
		return -1f;
	}

	public float HipsToGroundDistance()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Hips == (Object)null)
		{
			return 0.1f;
		}
		return Vector3.Distance(BaseTransform.position, Hips.position);
	}

	public float HipsToGroundDistanceLocal()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Hips == (Object)null)
		{
			return 0.1f;
		}
		return BaseTransform.InverseTransformPoint(Hips.position).y;
	}

	private void UpdateGroundedBlend()
	{
		if (IsGrounded)
		{
			if (UngroundFadeSpeed >= 1f)
			{
				IsGroundedBlend = 1f;
			}
			else
			{
				IsGroundedBlend = Mathf.MoveTowards(IsGroundedBlend, 1f, DeltaTime * Mathf.LerpUnclamped(20f, 60f, UngroundFadeSpeed));
			}
			return;
		}
		if (UngroundFadeSpeed >= 1f)
		{
			IsGroundedBlend = 0f;
			return;
		}
		IsGroundedBlend = Mathf.Lerp(IsGroundedBlend, -0.01f, DeltaTime * Mathf.LerpUnclamped(6f, 20f, UngroundFadeSpeed));
		if (IsGroundedBlend < 0f)
		{
			IsGroundedBlend = 0f;
		}
	}

	private void UpdateMovingBlend()
	{
		if (IsMoving)
		{
			if (IsMovingFadeSpeed >= 1f)
			{
				IsMovingBlend = 1f;
			}
			else
			{
				IsMovingBlend = Mathf.MoveTowards(IsMovingBlend, 1f, DeltaTime * Mathf.LerpUnclamped(5f, 60f, IsMovingFadeSpeed));
			}
		}
		else if (IsMovingFadeSpeed >= 1f)
		{
			IsMovingBlend = 0f;
		}
		else
		{
			IsMovingBlend = Mathf.MoveTowards(IsMovingBlend, 0f, DeltaTime * Mathf.LerpUnclamped(5f, 60f, IsMovingFadeSpeed));
		}
	}

	private void UpdateSlidingBlend()
	{
		if (IsSliding)
		{
			NotSlidingBlend = Mathf.MoveTowards(NotSlidingBlend, 0f, DeltaTime * 6f);
		}
		else
		{
			NotSlidingBlend = Mathf.MoveTowards(NotSlidingBlend, 1f, DeltaTime * 6f);
		}
	}

	public Vector3 ToRootLocalSpaceVec(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 invCastMx = InvCastMx;
		return ((Matrix4x4)(ref invCastMx)).MultiplyVector(vec);
	}

	internal float User_GetLocalRotationAngle(Vector3 worldMoveDirection, Vector3 currentWorldLookForwardDirection)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ToRootLocalSpaceVec(worldMoveDirection);
		val.y = 0f;
		Vector3 val2 = ToRootLocalSpaceVec(currentWorldLookForwardDirection);
		val2.y = 0f;
		((Vector3)(ref val)).Normalize();
		((Vector3)(ref val2)).Normalize();
		return 0f - Vector3.SignedAngle(val, val2, Vector3.up);
	}

	public Vector3 ToRootLocalSpace(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 invCastMx = InvCastMx;
		return ((Matrix4x4)(ref invCastMx)).MultiplyPoint3x4(worldPos);
	}

	public Vector3 RootToWorldSpaceVec(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 castMx = CastMx;
		return ((Matrix4x4)(ref castMx)).MultiplyVector(vec);
	}

	public void User_AddImpulse(PelvisImpulseSettings debugPushHipsImpulse, float multiplyPower = 1f, float multiplyDuration = 1f)
	{
		User_AddImpulse(new ImpulseExecutor(debugPushHipsImpulse, multiplyPower, multiplyDuration));
	}

	public void User_AddImpulse(ImpulseExecutor newImpulse)
	{
		if (!(newImpulse.ImpulseDuration <= 0f))
		{
			Impulses.Add(newImpulse);
		}
	}

	public Vector3 RootToWorldSpace(Vector3 localPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 castMx = CastMx;
		return ((Matrix4x4)(ref castMx)).MultiplyPoint3x4(localPos);
	}

	public void User_OverwriteIKCoords(int legID, Vector3? position, Quaternion? rotation = null)
	{
		if (Legs.ContainsIndex(legID, falseIfNull: true))
		{
			Legs[legID].OverrideTargetIKPosition(position);
			Legs[legID].OverrideTargetIKRotation(rotation);
		}
	}

	public void DoBackCompatibilityChecks()
	{
		if (ZeroStepsOnNoRaycast)
		{
			ZeroStepsOnNoRaycast = false;
			NoRaycastGroundBehaviour = ENoRaycastBehviour.ZeroFloorSteps;
		}
	}

	public bool CheckIfSomeOfTheLegsHasNullBone()
	{
		bool result = false;
		for (int i = 0; i < Legs.Count; i++)
		{
			Leg leg = Legs[i];
			if ((Object)(object)leg.BoneStart == (Object)null || (Object)(object)leg.BoneMid == (Object)null || (Object)(object)leg.BoneEnd == (Object)null)
			{
				result = true;
				break;
			}
		}
		return result;
	}

	private void IK_Initialize()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].IK_Initialize();
		}
		if (UseCustomIK)
		{
			CustomIK_Initialize();
		}
	}

	private void IK_TriggerGlueReinitialize()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Glue_Reset(initializing: true);
		}
	}

	private void IK_TriggerGlueInstantTransition()
	{
		_wasInstantTriggered = true;
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].G_InstantReglue = true;
		}
	}

	public void IK_TriggerReglue(bool onlyIfFar = true)
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.G_RequestRepose = ((!onlyIfFar) ? Leg.GlueReposeRequest.Repose : Leg.GlueReposeRequest.ReposeIfFar);
		}
	}

	public void User_RefreshHelperVariablesOnParametersChange()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		if (!IsSetupValid())
		{
			return;
		}
		if (ScaleReferenceMode == ELegsScaleReference.PelvisToGroundDistance)
		{
			finalScaleReference = HipsToGroundDistanceLocal();
		}
		else if (ScaleReferenceMode == ELegsScaleReference.FirstLegLength)
		{
			finalScaleReference = Legs[0].LegLimbLength() / Mathf.Max(0.001f, BaseTransform.lossyScale.x);
		}
		else if (ScaleReferenceMode == ELegsScaleReference.Custom)
		{
			if (customScaleReferenceValue < 0f)
			{
				customScaleReferenceValue = 0.2f;
			}
			finalScaleReference = customScaleReferenceValue;
		}
		else if (ScaleReferenceMode == ELegsScaleReference.PelvisLegAverage)
		{
			finalScaleReference = HipsToGroundDistanceLocal();
			finalScaleReference = Mathf.LerpUnclamped(finalScaleReference, Legs[0].LegLimbLength() / Mathf.Max(0.001f, BaseTransform.lossyScale.x), 0.5f);
		}
	}

	protected void Legs_PreCalibrate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.PreCalibrate();
		}
	}

	private void Legs_CheckAnimatorPose()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.CheckAnimatorPose();
		}
	}

	private void Legs_BeginLateUpdate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.BeginLateUpdate();
		}
	}

	private void Legs_LateUpdate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.LateUpdate();
		}
	}

	private void Legs_LateUpdate_Apply()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.LateUpdate_Apply();
		}
		if (UseCustomIK)
		{
			CustomIK_ApplyIK();
		}
	}

	private void Legs_MidLateUpdateAndRaycasting()
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (UseRaycastsForIsGrounded)
		{
			bool flag = false;
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].PreLateUpdate();
				if (!flag)
				{
					if (Legs[i].A_PreWasAligning)
					{
						flag = true;
					}
					else if (Legs[i].RaycastHitted && Legs[i].groundHitRootSpacePos.y > (0f - ScaleReference) * 0.05f)
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				RaycastHit legGroundHit = Legs[0].legGroundHit;
				if (Legs[0].DoRaycasting(_LastAppliedHipsFinalPosition, _LastAppliedHipsFinalPosition - Up * (HipsSetup.LastHipsHeightDiff * BaseTransform.lossyScale.y * 1.01f + ScaleReference * 0.075f)))
				{
					flag = true;
				}
				Legs[0].legGroundHit = legGroundHit;
			}
			if (flag)
			{
				if (_calc_rayGrounding < 0f)
				{
					_calc_rayGrounding = 0f;
				}
				_calc_rayGrounding += DeltaTime;
				if (_calc_rayGrounding < 0.05f)
				{
					flag = _grounded;
				}
			}
			else
			{
				if (_calc_rayGrounding > 0f)
				{
					_calc_rayGrounding = 0f;
				}
				_calc_rayGrounding -= DeltaTime;
				if (_calc_rayGrounding > 0.005f)
				{
					flag = _grounded;
				}
			}
			if (flag == _grounded)
			{
				return;
			}
			if (flag)
			{
				if (!(Time.time - _calc_lastGrounded > 0.05f))
				{
					return;
				}
				_calc_lastGrounded = Time.time;
			}
			User_SetIsGrounded(flag);
		}
		else
		{
			for (int j = 0; j < Legs.Count; j++)
			{
				Legs[j].PreLateUpdate();
			}
		}
	}

	public float GetCurrentCullingBlend()
	{
		return cullingBlend;
	}

	private void Start()
	{
		_started = true;
		AllowUpdate = false;
		if (!DelayedInitialization)
		{
			Initialize();
		}
		((MonoBehaviour)this).StartCoroutine(IEStart());
	}

	private IEnumerator IEStart()
	{
		yield return null;
		yield return null;
		if ((Object)(object)Rigidbody == (Object)null)
		{
			Rigidbody = ((Component)BaseTransform).GetComponent<Rigidbody>();
			if (!Object.op_Implicit((Object)(object)Rigidbody))
			{
				Rigidbody = ((Component)BaseTransform).GetComponentInChildren<Rigidbody>();
			}
			if (!Object.op_Implicit((Object)(object)Rigidbody))
			{
				Rigidbody = ((Component)BaseTransform).GetComponentInParent<Rigidbody>();
			}
		}
		Initialize();
	}

	private void OnEnable()
	{
		if (_started)
		{
			if (!LegsInitialized)
			{
				Initialize();
			}
			else
			{
				_wasInstantTriggered = false;
			}
		}
	}

	private void ReInitialize()
	{
		LegsInitialized = false;
		DisposeModules();
		Start();
	}

	private void CheckActivation()
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (FadeOffAtDistance < 0.01f)
		{
			cullingBlend = 1f;
		}
		else
		{
			bool flag = true;
			if ((Object)(object)FadeOff_DistanceToCamera == (Object)null && (Object)(object)Camera.main != (Object)null)
			{
				FadeOff_DistanceToCamera = ((Component)Camera.main).transform;
			}
			if ((Object)(object)FadeOff_DistanceToCamera != (Object)null)
			{
				FadeOff_lastCameraDistance = Vector3.Distance(BaseTransform.position, FadeOff_DistanceToCamera.position);
				if (FadeOff_lastCameraDistance > FadeOffAtDistance)
				{
					flag = false;
				}
			}
			if (flag)
			{
				if (cullingBlend < 1f)
				{
					cullingBlend = Mathf.Min(1f, Mathf.Lerp(cullingBlend, 1.05f, Time.unscaledDeltaTime * 6f));
					cullingBlend = Mathf.MoveTowards(cullingBlend, 1f, Time.unscaledDeltaTime);
				}
			}
			else
			{
				cullingBlend = Mathf.MoveTowards(cullingBlend, 0f, Time.unscaledDeltaTime * 1.5f);
			}
		}
		if ((Object)(object)DisableIfInvisible != (Object)null)
		{
			bool flag2 = !DisableIfInvisible.isVisible;
			for (int i = 0; i < DisableIfInvisibleExtraRenderers.Count; i++)
			{
				if (DisableIfInvisibleExtraRenderers[i].isVisible)
				{
					flag2 = false;
					break;
				}
			}
			if (flag2)
			{
				legsWasDisabled = true;
				return;
			}
		}
		if (legsWasDisabled && _MainBlendNoRagdolling > 0f && LegsInitialized)
		{
			OnLegsReactivate();
			legsWasDisabled = false;
		}
	}

	private void Update()
	{
		if (LegsInitialized)
		{
			CheckActivation();
			float delta = (UnscaledDeltaTime ? Time.unscaledDeltaTime : Time.deltaTime);
			PrepareValues(delta);
			if (AllowUpdate && !AnimatePhysics && !legsWasDisabled)
			{
				UpdateStack(delta);
			}
		}
	}

	protected virtual void ExtraFixedUpdate()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (UseRigidbodyVelocityForIsMoving && Object.op_Implicit((Object)(object)Rigidbody))
		{
			Vector3 val = ToRootLocalSpaceVec(Rigidbody.velocity);
			val.y = 0f;
			bool moving = ((Vector3)(ref val)).magnitude > ScaleReferenceNoScale * 0.02f;
			User_SetIsMoving(moving);
		}
	}

	private void LateUpdate()
	{
		if (!AllowUpdate || legsWasDisabled)
		{
			return;
		}
		if (AnimatePhysics)
		{
			if (!_fixedUpdated)
			{
				return;
			}
			_fixedUpdated = false;
		}
		PreLateUpdateStack();
		LateUpdateStack();
	}

	protected virtual void PrepareValues(float delta)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Invalid comparison between Unknown and I4
		_MainBlendNoRagdolling = LegsAnimatorBlend * cullingBlend * protectedBlend;
		_MainBlend = _MainBlendNoRagdolling * RagdolledDisablerBlend;
		_MainBlendPlusGrounded = _MainBlend * IsGroundedBlend;
		if ((Object)(object)Mecanim != (Object)null)
		{
			AnimatePhysics = (int)Mecanim.updateMode == 1;
		}
		if (_lastMainBlend != _MainBlend)
		{
			_lastMainBlendChanged = true;
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].IK_UpdateParamsBase();
			}
		}
		else
		{
			_lastMainBlendChanged = false;
		}
		_lastMainBlend = _MainBlend;
	}

	protected virtual void UpdateStack(float delta)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		MeasurePerformanceUpdate(start: true);
		DeltaTime = delta;
		Scale = baseTransform.lossyScale.y;
		if (_MainBlend > 0f)
		{
			if (!_wasInstantTriggered)
			{
				IK_TriggerGlueInstantTransition();
			}
			RefreshTargetMovementDirectionHelper();
			Controll_Update();
			UpdateGroundedBlend();
			UpdateMovingBlend();
			UpdateSlidingBlend();
			Hips_PreCalibrate();
			Legs_PreCalibrate();
			ExtraControls_Update();
			Modules_Update();
		}
		else
		{
			Controll_Update();
			Legs_PreCalibrate();
			legsWasDisabled = true;
		}
		MeasurePerformanceUpdate(start: false);
	}

	protected virtual void PreLateUpdateStack()
	{
		MeasurePerformancePreLateUpdate(start: true);
		RefreshMatrices();
		Legs_CheckAnimatorPose();
		Modules_AfterAnimatorCaptureUpdate();
		BaseObject_MotionUpdate();
		Hips_PreLateUpdate();
		Hips_LateUpdate();
		Legs_BeginLateUpdate();
		MeasurePerformancePreLateUpdate(start: false);
	}

	protected virtual void LateUpdateStack()
	{
		MeasurePerformanceMain(start: true);
		if (_MainBlend > 0.001f)
		{
			Legs_MidLateUpdateAndRaycasting();
		}
		Modules_PreLateUpdate();
		Legs_LateUpdate();
		Hips_PostLateUpdate();
		Modules_LateUpdatePreApply();
		Legs_LateUpdate_Apply();
		Modules_PostLateUpdate();
		MeasurePerformanceMain(start: false);
	}

	public virtual void User_UpdateParametersAfterManualChange()
	{
		if (AllowUpdate)
		{
			Modules_UpdateAfterManualChanges();
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].Leg_UpdateParams();
			}
			if (((UnityEventBase)Event_OnStep).GetPersistentEventCount() > 0 || Object.op_Implicit((Object)(object)StepInfoReceiver))
			{
				UseEvents = true;
			}
			else
			{
				UseEvents = false;
			}
		}
	}

	public void OnAddedReset()
	{
		MotionInfluence = new MotionInfluenceProcessor();
		MotionInfluence.AxisMotionInfluence.x = 0f;
		BaseLegAnimating = new LegStepAnimatingParameters();
		LegAnimatingSettings.RefreshDefaultCurves();
		CustomModules = new List<LegsAnimatorCustomModuleHelper>();
	}
}


using UnityEngine;

private struct CalibrateTransform
{
	public Transform Transform;

	private Quaternion initLocalRot;

	public CalibrateTransform(Transform t)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		Transform = t;
		initLocalRot = t.localRotation;
	}

	public void Calibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Transform.localRotation = initLocalRot;
	}
}


public enum EStepType
{
	IdleGluing,
	MovementGluing,
	OnLanding,
	OnStopping
}


using UnityEngine;

public interface ILegStepReceiver
{
	void LegAnimatorStepEvent(Leg leg, float power, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
}


using UnityEngine;

public interface ILegRaiseReceiver
{
	void LegAnimatorRaiseEvent(Leg leg, float predictedDistance, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class LegsAnimatorCustomModuleHelper
{
	public bool Enabled = true;

	public LegsAnimator Parent;

	public LegsAnimatorControlModuleBase ModuleReference;

	[SerializeField]
	[HideInInspector]
	public List<string> customStringList;

	[SerializeField]
	[HideInInspector]
	public List<Object> customObjectList;

	[SerializeField]
	private List<Variable> variables = new List<Variable>();

	public LegsAnimatorControlModuleBase PlaymodeModule { get; private set; }

	public LegsAnimatorControlModuleBase CurrentModule => PlaymodeModule;

	public LegsAnimatorCustomModuleHelper(LegsAnimator get)
	{
		Parent = get;
	}

	public void PreparePlaymodeModule(LegsAnimator parent)
	{
		if (!((Object)(object)PlaymodeModule != (Object)null) && !((Object)(object)ModuleReference == (Object)null))
		{
			PlaymodeModule = Object.Instantiate<LegsAnimatorControlModuleBase>(ModuleReference);
			PlaymodeModule.Base_Init(parent, this);
		}
	}

	public void DisposeModule()
	{
		if ((Object)(object)PlaymodeModule != (Object)null)
		{
			Object.Destroy((Object)(object)PlaymodeModule);
		}
		PlaymodeModule = null;
	}

	public Variable RequestVariable(string name, object defaultValue)
	{
		if (variables == null)
		{
			variables = new List<Variable>();
		}
		int hashCode = name.GetHashCode();
		for (int i = 0; i < variables.Count; i++)
		{
			if (variables[i].GetNameHash == hashCode)
			{
				return variables[i];
			}
		}
		Variable variable = new Variable(name, defaultValue);
		variables.Add(variable);
		return variable;
	}
}


using System;
using UnityEngine;

[Serializable]
public class PelvisImpulseSettings
{
	public string OptionalName = "Impulse";

	[Space(3f)]
	public float PowerMultiplier = 1f;

	[Tooltip("Duration of translation impulse in seconds")]
	public float ImpulseDuration = 0.5f;

	[Space(5f)]
	public Vector3 WorldTranslation = Vector3.zero;

	public Vector3 LocalTranslation = new Vector3(0f, -0.2f, 0.1f);

	[Space(5f)]
	public Vector3 HipsRotate = Vector3.zero;

	[Space(5f)]
	[Range(0f, 1f)]
	public float InheritElasticness = 0.75f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
	public AnimationCurve ImpulseCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
	public AnimationCurve YAxisMultiplyCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

	[Tooltip("Local Offset Z-forward will bo rotated to face the legs animator's current desired move direction value")]
	[Space(5f)]
	public bool AlignWithDesiredMoveDirection;

	public PelvisImpulseSettings Copy()
	{
		return (PelvisImpulseSettings)MemberwiseClone();
	}

	public PelvisImpulseSettings()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		ImpulseCurve = GetDefaultCurveInstance();
	}

	public static AnimationCurve GetDefaultCurveInstance()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		AnimationCurve obj = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);
		obj.AddKey(new Keyframe(0.2f, 1f));
		obj.SmoothTangents(1, 0.5f);
		return obj;
	}

	public PelvisImpulseSettings(Vector3 vector3, float duration, float power)
		: this()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		LocalTranslation = vector3;
		ImpulseDuration = duration;
		PowerMultiplier = power;
	}
}


using UnityEngine;

public struct ImpulseExecutor
{
	public float Elapsed;

	public float PowerMultiplier;

	public float ImpulseDuration;

	public Vector3 WorldTranslation;

	public Vector3 LocalTranslation;

	public float InheritElasticness;

	public Vector3 HipsRotation;

	public bool AlignDesired;

	public AnimationCurve ImpulseCurve;

	public AnimationCurve YAxisMultiplyCurve;

	private static AnimationCurve _defaultCurve;

	private static AnimationCurve _defaultCurve11;

	public static AnimationCurve DefaultCurve
	{
		get
		{
			if (_defaultCurve == null)
			{
				_defaultCurve = PelvisImpulseSettings.GetDefaultCurveInstance();
			}
			return _defaultCurve;
		}
	}

	public static AnimationCurve DefaultCurve11
	{
		get
		{
			if (_defaultCurve11 == null)
			{
				_defaultCurve11 = AnimationCurve.Linear(0f, 1f, 1f, 1f);
			}
			return _defaultCurve11;
		}
	}

	public bool Finished => Elapsed >= ImpulseDuration;

	public float Progress
	{
		get
		{
			if (ImpulseDuration != 0f)
			{
				return Elapsed / ImpulseDuration;
			}
			return 1f;
		}
	}

	public float Evaluation => ImpulseCurve.Evaluate(Progress);

	public float Elastic => InheritElasticness;

	public float Power => PowerMultiplier;

	public Vector3 CurrentLocalOffset => LocalTranslation * Evaluation * Power;

	public float CurrentLocalYAxisMultiplier => YAxisMultiplyCurve.Evaluate(Progress);

	public Vector3 CurrentWorldOffset => WorldTranslation * Evaluation * Power;

	public ImpulseExecutor(PelvisImpulseSettings settings, float powerMultiplier = 1f, float durationMultiplier = 1f)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Elapsed = 0f;
		PowerMultiplier = settings.PowerMultiplier * powerMultiplier;
		ImpulseDuration = settings.ImpulseDuration * durationMultiplier;
		WorldTranslation = settings.WorldTranslation;
		LocalTranslation = settings.LocalTranslation;
		InheritElasticness = settings.InheritElasticness;
		HipsRotation = settings.HipsRotate;
		ImpulseCurve = settings.ImpulseCurve;
		YAxisMultiplyCurve = settings.YAxisMultiplyCurve;
		AlignDesired = settings.AlignWithDesiredMoveDirection;
	}

	public ImpulseExecutor(Vector3 localOffset, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		Elapsed = 0f;
		PowerMultiplier = 1f;
		ImpulseDuration = duration;
		WorldTranslation = Vector3.zero;
		LocalTranslation = localOffset;
		InheritElasticness = elastic;
		ImpulseCurve = curve;
		if (curve == null)
		{
			ImpulseCurve = DefaultCurve;
		}
		YAxisMultiplyCurve = DefaultCurve11;
		HipsRotation = Vector3.zero;
		AlignDesired = alignWithDesiredDir;
	}

	public ImpulseExecutor(Vector3 localOffset, Vector3 hipsRotation, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Elapsed = 0f;
		PowerMultiplier = 1f;
		ImpulseDuration = duration;
		WorldTranslation = Vector3.zero;
		HipsRotation = hipsRotation;
		LocalTranslation = localOffset;
		InheritElasticness = elastic;
		ImpulseCurve = curve;
		if (curve == null)
		{
			ImpulseCurve = DefaultCurve;
		}
		YAxisMultiplyCurve = DefaultCurve11;
		AlignDesired = alignWithDesiredDir;
	}

	public ImpulseExecutor(float duration, Vector3 worldOffset, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Elapsed = 0f;
		PowerMultiplier = 1f;
		ImpulseDuration = duration;
		WorldTranslation = worldOffset;
		HipsRotation = Vector3.zero;
		LocalTranslation = Vector3.zero;
		InheritElasticness = elastic;
		ImpulseCurve = curve;
		if (curve == null)
		{
			ImpulseCurve = DefaultCurve;
		}
		YAxisMultiplyCurve = DefaultCurve11;
		AlignDesired = alignWithDesiredDir;
	}

	public void Update(float delta)
	{
		Elapsed += delta;
	}
}


public enum EHipsAdjustStyle
{
	SmoothDamp,
	FollowLegHeight
}


using UnityEngine;

public enum EHipsHubsHandling
{
	[Tooltip("Applying hips movement offset to the selected hub, in order to fix disconnected hips bones (rare case)")]
	FixDisconnected,
	[Tooltip("Detailed mode is computing hips hub offsets individually, giving more realistic effect but costs a bit more")]
	Detailed
}


using System;
using System.Collections.Generic;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class HipsReference
{
	public class HipsHubBackbone
	{
		public Transform frontBone;

		private Vector3 _dir = Vector3.zero;

		private Vector3 _sd_dir = Vector3.zero;

		private FMuscle_Vector3 _FMuscle;

		public LegsAnimator Owner { get; private set; }

		public Transform bone { get; private set; }

		public Quaternion initialLocalRotation { get; private set; }

		public Vector3 keyframePosition { get; private set; }

		public Quaternion TargetRotation { get; internal set; }

		public HipsHubBackbone(LegsAnimator owner, Transform b)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			Owner = owner;
			bone = b;
			initialLocalRotation = b.localRotation;
			_FMuscle = new FMuscle_Vector3();
			_FMuscle.Initialize(Vector3.zero);
		}

		public void PreCalibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			bone.localRotation = initialLocalRotation;
		}

		public void Calibrate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			keyframePosition = bone.position;
		}

		public Vector3 AnimateTargetDirection(Vector3 toHubNewB)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			if (Owner.HubBackBonesElasticity < 0.0001f)
			{
				return toHubNewB;
			}
			if (Owner.HubBackBonesElasticity <= 0.1f)
			{
				_dir = Vector3.SmoothDamp(_dir, toHubNewB, ref _sd_dir, 0.001f + Owner.HubBackBonesElasticity, 10000000f, Owner.DeltaTime);
			}
			else
			{
				_dir = Vector3.LerpUnclamped(toHubNewB, _FMuscle.Update(Owner.DeltaTime, toHubNewB), Owner.HubBackBonesElasticity);
			}
			return _dir;
		}
	}

	[Tooltip("Applying elasticity algorithm on the pelvis bone align motion, to make it look more organic.")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float HipsElasticityBlend = 1f;

	public FMuscle_Vector3 HipsMuscle;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float HipsRotElasticityBlend;

	public FMuscle_Quaternion HipsRotMuscle;

	[NonSerialized]
	public Vector3 LastKeyframePosition;

	[NonSerialized]
	public Vector3 LastKeyframeLocalPosition;

	[NonSerialized]
	public Quaternion LastKeyframeRotation;

	[NonSerialized]
	public Quaternion LastKeyframeLocalRotation;

	[NonSerialized]
	public Vector3 LastRootLocalPos;

	[NonSerialized]
	public float LastHipsHeightDiff;

	[NonSerialized]
	public Vector3 InitHipsPositionRootSpace;

	[NonSerialized]
	public float InitialHipsHeightLocal;

	[NonSerialized]
	internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

	private Transform root;

	private Vector3 initLocalPos;

	private Quaternion initLocalRot;

	private Vector3 _Hips_StabilityLocalAdjustement = Vector3.zero;

	private Vector3 _Hips_sd_StabilAdjustm = Vector3.zero;

	private Vector3 _stretchPreventerOff = Vector3.zero;

	private float _sd_Hips_StepHeightAdjustOffset;

	private int _h_lowestHitLeg = -1;

	private Vector3 _reAdjustLocal = Vector3.zero;

	private Vector3 _sd_readj = Vector3.zero;

	private Vector3 _pushSmoothed = Vector3.zero;

	private Vector3 _sd_pushSmoothed = Vector3.zero;

	public LegsAnimator Owner { get; private set; }

	public List<Leg> ChildLegs { get; private set; }

	public Transform bone { get; private set; }

	public UniRotateBone UniRotate { get; private set; }

	public List<HipsHubBackbone> HubBackBones { get; private set; }

	public Vector3 _Get_Hips_StabilityLocalAdjustement => _Hips_StabilityLocalAdjustement;

	public float _Hips_LastHipsOffset { get; private set; }

	public float _Hips_StepHeightAdjustOffset { get; private set; }

	public Vector3 ExtraNonElasticOffset { get; internal set; }

	public Vector3 _PreHipsAdjustPosition { get; internal set; }

	public void Initialize(LegsAnimator owner, Transform bone, Transform root)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		Owner = owner;
		this.bone = bone;
		this.root = root;
		initLocalPos = bone.localPosition;
		initLocalRot = bone.localRotation;
		ExtraNonElasticOffset = Vector3.zero;
		_Hips_StabilityLocalAdjustement = Vector3.zero;
		_Hips_sd_StabilAdjustm = Vector3.zero;
		InitHipsPositionRootSpace = root.InverseTransformPoint(bone.position);
		InitialHipsHeightLocal = InitHipsPositionRootSpace.y;
		if (HipsMuscle == null)
		{
			HipsMuscle = new FMuscle_Vector3();
		}
		if (HipsRotMuscle == null)
		{
			HipsRotMuscle = new FMuscle_Quaternion();
		}
		HipsMuscle.Initialize(Vector3.zero);
		HipsRotMuscle.Initialize(Quaternion.identity);
		UniRotate = new UniRotateBone(bone, root);
		Calibrate();
	}

	internal void PrepareLegs()
	{
		ChildLegs = new List<Leg>();
		if (!Owner._hipsHubs_using)
		{
			ChildLegs = Owner.Legs;
		}
		else
		{
			for (int i = 0; i < Owner.Legs.Count; i++)
			{
				bool? flag = IsFirstParent(Owner.Legs[i], bone);
				if (flag == true)
				{
					ChildLegs.Add(Owner.Legs[i]);
				}
				else if (!flag.HasValue && this == Owner.HipsSetup)
				{
					ChildLegs.Add(Owner.Legs[i]);
				}
			}
		}
		for (int j = 0; j < ChildLegs.Count; j++)
		{
			ChildLegs[j].AssignParentHub(this);
		}
	}

	internal void PrepareHubBones()
	{
		PrepareLegs();
		HubBackBones = new List<HipsHubBackbone>();
		Transform frontBone = bone;
		Transform parent = bone.parent;
		while ((Object)(object)parent != (Object)null)
		{
			bool flag = false;
			for (int i = 0; i < Owner.HipsHubs.Count; i++)
			{
				if ((Object)(object)parent == (Object)(object)Owner.HipsHubs[i].bone)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				HipsHubBackbone hipsHubBackbone = new HipsHubBackbone(Owner, parent);
				hipsHubBackbone.frontBone = frontBone;
				HubBackBones.Add(hipsHubBackbone);
				if (!((Object)(object)parent == (Object)(object)Owner.HipsSetup.bone))
				{
					frontBone = parent;
					parent = parent.parent;
					continue;
				}
				break;
			}
			break;
		}
	}

	private bool? IsFirstParent(Leg leg, Transform hub)
	{
		if ((Object)(object)leg.BoneStart == (Object)null)
		{
			return false;
		}
		Transform val = leg.BoneStart;
		while ((Object)(object)val != (Object)null)
		{
			if ((Object)(object)val == (Object)(object)hub)
			{
				return true;
			}
			if ((Object)(object)val == (Object)(object)Owner.Hips)
			{
				return false;
			}
			for (int i = 0; i < Owner.ExtraHipsHubs.Count; i++)
			{
				if ((Object)(object)val == (Object)(object)Owner.ExtraHipsHubs[i])
				{
					return false;
				}
			}
			val = val.parent;
		}
		return null;
	}

	public void Reset()
	{
		Calibrate();
		_Hips_LastHipsOffset = 0f;
	}

	public void PreCalibrate()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		UniRotate.PreCalibrate();
		if (Owner.Calibrate != ECalibrateMode.FixedCalibrate)
		{
			UniRotate.PreCalibrate();
		}
		else
		{
			bone.localPosition = LastKeyframeLocalPosition;
			bone.localRotation = LastKeyframeLocalRotation;
		}
		if (HubBackBones != null)
		{
			for (int i = 0; i < HubBackBones.Count; i++)
			{
				HubBackBones[i].PreCalibrate();
			}
		}
	}

	public void Calibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		LastKeyframePosition = bone.position;
		LastKeyframeLocalPosition = bone.localPosition;
		LastKeyframeLocalRotation = bone.localRotation;
		LastKeyframeRotation = bone.rotation;
		LastRootLocalPos = Owner.ToRootLocalSpace(LastKeyframePosition);
		LastHipsHeightDiff = GetHeightDiff(LastRootLocalPos.y);
		if (HubBackBones != null)
		{
			for (int i = 0; i < HubBackBones.Count; i++)
			{
				HubBackBones[i].Calibrate();
			}
		}
	}

	public float GetHeightDiff(float rootSpaceHeight)
	{
		return Mathf.InverseLerp(0f, InitialHipsHeightLocal, rootSpaceHeight);
	}

	public void CopyMuscleSettingsFrom(HipsReference hipsSetup)
	{
		HipsMuscle.Acceleration = hipsSetup.HipsMuscle.Acceleration;
		HipsMuscle.AccelerationLimit = hipsSetup.HipsMuscle.AccelerationLimit;
		HipsMuscle.Damping = hipsSetup.HipsMuscle.Damping;
		HipsMuscle.BrakePower = hipsSetup.HipsMuscle.BrakePower;
	}

	public Vector3 CalculateCenterOfMassStability(float stabilizingMultiplier)
	{
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.StabilizeCenterOfMass > 0f)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(0f, 0f, 0f);
			float num = ChildLegs.Count;
			if (Owner.StabilityAlgorithm == EStabilityMode.Biped_Deprecated)
			{
				for (int i = 0; i < ChildLegs.Count; i++)
				{
					Leg leg = ChildLegs[i];
					Vector3 val2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
					Vector3 previousFinalIKPosForStability = leg._PreviousFinalIKPosForStability;
					Vector3 val3 = Owner.ToRootLocalSpace(previousFinalIKPosForStability + val2);
					Vector3 initialPosInRootSpace = leg.InitialPosInRootSpace;
					initialPosInRootSpace.y += _Hips_LastHipsOffset;
					Vector3 val4 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace, leg.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace) : leg.AnkleH.LastKeyframeRootPos);
					Vector3 val5 = val3 - val4;
					val5.y *= 0.25f;
					val += val5 * leg.BlendWeight * 0.5f * (stabilizingMultiplier * Owner.StabilizeCenterOfMass);
				}
				val.y /= num;
			}
			else if (Owner.StabilityAlgorithm == EStabilityMode.Universal)
			{
				Vector3 lastRootLocalPos = LastRootLocalPos;
				for (int j = 0; j < ChildLegs.Count; j++)
				{
					Leg leg2 = ChildLegs[j];
					Vector3 initialPosInRootSpace2 = leg2.InitialPosInRootSpace;
					initialPosInRootSpace2.y += _Hips_LastHipsOffset;
					Vector3 val6 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace2, leg2.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace2) : leg2.AnkleH.LastKeyframeRootPos);
					Vector3 val7 = lastRootLocalPos - val6;
					Vector3 val8 = Owner.ToRootLocalSpace(leg2._PreviousFinalIKPosForStability);
					Vector3 val9 = lastRootLocalPos - val8;
					Vector3 val10 = val7 - val9;
					val10.y *= 0.25f;
					val += val10 * leg2.BlendWeight * (stabilizingMultiplier * Owner.StabilizeCenterOfMass) / num;
				}
			}
			if (val.y > 0f)
			{
				val.y = 0f;
			}
			if (Owner.StabilizingSpeed < 1f)
			{
				float duration = 0f;
				if (Owner.StabilizingSpeed < 1f)
				{
					duration = 0.001f + (1f - Owner.StabilizingSpeed) * 0.4f;
				}
				Owner.ValueTowards(ref _Hips_StabilityLocalAdjustement, val, ref _Hips_sd_StabilAdjustm, duration);
			}
			else
			{
				_Hips_StabilityLocalAdjustement = val;
			}
		}
		else
		{
			_Hips_StabilityLocalAdjustement = Vector3.zero;
		}
		return _Hips_StabilityLocalAdjustement;
	}

	public Vector3 CalculateStretchPreventerOffset()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.HipsStretchPreventer < 0.0001f)
		{
			return Vector3.zero;
		}
		Vector3 val = Vector3.zero;
		float num = 0f;
		Vector3 lastRootLocalPos = LastRootLocalPos;
		lastRootLocalPos.y = 0f;
		lastRootLocalPos = Owner.baseTransform.TransformPoint(lastRootLocalPos);
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			float stretchValue = leg.IKProcessor.GetStretchValue(leg._PreviousFinalIKPosForStability);
			if (stretchValue > Owner.LimitLegStretch * 0.975f)
			{
				num += 1f;
				float num2 = stretchValue - Owner.LimitLegStretch * 0.975f;
				Vector3 vec = lastRootLocalPos - leg._PreviousFinalIKPosForStability;
				vec = Owner.ToRootLocalSpaceVec(vec);
				if (vec.y > 0f)
				{
					vec.y = 0f;
				}
				vec.x *= -0.6f;
				vec.z *= -0.6f;
				val += vec * Mathf.Clamp(num2 * 3f, 0f, 0.5f);
			}
		}
		if (Owner.StretchPreventerSpeed < 1f)
		{
			float num3 = Mathf.Lerp(8f, 40f, Owner.StretchPreventerSpeed) * Owner.DeltaTime;
			if (num > 0f)
			{
				_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, val / num, num3);
			}
			else
			{
				_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, Vector3.zero, num3 * 0.7f);
			}
		}
		else
		{
			_stretchPreventerOff = val;
		}
		return _stretchPreventerOff;
	}

	public Vector3 CalculateGlueMovePush()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (Owner.GlueBlend < 0.0001f)
		{
			return val;
		}
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			if ((leg.G_Attached || leg.G_DuringLegAdjustMovement) && leg.G_LastLegMoveDistanceFactor > 0.055f && leg.G_GlueInternalTransition > 0f && leg.G_GlueInternalTransition < 1f && leg.G_HandlerExecutingLegAnimationMode == EGlueMode.Idle)
			{
				Vector3 val2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd);
				Vector3 val3 = Owner.ToRootLocalSpace(leg._PreviousFinalIKPosForStability + val2);
				val3.z = 0f - val3.z;
				float num = Owner.BaseLegAnimating.PushHipsOnMoveCurve.Evaluate(leg.G_GlueInternalTransition);
				Vector3 val4 = -val3 * num * 1f;
				val4.y -= num * leg.G_LastLegMoveDistanceFactor * Owner.ScaleReferenceNoScale * 0.75f;
				Vector3 val5;
				if (Owner.NormalizePush)
				{
					float num2 = Mathf.Min(1f, ((Vector3)(ref val4)).magnitude / (Owner.ScaleReferenceNoScale * 0.33f));
					num2 *= num2;
					val5 = ((Vector3)(ref val4)).normalized * Owner.ScaleReferenceNoScale * 0.33f * num2;
				}
				else
				{
					val5 = val4;
				}
				val5.y *= Owner.PushYBlend;
				val += val5 * leg.BlendWeight;
			}
		}
		return val;
	}

	private void AnimateStepAdjustTo(float yOffset)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.HipsHeightStepSpeed >= 1f)
		{
			_Hips_StepHeightAdjustOffset = yOffset;
			return;
		}
		float landingBoost = Owner.GetLandingBoost();
		if (Owner.HipsAdjustStyle == EHipsAdjustStyle.FollowLegHeight && yOffset < _Hips_StepHeightAdjustOffset && _h_lowestHitLeg != -1)
		{
			Vector3 previousFinalIKPos = Owner.Legs[_h_lowestHitLeg]._PreviousFinalIKPos;
			previousFinalIKPos = Owner.ToRootLocalSpace(previousFinalIKPos);
			previousFinalIKPos.y -= Owner.ScaleReferenceNoScale * 0.325f;
			if (previousFinalIKPos.y > yOffset)
			{
				yOffset = previousFinalIKPos.y;
			}
		}
		_Hips_StepHeightAdjustOffset = Mathf.SmoothDamp(_Hips_StepHeightAdjustOffset, yOffset, ref _sd_Hips_StepHeightAdjustOffset, Mathf.LerpUnclamped(0.4f, 0.01f, landingBoost), 1000000f, Owner.DeltaTime);
		_h_lowestHitLeg = -1;
	}

	public float CalculateBodyAdjust()
	{
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		_Hips_LastHipsOffset = 0f;
		if (Owner.HipsHeightStepBlend <= 0f)
		{
			return 0f;
		}
		if (Owner.IsGrounded)
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(float.MaxValue, float.MaxValue, float.MaxValue);
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				if (!leg.RaycastHitted)
				{
					continue;
				}
				RaycastHit lastGroundHit = leg.LastGroundHit;
				Vector3 point = ((RaycastHit)(ref lastGroundHit)).point;
				point = Owner.ToRootLocalSpace(point);
				if (point.y <= 0f)
				{
					if (0f - point.y < Owner.BodyStepDown * Owner.ScaleReferenceNoScale && point.y < val.y)
					{
						val = point;
						_h_lowestHitLeg = i;
					}
				}
				else if (point.y < Owner.MaxBodyStepUp * Owner.ScaleReferenceNoScale && point.y < val.y)
				{
					val2 = point;
				}
			}
			bool flag = false;
			if (val.x != float.MaxValue && Owner.BodyStepDown > 0f && val.y <= 0f)
			{
				AnimateStepAdjustTo(val.y);
				flag = true;
			}
			if (!flag && Owner.MaxBodyStepUp > 0f && val2.x != float.MaxValue)
			{
				AnimateStepAdjustTo(val2.y);
				flag = true;
			}
			if (!flag)
			{
				AnimateStepAdjustTo(0f);
			}
		}
		else
		{
			AnimateStepAdjustTo(0f);
		}
		float num = Owner.HipsBlendWeight * Owner._MainBlend * Owner.IsGroundedBlend * Owner.RagdolledDisablerBlend;
		_Hips_LastHipsOffset = _Hips_StepHeightAdjustOffset * Owner.baseTransform.lossyScale.y * num;
		return _Hips_LastHipsOffset;
	}

	public Vector3 CalculateStretchReadjust()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			Vector3 val2 = leg._FinalIKPos - val;
			if (leg.IKProcessor.GetStretchValue(val2) > Owner.LimitLegStretch)
			{
				Vector3 notStretchedPositionTowards = leg.IKProcessor.GetNotStretchedPositionTowards(val2, Owner.LimitLegStretch);
				Vector3 val3 = val2 - notStretchedPositionTowards;
				val += val3;
			}
		}
		val = Owner.ToRootLocalSpaceVec(val);
		_reAdjustLocal = Vector3.SmoothDamp(_reAdjustLocal, val, ref _sd_readj, 0.1f, 10000000f, Owner.DeltaTime);
		return _reAdjustLocal;
	}

	public Vector3 SmoothPushOffset(Vector3 pushLocalOffset, float pushDuration)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Owner.ValueTowards(ref _pushSmoothed, pushLocalOffset, ref _sd_pushSmoothed, pushDuration);
		return _pushSmoothed;
	}

	public Vector3 AnimateOffset(Vector3 hubOffset)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return hubOffset;
	}
}


using FIMSpace.FTools;
using UnityEngine;

public class HipsHubBackbone
{
	public Transform frontBone;

	private Vector3 _dir = Vector3.zero;

	private Vector3 _sd_dir = Vector3.zero;

	private FMuscle_Vector3 _FMuscle;

	public LegsAnimator Owner { get; private set; }

	public Transform bone { get; private set; }

	public Quaternion initialLocalRotation { get; private set; }

	public Vector3 keyframePosition { get; private set; }

	public Quaternion TargetRotation { get; internal set; }

	public HipsHubBackbone(LegsAnimator owner, Transform b)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Owner = owner;
		bone = b;
		initialLocalRotation = b.localRotation;
		_FMuscle = new FMuscle_Vector3();
		_FMuscle.Initialize(Vector3.zero);
	}

	public void PreCalibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		bone.localRotation = initialLocalRotation;
	}

	public void Calibrate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		keyframePosition = bone.position;
	}

	public Vector3 AnimateTargetDirection(Vector3 toHubNewB)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.HubBackBonesElasticity < 0.0001f)
		{
			return toHubNewB;
		}
		if (Owner.HubBackBonesElasticity <= 0.1f)
		{
			_dir = Vector3.SmoothDamp(_dir, toHubNewB, ref _sd_dir, 0.001f + Owner.HubBackBonesElasticity, 10000000f, Owner.DeltaTime);
		}
		else
		{
			_dir = Vector3.LerpUnclamped(toHubNewB, _FMuscle.Update(Owner.DeltaTime, toHubNewB), Owner.HubBackBonesElasticity);
		}
		return _dir;
	}
}


public enum EStabilityMode
{
	Biped_Deprecated,
	Universal
}


using System;
using System.Collections.Generic;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class Leg
{
	private struct GlueAttachement
	{
		public RaycastHit AttachHit;

		public Transform AttachedTo;

		public Vector3 PosInAttachementLocal;

		public Vector3 NormalInAttachementLocal;

		public Quaternion RotInAttachementLocal;

		public bool NoTransform { get; private set; }

		public GlueAttachement(Leg leg, RaycastHit legGroundHit)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			AttachHit = legGroundHit;
			AttachedTo = ((RaycastHit)(ref legGroundHit)).transform;
			if ((Object)(object)((RaycastHit)(ref legGroundHit)).transform == (Object)null)
			{
				NoTransform = true;
				PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).point;
				NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).normal;
				RotInAttachementLocal = leg._PreviousFinalIKRot;
				return;
			}
			NoTransform = false;
			PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformPoint(((RaycastHit)(ref legGroundHit)).point);
			NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformDirection(((RaycastHit)(ref legGroundHit)).normal);
			if (!leg.Owner.AnimateFeet)
			{
				RotInAttachementLocal = Quaternion.identity;
			}
			else
			{
				RotInAttachementLocal = AttachedTo.rotation.QToLocal(leg.GetAlignedOnGroundHitRot(leg._SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal));
			}
		}

		internal Vector3 GetRelevantAlignedHitPoint(Leg leg)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			Vector3 relevantHitPoint = GetRelevantHitPoint();
			return leg.GetAlignedOnGroundHitPos(leg.ToRootLocalSpace(relevantHitPoint), relevantHitPoint, GetRelevantNormal());
		}

		internal Vector3 GetRelevantHitPoint()
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			if (NoTransform || (Object)(object)AttachedTo == (Object)null)
			{
				return PosInAttachementLocal;
			}
			return AttachedTo.TransformPoint(PosInAttachementLocal);
		}

		internal Vector3 GetRelevantNormal()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			if (NoTransform)
			{
				return NormalInAttachementLocal;
			}
			return AttachedTo.TransformDirection(NormalInAttachementLocal);
		}

		internal Quaternion GetRelevantAttachementRotation()
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			if (NoTransform)
			{
				return RotInAttachementLocal;
			}
			return AttachedTo.rotation.QToWorld(RotInAttachementLocal);
		}

		internal void OverwritePosition(Vector3 legAnimPos)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)AttachedTo == (Object)null)
			{
				PosInAttachementLocal = legAnimPos;
			}
			else
			{
				PosInAttachementLocal = ((Component)AttachedTo).transform.InverseTransformPoint(legAnimPos);
			}
		}
	}

	private class GlueAttachementHandler
	{
		public class LegTransitionAnimation
		{
			private enum EMoveType
			{
				FromAnimation,
				FromLastAttachement
			}

			private GlueAttachementHandler handler;

			public float LegAdjustementYOffset;

			public float LegAdjustementFootAngleOffset;

			private Vector3 _legSpherizeLocalVector = Vector3.zero;

			private float _legMoveDurMul = 1f;

			private Quaternion baseRotationOnStepUp;

			public float legMoveDistanceFactor;

			private float sd_trProgress;

			private Vector3 previousPositionLocal;

			private Vector3 previousPositionWorld;

			private Quaternion previousRotationWorld;

			private Vector3 lastAppliedGluePosition;

			private Vector3 lastAppliedGluePositionLocal;

			private Quaternion lastAppliedGlueRotation;

			private float lastSpeedup;

			private EMoveType animationMoveType;

			private bool _instantTransition;

			private bool _wasAnimatingLeg;

			private LegsAnimator Owner => handler.Owner;

			private Leg leg => handler.leg;

			public bool duringLegAdjustMovement { get; private set; }

			public bool wasAttaching { get; private set; }

			public bool attached { get; private set; }

			public float transitionProgress { get; private set; }

			public float lastAttachCompleteTime { get; private set; }

			public float transitionProgressLastFrame { get; private set; }

			public EGlueMode LastAnimationGlueMode
			{
				get
				{
					if (animationMoveType != 0)
					{
						return EGlueMode.Idle;
					}
					return EGlueMode.Moving;
				}
			}

			public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				handler = glueTransitionHelper;
				Reset();
			}

			public void Reset()
			{
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				//IL_002e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0049: Unknown result type (might be due to invalid IL or missing references)
				//IL_004e: Unknown result type (might be due to invalid IL or missing references)
				animationMoveType = EMoveType.FromAnimation;
				transitionProgress = 0f;
				transitionProgressLastFrame = 0f;
				baseRotationOnStepUp = Owner.BaseTransform.rotation;
				duringLegAdjustMovement = false;
				wasAttaching = false;
				attached = false;
				_legSpherizeLocalVector = Vector3.zero;
				ReInitialize();
			}

			public void ReInitialize()
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				//IL_002e: Unknown result type (might be due to invalid IL or missing references)
				//IL_003a: Unknown result type (might be due to invalid IL or missing references)
				//IL_003f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0051: Unknown result type (might be due to invalid IL or missing references)
				//IL_0056: Unknown result type (might be due to invalid IL or missing references)
				//IL_005b: Unknown result type (might be due to invalid IL or missing references)
				lastAppliedGluePosition = leg._SourceIKPos;
				lastAppliedGlueRotation = leg._SourceIKRot;
				previousPositionWorld = leg._SourceIKPos;
				previousRotationWorld = leg._SourceIKRot;
				previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
			}

			internal void ScheduleInstantTransition()
			{
				_instantTransition = true;
			}

			internal void DoAttaching(bool canAttach)
			{
				if (canAttach != wasAttaching)
				{
					wasAttaching = canAttach;
					if (canAttach)
					{
						OnChangeTargetPosition();
					}
					else
					{
						attached = false;
						if (transitionProgress != 0f)
						{
							OnChangeTargetPosition();
						}
					}
				}
				if (duringLegAdjustMovement && transitionProgress >= 1f)
				{
					duringLegAdjustMovement = false;
				}
			}

			internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
			{
				//IL_0099: Unknown result type (might be due to invalid IL or missing references)
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_006a: Unknown result type (might be due to invalid IL or missing references)
				//IL_005d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0070: Unknown result type (might be due to invalid IL or missing references)
				//IL_0076: Unknown result type (might be due to invalid IL or missing references)
				//IL_006f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0080: Unknown result type (might be due to invalid IL or missing references)
				//IL_0091: Unknown result type (might be due to invalid IL or missing references)
				//IL_0092: Unknown result type (might be due to invalid IL or missing references)
				//IL_0097: Unknown result type (might be due to invalid IL or missing references)
				if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
				{
					Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
					Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
					if (val.y < val2.y)
					{
						val.y = val2.y;
						legAnimPos = Owner.RootToWorldSpace(val);
					}
				}
				return legAnimPos;
			}

			public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
			{
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_000d: Unknown result type (might be due to invalid IL or missing references)
				//IL_001f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				//IL_0056: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				//IL_006b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0078: Unknown result type (might be due to invalid IL or missing references)
				//IL_007d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0082: Unknown result type (might be due to invalid IL or missing references)
				//IL_0087: Unknown result type (might be due to invalid IL or missing references)
				//IL_012a: Unknown result type (might be due to invalid IL or missing references)
				LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
				Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
				if (legAnimatingSettings.SpherizeTrack.length > 1)
				{
					float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
					val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
				}
				if (Owner.AnimateFeet)
				{
					LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
					LegAdjustementFootAngleOffset /= lastSpeedup;
				}
				float num2 = Owner.ScaleReferenceNoScale * 0.75f;
				float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
				num3 *= num2;
				LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
				_wasAnimatingLeg = true;
				return val;
			}

			internal Vector3 GetTargetPosition()
			{
				//IL_0122: Unknown result type (might be due to invalid IL or missing references)
				//IL_0127: Unknown result type (might be due to invalid IL or missing references)
				//IL_0107: Unknown result type (might be due to invalid IL or missing references)
				//IL_010c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0111: Unknown result type (might be due to invalid IL or missing references)
				//IL_0038: Unknown result type (might be due to invalid IL or missing references)
				//IL_003d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0138: Unknown result type (might be due to invalid IL or missing references)
				//IL_0144: Unknown result type (might be due to invalid IL or missing references)
				//IL_0149: Unknown result type (might be due to invalid IL or missing references)
				//IL_0154: Unknown result type (might be due to invalid IL or missing references)
				//IL_0159: Unknown result type (might be due to invalid IL or missing references)
				//IL_0135: Unknown result type (might be due to invalid IL or missing references)
				//IL_011f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0050: Unknown result type (might be due to invalid IL or missing references)
				//IL_0177: Unknown result type (might be due to invalid IL or missing references)
				//IL_017e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0183: Unknown result type (might be due to invalid IL or missing references)
				//IL_0188: Unknown result type (might be due to invalid IL or missing references)
				//IL_016d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0172: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				//IL_006d: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
				//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
				//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
				//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_0197: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
				//IL_00de: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
				//IL_008e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0093: Unknown result type (might be due to invalid IL or missing references)
				//IL_0098: Unknown result type (might be due to invalid IL or missing references)
				float glueAnimationBlend = handler.glueAnimationBlend;
				if (animationMoveType == EMoveType.FromAnimation)
				{
					if (glueAnimationBlend < 0.0001f)
					{
						return Owner.RootToWorldSpace(previousPositionLocal);
					}
					Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
					if (transitionProgress < 0.0001f)
					{
						return val;
					}
					Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
					if (transitionProgress > 0.9995f)
					{
						return val2;
					}
					return Vector3.LerpUnclamped(val, val2, transitionProgress);
				}
				Vector3 val3;
				if (leg.Owner.OnlyLocalAnimation)
				{
					val3 = Owner.RootToWorldSpace(previousPositionLocal);
					if (transitionProgress < 0.0001f)
					{
						return val3;
					}
				}
				else
				{
					val3 = previousPositionWorld;
					if (transitionProgress < 0.0001f)
					{
						return val3;
					}
					val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
				}
				Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
				if (transitionProgress >= 1f)
				{
					return val4;
				}
				float num = 1f - transitionProgress;
				return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
			}

			internal void RequireRepose()
			{
				if (attached)
				{
					attached = false;
					OnChangeTargetPosition();
				}
			}

			internal Quaternion GetTargetRotation()
			{
				//IL_0001: Unknown result type (might be due to invalid IL or missing references)
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_0014: Unknown result type (might be due to invalid IL or missing references)
				//IL_0015: Unknown result type (might be due to invalid IL or missing references)
				//IL_0016: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0039: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_004b: Unknown result type (might be due to invalid IL or missing references)
				//IL_004c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0053: Unknown result type (might be due to invalid IL or missing references)
				//IL_0058: Unknown result type (might be due to invalid IL or missing references)
				//IL_0047: Unknown result type (might be due to invalid IL or missing references)
				//IL_0048: Unknown result type (might be due to invalid IL or missing references)
				//IL_0059: Unknown result type (might be due to invalid IL or missing references)
				Quaternion val = previousRotationWorld;
				if (transitionProgress < 0.001f)
				{
					return val;
				}
				Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
				if (transitionProgress > 0.9995f)
				{
					return val2;
				}
				return Quaternion.LerpUnclamped(val, val2, transitionProgress);
			}

			internal void OnChangeTargetPosition()
			{
				//IL_0022: Unknown result type (might be due to invalid IL or missing references)
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
				//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
				//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
				//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
				//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
				//IL_0100: Unknown result type (might be due to invalid IL or missing references)
				//IL_0105: Unknown result type (might be due to invalid IL or missing references)
				//IL_010a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0141: Unknown result type (might be due to invalid IL or missing references)
				//IL_0146: Unknown result type (might be due to invalid IL or missing references)
				//IL_014d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0152: Unknown result type (might be due to invalid IL or missing references)
				//IL_0153: Unknown result type (might be due to invalid IL or missing references)
				//IL_0158: Unknown result type (might be due to invalid IL or missing references)
				//IL_0197: Unknown result type (might be due to invalid IL or missing references)
				//IL_019c: Unknown result type (might be due to invalid IL or missing references)
				//IL_019d: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
				//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
				//IL_0247: Unknown result type (might be due to invalid IL or missing references)
				//IL_024c: Unknown result type (might be due to invalid IL or missing references)
				//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
				//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
				//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
				//IL_0201: Unknown result type (might be due to invalid IL or missing references)
				//IL_0211: Unknown result type (might be due to invalid IL or missing references)
				//IL_0213: Unknown result type (might be due to invalid IL or missing references)
				//IL_0223: Unknown result type (might be due to invalid IL or missing references)
				//IL_022d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0232: Unknown result type (might be due to invalid IL or missing references)
				handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
				baseRotationOnStepUp = Owner.BaseTransform.rotation;
				if (handler.glueAnimationBlend < 0.2f)
				{
					animationMoveType = EMoveType.FromAnimation;
				}
				else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
				{
					animationMoveType = EMoveType.FromAnimation;
				}
				else if (animationMoveType == EMoveType.FromLastAttachement)
				{
					animationMoveType = EMoveType.FromLastAttachement;
				}
				else if (handler.glueAnimationBlend > 0.75f)
				{
					if (transitionProgress < 0.1f || transitionProgress > 0.9f)
					{
						animationMoveType = EMoveType.FromLastAttachement;
					}
					else
					{
						animationMoveType = EMoveType.FromAnimation;
					}
				}
				else
				{
					animationMoveType = EMoveType.FromAnimation;
				}
				if (leg.Owner.OnlyLocalAnimation)
				{
					previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
				}
				else
				{
					previousPositionWorld = lastAppliedGluePosition;
				}
				previousRotationWorld = lastAppliedGlueRotation;
				previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
				if (animationMoveType == EMoveType.FromLastAttachement)
				{
					if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
					{
						transitionProgress = 0f;
					}
					Vector3 val = previousPositionWorld;
					Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
					float magnitude = ((Vector3)(ref val2)).magnitude;
					legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
					legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
					Vector3 val3 = ((Vector3)(ref val2)).normalized;
					val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
					((Vector3)(ref val3)).Normalize();
					leg.SendRaiseEvent(magnitude);
					if (legMoveDistanceFactor > 0.0401f)
					{
						_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
						Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
						((Vector3)(ref worldDir)).Normalize();
						_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
						duringLegAdjustMovement = true;
					}
					else
					{
						animationMoveType = EMoveType.FromAnimation;
						_legSpherizeLocalVector = Vector3.zero;
						duringLegAdjustMovement = false;
					}
				}
				else
				{
					duringLegAdjustMovement = false;
					transitionProgress = 0f;
				}
			}

			public void UpdateAnimation()
			{
				//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
				//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
				//IL_0201: Unknown result type (might be due to invalid IL or missing references)
				//IL_0211: Unknown result type (might be due to invalid IL or missing references)
				//IL_011a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0107: Unknown result type (might be due to invalid IL or missing references)
				//IL_010c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0111: Unknown result type (might be due to invalid IL or missing references)
				//IL_0192: Unknown result type (might be due to invalid IL or missing references)
				//IL_0197: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
				//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
				//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
				float num = (Owner.JustGrounded ? 0.2f : 1f);
				float num2 = (Owner.JustGrounded ? 5f : 1f);
				transitionProgressLastFrame = transitionProgress;
				if (_instantTransition)
				{
					_instantTransition = false;
					transitionProgress = 1f;
					lastAttachCompleteTime = Time.time;
				}
				if (!Owner.IsGrounded)
				{
					return;
				}
				if (animationMoveType == EMoveType.FromLastAttachement)
				{
					float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
					float num4 = 1f;
					lastSpeedup = 1f;
					if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
					{
						if (leg.hasOppositeleg)
						{
							Leg oppositeLeg = leg.GetOppositeLeg();
							Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
							if (leg.Owner.OnlyLocalAnimation)
							{
								targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
							}
							float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
							if (stretchValue > leg.LegStretchLimit * 0.95f)
							{
								float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
								if (num5 < 0f)
								{
									num5 = 0f;
								}
								num4 += num5;
							}
							if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
							{
								Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
								float magnitude = ((Vector3)(ref val)).magnitude;
								float num6 = Owner.ScaleReference * 0.4f;
								if (magnitude > num6)
								{
									float num7 = magnitude - num6;
									num4 += num7 / num6 * 2f;
								}
							}
						}
						if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
						{
							float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
							if (num8 > 12f)
							{
								float num9 = Mathf.InverseLerp(30f, 135f, num8);
								num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
								transitionProgress += Owner.DeltaTime * num9 * num2;
							}
						}
						num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
					}
					lastSpeedup = num4;
					transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
					if (transitionProgress > 0.9995f && duringLegAdjustMovement)
					{
						TriggerAttach();
					}
				}
				else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
				{
					TriggerAttach();
				}
				else
				{
					transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
				}
			}

			private void TriggerAttach()
			{
				if (!attached)
				{
					transitionProgress = 1f;
					lastAttachCompleteTime = Time.time;
					attached = leg.Glue_TriggerFinalAttach();
					duringLegAdjustMovement = false;
				}
			}

			public void PostUpdate()
			{
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				//IL_001e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				lastAppliedGluePosition = leg._GluePosition;
				lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
				lastAppliedGlueRotation = leg._GlueRotation;
				if (!_wasAnimatingLeg)
				{
					LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
					LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
				}
				else
				{
					_wasAnimatingLeg = false;
				}
			}
		}

		private LegsAnimator Owner;

		private Leg ParentLeg;

		private float _sd_glueAnimationBlend;

		private bool _instantTransition;

		private Vector3 lastGluePosition = Vector3.zero;

		private Quaternion lastGlueRotation = Quaternion.identity;

		public LegTransitionAnimation legMoveAnimation { get; private set; }

		private Leg leg => ParentLeg;

		public float glueAnimationBlend { get; private set; }

		public float attachTransitionProgress => legMoveAnimation.transitionProgress;

		public float attachTransitionProgressLastFrame => legMoveAnimation.transitionProgressLastFrame;

		public float legMoveDistanceFactor => legMoveAnimation.legMoveDistanceFactor;

		public EGlueMode lasGlueModeOnAttaching { get; private set; }

		public GlueAttachementHandler(Leg leg)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			ParentLeg = leg;
			Owner = leg.Owner;
			legMoveAnimation = new LegTransitionAnimation(this);
			lasGlueModeOnAttaching = Owner._glueModeExecuted;
			Reset(initializing: true);
		}

		public void Reset(bool initializing)
		{
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			glueAnimationBlend = 0f;
			_sd_glueAnimationBlend = 0f;
			if (initializing)
			{
				lastGluePosition = leg.BoneEnd.position;
				lastGlueRotation = leg.BoneEnd.rotation;
			}
			legMoveAnimation.Reset();
		}

		public void SheduleInstantTransition()
		{
			_instantTransition = true;
			legMoveAnimation.ScheduleInstantTransition();
		}

		public void TransitionToGlueAnimation()
		{
			legMoveAnimation.DoAttaching(canAttach: true);
			ChangeGlueAnimationBlendTo(1f, Owner.GlueFadeInSpeed);
		}

		public void TransitionToDisableGlueAnimation()
		{
			legMoveAnimation.DoAttaching(canAttach: false);
			ChangeGlueAnimationBlendTo(0f, Owner.GlueFadeOutSpeed);
		}

		public Vector3 GetGluePosition()
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			if (glueAnimationBlend > 0.9995f)
			{
				lastGluePosition = legMoveAnimation.GetTargetPosition();
			}
			else if (glueAnimationBlend < 0.0001f)
			{
				lastGluePosition = leg.A_PreIKPosForGluing;
			}
			else
			{
				lastGluePosition = Vector3.LerpUnclamped(leg.A_PreIKPosForGluing, legMoveAnimation.GetTargetPosition(), glueAnimationBlend);
			}
			return lastGluePosition;
		}

		public Quaternion GetGlueRotation()
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			if (glueAnimationBlend > 0.999f)
			{
				lastGlueRotation = legMoveAnimation.GetTargetRotation();
			}
			else if (glueAnimationBlend < 0f)
			{
				lastGlueRotation = leg._FinalIKRot;
			}
			else
			{
				lastGlueRotation = Quaternion.LerpUnclamped(leg._FinalIKRot, legMoveAnimation.GetTargetRotation(), glueAnimationBlend);
			}
			return lastGlueRotation;
		}

		public void UpdateTransitioning(bool attaching)
		{
			legMoveAnimation.UpdateAnimation();
		}

		public void PostUpdate()
		{
			legMoveAnimation.PostUpdate();
		}

		internal void OnLegRequireRepose()
		{
			legMoveAnimation.RequireRepose();
		}

		private void ChangeGlueAnimationBlendTo(float target, float speed)
		{
			if (Owner.GroundedTime < 0f)
			{
				speed = 0.99f;
			}
			if (_instantTransition && target > 0f)
			{
				glueAnimationBlend = target;
				_instantTransition = false;
				return;
			}
			if (speed >= 1f)
			{
				glueAnimationBlend = target;
				return;
			}
			if (leg.G_JustLanded)
			{
				glueAnimationBlend = Mathf.MoveTowards(glueAnimationBlend, target, Owner.DeltaTime * 3f);
			}
			glueAnimationBlend = Mathf.SmoothDamp(glueAnimationBlend, target, ref _sd_glueAnimationBlend, Mathf.LerpUnclamped(0.2f, 0.005f, speed), 100000f, Owner.DeltaTime);
			if (float.IsNaN(_sd_glueAnimationBlend))
			{
				_sd_glueAnimationBlend = 0f;
			}
		}
	}

	public enum GlueReposeRequest
	{
		None,
		Repose,
		ReposeIfFar
	}

	public class LegHelper
	{
		public Transform Bone;

		public LegHelper Child;

		public Vector3 InitPositionRootSpace;

		public Vector3 LastKeyframeRootPos;

		public LegHelper(Leg leg, Transform bone)
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			Bone = bone;
			InitPositionRootSpace = leg.ToRootLocalSpace(bone.position);
		}

		public void Calibrate(Leg leg, Vector3 wPos)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0003: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			LastKeyframeRootPos = leg.ToRootLocalSpace(wPos);
		}
	}

	private GlueAttachement G_Attachement;

	public bool G_CustomForceAttach;

	public bool G_CustomForceNOTDetach;

	public bool G_CustomForceDetach;

	public bool G_CustomForceNOTAttach;

	private float lastFootForwardAngleDiffABS;

	private GlueAttachementHandler G_AttachementHandler;

	private Vector3 A_PreviousRelevantAnklePos;

	private Vector3 A_LastApppliedAlignPos;

	private Vector3 A_LastApppliedAlignPosLocal;

	private Vector3 A_PreIKPosForGluing;

	private Quaternion A_LastApppliedAlignRot;

	private Quaternion A_LastTargetAlignRot;

	private bool A_WasFullAlign;

	private float A_aligningBlendByGluing = 1f;

	private Vector3 A_LastElevation;

	private float A_LastElevateH;

	private float _sd_A_Elev;

	[NonSerialized]
	public float Adj_A_ElevateLerpSpeedStart = 8f;

	[NonSerialized]
	public float Adj_A_ElevateLerpSpeedAfter = 5f;

	[NonSerialized]
	public float Adj_A_ElevateSpeedupMargin = 0.014f;

	private float A_AligningFor;

	private Vector3 A_LastAlignRootSpacePos;

	private Vector3 A_LastSmoothTargetedPosLocal;

	private float A_LastSuddenSmoothYOffset;

	private float A_SuddenSmoothing;

	private float A_lastSuddenSmoothingDiff;

	private bool A_WasSmoothing;

	private bool A_WasAligningFrameBack;

	private Vector3 A_SmoothedIKPos;

	[NonSerialized]
	public bool G_InstantReglue;

	private float _glueTargetBlend = 1f;

	private float _gluingCulldown;

	protected bool G_JustLanded;

	[NonSerialized]
	public float ExtraGluingBlend = 1f;

	private Vector3 _GlueLastAttachPosition;

	private Vector3 _GlueLastAttachPositionRootLocal;

	private Quaternion _GlueLastAttachRotation;

	private Vector3 _GluePosition;

	private Quaternion _GlueRotation;

	private Vector3 _G_LastPreGlueSourceLocalIKPos;

	private Vector3 _G_PreGlueSourceLocalIKPos;

	private Vector3 _G_sd_RefSwing = Vector3.zero;

	private bool _G_WasDisabled = true;

	[NonSerialized]
	public GlueReposeRequest G_RequestRepose;

	private bool _G_WasGrounded = true;

	private Vector3 _G_LasGroundedPosLocal;

	private Quaternion _G_LasGroundedRotLocal;

	private Vector3 G_GlueDragOffset = Vector3.zero;

	private LegHelper _h_boneStart;

	private LegHelper _h_boneMid;

	private LegHelper _h_boneEnd;

	private Vector3 C_AnkleToHeelRootSpace = Vector3.one;

	private Vector3 C_LastHeelWorldPos;

	private Vector3 C_LastHeelRootSpacePos;

	private Vector3 C_LastFootEndWorldPos;

	private Vector3 C_LastFootEndRootSpacePos;

	private Vector3 C_Local_AnkleToHeelRotated;

	private float _C_DynamicYScale = 1f;

	public LegsAnimator Owner;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float LegBlendWeight = 1f;

	internal float InternalModuleBlendWeight = 1f;

	private float finalBoneBlend = 1f;

	[Tooltip("Make idle glue animation motion faster for this single leg")]
	public float LegMoveSpeedMultiplier = 1f;

	public float LegRaiseMultiplier = 1f;

	[Space(3f)]
	public float GlueThresholdMultiplier = 1f;

	public Vector2 GluePointOffset = Vector2.zero;

	[Space(3f)]
	[Range(0f, 1f)]
	public float LegStretchMultiplier = 1f;

	[Tooltip("Motion preset for the leg to be animated with different character than the other legs ('Idle Glue Motion' settings)")]
	public LegMotionSettingsPreset CustomLegAnimating;

	[Range(-40f, 40f)]
	public float FootPitchOffset;

	public Transform BoneStart;

	public Transform BoneMid;

	public Transform BoneEnd;

	public ELegSide Side;

	public int OppositeLegIndex = -1;

	public ERaycastPrecision RaycastPrecision;

	[Tooltip("(Experimental) If you want to animate in additional feet bone which in some cases can add nice animation feeling")]
	public bool UseFeet;

	public Transform BoneFeet;

	[Tooltip("Defining how quick heel should get up if leg gets stretched (change max stretching param under IK tab to be lower value that 1.1)")]
	[Range(0f, 1f)]
	public float FeetSensitivity = 0.5f;

	private bool hasOppositeleg;

	private LegStepAnimatingParameters targetLegAnimating;

	[Tooltip("Apply IK hint inversion, in case leg is bending in wrong direction.")]
	public bool InverseHint;

	public Vector3 AnkleToHeel = Vector3.zero;

	public Vector3 AnkleToFeetEnd = Vector3.zero;

	public Vector3 AnkleRight = Vector3.right;

	public Vector3 AnkleUp = Vector3.up;

	public Vector3 AnkleForward = Vector3.forward;

	[Range(0f, 1.001f)]
	public float FootMiddlePosition = 0.5f;

	[FPD_Suffix(-45f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "°", true, 0)]
	[Space(5f)]
	public float AnkleYawCorrection;

	private bool _StepSent = true;

	private float _StepSentAt = -100f;

	private float _RaiseSentAt = -100f;

	private bool _OppositeLegStepped = true;

	private float _ToConfirmStepEvent;

	private Vector3 _SourceIKPosUnchangedY;

	private Vector3 _SourceIKPos;

	public Vector3 _FinalIKPos;

	private Quaternion _SourceIKRot;

	private Quaternion _FinalIKRot;

	private bool customOverwritingIKPos;

	private Vector3 customOverwritePos = Vector3.zero;

	private bool customOverwritingIKRot;

	private Quaternion customOverwriteRot = Quaternion.identity;

	private bool _wasFixedCalibrateAnimationCaptured;

	private bool _wasGrounded = true;

	private Vector3 _ungroundLocalIKCache;

	private bool _overwrittenSourceIKPos;

	public RaycastHit legGroundHit;

	public RaycastHit lastGroundHitWithTarget;

	private Vector3 previousAnkleAlignedOnGroundHitWorldPos;

	private Vector3 ankleAlignedOnGroundHitRootLocal;

	private Quaternion ankleAlignedOnGroundHitRotation;

	private RaycastHit replacementHit;

	private bool _UsingEmptyRaycast;

	private bool _UsingCustomRaycast;

	private bool _disableSourceRaycast;

	private float _CustomRaycastBlendIn;

	private RaycastHit _CustomRaycastHit;

	private Vector3 _PreviousCustomRaycastingStartIKPos;

	private Vector3 _PreviousCustomRaycastingIKPos;

	private bool _noRaycast_skipFeetCalcs;

	public bool G_AttachPossible
	{
		get
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			if (RaycastHitted)
			{
				return C_Local_MidFootPosVsGroundHit.y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel;
			}
			return false;
		}
	}

	public bool _Glue_AskingForDetach { get; private set; }

	public float BelowFootRange => ScaleRef * _C_DynamicYScale * 0.2f;

	private GlueAttachementHandler.LegTransitionAnimation G_LegAnimation => G_AttachementHandler.legMoveAnimation;

	public Vector3 G_GluePosition => _GluePosition;

	public float G_GlueAnimationBlend => G_AttachementHandler.glueAnimationBlend;

	public float G_GlueInternalTransition => G_AttachementHandler.attachTransitionProgress;

	public float G_LastAttachCompleteTime => G_AttachementHandler.legMoveAnimation.lastAttachCompleteTime;

	public float G_GlueInternalTransitionLastFrame => G_AttachementHandler.attachTransitionProgressLastFrame;

	public float G_LastLegMoveDistanceFactor => G_AttachementHandler.legMoveDistanceFactor;

	public bool G_DuringLegAdjustMovement => G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement;

	public EGlueMode G_HandlerExecutingLegAnimationMode => G_AttachementHandler.legMoveAnimation.LastAnimationGlueMode;

	public bool A_PreWasAligning { get; private set; }

	public bool A_PreWasAligningNearGround { get; private set; }

	public bool A_WasAligning { get; private set; }

	public float A_AligningHelperBlend { get; private set; }

	public float A_LastAlignHeightDiff { get; private set; }

	public float A_LastAlignHeightCompareValue { get; private set; }

	public bool G_Attached { get; private set; }

	public bool G_DuringAttaching => G_LegAnimation.duringLegAdjustMovement;

	public bool G_FadingIn => G_LegAnimation.duringLegAdjustMovement;

	public Vector3 _G_RefernceSwing { get; private set; }

	private float G_GlueTesholdRange => Owner.ScaleReferenceNoScale * GlueThresholdMultiplier * Owner.GlueRangeThreshold * 0.5f;

	private Transform Root => Owner.BaseTransform;

	private float ScaleRef => Owner.ScaleReference;

	private float FloorLevel => Owner._glueingFloorLevel;

	private float DeltaTime => Owner.DeltaTime;

	public LegHelper ThighH => _h_boneStart;

	private FimpIK_Limb.IKBone ThighIK => IKProcessor.StartIKBone;

	public LegHelper LowerLegH => _h_boneMid;

	private FimpIK_Limb.IKBone LowerLegIK => IKProcessor.MiddleIKBone;

	public LegHelper AnkleH => _h_boneEnd;

	public FimpIK_Limb.IKBone AnkleIK => IKProcessor.EndIKBone;

	public Vector3 C_LastMidRefFootWorldPos { get; private set; }

	public Vector3 C_LastMidRefFootRootSpacePos { get; private set; }

	public Vector3 C_Local_MidFootPosVsGroundHit { get; private set; }

	public float C_Local_FootElevateInAnimation { get; private set; }

	public float C_AnkleToHeelWorldHeight { get; private set; }

	public float C_AnimatedAnkleFlatHeight { get; private set; }

	public int PlaymodeIndex { get; private set; }

	public float BlendWeight { get; private set; }

	[field: NonSerialized]
	public Leg NextLeg { get; private set; }

	[field: NonSerialized]
	public HipsReference ParentHub { get; private set; }

	public LegStepAnimatingParameters LegAnimatingSettings => targetLegAnimating;

	public float LegStretchLimit { get; private set; } = 1f;

	public FimpIK_Limb IKProcessor { get; private set; }

	public Vector3 _PreviousFinalIKPos { get; private set; }

	public Vector3 _PreviousFinalIKPosRootLocal { get; private set; }

	public Vector3 _PreviousFinalIKPosForStability { get; private set; }

	public Quaternion _PreviousFinalIKRot { get; private set; }

	public Vector3 _AnimatorStartBonePos { get; private set; }

	public Vector3 _AnimatorMidBonePos { get; private set; }

	public Vector3 _AnimatorEndBonePos { get; private set; }

	public Quaternion _AnimatorStartBoneLocRot { get; private set; }

	public Quaternion _AnimatorMidBoneLocRot { get; private set; }

	public Quaternion _AnimatorEndBoneLocRot { get; private set; }

	public bool RaycastHitted { get; private set; }

	public RaycastHit LastGroundHit => legGroundHit;

	public Vector3 groundHitRootSpacePos { get; private set; }

	public Vector3 lastRaycastingOrigin { get; private set; }

	public Vector3 lastRaycastingEndPoint { get; private set; }

	public Vector3 ankleAlignedOnGroundHitWorldPos { get; private set; }

	public bool User_RaycastHittedSource { get; private set; }

	public float raycastSlopeAngle { get; private set; }

	public Vector3 InitialPosInRootSpace { get; private set; }

	public List<Leg> Legs => Owner.Legs;

	public bool Glue_CheckDetachement()
	{
		bool flag = Glue_Conditions_Detach();
		if (!flag)
		{
			flag = Glue_Conditions_DetachForced();
		}
		_Glue_AskingForDetach = flag;
		return flag;
	}

	public bool Glue_CheckIdleDetachementConfirm()
	{
		if (Owner._glueModeExecuted != 0)
		{
			return true;
		}
		if (hasOppositeleg)
		{
			Leg oppositeLeg = GetOppositeLeg();
			if (Glue_CheckOppositeLegMovementRestriction(oppositeLeg))
			{
				return false;
			}
		}
		return true;
	}

	private bool Glue_Conditions_Attach()
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		if (!Owner.IsGrounded)
		{
			return false;
		}
		if (_glueTargetBlend < 0.0001f)
		{
			return false;
		}
		if (!RaycastHitted)
		{
			return false;
		}
		if (G_CustomForceNOTDetach)
		{
			return true;
		}
		if (_gluingCulldown > 0f)
		{
			return false;
		}
		if (G_CustomForceAttach)
		{
			return true;
		}
		if (Owner.DontGlueAttachIfTooNearOppositeLeg > 0f && hasOppositeleg)
		{
			Vector3 val = ToRootLocalSpace(_PreviousFinalIKPos);
			Leg oppositeLeg = GetOppositeLeg();
			Vector3 val2 = ToRootLocalSpace(oppositeLeg._PreviousFinalIKPos);
			float num = Owner.DontGlueAttachIfTooNearOppositeLeg * Owner.ScaleReference;
			if (Vector2.Distance(new Vector2(val.x, val.z), new Vector2(val2.x, val2.z)) < num)
			{
				return false;
			}
		}
		if (G_HandlerExecutingLegAnimationMode == EGlueMode.Moving)
		{
			bool flag = false;
			float y = C_Local_MidFootPosVsGroundHit.y;
			if (y > FloorLevel)
			{
				if (y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel)
				{
					flag = true;
				}
			}
			else
			{
				flag = true;
			}
			if (!flag)
			{
				return false;
			}
		}
		if (G_CustomForceNOTAttach)
		{
			return false;
		}
		if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f && Owner.DesiredMovementDirection != Vector3.zero)
		{
			Vector3 val3 = ToRootLocalSpaceDir(Owner.DesiredMovementDirection);
			Vector3 g_RefernceSwing = _G_RefernceSwing;
			if (Vector3.Dot(((Vector3)(ref val3)).normalized, ((Vector3)(ref g_RefernceSwing)).normalized) > 1f - Owner.SwingHelper)
			{
				return false;
			}
		}
		return true;
	}

	private bool Glue_CheckOppositeLegMovementRestriction(Leg oppositeLeg)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (!RaycastHitted)
		{
			return false;
		}
		if (!Owner.IsGrounded)
		{
			return false;
		}
		if (C_Local_MidFootPosVsGroundHit.y > BelowFootRange)
		{
			return false;
		}
		if (G_CustomForceNOTDetach)
		{
			return true;
		}
		if (!oppositeLeg.RaycastHitted)
		{
			return false;
		}
		if (oppositeLeg.C_Local_MidFootPosVsGroundHit.y > oppositeLeg.BelowFootRange)
		{
			return false;
		}
		if (oppositeLeg.G_GlueInternalTransition < LegAnimatingSettings.AllowDetachBefore)
		{
			return true;
		}
		return false;
	}

	private Leg GetOppositeLeg()
	{
		if (OppositeLegIndex < 0)
		{
			return null;
		}
		if (OppositeLegIndex >= Owner.Legs.Count)
		{
			return null;
		}
		return Owner.Legs[OppositeLegIndex];
	}

	private void Gluing_SetCulldown(float minDuration = 0.01f)
	{
		_gluingCulldown = Mathf.Max(_gluingCulldown, minDuration + (0.02f - Owner.GlueFadeOutSpeed * 0.03f));
	}

	public bool Glue_Conditions_Detach()
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		if (G_CustomForceNOTDetach)
		{
			return flag;
		}
		if (G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement)
		{
			return false;
		}
		if (!Glue_Conditions_Attach())
		{
			flag = true;
		}
		if (Owner.AnimateFeet && lastFootForwardAngleDiffABS > Owner.UnglueOn && !G_JustLanded)
		{
			if (Owner._glueModeExecuted != 0)
			{
				Gluing_SetCulldown();
			}
			flag = true;
		}
		if (!flag && !G_JustLanded)
		{
			Vector3 val = Vector3.zero;
			if (GluePointOffset != Vector2.zero)
			{
				val = -GetGluePointOffset();
			}
			if (Vector3.Distance(ankleAlignedOnGroundHitRootLocal + val, _GlueLastAttachPositionRootLocal) > G_GlueTesholdRange)
			{
				if (Owner._glueModeExecuted != 0)
				{
					Gluing_SetCulldown();
				}
				flag = true;
			}
		}
		return flag;
	}

	public Vector3 GetGluePointOffset()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		float num = Owner.ScaleReferenceNoScale * Owner.GlueRangeThreshold;
		return Owner.RootToWorldSpaceVec(new Vector3(GluePointOffset.x * num, 0f, GluePointOffset.y * num));
	}

	private bool Glue_Conditions_DetachForced()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (G_CustomForceDetach)
		{
			return true;
		}
		if (G_RequestRepose != 0)
		{
			if (G_RequestRepose != GlueReposeRequest.ReposeIfFar)
			{
				G_RequestRepose = GlueReposeRequest.None;
				return true;
			}
			G_RequestRepose = GlueReposeRequest.None;
			if (G_Attached && Vector3.Distance(_GluePosition, ankleAlignedOnGroundHitWorldPos) > ScaleRef * 0.1f)
			{
				return true;
			}
		}
		return false;
	}

	private void ExtraProcessingApply()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (G_LegAnimation.LegAdjustementYOffset != 0f)
		{
			_FinalIKPos += RootSpaceToWorldVec(new Vector3(0f, G_LegAnimation.LegAdjustementYOffset * LegRaiseMultiplier * _glueTargetBlend, 0f));
		}
		if (Owner.AnimateFeet)
		{
			PostCalculate_LimitFootYaw();
		}
	}

	private void ExtraIKPostProcessingApply()
	{
		if (Owner._stepPointsOverlapRadius > 0f)
		{
			PostCalculate_FeetOverlapRadius();
		}
		if (Owner.FeetYOffset != 0f)
		{
			PostCalculate_FeetYOffset();
		}
	}

	public void PostCalculate_LimitFootYaw()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ankleAlignedOnGroundHitRotation * AnkleIK.forward;
		val = ToRootLocalSpaceDir(val);
		val.y = 0f;
		val = RootSpaceToWorldVec(val);
		Vector3 worldDir = _FinalIKRot * AnkleIK.forward;
		val = ToRootLocalSpaceDir(val);
		val.y = 0f;
		worldDir = ToRootLocalSpaceDir(worldDir);
		worldDir.y = 0f;
		float num = (lastFootForwardAngleDiffABS = Mathf.Abs(Vector3.SignedAngle(((Vector3)(ref val)).normalized, ((Vector3)(ref worldDir)).normalized, Vector3.up)));
		if (Owner.LimitFeetYaw > 0f && Owner.LimitFeetYaw < 90f && num > Owner.LimitFeetYaw)
		{
			float num2 = num - Owner.LimitFeetYaw;
			Quaternion val2 = (A_WasAligning ? ankleAlignedOnGroundHitRotation : AnkleIK.srcRotation);
			_FinalIKRot = Quaternion.LerpUnclamped(val2, _FinalIKRot, 1f - num2 / (90f - Owner.LimitFeetYaw));
		}
	}

	private void PostCalculate_FeetOverlapRadius()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		float num = Owner._stepPointsOverlapRadius * GlueThresholdMultiplier;
		Vector3 val = ToRootLocalSpace(IKProcessor.IKTargetPosition);
		Leg leg = Owner.Legs[0];
		while (leg != null)
		{
			if (leg == this)
			{
				leg = leg.NextLeg;
				continue;
			}
			Vector3 val2 = ToRootLocalSpace(leg.IKProcessor.IKTargetPosition);
			Vector2 val3 = new Vector2(val2.x, val2.z) - new Vector2(val.x, val.z);
			float magnitude = ((Vector2)(ref val3)).magnitude;
			if (magnitude < num)
			{
				Vector2 val4 = -val3 * (num - magnitude) * 2f;
				FimpIK_Limb iKProcessor = IKProcessor;
				iKProcessor.IKTargetPosition += RootSpaceToWorldVec(new Vector3(val4.x, 0f, val4.y));
			}
			leg = leg.NextLeg;
		}
	}

	private void PostCalculate_FeetYOffset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		FimpIK_Limb iKProcessor = IKProcessor;
		iKProcessor.IKTargetPosition += _FinalIKRot * (Owner.FeetYOffset * Owner.Scale * A_AligningHelperBlend * AnkleIK.up);
	}

	private void AlignStep_Init()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		A_PreWasAligning = false;
		A_PreWasAligningNearGround = false;
		A_WasAligning = false;
		A_AligningHelperBlend = 0f;
		A_LastTargetAlignRot = BoneEnd.rotation;
		A_LastApppliedAlignRot = BoneEnd.rotation;
		A_PreIKPosForGluing = _FinalIKPos;
	}

	private void AlignStep_CheckAlignStatePre()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		A_PreIKPosForGluing = _FinalIKPos;
		if (_noRaycast_skipFeetCalcs)
		{
			return;
		}
		bool flag = false;
		A_PreWasAligningNearGround = false;
		if (RaycastHitted)
		{
			float hips_StepHeightAdjustOffset = ParentHub._Hips_StepHeightAdjustOffset;
			hips_StepHeightAdjustOffset = ((!(hips_StepHeightAdjustOffset < 0f)) ? 0f : (hips_StepHeightAdjustOffset * -0.03f));
			A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
			A_LastAlignHeightCompareValue = ScaleRef * (0.002f + Owner.AnimationFloorLevel) + hips_StepHeightAdjustOffset;
			if (Owner.FootAlignRapidity > 0.9999f)
			{
				if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
				{
					flag = true;
					A_PreWasAligningNearGround = true;
				}
			}
			else if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue + ScaleRef * (0.04f + (1f - Owner.FootAlignRapidity) * 0.04f))
			{
				A_PreWasAligningNearGround = true;
				if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
				{
					flag = true;
				}
			}
		}
		else
		{
			A_LastAlignHeightDiff = 100f;
		}
		A_PreWasAligning = flag;
		if (flag)
		{
			Vector3 val = ankleAlignedOnGroundHitWorldPos;
			if (A_AligningHelperBlend > 0.99f)
			{
				_FinalIKPos = val;
			}
			else
			{
				_FinalIKPos = Vector3.Lerp(_FinalIKPos, val, A_AligningHelperBlend * 8f);
			}
			A_PreIKPosForGluing = val;
		}
		else if (A_AligningHelperBlend > 0.01f)
		{
			_FinalIKPos = Vector3.Lerp(_FinalIKPos, RootSpaceToWorld(A_LastApppliedAlignPosLocal), A_AligningHelperBlend);
		}
	}

	private void AlignStep_ValidateFootRotation()
	{
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		if (!Owner.AnimateFeet || _noRaycast_skipFeetCalcs)
		{
			return;
		}
		if (A_PreWasAligningNearGround)
		{
			float num = Owner.FootRotationBlend * A_AligningHelperBlend;
			if (A_LastElevateH < 0.02f)
			{
				if (num >= 1f)
				{
					A_LastTargetAlignRot = ankleAlignedOnGroundHitRotation;
				}
				else
				{
					A_LastTargetAlignRot = Quaternion.LerpUnclamped(_FinalIKRot, ankleAlignedOnGroundHitRotation, num);
				}
			}
			else
			{
				float num2 = A_LastElevateH / (ScaleRef * 0.15f);
				if (A_LastElevateH > 1f)
				{
					A_LastElevateH = 1f;
				}
				A_LastTargetAlignRot = Quaternion.LerpUnclamped(ankleAlignedOnGroundHitRotation, _FinalIKRot, num2 * num);
			}
		}
		else if (A_AligningHelperBlend < 0.001f)
		{
			A_LastTargetAlignRot = _FinalIKRot;
		}
		else
		{
			A_LastTargetAlignRot = Quaternion.Lerp(_FinalIKRot, A_LastTargetAlignRot, A_AligningHelperBlend);
		}
		if (Owner.FootAlignRapidity >= 1f)
		{
			A_LastApppliedAlignRot = A_LastTargetAlignRot;
		}
		else
		{
			A_LastApppliedAlignRot = Quaternion.Lerp(A_LastApppliedAlignRot, A_LastTargetAlignRot, DeltaTime * (8f + Owner.FootAlignRapidity * 26f));
		}
		_FinalIKRot = A_LastApppliedAlignRot;
	}

	private void AlignStep_OnGroundAlign()
	{
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		if (_noRaycast_skipFeetCalcs)
		{
			A_WasAligning = A_PreWasAligning;
			if (A_PreWasAligning)
			{
				if (A_AligningHelperBlend < 0.05f)
				{
					A_AligningHelperBlend = 0.05f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
				if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
				{
					A_WasFullAlign = true;
					if (!Owner.UseGluing)
					{
						SendStepEvent();
					}
				}
			}
			else
			{
				if (A_AligningHelperBlend > 0.5f)
				{
					A_AligningHelperBlend = 0.5f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 14f);
			}
			if (A_AligningHelperBlend < 0.65f)
			{
				A_WasFullAlign = false;
			}
			return;
		}
		A_aligningBlendByGluing = 1f;
		if (Owner.UseGluing)
		{
			A_aligningBlendByGluing = 1f - _glueTargetBlend * G_GlueAnimationBlend;
		}
		if (A_PreWasAligning)
		{
			if (A_WasAligning)
			{
				A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
			}
			float num = A_aligningBlendByGluing * A_AligningHelperBlend;
			if (num >= 1f)
			{
				_FinalIKPos = ankleAlignedOnGroundHitWorldPos;
			}
			else
			{
				_FinalIKPos = Vector3.LerpUnclamped(_FinalIKPos, ankleAlignedOnGroundHitWorldPos, num);
			}
			if (A_AligningHelperBlend < 0.05f)
			{
				A_AligningHelperBlend = 0.05f;
			}
			A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
			if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
			{
				A_WasFullAlign = true;
				if (!Owner.UseGluing)
				{
					SendStepEvent();
				}
			}
			A_LastApppliedAlignPosLocal = ToRootLocalSpace(_FinalIKPos);
		}
		else
		{
			A_PreviousRelevantAnklePos = _SourceIKPosUnchangedY;
			if (A_AligningHelperBlend > 0.75f)
			{
				A_AligningHelperBlend = 0.75f;
			}
			A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 18f);
		}
		if (A_AligningHelperBlend < 0.6f)
		{
			A_WasFullAlign = false;
		}
		A_LastApppliedAlignPos = _FinalIKPos;
		A_WasAligning = A_PreWasAligning;
	}

	private void AlignStep_LegElevation()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.LegElevateBlend < 0.001f)
		{
			return;
		}
		if (_noRaycast_skipFeetCalcs)
		{
			A_LastElevation = Vector3.zero;
			return;
		}
		float scaleRef = ScaleRef;
		float num = groundHitRootSpacePos.y - A_LastSuddenSmoothYOffset - ParentHub._Hips_StepHeightAdjustOffset;
		float num2 = Owner.AnimationFloorLevel * scaleRef;
		float c_Local_FootElevateInAnimation = C_Local_FootElevateInAnimation;
		if (c_Local_FootElevateInAnimation > num2 && num > 0.001f * scaleRef + num2 + 0.1f)
		{
			c_Local_FootElevateInAnimation -= num2;
			float num3 = c_Local_FootElevateInAnimation;
			float num4 = c_Local_FootElevateInAnimation - num;
			float num5 = scaleRef * 0.015f;
			float num6 = scaleRef * 0.35f;
			float num7 = num4 / num6;
			num7 = Mathf.Clamp01(num7);
			if (num4 > num5)
			{
				num3 *= 1f - num7;
				if (A_AligningFor < 0f)
				{
					A_AligningFor = DeltaTime;
				}
				if (A_AligningFor < 0.3f)
				{
					A_AligningFor += DeltaTime;
				}
				else
				{
					A_AligningFor = 0.3f;
				}
			}
			else if (A_AligningFor > 0f)
			{
				A_AligningFor -= DeltaTime;
			}
			else
			{
				A_AligningFor = 0f;
			}
			float num8 = num3;
			float num9 = scaleRef * Mathf.LerpUnclamped(0.1f, 0.9f, Owner.LegElevateHeightLimit);
			if (num8 > num9)
			{
				num8 = num9;
			}
			if (groundHitRootSpacePos.y > 0f)
			{
				float num10 = ScaleRef * 0.2f;
				if (num10 > 0f)
				{
					float num11 = groundHitRootSpacePos.y / num10;
					if (num11 > 0.8f)
					{
						num8 = Mathf.LerpUnclamped(num8, 0f, Mathf.InverseLerp(0.8f, 1.1f, num11));
					}
				}
			}
			if (Mathf.Abs(num8 - A_LastElevateH) > scaleRef * Adj_A_ElevateSpeedupMargin)
			{
				A_LastElevateH = Mathf.Lerp(A_LastElevateH, num8, DeltaTime * Adj_A_ElevateLerpSpeedAfter);
			}
			else
			{
				A_LastElevateH = Mathf.Lerp(A_LastElevateH, num8, DeltaTime * Adj_A_ElevateLerpSpeedStart);
			}
			if (A_LastElevateH < 0f)
			{
				A_LastElevateH = 0f;
			}
		}
		else
		{
			A_LastElevateH = Mathf.SmoothDamp(A_LastElevateH, 0f, ref _sd_A_Elev, 0.02f, 100000f, DeltaTime);
		}
		A_LastElevation = RootSpaceToWorldVec(new Vector3(0f, A_LastElevateH * Owner.LegElevateBlend * A_aligningBlendByGluing, 0f));
		_FinalIKPos += A_LastElevation;
	}

	private void AlignStep_SmoothSuddenSteps()
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.SmoothSuddenSteps < 0.0001f)
		{
			return;
		}
		if (_noRaycast_skipFeetCalcs || G_Attached)
		{
			A_WasAligningFrameBack = A_WasAligning;
			A_WasSmoothing = false;
			return;
		}
		float scaleRef = ScaleRef;
		if (A_WasAligning || A_WasAligningFrameBack)
		{
			if (!A_WasAligning)
			{
				A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
			}
			Vector3 val = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
			Vector3 val2 = ((!A_WasSmoothing) ? ToRootLocalSpace(A_PreviousRelevantAnklePos) : ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos));
			float num = val2.y - val.y;
			num = Mathf.Abs(num);
			float num2 = scaleRef * 0.006f;
			if ((raycastSlopeAngle < 17f || raycastSlopeAngle > 80f || Owner.RaycastShape == ERaycastMode.Spherecast) && num > num2)
			{
				float num3 = num / (scaleRef * 0.275f);
				if (num3 > 1f)
				{
					num3 = 1f;
				}
				if (num3 > Mathf.LerpUnclamped(0.25f, 0.1f, Owner.SmoothSuddenSteps))
				{
					float num4 = Mathf.LerpUnclamped(0.3f, 0.1f, Owner.SmoothSuddenSteps);
					if (A_lastSuddenSmoothingDiff == 0f || A_SuddenSmoothing < num3)
					{
						A_lastSuddenSmoothingDiff = num;
						A_LastAlignRootSpacePos = ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos);
						num4 *= 0.7f;
					}
					else if (Owner.SmoothSuddenSteps < 0.5f)
					{
						float num5 = Mathf.LerpUnclamped(0.5f, 0f, Owner.SmoothSuddenSteps);
						A_lastSuddenSmoothingDiff = Mathf.LerpUnclamped(A_lastSuddenSmoothingDiff, num, num5);
					}
					A_SuddenSmoothing += Mathf.Clamp01(A_lastSuddenSmoothingDiff / (scaleRef * num4));
					float num6 = 0.85f + Owner.SmoothSuddenSteps * 0.165f;
					if (A_SuddenSmoothing > num6)
					{
						A_SuddenSmoothing = num6;
					}
				}
			}
		}
		if (A_SuddenSmoothing > 0f)
		{
			Vector3 val3 = ToRootLocalSpace(_FinalIKPos);
			A_LastSuddenSmoothYOffset = val3.y;
			A_SuddenSmoothing -= Owner.DeltaTime * Mathf.LerpUnclamped(60f, 7.5f, Owner.SmoothSuddenSteps);
			val3.y = Mathf.Lerp(val3.y, A_LastAlignRootSpacePos.y, A_SuddenSmoothing);
			A_LastSuddenSmoothYOffset = val3.y - A_LastSuddenSmoothYOffset;
			A_LastSmoothTargetedPosLocal = val3;
			A_SmoothedIKPos = RootSpaceToWorld(val3);
			_FinalIKPos = A_SmoothedIKPos;
			if (A_SuddenSmoothing < 0f)
			{
				A_SuddenSmoothing = 0f;
			}
			A_WasSmoothing = true;
		}
		else
		{
			A_LastSuddenSmoothYOffset = 0f;
			A_WasSmoothing = false;
		}
	}

	private void AlignStep_Complete()
	{
		A_WasAligningFrameBack = A_WasAligning;
	}

	private void Gluing_Init()
	{
		G_AttachementHandler = new GlueAttachementHandler(this);
		Glue_Reset(initializing: true);
	}

	public void Glue_Reset(bool initializing)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		G_Attached = false;
		if (initializing)
		{
			_GlueLastAttachPosition = BoneEnd.position;
			_GlueLastAttachRotation = BoneEnd.rotation;
			_GluePosition = BoneEnd.position;
			_GlueLastAttachPositionRootLocal = ToRootLocalSpace(BoneEnd.position);
			_G_LastPreGlueSourceLocalIKPos = _GlueLastAttachPosition;
			_G_PreGlueSourceLocalIKPos = _SourceIKPos;
			A_PreIKPosForGluing = BoneEnd.position;
			_G_LasGroundedPosLocal = _GlueLastAttachPositionRootLocal;
		}
		GlueAttachement g_Attachement = default(GlueAttachement);
		g_Attachement.PosInAttachementLocal = _FinalIKPos;
		g_Attachement.RotInAttachementLocal = _FinalIKRot;
		G_Attachement = g_Attachement;
		_G_RefernceSwing = Vector3.zero;
		_G_WasDisabled = true;
		G_AttachementHandler.Reset(initializing);
	}

	private void Gluing_Update()
	{
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		_glueTargetBlend = Owner.GlueBlend * ExtraGluingBlend * Owner.RagdolledDisablerBlend * Owner.NotSlidingBlend;
		if (Owner.GlueOnlyOnIdle)
		{
			_glueTargetBlend *= 1f - Owner.IsMovingBlend;
		}
		if (Owner.IsGrounded)
		{
			if (Owner.GroundedTime < 0.25f)
			{
				G_JustLanded = true;
				_glueTargetBlend *= 0.1f + Mathf.InverseLerp(0f, 0.25f, Owner.GroundedTime) * 0.9f;
			}
			else
			{
				G_JustLanded = false;
			}
		}
		else
		{
			G_JustLanded = false;
			_glueTargetBlend *= Owner.IsGroundedBlend;
		}
		if (_glueTargetBlend < 0.0001f)
		{
			_glueTargetBlend = 0f;
			_G_WasDisabled = true;
			return;
		}
		if (_G_WasDisabled)
		{
			Glue_Reset(initializing: false);
			_G_WasDisabled = false;
		}
		if (_gluingCulldown > 0f)
		{
			_gluingCulldown -= Owner.DeltaTime;
		}
		if (!Owner.IsGrounded)
		{
			if (_G_WasGrounded)
			{
				_G_WasGrounded = false;
				_G_LasGroundedPosLocal = ToRootLocalSpace(_GluePosition);
				_G_LasGroundedRotLocal = _GlueRotation;
				G_AttachementHandler.legMoveAnimation.Reset();
			}
			_GluePosition = RootSpaceToWorld(_G_LasGroundedPosLocal);
			_GlueRotation = _G_LasGroundedRotLocal;
			return;
		}
		_G_WasGrounded = true;
		if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f)
		{
			Vector3 val = AnkleH.LastKeyframeRootPos - _G_LastPreGlueSourceLocalIKPos;
			if (((Vector3)(ref val)).magnitude > Owner.ScaleReferenceNoScale * 0.001f)
			{
				_G_LastPreGlueSourceLocalIKPos = _G_PreGlueSourceLocalIKPos;
			}
			_G_PreGlueSourceLocalIKPos = AnkleH.LastKeyframeRootPos;
			_G_RefernceSwing = Vector3.SmoothDamp(_G_RefernceSwing, val * 2f, ref _G_sd_RefSwing, 0.04f, 100000f, Owner.DeltaTime);
		}
		else
		{
			_G_RefernceSwing = Vector3.zero;
			_G_sd_RefSwing = Vector3.zero;
		}
		_Glue_AskingForDetach = false;
		if (G_Attached)
		{
			bool flag = !Glue_CheckDetachement();
			if (!flag)
			{
				flag = !Glue_CheckIdleDetachementConfirm();
			}
			if (!flag)
			{
				G_Attached = flag;
				G_AttachementHandler.OnLegRequireRepose();
				flag = Glue_Conditions_Attach();
			}
			else if (!Glue_Conditions_Attach())
			{
				flag = false;
			}
			if (flag)
			{
				G_AttachementHandler.TransitionToGlueAnimation();
			}
			else
			{
				G_AttachementHandler.TransitionToDisableGlueAnimation();
			}
		}
		else if (Glue_Conditions_Attach())
		{
			G_AttachementHandler.TransitionToGlueAnimation();
		}
		else
		{
			G_AttachementHandler.TransitionToDisableGlueAnimation();
		}
		if (G_InstantReglue)
		{
			G_AttachementHandler.SheduleInstantTransition();
			G_InstantReglue = false;
		}
		G_AttachementHandler.UpdateTransitioning(G_DuringAttaching);
		Gluing_UpdateAttachement();
	}

	private bool Glue_TriggerFinalAttach()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)((RaycastHit)(ref legGroundHit)).transform) || _UsingEmptyRaycast)
		{
			G_Attached = true;
			G_Attachement = new GlueAttachement(this, legGroundHit);
			return true;
		}
		return false;
	}

	private void Gluing_UpdateAttachement()
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!G_Attachement.NoTransform && (Object)(object)G_Attachement.AttachedTo == (Object)null)
		{
			G_Attachement = default(GlueAttachement);
			G_AttachementHandler.OnLegRequireRepose();
			G_Attached = false;
		}
		if (!G_Attached)
		{
			_GluePosition = G_AttachementHandler.GetGluePosition();
			Gluing_DragStretchApply();
			if (Owner.AnimateFeet)
			{
				if (Owner.LimitFeetYaw > 0f)
				{
					_GlueRotation = G_AttachementHandler.GetGlueRotation();
				}
				else
				{
					_GlueRotation = A_LastApppliedAlignRot;
				}
			}
		}
		else
		{
			_GlueLastAttachPosition = G_Attachement.GetRelevantAlignedHitPoint(this);
			_GlueLastAttachPositionRootLocal = ToRootLocalSpace(_GlueLastAttachPosition);
			Quaternion relevantAttachementRotation = G_Attachement.GetRelevantAttachementRotation();
			_GlueLastAttachRotation = relevantAttachementRotation;
			_GluePosition = G_AttachementHandler.GetGluePosition();
			Gluing_DragStretchApply();
			if (Owner.AnimateFeet)
			{
				if (Owner.LimitFeetYaw > 0f)
				{
					_GlueRotation = G_AttachementHandler.GetGlueRotation();
				}
				else
				{
					_GlueRotation = A_LastApppliedAlignRot;
				}
			}
		}
		G_AttachementHandler.PostUpdate();
	}

	private void Gluing_DragStretchApply()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.AllowGlueDrag > 0f)
		{
			float stretchValue = IKProcessor.GetStretchValue(_GluePosition - Owner._LastAppliedHipsStabilityOffset);
			float num = Mathf.LerpUnclamped(1f, 0.825f, Owner.AllowGlueDrag);
			float num2 = num * Mathf.LerpUnclamped(1f, LegStretchLimit, Owner.AllowGlueDrag);
			if (num2 > num)
			{
				num2 = num;
			}
			Vector3 val = _GluePosition;
			if (stretchValue > num2 * 1.1f)
			{
				float num3 = (stretchValue - num2 * 1.1f) * 2f * Mathf.Min(1f, Owner.AllowGlueDrag);
				val = ((!A_PreWasAligning) ? Vector3.Lerp(_GluePosition, A_PreIKPosForGluing, num3) : Vector3.Lerp(_GluePosition, ankleAlignedOnGroundHitWorldPos, num3));
			}
			Vector3 val2 = val - _GluePosition;
			G_GlueDragOffset = Vector3.Lerp(G_GlueDragOffset, val2, Owner.DeltaTime * 14f);
			if (float.IsNaN(G_GlueDragOffset.x) || float.IsNaN(G_GlueDragOffset.z))
			{
				G_GlueDragOffset = Vector3.zero;
			}
		}
	}

	private void Gluing_ApplyCoords()
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (_glueTargetBlend < 0.0001f)
		{
			return;
		}
		float num = _glueTargetBlend * G_AttachementHandler.glueAnimationBlend;
		if (num >= 1f)
		{
			_FinalIKPos = _GluePosition + G_GlueDragOffset;
			if (Owner.AnimateFeet)
			{
				_FinalIKRot = _GlueRotation;
			}
		}
		else
		{
			_FinalIKPos = Vector3.LerpUnclamped(A_PreIKPosForGluing, _GluePosition + G_GlueDragOffset, num);
			if (Owner.AnimateFeet)
			{
				_FinalIKRot = Quaternion.LerpUnclamped(_FinalIKRot, _GlueRotation, num);
			}
		}
	}

	private void Controll_Init()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		C_AnkleToHeelRootSpace = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
		ThighH.Calibrate(this, ThighH.Bone.position);
		AnkleH.Calibrate(this, AnkleH.Bone.position);
	}

	private Vector3 TransformVectorAnkleWithAlignedRotation(Vector3 offset)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return ankleAlignedOnGroundHitRotation * Vector3.Scale(offset, BoneEnd.lossyScale);
	}

	private void Controll_Calibrate()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		_C_DynamicYScale = Owner.DynamicYScale;
		ThighH.Calibrate(this, ThighH.Bone.position);
		AnkleH.Calibrate(this, _SourceIKPosUnchangedY);
		Vector3 ankleToHeel = AnkleToHeel;
		Vector3 val = TransformVectorAnkleWithAlignedRotation(AnkleToHeel);
		C_LastFootEndWorldPos = _SourceIKPosUnchangedY + TransformVectorAnkleWithAlignedRotation(ankleToHeel);
		C_LastFootEndRootSpacePos = ToRootLocalSpace(C_LastFootEndWorldPos);
		C_AnimatedAnkleFlatHeight = ToRootLocalSpaceDir(val).y;
		C_LastHeelWorldPos = _SourceIKPosUnchangedY + val;
		C_LastHeelRootSpacePos = ToRootLocalSpace(C_LastHeelWorldPos);
		if (Owner.AnimateFeet)
		{
			C_LastMidRefFootWorldPos = Vector3.LerpUnclamped(C_LastFootEndWorldPos, C_LastHeelWorldPos, FootMiddlePosition);
			C_LastMidRefFootRootSpacePos = Vector3.LerpUnclamped(C_LastFootEndRootSpacePos, C_LastHeelRootSpacePos, FootMiddlePosition);
		}
		else
		{
			C_LastMidRefFootRootSpacePos = C_LastHeelRootSpacePos;
			C_LastMidRefFootWorldPos = C_LastHeelWorldPos;
		}
		C_Local_MidFootPosVsGroundHit = C_LastMidRefFootRootSpacePos - groundHitRootSpacePos;
		C_Local_FootElevateInAnimation = C_LastMidRefFootRootSpacePos.y - ParentHub._Hips_LastHipsOffset;
		C_Local_AnkleToHeelRotated = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
		Vector3 val2 = BoneEnd.TransformVector(AnkleToHeel);
		C_AnkleToHeelWorldHeight = ((Vector3)(ref val2)).magnitude;
	}

	private Vector3 RootSpaceToWorldVec(Vector3 localVec)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Owner.RootToWorldSpaceVec(localVec);
	}

	private Vector3 RootSpaceToWorld(Vector3 rootLocal)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Owner.RootToWorldSpace(rootLocal);
	}

	private Vector3 ToRootLocalSpaceDir(Vector3 worldDir)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Owner.ToRootLocalSpaceVec(worldDir);
	}

	private Vector3 ToRootLocalSpace(Vector3 worldPos)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Owner.ToRootLocalSpace(worldPos);
	}

	private Vector3 ChangeLocalY(Vector3 worldPos, float targetLocalY)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		worldPos = ToRootLocalSpace(worldPos);
		worldPos.y = targetLocalY;
		return RootSpaceToWorld(worldPos);
	}

	private Vector3 ChangeLocalPosExceptY(Vector3 worldPos, Vector3 targetWorldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		worldPos = ToRootLocalSpace(worldPos);
		Vector3 val = ToRootLocalSpace(targetWorldPos);
		worldPos.x = val.x;
		worldPos.z = val.z;
		return RootSpaceToWorld(worldPos);
	}

	private void Control_StepEventCalcs()
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		StepEventRestore();
		if (!Owner.UseGluing || _StepSent)
		{
			return;
		}
		if (Owner._glueModeExecuted == EGlueMode.Idle)
		{
			if (G_GlueInternalTransition >= 0.85f - Owner.EventExecuteSooner)
			{
				if (_ToConfirmStepEvent > 0.1f)
				{
					SendStepEvent(G_AttachementHandler.legMoveDistanceFactor);
					return;
				}
				float num = Mathf.InverseLerp(1f, 0f, LegAnimatingSettings.RaiseYAxisCurve.Evaluate(G_GlueInternalTransition));
				_ToConfirmStepEvent += DeltaTime * (3f + 3f * num);
			}
			else
			{
				_ToConfirmStepEvent = 0f;
			}
		}
		else
		{
			if (G_HandlerExecutingLegAnimationMode != EGlueMode.Moving || !Owner.SendOnMovingGlue || G_CustomForceNOTAttach)
			{
				return;
			}
			float num2 = FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.5f + A_LastAlignHeightCompareValue * (1.65f + Owner.EventExecuteSooner);
			if (G_CustomForceAttach)
			{
				_ToConfirmStepEvent += DeltaTime * 5f;
				num2 += ScaleRef * 0.1f;
			}
			if (A_LastAlignHeightDiff <= num2)
			{
				if (_ToConfirmStepEvent > 0.2f)
				{
					SendStepEvent(1f, EStepType.MovementGluing);
					_ToConfirmStepEvent = 0f;
					return;
				}
				_ToConfirmStepEvent += DeltaTime;
				if (A_LastAlignHeightDiff < num2 * 0.75f)
				{
					_ToConfirmStepEvent += DeltaTime * 1f;
				}
				if (A_LastAlignHeightDiff < num2 * 0.5f)
				{
					_ToConfirmStepEvent += DeltaTime * 1f;
				}
			}
			else
			{
				_ToConfirmStepEvent = 0f;
			}
		}
	}

	internal void StepEventSentInCustomWay()
	{
		_StepSent = true;
		_StepSentAt = Time.unscaledTime;
	}

	public void InitLegBasics(LegsAnimator creator, int index, Leg nextLeg)
	{
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)creator != (Object)null)
		{
			Owner = creator;
		}
		PlaymodeIndex = index;
		NextLeg = nextLeg;
		LegStretchLimit = 1f;
		BlendWeight = 1f;
		InternalModuleBlendWeight = 1f;
		EnsureAxesNormalization();
		_h_boneStart = new LegHelper(this, BoneStart);
		_h_boneMid = new LegHelper(this, BoneMid);
		_h_boneEnd = new LegHelper(this, BoneEnd);
		_h_boneStart.Child = _h_boneMid;
		_h_boneMid.Child = _h_boneEnd;
		Gluing_Init();
		Reset();
		Controll_Init();
		Raycasting_Init();
		Stability_Init();
		AlignStep_Init();
		RefreshHasOppositeLeg();
		targetLegAnimating = (Object.op_Implicit((Object)(object)CustomLegAnimating) ? CustomLegAnimating.Settings : creator.LegAnimatingSettings);
		ankleAlignedOnGroundHitWorldPos = _FinalIKPos;
	}

	public void RefreshHasOppositeLeg()
	{
		hasOppositeleg = false;
		if (GetOppositeLeg() != null)
		{
			hasOppositeleg = true;
		}
	}

	public void Leg_UpdateParams()
	{
		targetLegAnimating = (Object.op_Implicit((Object)(object)CustomLegAnimating) ? CustomLegAnimating.Settings : Owner.LegAnimatingSettings);
		IK_UpdateParams();
	}

	internal void AssignParentHub(HipsReference hipsReference)
	{
		ParentHub = hipsReference;
	}

	internal void Reset()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		_SourceIKPos = BoneEnd.position;
		_SourceIKRot = BoneEnd.rotation;
		_FinalIKPos = _SourceIKPos;
		_FinalIKRot = _SourceIKRot;
		_PreviousFinalIKPos = _FinalIKPos;
		_PreviousFinalIKRot = _FinalIKRot;
		legGroundHit = default(RaycastHit);
		((RaycastHit)(ref legGroundHit)).point = _FinalIKPos;
		((RaycastHit)(ref legGroundHit)).normal = Owner.Up;
		_PreviousFinalIKPosForStability = _SourceIKPos;
		ankleAlignedOnGroundHitRotation = _SourceIKRot;
		A_LastApppliedAlignRot = _SourceIKRot;
		A_LastTargetAlignRot = _SourceIKRot;
		groundHitRootSpacePos = ToRootLocalSpace(_SourceIKPos);
		_SourceIKPosUnchangedY = groundHitRootSpacePos;
		RaycastHit val = default(RaycastHit);
		((RaycastHit)(ref val)).point = _FinalIKPos;
		((RaycastHit)(ref val)).normal = Owner.Up;
		legGroundHit = val;
		Glue_Reset(initializing: true);
	}

	public void PreCalibrate()
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		BlendWeight *= InternalModuleBlendWeight;
		finalBoneBlend = BlendWeight * Owner._MainBlend;
		if (finalBoneBlend < 0.0001f)
		{
			if (!_G_WasDisabled)
			{
				G_Attached = false;
				G_AttachementHandler.Reset(initializing: false);
				G_Attachement = default(GlueAttachement);
				_G_WasDisabled = true;
				legGroundHit = default(RaycastHit);
				RaycastHitted = false;
			}
		}
		else if (Owner.Calibrate == ECalibrateMode.Calibrate)
		{
			IKProcessor.PreCalibrate();
		}
		else if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
		{
			if (!_wasFixedCalibrateAnimationCaptured)
			{
				IKProcessor.PreCalibrate();
				return;
			}
			BoneStart.localRotation = _AnimatorStartBoneLocRot;
			BoneMid.localRotation = _AnimatorMidBoneLocRot;
			BoneEnd.localRotation = _AnimatorEndBoneLocRot;
		}
	}

	public void CheckAnimatorPose()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		_AnimatorStartBonePos = BoneStart.position;
		_AnimatorMidBonePos = BoneMid.position;
		_AnimatorEndBonePos = BoneEnd.position;
		if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
		{
			_wasFixedCalibrateAnimationCaptured = true;
			_AnimatorStartBoneLocRot = BoneStart.localRotation;
			_AnimatorMidBoneLocRot = BoneMid.localRotation;
			_AnimatorEndBoneLocRot = BoneEnd.localRotation;
		}
	}

	public void BeginLateUpdate()
	{
		if (!(finalBoneBlend < 0.0001f))
		{
			G_CustomForceAttach = false;
			G_CustomForceNOTDetach = false;
			G_CustomForceDetach = false;
			G_CustomForceNOTAttach = false;
			IK_PreUpdate();
			LegStretchLimit = Owner.LimitLegStretch * LegStretchMultiplier;
		}
	}

	public void PreLateUpdate()
	{
		if (!customOverwritingIKPos && (!_G_WasDisabled || !(finalBoneBlend < 0.0001f)))
		{
			Owner.Modules_LegBeforeRaycastingUpdate(this);
			Raycasting_PreLateUpdate();
			Controll_Calibrate();
		}
	}

	public void LateUpdate()
	{
		if (!(finalBoneBlend < 0.0001f) && !customOverwritingIKPos)
		{
			Owner.Modules_Leg_LateUpdate(this);
			AlignStep_CheckAlignStatePre();
			AlignStep_ValidateFootRotation();
			Gluing_Update();
			Gluing_ApplyCoords();
			AlignStep_OnGroundAlign();
			AlignStep_SmoothSuddenSteps();
			AlignStep_LegElevation();
			AlignStep_Complete();
			Control_StepEventCalcs();
			ExtraProcessingApply();
		}
	}

	public void LateUpdate_Apply()
	{
		IK_PostUpdate();
	}

	public void FixedUpdate()
	{
	}

	public float LegLimbLength()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)BoneStart == (Object)null || (Object)(object)BoneMid == (Object)null || (Object)(object)BoneEnd == (Object)null)
		{
			return Owner.HipsToGroundDistance();
		}
		return 0f + Vector3.Distance(BoneStart.position, BoneMid.position) + Vector3.Distance(BoneEnd.position, BoneMid.position);
	}

	public bool HasAllBonesSet()
	{
		if ((Object)(object)BoneStart == (Object)null)
		{
			return false;
		}
		if ((Object)(object)BoneMid == (Object)null)
		{
			return false;
		}
		if ((Object)(object)BoneEnd == (Object)null)
		{
			return false;
		}
		return true;
	}

	public float R(float toRound, int digits = 2)
	{
		return (float)Math.Round(toRound, digits);
	}

	private void SendStepEvent(float factor = 1f, EStepType type = EStepType.IdleGluing)
	{
		if (!_StepSent)
		{
			if (Owner.GroundedTime < 0.1f)
			{
				type = EStepType.OnLanding;
			}
			else if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
			{
				type = EStepType.OnStopping;
			}
			Owner.Events_OnStep(this, factor, type);
			_StepSent = true;
			_StepSentAt = Time.unscaledTime;
			if (hasOppositeleg)
			{
				_OppositeLegStepped = true;
				GetOppositeLeg()._OppositeLegStepped = !Owner.IsMoving;
			}
		}
	}

	private void SendRaiseEvent(float distanceToNew = 1f)
	{
		if (!(Time.unscaledTime - _RaiseSentAt < 0.05f))
		{
			_RaiseSentAt = Time.unscaledTime;
			EStepType type = EStepType.IdleGluing;
			if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
			{
				type = EStepType.OnStopping;
			}
			Owner.Events_OnRaise(this, distanceToNew, type);
		}
	}

	private void StepEventRestore()
	{
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		if (!Owner.UseEvents || !_StepSent || Time.unscaledTime - _StepSentAt < 0.1f || Owner.GroundedTime < 0.1f)
		{
			return;
		}
		if (Owner.UseGluing)
		{
			if (G_AttachementHandler.glueAnimationBlend > 0.5f && G_GlueInternalTransition > 0.25f)
			{
				return;
			}
			if (Owner._glueModeExecuted == EGlueMode.Idle)
			{
				if (!G_DuringAttaching || (Owner.GlueMode == EGlueMode.Automatic && (Owner.IsMoving || Owner.Helper_WasMoving)) || (!Owner.SendOnStopping && Owner.StoppedTime < 0.155f) || G_AttachementHandler.lasGlueModeOnAttaching != 0 || G_AttachementHandler.legMoveDistanceFactor < 0.05f)
				{
					return;
				}
			}
			else
			{
				if ((Owner.GlueMode == EGlueMode.Automatic && !Owner.IsMoving) || Owner.MovingTime < 0.06f || A_PreWasAligning || A_AligningHelperBlend > 0.5f - Owner.EventExecuteSooner || (hasOppositeleg && !GetOppositeLeg()._OppositeLegStepped))
				{
					return;
				}
				float num = (0f - ScaleRef) * 0.2f + FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.75f + A_LastAlignHeightCompareValue * (3f + Owner.EventExecuteSooner);
				if (A_LastAlignHeightDiff < num)
				{
					return;
				}
			}
		}
		else
		{
			if (A_PreWasAligning || A_AligningHelperBlend > 0.05f)
			{
				return;
			}
			if (Owner.IsMovingBlend < 0.05f)
			{
				_StepSent = true;
				return;
			}
			if (!Owner.Helper_WasMoving)
			{
				_StepSent = true;
				return;
			}
			if (!Owner.IsMoving)
			{
				_StepSent = true;
				return;
			}
		}
		_StepSent = false;
	}

	public void IK_Initialize(bool generateNew = true)
	{
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		if (generateNew)
		{
			IKProcessor = new FimpIK_Limb();
		}
		if (Object.op_Implicit((Object)(object)BoneFeet))
		{
			IKProcessor.SetLegWithFeet(BoneStart, BoneMid, BoneEnd, BoneFeet);
		}
		else
		{
			IKProcessor.SetBones(BoneStart, BoneMid, BoneEnd);
		}
		IKProcessor.Init(Owner.BaseTransform);
		IKProcessor.UseEndBoneMapping = false;
		IKProcessor.IKWeight = 1f;
		IKProcessor.IKPositionWeight = 1f;
		IKProcessor.FootRotationWeight = 1f;
		IKProcessor.ManualHintPositionWeight = 0f;
		IKProcessor.FeetStretchSensitivity = 0.9f;
		IKProcessor.FeetFadeQuicker = 1.1f;
		IKProcessor.FeetStretchLimit = 0.8f;
		IKProcessor.HumanoidAnimator = Owner.Mecanim;
		IKProcessor.IsRight = Side == ELegSide.Right;
		_FinalIKPos = IKProcessor.EndIKBone.transform.position;
		_PreviousFinalIKPos = _FinalIKPos;
		_PreviousFinalIKPosForStability = _FinalIKPos;
		_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_FinalIKPos);
		IKProcessor.IKTargetPosition = _FinalIKPos;
		IKProcessor.IKTargetRotation = _FinalIKRot;
	}

	public void AssignCustomIKProcessor(FimpIK_Limb ik)
	{
		IKProcessor = ik;
		IK_Initialize(generateNew: false);
	}

	public void OverrideTargetIKPosition(Vector3? targetIKPos)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!targetIKPos.HasValue)
		{
			customOverwritingIKPos = false;
			return;
		}
		customOverwritingIKPos = true;
		customOverwritePos = targetIKPos.Value;
	}

	public void OverrideTargetIKRotation(Quaternion? targetIKRot)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (!targetIKRot.HasValue)
		{
			if (customOverwritingIKRot)
			{
				IKProcessor.FootRotationWeight = 1f;
			}
			customOverwritingIKRot = false;
		}
		else
		{
			customOverwritingIKRot = true;
			customOverwriteRot = targetIKRot.Value;
		}
	}

	public void OverrideFinalIKPos(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_FinalIKPos = pos;
	}

	public void OverrideFinalAndSourceIKPos(Vector3 pos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		_FinalIKPos = pos;
		_SourceIKPos = pos;
	}

	public Vector3 GetFinalIKPos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _FinalIKPos;
	}

	public Vector3 GetSourceIKPos()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _SourceIKPos;
	}

	public Quaternion GetFinalIKRot()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _FinalIKRot;
	}

	public Quaternion GetSourceIKRot()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _SourceIKRot;
	}

	public void OverrideFinalIKRot(Quaternion rot)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_FinalIKRot = rot;
	}

	public void IK_PreUpdate()
	{
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		IKProcessor.CallPreCalibrate = Owner.Calibrate == ECalibrateMode.Calibrate;
		if (!Owner.IsGrounded)
		{
			if (_wasGrounded)
			{
				_ungroundLocalIKCache = ToRootLocalSpace(_PreviousFinalIKPos);
				_wasGrounded = false;
			}
			_SourceIKPos = RootSpaceToWorld(_ungroundLocalIKCache);
			_SourceIKPos = Vector3.Lerp(_SourceIKPos, IKProcessor.EndIKBone.transform.position, 1f - Owner.IsGroundedBlend);
			_ungroundLocalIKCache = ToRootLocalSpace(_SourceIKPos);
			_SourceIKRot = BoneEnd.rotation;
			_SourceIKPosUnchangedY = _SourceIKPos;
			_FinalIKPos = _SourceIKPos;
			_FinalIKRot = _SourceIKRot;
		}
		else
		{
			_wasGrounded = true;
			if (!_overwrittenSourceIKPos)
			{
				_SourceIKPos = IKProcessor.EndIKBone.transform.position;
			}
			else
			{
				_overwrittenSourceIKPos = false;
			}
			_SourceIKRot = BoneEnd.rotation;
			_SourceIKPosUnchangedY = _SourceIKPos;
			_FinalIKPos = _SourceIKPos;
			_FinalIKRot = _SourceIKRot;
		}
	}

	public void IK_PostUpdate()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		if (customOverwritingIKPos)
		{
			_FinalIKPos = customOverwritePos;
			if (customOverwritingIKRot)
			{
				IKProcessor.FootRotationWeight = 1f;
				_FinalIKRot = customOverwriteRot;
			}
			else
			{
				IKProcessor.FootRotationWeight = 0f;
			}
		}
		else if (G_LegAnimation.LegAdjustementFootAngleOffset != 0f || FootPitchOffset != 0f)
		{
			_FinalIKRot = Quaternion.AngleAxis(G_LegAnimation.LegAdjustementFootAngleOffset + FootPitchOffset, _SourceIKRot * AnkleIK.right) * _FinalIKRot;
		}
		if (float.IsNaN(_FinalIKPos.x) || float.IsNaN(_FinalIKPos.y) || float.IsNaN(_FinalIKPos.z))
		{
			Reset();
			_FinalIKPos = RootSpaceToWorld(InitialPosInRootSpace);
			Gluing_Init();
		}
		_PreviousFinalIKPosForStability = _FinalIKPos;
		IKProcessor.IKTargetPosition = _FinalIKPos;
		IKProcessor.IKTargetRotation = _FinalIKRot;
		if (IKProcessor.IKWeight > 0f)
		{
			if (!Owner.UseCustomIK && LegStretchLimit < 1.1f)
			{
				IKProcessor.ApplyMaxStretchingPreprocessing(LegStretchLimit, 3f);
			}
			ExtraIKPostProcessingApply();
			if (!Owner.UseCustomIK)
			{
				IKProcessor.Update();
			}
		}
		_PreviousFinalIKPos = IKProcessor.IKTargetPosition;
		_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_PreviousFinalIKPos);
		if (Owner.AnimateFeet)
		{
			_PreviousFinalIKRot = IKProcessor.IKTargetRotation;
		}
	}

	public void IK_UpdateParamsBase()
	{
		IKProcessor.IKWeight = Owner._MainBlend * LegBlendWeight * InternalModuleBlendWeight;
		BlendWeight = IKProcessor.IKWeight;
		IKProcessor.InverseHint = InverseHint;
	}

	public void IK_UpdateParams()
	{
		IK_UpdateParamsBase();
		IKProcessor.AutoHintMode = Owner.IKHintMode;
		IKProcessor.FeetStretchSensitivity = 0.7f + 0.6f * FeetSensitivity;
		IKProcessor.FeetFadeQuicker = 0.95f + 0.35f * FeetSensitivity;
		IKProcessor.FeetStretchLimit = 0.8f + 0.2f * FeetSensitivity;
		IKProcessor.disableFeet = !UseFeet;
	}

	public void RandomizeIndividualSettings(float from, float to)
	{
		GlueThresholdMultiplier = Random.Range(Mathf.Lerp(from, to, 0.4f), to);
		LegMoveSpeedMultiplier = Random.Range(from, to);
		LegRaiseMultiplier = Random.Range(from, to);
	}

	public void OverrideAnimatorAnklePosition(Vector3 targetPos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		_overwrittenSourceIKPos = true;
		_AnimatorEndBonePos = targetPos + (Owner._LastAppliedHipsFinalPosition - ParentHub.LastKeyframePosition);
		_SourceIKPos = _AnimatorEndBonePos;
	}

	public void User_OverrideRaycastHit(Transform tr, bool disableSourceRaycast = true)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!_UsingCustomRaycast)
		{
			_CustomRaycastBlendIn = 0f;
			_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
		}
		_disableSourceRaycast = disableSourceRaycast;
		_UsingCustomRaycast = true;
		RaycastHit hit = default(RaycastHit);
		((RaycastHit)(ref hit)).point = tr.position;
		((RaycastHit)(ref hit)).normal = tr.up;
		_CustomRaycastOnBlendIn(hit);
	}

	public void User_OverrideRaycastHit(RaycastHit hit, bool disableSourceRaycast = true)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!_UsingCustomRaycast)
		{
			_CustomRaycastBlendIn = 0f;
			_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
		}
		_disableSourceRaycast = disableSourceRaycast;
		_UsingCustomRaycast = true;
		_CustomRaycastOnBlendIn(hit);
	}

	public void User_RestoreRaycasting()
	{
		if (_UsingCustomRaycast)
		{
			_CustomRaycastBlendIn = 1f;
		}
		_UsingCustomRaycast = false;
		_disableSourceRaycast = false;
	}

	private void _CustomRaycastOnBlendIn(RaycastHit hit)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		_CustomRaycastBlendIn += Owner.DeltaTime * 6f;
		if (_CustomRaycastBlendIn > 1f)
		{
			_CustomRaycastBlendIn = 1f;
		}
		((RaycastHit)(ref hit)).point = Vector3.LerpUnclamped(_PreviousCustomRaycastingStartIKPos, ((RaycastHit)(ref hit)).point, _CustomRaycastBlendIn);
		_CustomRaycastHit = hit;
		_PreviousCustomRaycastingIKPos = ((RaycastHit)(ref hit)).point;
	}

	private void _CustomRaycastOnBlendOut()
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (!_UsingCustomRaycast && !(_CustomRaycastBlendIn <= 0f))
		{
			_CustomRaycastBlendIn -= Owner.DeltaTime * 8f;
			if (_CustomRaycastBlendIn < 0f)
			{
				_CustomRaycastBlendIn = 0f;
			}
			if (!RaycastHitted)
			{
				legGroundHit = _CustomRaycastHit;
				return;
			}
			RaycastHit val = legGroundHit;
			((RaycastHit)(ref val)).point = Vector3.LerpUnclamped(((RaycastHit)(ref val)).point, _PreviousCustomRaycastingIKPos, _CustomRaycastBlendIn);
			((RaycastHit)(ref val)).normal = Vector3.SlerpUnclamped(((RaycastHit)(ref val)).normal, ((RaycastHit)(ref _CustomRaycastHit)).normal, _CustomRaycastBlendIn);
			legGroundHit = val;
		}
	}

	private void Raycasting_Init()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		ankleAlignedOnGroundHitWorldPos = BoneEnd.position;
		raycastSlopeAngle = 0f;
	}

	public void OverrideControlPositionsWithCurrentIKState()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		AnkleH.LastKeyframeRootPos = ToRootLocalSpace(_FinalIKPos);
		_AnimatorEndBonePos = _FinalIKPos;
	}

	public void OverrideSourceIKPos()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		OverrideSourceIKPos(_FinalIKPos);
	}

	public void OverrideSourceIKPos(Vector3 newSrc)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_SourceIKPos = newSrc;
	}

	public void Raycasting_PreLateUpdate()
	{
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		RaycastHitted = false;
		_noRaycast_skipFeetCalcs = false;
		if (!_disableSourceRaycast)
		{
			if (Owner.RaycastStyle == ERaycastStyle.NoRaycasting)
			{
				GenerateZeroFloorRaycastHit();
				CustomRaycastValidate();
				_noRaycast_skipFeetCalcs = true;
				_UsingEmptyRaycast = true;
				ankleAlignedOnGroundHitRotation = _SourceIKRot;
			}
			else
			{
				_UsingEmptyRaycast = false;
				if (Owner.RaycastStyle == ERaycastStyle.StraightDown)
				{
					Raycast_StraightDown();
				}
				else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot)
				{
					Raycast_OriginToFoot();
				}
				else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot_DownOnNeed)
				{
					Raycast_OriginToFoot();
					if (!RaycastHitted)
					{
						Raycast_StraightDown();
					}
				}
				else if (Owner.RaycastStyle == ERaycastStyle.AlongBones)
				{
					Raycast_AlongBones();
					if (!RaycastHitted)
					{
						Raycast_StraightDown();
					}
				}
				if (!RaycastHitted)
				{
					NoRaycastBehaviour();
				}
			}
			User_RaycastHittedSource = RaycastHitted;
			_CustomRaycastOnBlendOut();
		}
		if (_UsingCustomRaycast)
		{
			RaycastHitted = true;
			legGroundHit = _CustomRaycastHit;
			groundHitRootSpacePos = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
			_UsingEmptyRaycast = true;
			_noRaycast_skipFeetCalcs = true;
			_Raycasting_CalculateBasis();
			ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal);
		}
		if (!_noRaycast_skipFeetCalcs)
		{
			if (RaycastHitted)
			{
				lastGroundHitWithTarget = legGroundHit;
				ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal);
			}
			else
			{
				ankleAlignedOnGroundHitRotation = _SourceIKRot;
			}
		}
	}

	private void NoRaycastBehaviour()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.Detach)
		{
			return;
		}
		if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.ZeroFloorSteps)
		{
			_noRaycast_skipFeetCalcs = true;
			_UsingEmptyRaycast = true;
			GenerateZeroFloorRaycastHit();
			ankleAlignedOnGroundHitRotation = _SourceIKRot;
		}
		else if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.KeepAttached)
		{
			if (IKProcessor.GetStretchValue(_PreviousFinalIKPos) > Owner.NoRaycast_KeepAttachedUntilStretch)
			{
				lastGroundHitWithTarget = default(RaycastHit);
			}
			else if (Object.op_Implicit((Object)(object)((RaycastHit)(ref lastGroundHitWithTarget)).transform))
			{
				_noRaycast_skipFeetCalcs = true;
				legGroundHit = lastGroundHitWithTarget;
				RaycastHitted = true;
				_Raycasting_CalculateBasis();
				Vector3 val = ToRootLocalSpace(((RaycastHit)(ref lastGroundHitWithTarget)).point);
				val.y = 0f;
				groundHitRootSpacePos = val;
			}
		}
	}

	private void GenerateZeroFloorRaycastHit()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		Vector3 rootLocal = (ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(_SourceIKPos));
		rootLocal.y = 0f;
		Vector3 point = RootSpaceToWorld(rootLocal);
		((RaycastHit)(ref val)).point = point;
		((RaycastHit)(ref val)).normal = Owner.Up;
		legGroundHit = val;
		RaycastHitted = true;
		groundHitRootSpacePos = rootLocal;
	}

	private void CustomRaycastValidate()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		_Raycasting_CalculateBasis();
		raycastSlopeAngle = 0f;
		A_WasAligning = true;
		A_WasAligningFrameBack = true;
		A_LastTargetAlignRot = _SourceIKRot;
		A_LastApppliedAlignRot = _SourceIKRot;
		A_PreviousRelevantAnklePos = _SourceIKPos;
		A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
		A_LastAlignHeightCompareValue = ScaleRef * 0.002f + ParentHub._Hips_StepHeightAdjustOffset;
	}

	private Vector3 Raycast_RefreshOrigin()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
		return lastRaycastingOrigin = RootSpaceToWorld(lastRootLocalPos);
	}

	private void Raycast_OriginToFoot()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Raycast_RefreshOrigin();
		Vector3 val2 = RootSpaceToWorld(AnkleH.LastKeyframeRootPos) - Owner.Up * C_AnkleToHeelWorldHeight - val;
		float num = ((Vector3)(ref val2)).magnitude * 1.05f;
		((Vector3)(ref val2)).Normalize();
		Vector3 val3 = val + val2 * num;
		if (Physics.Linecast(val, val3, ref legGroundHit, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger))
		{
			CaptureRaycastHitForLeg();
		}
		else
		{
			ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
		}
	}

	private void Raycast_AlongBones()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		Raycast_RefreshOrigin();
		if (DoRaycasting(_AnimatorStartBonePos, _AnimatorMidBonePos))
		{
			CaptureRaycastHitForLeg();
			return;
		}
		Vector3 rayEnd = _AnimatorEndBonePos + (_AnimatorEndBonePos - _AnimatorMidBonePos) * 0.1f;
		if (DoRaycasting(_AnimatorMidBonePos, rayEnd))
		{
			CaptureRaycastHitForLeg();
		}
		else
		{
			ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
		}
	}

	private void Raycast_StraightDown()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastKeyframeRootPos = AnkleH.LastKeyframeRootPos;
		Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
		float num;
		if (Owner.RaycastStartHeight == ERaycastStartHeight.FirstBone)
		{
			lastRootLocalPos = BoneStart.position;
			num = IKProcessor.fullLength;
		}
		else
		{
			lastRootLocalPos.x = lastKeyframeRootPos.x;
			lastRootLocalPos.z = lastKeyframeRootPos.z;
			num = Owner.ScaleReference * (Owner.RaycastStartHeightMul / Root.lossyScale.y);
			if (Owner.RaycastStartHeight == ERaycastStartHeight.StaticScaleReference)
			{
				lastRootLocalPos.y = num;
			}
			lastRootLocalPos = RootSpaceToWorld(lastRootLocalPos);
		}
		lastRaycastingOrigin = lastRootLocalPos;
		Vector3 val = -Owner.Up;
		Vector3 val2 = lastRootLocalPos + val * num;
		float num2 = ScaleRef * Owner.CastDistance;
		Vector3 rayEnd = (lastRaycastingEndPoint = val2 + val * num2);
		if (DoRaycasting(lastRootLocalPos, rayEnd))
		{
			CaptureRaycastHitForLeg();
		}
		else
		{
			ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
		}
	}

	internal bool DoRaycasting(Vector3 origin, Vector3 rayEnd)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		bool flag;
		if (Owner.RaycastShape == ERaycastMode.Linecast)
		{
			flag = Physics.Linecast(origin, rayEnd, ref legGroundHit, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger);
		}
		else
		{
			float num = Owner.ScaleReference * 0.065f * Owner.SpherecastResize;
			Vector3 val = rayEnd - origin;
			float num2 = ((Vector3)(ref val)).magnitude - num;
			flag = Physics.SphereCast(origin, num, ((Vector3)(ref val)).normalized, ref legGroundHit, num2 - num, LayerMask.op_Implicit(Owner.GroundMask), Owner.RaycastHitTrigger);
			if (flag && Owner.SpherecastRealign > 0f)
			{
				Vector3 val2 = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
				val2.x = Mathf.LerpUnclamped(val2.x, AnkleH.LastKeyframeRootPos.x, Owner.SpherecastRealign);
				val2.z = Mathf.LerpUnclamped(val2.z, AnkleH.LastKeyframeRootPos.z, Owner.SpherecastRealign);
				((RaycastHit)(ref legGroundHit)).point = RootSpaceToWorld(val2);
			}
		}
		return flag;
	}

	private void CaptureRaycastHitForLeg()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		RaycastHitted = true;
		groundHitRootSpacePos = ToRootLocalSpace(((RaycastHit)(ref legGroundHit)).point);
		raycastSlopeAngle = Vector3.Angle(Owner.Up, ((RaycastHit)(ref legGroundHit)).normal);
		if (raycastSlopeAngle > 45f)
		{
			RaycastHit val = legGroundHit;
			((RaycastHit)(ref val)).normal = Vector3.Slerp(((RaycastHit)(ref legGroundHit)).normal, Owner.Up, Mathf.InverseLerp(45f, 90f, raycastSlopeAngle) * 0.5f);
			legGroundHit = val;
		}
		_Raycasting_CalculateBasis();
	}

	private void _Raycasting_CalculateBasis()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		previousAnkleAlignedOnGroundHitWorldPos = ankleAlignedOnGroundHitWorldPos;
		ankleAlignedOnGroundHitWorldPos = GetAlignedOnGroundHitPos(groundHitRootSpacePos, ((RaycastHit)(ref legGroundHit)).point, ((RaycastHit)(ref legGroundHit)).normal);
		ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
	}

	private Vector3 GetAlignedOnGroundHitPos(Vector3 rootSpaceHitPos, Vector3 worldHit, Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		Vector3 rootLocal = rootSpaceHitPos;
		rootLocal.y = ToRootLocalSpace(worldHit + normal * C_AnkleToHeelWorldHeight).y;
		return RootSpaceToWorld(rootLocal);
	}

	private Quaternion GetAlignedOnGroundHitRot(Quaternion sourceRotation, Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.FromToRotation(sourceRotation * AnkleIK.up, normal) * sourceRotation;
	}

	private void Stability_Init()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Vector3 initialPosInRootSpace = ToRootLocalSpace(BoneEnd.position);
		InitialPosInRootSpace = initialPosInRootSpace;
	}

	public void DefineLegSide(LegsAnimator get, Leg knownOppositeLeg = null)
	{
		if (knownOppositeLeg != null && knownOppositeLeg.Side != 0)
		{
			if (knownOppositeLeg.Side == ELegSide.Left)
			{
				Side = ELegSide.Right;
			}
			else
			{
				Side = ELegSide.Left;
			}
		}
		else if ((Object)(object)BoneStart != (Object)null)
		{
			if (get.Util_OnLeftSide(BoneStart))
			{
				Side = ELegSide.Left;
			}
			else
			{
				Side = ELegSide.Right;
			}
		}
	}

	public void AssignOppositeLegIndex(int oppositeIndex)
	{
		if (oppositeIndex != OppositeLegIndex)
		{
			if (Object.op_Implicit((Object)(object)Owner) && Owner.Legs.ContainsIndex(oppositeIndex, falseIfNull: true))
			{
				Owner.Legs[oppositeIndex].OppositeLegIndex = Owner.Leg_GetIndex(this);
			}
			OppositeLegIndex = oppositeIndex;
		}
	}

	public Leg GetOppositeLegReference(LegsAnimator legs)
	{
		if (OppositeLegIndex < 0)
		{
			return null;
		}
		if (!legs.Legs.ContainsIndex(OppositeLegIndex, falseIfNull: true))
		{
			return null;
		}
		return legs.Legs[OppositeLegIndex];
	}

	public void RefreshLegAnkleToHeelAndFeetAndAxes(Transform baseT)
	{
		RefreshLegAnkleToHeelAndFeet(baseT);
		RefreshLegAnkleAxes(baseT);
	}

	public void RefreshLegAnkleToHeelAndFeet(Transform baseT)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)BoneEnd == (Object)null))
		{
			Vector3 position = BoneEnd.position;
			position.y = baseT.position.y;
			AnkleToHeel = BoneEnd.InverseTransformPoint(position);
			AnkleToFeetEnd = BoneEnd.InverseTransformPoint(position + baseT.forward * ScaleRef * 0.15f);
		}
	}

	public void RefreshLegAnkleAxes(Transform baseT)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)BoneEnd))
		{
			Quaternion val = baseT.rotation * Quaternion.Euler(0f, AnkleYawCorrection, 0f);
			AnkleForward = BoneEnd.InverseTransformDirection(val * Vector3.forward);
			AnkleUp = BoneEnd.InverseTransformDirection(val * Vector3.up);
			AnkleRight = BoneEnd.InverseTransformDirection(val * Vector3.right);
		}
	}

	private void EnsureAxesNormalization()
	{
		((Vector3)(ref AnkleRight)).Normalize();
		((Vector3)(ref AnkleUp)).Normalize();
		((Vector3)(ref AnkleForward)).Normalize();
	}
}


using UnityEngine;

private struct GlueAttachement
{
	public RaycastHit AttachHit;

	public Transform AttachedTo;

	public Vector3 PosInAttachementLocal;

	public Vector3 NormalInAttachementLocal;

	public Quaternion RotInAttachementLocal;

	public bool NoTransform { get; private set; }

	public GlueAttachement(Leg leg, RaycastHit legGroundHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		AttachHit = legGroundHit;
		AttachedTo = ((RaycastHit)(ref legGroundHit)).transform;
		if ((Object)(object)((RaycastHit)(ref legGroundHit)).transform == (Object)null)
		{
			NoTransform = true;
			PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).point;
			NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).normal;
			RotInAttachementLocal = leg._PreviousFinalIKRot;
			return;
		}
		NoTransform = false;
		PosInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformPoint(((RaycastHit)(ref legGroundHit)).point);
		NormalInAttachementLocal = ((RaycastHit)(ref legGroundHit)).transform.InverseTransformDirection(((RaycastHit)(ref legGroundHit)).normal);
		if (!leg.Owner.AnimateFeet)
		{
			RotInAttachementLocal = Quaternion.identity;
		}
		else
		{
			RotInAttachementLocal = AttachedTo.rotation.QToLocal(leg.GetAlignedOnGroundHitRot(leg._SourceIKRot, ((RaycastHit)(ref legGroundHit)).normal));
		}
	}

	internal Vector3 GetRelevantAlignedHitPoint(Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Vector3 relevantHitPoint = GetRelevantHitPoint();
		return leg.GetAlignedOnGroundHitPos(leg.ToRootLocalSpace(relevantHitPoint), relevantHitPoint, GetRelevantNormal());
	}

	internal Vector3 GetRelevantHitPoint()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform || (Object)(object)AttachedTo == (Object)null)
		{
			return PosInAttachementLocal;
		}
		return AttachedTo.TransformPoint(PosInAttachementLocal);
	}

	internal Vector3 GetRelevantNormal()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform)
		{
			return NormalInAttachementLocal;
		}
		return AttachedTo.TransformDirection(NormalInAttachementLocal);
	}

	internal Quaternion GetRelevantAttachementRotation()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (NoTransform)
		{
			return RotInAttachementLocal;
		}
		return AttachedTo.rotation.QToWorld(RotInAttachementLocal);
	}

	internal void OverwritePosition(Vector3 legAnimPos)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)AttachedTo == (Object)null)
		{
			PosInAttachementLocal = legAnimPos;
		}
		else
		{
			PosInAttachementLocal = ((Component)AttachedTo).transform.InverseTransformPoint(legAnimPos);
		}
	}
}


using UnityEngine;

private class GlueAttachementHandler
{
	public class LegTransitionAnimation
	{
		private enum EMoveType
		{
			FromAnimation,
			FromLastAttachement
		}

		private GlueAttachementHandler handler;

		public float LegAdjustementYOffset;

		public float LegAdjustementFootAngleOffset;

		private Vector3 _legSpherizeLocalVector = Vector3.zero;

		private float _legMoveDurMul = 1f;

		private Quaternion baseRotationOnStepUp;

		public float legMoveDistanceFactor;

		private float sd_trProgress;

		private Vector3 previousPositionLocal;

		private Vector3 previousPositionWorld;

		private Quaternion previousRotationWorld;

		private Vector3 lastAppliedGluePosition;

		private Vector3 lastAppliedGluePositionLocal;

		private Quaternion lastAppliedGlueRotation;

		private float lastSpeedup;

		private EMoveType animationMoveType;

		private bool _instantTransition;

		private bool _wasAnimatingLeg;

		private LegsAnimator Owner => handler.Owner;

		private Leg leg => handler.leg;

		public bool duringLegAdjustMovement { get; private set; }

		public bool wasAttaching { get; private set; }

		public bool attached { get; private set; }

		public float transitionProgress { get; private set; }

		public float lastAttachCompleteTime { get; private set; }

		public float transitionProgressLastFrame { get; private set; }

		public EGlueMode LastAnimationGlueMode
		{
			get
			{
				if (animationMoveType != 0)
				{
					return EGlueMode.Idle;
				}
				return EGlueMode.Moving;
			}
		}

		public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			handler = glueTransitionHelper;
			Reset();
		}

		public void Reset()
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			animationMoveType = EMoveType.FromAnimation;
			transitionProgress = 0f;
			transitionProgressLastFrame = 0f;
			baseRotationOnStepUp = Owner.BaseTransform.rotation;
			duringLegAdjustMovement = false;
			wasAttaching = false;
			attached = false;
			_legSpherizeLocalVector = Vector3.zero;
			ReInitialize();
		}

		public void ReInitialize()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			lastAppliedGluePosition = leg._SourceIKPos;
			lastAppliedGlueRotation = leg._SourceIKRot;
			previousPositionWorld = leg._SourceIKPos;
			previousRotationWorld = leg._SourceIKRot;
			previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
		}

		internal void ScheduleInstantTransition()
		{
			_instantTransition = true;
		}

		internal void DoAttaching(bool canAttach)
		{
			if (canAttach != wasAttaching)
			{
				wasAttaching = canAttach;
				if (canAttach)
				{
					OnChangeTargetPosition();
				}
				else
				{
					attached = false;
					if (transitionProgress != 0f)
					{
						OnChangeTargetPosition();
					}
				}
			}
			if (duringLegAdjustMovement && transitionProgress >= 1f)
			{
				duringLegAdjustMovement = false;
			}
		}

		internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
		{
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
			{
				Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
				Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
				if (val.y < val2.y)
				{
					val.y = val2.y;
					legAnimPos = Owner.RootToWorldSpace(val);
				}
			}
			return legAnimPos;
		}

		public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
			Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
			if (legAnimatingSettings.SpherizeTrack.length > 1)
			{
				float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
				val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
			}
			if (Owner.AnimateFeet)
			{
				LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
				LegAdjustementFootAngleOffset /= lastSpeedup;
			}
			float num2 = Owner.ScaleReferenceNoScale * 0.75f;
			float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
			num3 *= num2;
			LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
			_wasAnimatingLeg = true;
			return val;
		}

		internal Vector3 GetTargetPosition()
		{
			//IL_0122: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0183: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			float glueAnimationBlend = handler.glueAnimationBlend;
			if (animationMoveType == EMoveType.FromAnimation)
			{
				if (glueAnimationBlend < 0.0001f)
				{
					return Owner.RootToWorldSpace(previousPositionLocal);
				}
				Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
				if (transitionProgress < 0.0001f)
				{
					return val;
				}
				Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
				if (transitionProgress > 0.9995f)
				{
					return val2;
				}
				return Vector3.LerpUnclamped(val, val2, transitionProgress);
			}
			Vector3 val3;
			if (leg.Owner.OnlyLocalAnimation)
			{
				val3 = Owner.RootToWorldSpace(previousPositionLocal);
				if (transitionProgress < 0.0001f)
				{
					return val3;
				}
			}
			else
			{
				val3 = previousPositionWorld;
				if (transitionProgress < 0.0001f)
				{
					return val3;
				}
				val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
			}
			Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
			if (transitionProgress >= 1f)
			{
				return val4;
			}
			float num = 1f - transitionProgress;
			return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
		}

		internal void RequireRepose()
		{
			if (attached)
			{
				attached = false;
				OnChangeTargetPosition();
			}
		}

		internal Quaternion GetTargetRotation()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			Quaternion val = previousRotationWorld;
			if (transitionProgress < 0.001f)
			{
				return val;
			}
			Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
			if (transitionProgress > 0.9995f)
			{
				return val2;
			}
			return Quaternion.LerpUnclamped(val, val2, transitionProgress);
		}

		internal void OnChangeTargetPosition()
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0141: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_0153: Unknown result type (might be due to invalid IL or missing references)
			//IL_0158: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_019c: Unknown result type (might be due to invalid IL or missing references)
			//IL_019d: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_0247: Unknown result type (might be due to invalid IL or missing references)
			//IL_024c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0223: Unknown result type (might be due to invalid IL or missing references)
			//IL_022d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0232: Unknown result type (might be due to invalid IL or missing references)
			handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
			baseRotationOnStepUp = Owner.BaseTransform.rotation;
			if (handler.glueAnimationBlend < 0.2f)
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			else if (animationMoveType == EMoveType.FromLastAttachement)
			{
				animationMoveType = EMoveType.FromLastAttachement;
			}
			else if (handler.glueAnimationBlend > 0.75f)
			{
				if (transitionProgress < 0.1f || transitionProgress > 0.9f)
				{
					animationMoveType = EMoveType.FromLastAttachement;
				}
				else
				{
					animationMoveType = EMoveType.FromAnimation;
				}
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
			}
			if (leg.Owner.OnlyLocalAnimation)
			{
				previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
			}
			else
			{
				previousPositionWorld = lastAppliedGluePosition;
			}
			previousRotationWorld = lastAppliedGlueRotation;
			previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
			if (animationMoveType == EMoveType.FromLastAttachement)
			{
				if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
				{
					transitionProgress = 0f;
				}
				Vector3 val = previousPositionWorld;
				Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
				float magnitude = ((Vector3)(ref val2)).magnitude;
				legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
				legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
				Vector3 val3 = ((Vector3)(ref val2)).normalized;
				val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
				((Vector3)(ref val3)).Normalize();
				leg.SendRaiseEvent(magnitude);
				if (legMoveDistanceFactor > 0.0401f)
				{
					_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
					Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
					((Vector3)(ref worldDir)).Normalize();
					_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
					duringLegAdjustMovement = true;
				}
				else
				{
					animationMoveType = EMoveType.FromAnimation;
					_legSpherizeLocalVector = Vector3.zero;
					duringLegAdjustMovement = false;
				}
			}
			else
			{
				duringLegAdjustMovement = false;
				transitionProgress = 0f;
			}
		}

		public void UpdateAnimation()
		{
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0192: Unknown result type (might be due to invalid IL or missing references)
			//IL_0197: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			float num = (Owner.JustGrounded ? 0.2f : 1f);
			float num2 = (Owner.JustGrounded ? 5f : 1f);
			transitionProgressLastFrame = transitionProgress;
			if (_instantTransition)
			{
				_instantTransition = false;
				transitionProgress = 1f;
				lastAttachCompleteTime = Time.time;
			}
			if (!Owner.IsGrounded)
			{
				return;
			}
			if (animationMoveType == EMoveType.FromLastAttachement)
			{
				float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
				float num4 = 1f;
				lastSpeedup = 1f;
				if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
				{
					if (leg.hasOppositeleg)
					{
						Leg oppositeLeg = leg.GetOppositeLeg();
						Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
						if (leg.Owner.OnlyLocalAnimation)
						{
							targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
						}
						float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
						if (stretchValue > leg.LegStretchLimit * 0.95f)
						{
							float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
							if (num5 < 0f)
							{
								num5 = 0f;
							}
							num4 += num5;
						}
						if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
						{
							Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
							float magnitude = ((Vector3)(ref val)).magnitude;
							float num6 = Owner.ScaleReference * 0.4f;
							if (magnitude > num6)
							{
								float num7 = magnitude - num6;
								num4 += num7 / num6 * 2f;
							}
						}
					}
					if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
					{
						float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
						if (num8 > 12f)
						{
							float num9 = Mathf.InverseLerp(30f, 135f, num8);
							num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
							transitionProgress += Owner.DeltaTime * num9 * num2;
						}
					}
					num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
				}
				lastSpeedup = num4;
				transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
				if (transitionProgress > 0.9995f && duringLegAdjustMovement)
				{
					TriggerAttach();
				}
			}
			else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
			{
				TriggerAttach();
			}
			else
			{
				transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
			}
		}

		private void TriggerAttach()
		{
			if (!attached)
			{
				transitionProgress = 1f;
				lastAttachCompleteTime = Time.time;
				attached = leg.Glue_TriggerFinalAttach();
				duringLegAdjustMovement = false;
			}
		}

		public void PostUpdate()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			lastAppliedGluePosition = leg._GluePosition;
			lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
			lastAppliedGlueRotation = leg._GlueRotation;
			if (!_wasAnimatingLeg)
			{
				LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
				LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
			}
			else
			{
				_wasAnimatingLeg = false;
			}
		}
	}

	private LegsAnimator Owner;

	private Leg ParentLeg;

	private float _sd_glueAnimationBlend;

	private bool _instantTransition;

	private Vector3 lastGluePosition = Vector3.zero;

	private Quaternion lastGlueRotation = Quaternion.identity;

	public LegTransitionAnimation legMoveAnimation { get; private set; }

	private Leg leg => ParentLeg;

	public float glueAnimationBlend { get; private set; }

	public float attachTransitionProgress => legMoveAnimation.transitionProgress;

	public float attachTransitionProgressLastFrame => legMoveAnimation.transitionProgressLastFrame;

	public float legMoveDistanceFactor => legMoveAnimation.legMoveDistanceFactor;

	public EGlueMode lasGlueModeOnAttaching { get; private set; }

	public GlueAttachementHandler(Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ParentLeg = leg;
		Owner = leg.Owner;
		legMoveAnimation = new LegTransitionAnimation(this);
		lasGlueModeOnAttaching = Owner._glueModeExecuted;
		Reset(initializing: true);
	}

	public void Reset(bool initializing)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		glueAnimationBlend = 0f;
		_sd_glueAnimationBlend = 0f;
		if (initializing)
		{
			lastGluePosition = leg.BoneEnd.position;
			lastGlueRotation = leg.BoneEnd.rotation;
		}
		legMoveAnimation.Reset();
	}

	public void SheduleInstantTransition()
	{
		_instantTransition = true;
		legMoveAnimation.ScheduleInstantTransition();
	}

	public void TransitionToGlueAnimation()
	{
		legMoveAnimation.DoAttaching(canAttach: true);
		ChangeGlueAnimationBlendTo(1f, Owner.GlueFadeInSpeed);
	}

	public void TransitionToDisableGlueAnimation()
	{
		legMoveAnimation.DoAttaching(canAttach: false);
		ChangeGlueAnimationBlendTo(0f, Owner.GlueFadeOutSpeed);
	}

	public Vector3 GetGluePosition()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (glueAnimationBlend > 0.9995f)
		{
			lastGluePosition = legMoveAnimation.GetTargetPosition();
		}
		else if (glueAnimationBlend < 0.0001f)
		{
			lastGluePosition = leg.A_PreIKPosForGluing;
		}
		else
		{
			lastGluePosition = Vector3.LerpUnclamped(leg.A_PreIKPosForGluing, legMoveAnimation.GetTargetPosition(), glueAnimationBlend);
		}
		return lastGluePosition;
	}

	public Quaternion GetGlueRotation()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (glueAnimationBlend > 0.999f)
		{
			lastGlueRotation = legMoveAnimation.GetTargetRotation();
		}
		else if (glueAnimationBlend < 0f)
		{
			lastGlueRotation = leg._FinalIKRot;
		}
		else
		{
			lastGlueRotation = Quaternion.LerpUnclamped(leg._FinalIKRot, legMoveAnimation.GetTargetRotation(), glueAnimationBlend);
		}
		return lastGlueRotation;
	}

	public void UpdateTransitioning(bool attaching)
	{
		legMoveAnimation.UpdateAnimation();
	}

	public void PostUpdate()
	{
		legMoveAnimation.PostUpdate();
	}

	internal void OnLegRequireRepose()
	{
		legMoveAnimation.RequireRepose();
	}

	private void ChangeGlueAnimationBlendTo(float target, float speed)
	{
		if (Owner.GroundedTime < 0f)
		{
			speed = 0.99f;
		}
		if (_instantTransition && target > 0f)
		{
			glueAnimationBlend = target;
			_instantTransition = false;
			return;
		}
		if (speed >= 1f)
		{
			glueAnimationBlend = target;
			return;
		}
		if (leg.G_JustLanded)
		{
			glueAnimationBlend = Mathf.MoveTowards(glueAnimationBlend, target, Owner.DeltaTime * 3f);
		}
		glueAnimationBlend = Mathf.SmoothDamp(glueAnimationBlend, target, ref _sd_glueAnimationBlend, Mathf.LerpUnclamped(0.2f, 0.005f, speed), 100000f, Owner.DeltaTime);
		if (float.IsNaN(_sd_glueAnimationBlend))
		{
			_sd_glueAnimationBlend = 0f;
		}
	}
}


using UnityEngine;

public class LegTransitionAnimation
{
	private enum EMoveType
	{
		FromAnimation,
		FromLastAttachement
	}

	private GlueAttachementHandler handler;

	public float LegAdjustementYOffset;

	public float LegAdjustementFootAngleOffset;

	private Vector3 _legSpherizeLocalVector = Vector3.zero;

	private float _legMoveDurMul = 1f;

	private Quaternion baseRotationOnStepUp;

	public float legMoveDistanceFactor;

	private float sd_trProgress;

	private Vector3 previousPositionLocal;

	private Vector3 previousPositionWorld;

	private Quaternion previousRotationWorld;

	private Vector3 lastAppliedGluePosition;

	private Vector3 lastAppliedGluePositionLocal;

	private Quaternion lastAppliedGlueRotation;

	private float lastSpeedup;

	private EMoveType animationMoveType;

	private bool _instantTransition;

	private bool _wasAnimatingLeg;

	private LegsAnimator Owner => handler.Owner;

	private Leg leg => handler.leg;

	public bool duringLegAdjustMovement { get; private set; }

	public bool wasAttaching { get; private set; }

	public bool attached { get; private set; }

	public float transitionProgress { get; private set; }

	public float lastAttachCompleteTime { get; private set; }

	public float transitionProgressLastFrame { get; private set; }

	public EGlueMode LastAnimationGlueMode
	{
		get
		{
			if (animationMoveType != 0)
			{
				return EGlueMode.Idle;
			}
			return EGlueMode.Moving;
		}
	}

	public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		handler = glueTransitionHelper;
		Reset();
	}

	public void Reset()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		animationMoveType = EMoveType.FromAnimation;
		transitionProgress = 0f;
		transitionProgressLastFrame = 0f;
		baseRotationOnStepUp = Owner.BaseTransform.rotation;
		duringLegAdjustMovement = false;
		wasAttaching = false;
		attached = false;
		_legSpherizeLocalVector = Vector3.zero;
		ReInitialize();
	}

	public void ReInitialize()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		lastAppliedGluePosition = leg._SourceIKPos;
		lastAppliedGlueRotation = leg._SourceIKRot;
		previousPositionWorld = leg._SourceIKPos;
		previousRotationWorld = leg._SourceIKRot;
		previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
	}

	internal void ScheduleInstantTransition()
	{
		_instantTransition = true;
	}

	internal void DoAttaching(bool canAttach)
	{
		if (canAttach != wasAttaching)
		{
			wasAttaching = canAttach;
			if (canAttach)
			{
				OnChangeTargetPosition();
			}
			else
			{
				attached = false;
				if (transitionProgress != 0f)
				{
					OnChangeTargetPosition();
				}
			}
		}
		if (duringLegAdjustMovement && transitionProgress >= 1f)
		{
			duringLegAdjustMovement = false;
		}
	}

	internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
	{
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
		{
			Vector3 val = Owner.ToRootLocalSpace(legAnimPos);
			Vector3 val2 = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
			if (val.y < val2.y)
			{
				val.y = val2.y;
				legAnimPos = Owner.RootToWorldSpace(val);
			}
		}
		return legAnimPos;
	}

	public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
		Vector3 val = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
		if (legAnimatingSettings.SpherizeTrack.length > 1)
		{
			float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
			val += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
		}
		if (Owner.AnimateFeet)
		{
			LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
			LegAdjustementFootAngleOffset /= lastSpeedup;
		}
		float num2 = Owner.ScaleReferenceNoScale * 0.75f;
		float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
		num3 *= num2;
		LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
		_wasAnimatingLeg = true;
		return val;
	}

	internal Vector3 GetTargetPosition()
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		float glueAnimationBlend = handler.glueAnimationBlend;
		if (animationMoveType == EMoveType.FromAnimation)
		{
			if (glueAnimationBlend < 0.0001f)
			{
				return Owner.RootToWorldSpace(previousPositionLocal);
			}
			Vector3 val = Owner.RootToWorldSpace(previousPositionLocal);
			if (transitionProgress < 0.0001f)
			{
				return val;
			}
			Vector3 val2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
			if (transitionProgress > 0.9995f)
			{
				return val2;
			}
			return Vector3.LerpUnclamped(val, val2, transitionProgress);
		}
		Vector3 val3;
		if (leg.Owner.OnlyLocalAnimation)
		{
			val3 = Owner.RootToWorldSpace(previousPositionLocal);
			if (transitionProgress < 0.0001f)
			{
				return val3;
			}
		}
		else
		{
			val3 = previousPositionWorld;
			if (transitionProgress < 0.0001f)
			{
				return val3;
			}
			val3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
		}
		Vector3 val4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(val3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
		if (transitionProgress >= 1f)
		{
			return val4;
		}
		float num = 1f - transitionProgress;
		return Vector3.LerpUnclamped(val3, val4, 1f - num * num);
	}

	internal void RequireRepose()
	{
		if (attached)
		{
			attached = false;
			OnChangeTargetPosition();
		}
	}

	internal Quaternion GetTargetRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = previousRotationWorld;
		if (transitionProgress < 0.001f)
		{
			return val;
		}
		Quaternion val2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
		if (transitionProgress > 0.9995f)
		{
			return val2;
		}
		return Quaternion.LerpUnclamped(val, val2, transitionProgress);
	}

	internal void OnChangeTargetPosition()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
		baseRotationOnStepUp = Owner.BaseTransform.rotation;
		if (handler.glueAnimationBlend < 0.2f)
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		else if (animationMoveType == EMoveType.FromLastAttachement)
		{
			animationMoveType = EMoveType.FromLastAttachement;
		}
		else if (handler.glueAnimationBlend > 0.75f)
		{
			if (transitionProgress < 0.1f || transitionProgress > 0.9f)
			{
				animationMoveType = EMoveType.FromLastAttachement;
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
			}
		}
		else
		{
			animationMoveType = EMoveType.FromAnimation;
		}
		if (leg.Owner.OnlyLocalAnimation)
		{
			previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
		}
		else
		{
			previousPositionWorld = lastAppliedGluePosition;
		}
		previousRotationWorld = lastAppliedGlueRotation;
		previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
		if (animationMoveType == EMoveType.FromLastAttachement)
		{
			if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
			{
				transitionProgress = 0f;
			}
			Vector3 val = previousPositionWorld;
			Vector3 val2 = leg.ankleAlignedOnGroundHitWorldPos - val;
			float magnitude = ((Vector3)(ref val2)).magnitude;
			legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
			legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
			Vector3 val3 = ((Vector3)(ref val2)).normalized;
			val3 = Vector3.ProjectOnPlane(val3, Owner.Up);
			((Vector3)(ref val3)).Normalize();
			leg.SendRaiseEvent(magnitude);
			if (legMoveDistanceFactor > 0.0401f)
			{
				_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
				Vector3 worldDir = Vector3.Cross(val3, Owner.Up);
				((Vector3)(ref worldDir)).Normalize();
				_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
				duringLegAdjustMovement = true;
			}
			else
			{
				animationMoveType = EMoveType.FromAnimation;
				_legSpherizeLocalVector = Vector3.zero;
				duringLegAdjustMovement = false;
			}
		}
		else
		{
			duringLegAdjustMovement = false;
			transitionProgress = 0f;
		}
	}

	public void UpdateAnimation()
	{
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		float num = (Owner.JustGrounded ? 0.2f : 1f);
		float num2 = (Owner.JustGrounded ? 5f : 1f);
		transitionProgressLastFrame = transitionProgress;
		if (_instantTransition)
		{
			_instantTransition = false;
			transitionProgress = 1f;
			lastAttachCompleteTime = Time.time;
		}
		if (!Owner.IsGrounded)
		{
			return;
		}
		if (animationMoveType == EMoveType.FromLastAttachement)
		{
			float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
			float num4 = 1f;
			lastSpeedup = 1f;
			if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
			{
				if (leg.hasOppositeleg)
				{
					Leg oppositeLeg = leg.GetOppositeLeg();
					Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
					if (leg.Owner.OnlyLocalAnimation)
					{
						targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
					}
					float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
					if (stretchValue > leg.LegStretchLimit * 0.95f)
					{
						float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
						if (num5 < 0f)
						{
							num5 = 0f;
						}
						num4 += num5;
					}
					if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
					{
						Vector3 val = leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint();
						float magnitude = ((Vector3)(ref val)).magnitude;
						float num6 = Owner.ScaleReference * 0.4f;
						if (magnitude > num6)
						{
							float num7 = magnitude - num6;
							num4 += num7 / num6 * 2f;
						}
					}
				}
				if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
				{
					float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
					if (num8 > 12f)
					{
						float num9 = Mathf.InverseLerp(30f, 135f, num8);
						num9 = Mathf.LerpUnclamped(0.5f, 2f, num9) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
						transitionProgress += Owner.DeltaTime * num9 * num2;
					}
				}
				num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
			}
			lastSpeedup = num4;
			transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
			if (transitionProgress > 0.9995f && duringLegAdjustMovement)
			{
				TriggerAttach();
			}
		}
		else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
		{
			TriggerAttach();
		}
		else
		{
			transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
		}
	}

	private void TriggerAttach()
	{
		if (!attached)
		{
			transitionProgress = 1f;
			lastAttachCompleteTime = Time.time;
			attached = leg.Glue_TriggerFinalAttach();
			duringLegAdjustMovement = false;
		}
	}

	public void PostUpdate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		lastAppliedGluePosition = leg._GluePosition;
		lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
		lastAppliedGlueRotation = leg._GlueRotation;
		if (!_wasAnimatingLeg)
		{
			LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
			LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
		}
		else
		{
			_wasAnimatingLeg = false;
		}
	}
}


private enum EMoveType
{
	FromAnimation,
	FromLastAttachement
}


public enum GlueReposeRequest
{
	None,
	Repose,
	ReposeIfFar
}


using UnityEngine;

public class LegHelper
{
	public Transform Bone;

	public LegHelper Child;

	public Vector3 InitPositionRootSpace;

	public Vector3 LastKeyframeRootPos;

	public LegHelper(Leg leg, Transform bone)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Bone = bone;
		InitPositionRootSpace = leg.ToRootLocalSpace(bone.position);
	}

	public void Calibrate(Leg leg, Vector3 wPos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		LastKeyframeRootPos = leg.ToRootLocalSpace(wPos);
	}
}


public enum ELegSide
{
	Undefined,
	Left,
	Right
}


using System;
using System.Globalization;
using UnityEngine;

[Serializable]
public class LegStepAnimatingParameters
{
	[Tooltip("Average duration of the automatic leg animation")]
	[Range(0.1f, 1f)]
	public float StepMoveDuration = 0.375f;

	[Tooltip("Curve of ik point going towards desired position (just XZ movement, to Y - no leg rise curve)")]
	[FPD_FixedCurveWindow(0f, 0f, 1f, 1.25f, 0.4f, 0.5f, 1f, 1f)]
	public AnimationCurve MoveToGoalCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	[Tooltip("Making foot motion move towards target not in full linear straight towards target motion but adding a bit curve back (positive value) or forward (negative values) making movement a bit more natural")]
	[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0.4f, 0.6f, 0.9f, 1f)]
	public AnimationCurve SpherizeTrack = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);

	[Range(0f, 2f)]
	public float SpherizePower = 0.3f;

	[Range(0f, 1f)]
	[Tooltip("Minimum leg raise height. If distance of target step animation is small, then foot raise is smaller - down to this minimum raise value.")]
	public float MinFootRaise = 0.1f;

	[Tooltip("Maximum leg raise height. If distance of target step animation is very big, then foot raise is bigger - up to this maximum raise value.")]
	[Range(0f, 1f)]
	public float MaxFootRaise = 0.4f;

	[Tooltip("Raise height step animation curve evaluated on step animation duration.")]
	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.5f, 1f, 0.5f, 1f)]
	public AnimationCurve RaiseYAxisCurve;

	[Space(3f)]
	[Tooltip("Allowing to speed up leg adjusting animation when leg is getting stretched, when opposite leg is requesting adjustement or when main character is rotating in place quickly")]
	[Range(0f, 1f)]
	public float AllowSpeedups = 0.4f;

	[Tooltip("You can allow to use opposite leg before idle glue leg adjustement finishes")]
	[Range(0.1f, 1f)]
	public float AllowDetachBefore = 1f;

	[Tooltip("Extra hips push power animation curve evaluated on step animation duration.")]
	[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 1f, 0.6f, 0.6f, 1f)]
	public AnimationCurve PushHipsOnMoveCurve;

	[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0f, 1f, 1f, 1f)]
	[Tooltip("Extra foot ankle rotation animation curve evaluated on step animation duration.")]
	public AnimationCurve FootRotationCurve;

	public void RefreshDefaultCurves()
	{
		Curves_RefreshMoveToGoalCurve();
		Curves_RefreshRaiseYAxisCurve();
		Curves_RefreshSpherizeTrack();
		Curves_RefreshFootRotationCurve();
		Curves_RefreshPushHipsOnMoveCurve();
	}

	public void Curves_RefreshRaiseYAxisCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		RaiseYAxisCurve = new AnimationCurve();
		RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.505118f, 0.5f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.9110107f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
	}

	public void Curves_RefreshRaiseYAxisCurveSpiderPreset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		RaiseYAxisCurve = new AnimationCurve();
		RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
		RaiseYAxisCurve.AddKey(new Keyframe(0.5943514f, 0.7946472f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
		RaiseYAxisCurve.AddKey(new Keyframe(1f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
	}

	public void Curves_RefreshMoveToGoalCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		MoveToGoalCurve = new AnimationCurve();
		MoveToGoalCurve.AddKey(new Keyframe(0f, 0f, 0f, 0f, 0f, 0.1842105f));
		MoveToGoalCurve.AddKey(new Keyframe(0.4885197f, 0.8972011f, 1.38764f, 1.38764f, 0.3333333f, 0.3333333f));
		MoveToGoalCurve.AddKey(new Keyframe(1f, 1f, 0f, 0f, 0f, 0f));
	}

	public void Curves_RefreshFootRotationCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		FootRotationCurve = new AnimationCurve();
		FootRotationCurve.AddKey(new Keyframe(0f, 0f, 0.5764588f, 0.5764588f, 0f, 0.4956417f));
		FootRotationCurve.AddKey(new Keyframe(0.4378169f, 0.2035736f, -0.2411275f, -0.2411275f, 0.3333333f, 0.4033037f));
		FootRotationCurve.AddKey(new Keyframe(0.7841034f, -0.1339308f, 0.3331003f, 0.3331003f, 0.3333333f, 0.3333333f));
		FootRotationCurve.AddKey(new Keyframe(1f, 0f, 0.3498169f, 0.3498169f, 0.5534658f, 0f));
	}

	public void Curves_RefreshPushHipsOnMoveCurve()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		PushHipsOnMoveCurve = new AnimationCurve();
		PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.383f, 0.3733972f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.7075226f, 0.1460427f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
	}

	public void Curves_RefreshPushHipsOnMoveCurveSpiderPreset()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		PushHipsOnMoveCurve = new AnimationCurve();
		PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.320017f, 0.654645f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(0.6681702f, 0.2174691f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
		PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
	}

	public void Curves_RefreshSpherizeTrack()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		SpherizeTrack = new AnimationCurve();
		SpherizeTrack.AddKey(new Keyframe(0f, 0f, 0.6958197f, 0.6958197f, 0f, 0.460011f));
		SpherizeTrack.AddKey(new Keyframe(0.4f, 0.3f, -0.04204308f, -0.04204308f, 0.333f, 0.3410656f));
		SpherizeTrack.AddKey(new Keyframe(0.85f, 0f, -0.2721428f, -0.2721428f, 0.3953607f, 0f));
	}

	public void LogCurve(string name, AnimationCurve c)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		string text = "";
		IFormatProvider invariantCulture = CultureInfo.InvariantCulture;
		for (int i = 0; i < c.keys.Length; i++)
		{
			Keyframe val = c.keys[i];
			text = text + "\n" + name + ".AddKey(new Keyframe(" + ((Keyframe)(ref val)).time.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).value.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outTangent.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).inWeight.ToString(invariantCulture) + "f, " + ((Keyframe)(ref val)).outWeight.ToString(invariantCulture) + "f));";
		}
		Debug.Log((object)text);
	}
}


using UnityEngine;

public enum EGlueMode
{
	[Tooltip("Idle Mode is applying leg animation with extra motion and is checking some extra conditions like opposite leg grounded state etc.")]
	Idle,
	[Tooltip("Moving Mode is dedicated to be applied during playing animations with dynamic legs, it's checking less conditions than Idle Mode and is snapping glue points in a more straight forward slide animation.")]
	Moving,
	[Tooltip("Automatic mode is syncing with IsMoving/IsIdling LegsAnimator flags.")]
	Automatic
}


using System;
using UnityEngine;

[Serializable]
public class Variable
{
	public enum EVariableType
	{
		Number,
		Bool,
		Vector2,
		Vector3,
		String,
		Curve,
		UnityObject,
		CustomObject
	}

	public string VariableName = "Variable";

	[SerializeField]
	private string Tooltip = "";

	private bool _tooltipWasSet;

	[SerializeField]
	private Vector4 _value = Vector4.zero;

	[SerializeField]
	private string _string = "";

	[SerializeField]
	private AnimationCurve _curve;

	[SerializeField]
	private Object _uObject;

	[SerializeField]
	private object _object;

	[NonSerialized]
	private int nameHash;

	public EVariableType VariableType;

	[SerializeField]
	private Vector4 _rangeHelper = Vector4.zero;

	public bool TooltipAssigned => _tooltipWasSet;

	public int GetNameHash
	{
		get
		{
			if (nameHash == 0)
			{
				nameHash = VariableName.GetHashCode();
			}
			return nameHash;
		}
	}

	public void AssignTooltip(string tooltip)
	{
		if (!_tooltipWasSet)
		{
			Tooltip = tooltip;
			_tooltipWasSet = true;
		}
	}

	public Variable(string name, object value)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		VariableName = name;
		SetValue(value);
	}

	public void SetValue(object o)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if (o is int)
		{
			_value = new Vector4((float)(int)o, 0f, 0f, 1f);
			VariableType = EVariableType.Number;
		}
		else if (o is float)
		{
			_value = new Vector4((float)o, 0f, 0f, 0f);
			VariableType = EVariableType.Number;
		}
		else if (o is bool)
		{
			if ((bool)o)
			{
				_value.x = 1f;
			}
			else
			{
				_value.x = 0f;
			}
			VariableType = EVariableType.Bool;
		}
		else if (o is Vector2 val)
		{
			_value = Vector4.op_Implicit(val);
			VariableType = EVariableType.Vector2;
		}
		else if (o is Vector3 val2)
		{
			_value = Vector4.op_Implicit(val2);
			VariableType = EVariableType.Vector3;
		}
		else if (o is string)
		{
			_string = o as string;
			VariableType = EVariableType.String;
		}
		else if (o is AnimationCurve)
		{
			_curve = (AnimationCurve)((o is AnimationCurve) ? o : null);
			VariableType = EVariableType.Curve;
		}
		else if (o is Object)
		{
			_uObject = (Object)((o is Object) ? o : null);
			VariableType = EVariableType.UnityObject;
		}
		else
		{
			_object = o;
			VariableType = EVariableType.CustomObject;
		}
	}

	public int GetInt()
	{
		return (int)_value.x;
	}

	public float GetFloat()
	{
		return _value.x;
	}

	public bool GetBool()
	{
		return _value.x == 1f;
	}

	public Vector2 GetVector2()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2(_value.x, _value.y);
	}

	public Vector3 GetVector3()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(_value.x, _value.y, _value.z);
	}

	public string GetString()
	{
		return _string;
	}

	public AnimationCurve GetCurve()
	{
		return _curve;
	}

	public Object GetUnityObject()
	{
		return _uObject;
	}

	public object GetObject()
	{
		return _object;
	}

	public void SetMinMaxSlider(float min, float max)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		_rangeHelper = new Vector4(min, max, 0f, 0f);
	}

	public void SetCurveFixedRange(float startTime, float startValue, float endTime, float endValue)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		_rangeHelper = new Vector4(startTime, startValue, endTime, endValue);
	}

	public bool Editor_DisplayVariableGUI()
	{
		return false;
	}
}


public enum EVariableType
{
	Number,
	Bool,
	Vector2,
	Vector3,
	String,
	Curve,
	UnityObject,
	CustomObject
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class ReferencePose
{
	[Serializable]
	public class LegPoseReference
	{
		public BonePoseReference UpperLegPose = new BonePoseReference();

		public BonePoseReference LowerLegPose = new BonePoseReference();

		public BonePoseReference AnklePose = new BonePoseReference();

		public BonePoseReference FeetPose = new BonePoseReference();

		public void SaveLegPose(Leg leg, LegsAnimator animator)
		{
			UpperLegPose.SavePose(leg.BoneStart, animator);
			LowerLegPose.SavePose(leg.BoneMid, animator);
			AnklePose.SavePose(leg.BoneEnd, animator);
			FeetPose.SavePose(leg.BoneFeet, animator);
		}

		public void RestoreLegPose(LegsAnimator animator)
		{
			UpperLegPose.RestorePose(animator);
			LowerLegPose.RestorePose(animator);
			AnklePose.RestorePose(animator);
			FeetPose.RestorePose(animator);
		}
	}

	[Serializable]
	public class BonePoseReference
	{
		public Transform SourceTransform;

		public Quaternion RotationInRoot;

		public Vector3 PositionInRoot;

		public void SavePose(Transform transform, LegsAnimator animator)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)animator == (Object)null) && !((Object)(object)transform == (Object)null))
			{
				SourceTransform = transform;
				PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
				RotationInRoot = animator.BaseTransform.rotation.QToLocal(transform.rotation);
			}
		}

		public void RestorePose(LegsAnimator animator)
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			if (!((Object)(object)animator == (Object)null) && !((Object)(object)SourceTransform == (Object)null))
			{
				SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
				SourceTransform.rotation = animator.BaseTransform.rotation.QToWorld(RotationInRoot);
			}
		}
	}

	public BonePoseReference MainHipsPose = new BonePoseReference();

	public List<BonePoseReference> HipsPoses = new List<BonePoseReference>();

	public List<LegPoseReference> LegPoses = new List<LegPoseReference>();

	public bool IsSet(LegsAnimator animator)
	{
		if ((Object)(object)MainHipsPose.SourceTransform != (Object)null && HipsPoses.Count == animator.ExtraHipsHubs.Count)
		{
			return LegPoses.Count == animator.Legs.Count;
		}
		return false;
	}

	public void TweakListsFor(LegsAnimator animator)
	{
		while (HipsPoses.Count > animator.ExtraHipsHubs.Count)
		{
			HipsPoses.RemoveAt(HipsPoses.Count - 1);
		}
		while (HipsPoses.Count < animator.ExtraHipsHubs.Count)
		{
			HipsPoses.Add(new BonePoseReference());
		}
		while (LegPoses.Count > animator.Legs.Count)
		{
			LegPoses.RemoveAt(LegPoses.Count - 1);
		}
		while (LegPoses.Count < animator.Legs.Count)
		{
			LegPoses.Add(new LegPoseReference());
		}
	}

	public void Clear()
	{
		MainHipsPose.SourceTransform = null;
		HipsPoses.Clear();
		LegPoses.Clear();
	}
}


using System;

[Serializable]
public class LegPoseReference
{
	public BonePoseReference UpperLegPose = new BonePoseReference();

	public BonePoseReference LowerLegPose = new BonePoseReference();

	public BonePoseReference AnklePose = new BonePoseReference();

	public BonePoseReference FeetPose = new BonePoseReference();

	public void SaveLegPose(Leg leg, LegsAnimator animator)
	{
		UpperLegPose.SavePose(leg.BoneStart, animator);
		LowerLegPose.SavePose(leg.BoneMid, animator);
		AnklePose.SavePose(leg.BoneEnd, animator);
		FeetPose.SavePose(leg.BoneFeet, animator);
	}

	public void RestoreLegPose(LegsAnimator animator)
	{
		UpperLegPose.RestorePose(animator);
		LowerLegPose.RestorePose(animator);
		AnklePose.RestorePose(animator);
		FeetPose.RestorePose(animator);
	}
}


using System;
using UnityEngine;

[Serializable]
public class BonePoseReference
{
	public Transform SourceTransform;

	public Quaternion RotationInRoot;

	public Vector3 PositionInRoot;

	public void SavePose(Transform transform, LegsAnimator animator)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)animator == (Object)null) && !((Object)(object)transform == (Object)null))
		{
			SourceTransform = transform;
			PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
			RotationInRoot = animator.BaseTransform.rotation.QToLocal(transform.rotation);
		}
	}

	public void RestorePose(LegsAnimator animator)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)animator == (Object)null) && !((Object)(object)SourceTransform == (Object)null))
		{
			SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
			SourceTransform.rotation = animator.BaseTransform.rotation.QToWorld(RotationInRoot);
		}
	}
}


public enum ELegsScaleReference
{
	PelvisToGroundDistance,
	FirstLegLength,
	Custom,
	PelvisLegAverage
}


using UnityEngine;

public enum ECalibrateMode
{
	[Tooltip("No Extra overhead")]
	None,
	[Tooltip("Resetting bones local rotations to the initialized state")]
	Calibrate,
	[Tooltip("Resetting bones local rotations to the captured animator state (can fix trigger colliders detection when colliders added on legs)")]
	FixedCalibrate
}


public enum ERaycastPrecision
{
	Linecast,
	BoxcastPrecision
}


using UnityEngine;

public enum ERaycastStartHeight
{
	[Tooltip("Casting ray starting from current hips height position of the character. Can be bad for insect creatures!")]
	Hips,
	[Tooltip("Good for spiders! Casting raycast on defined height of the character")]
	StaticScaleReference,
	[Tooltip("Casting ray starting from first bone of the leg (it's affecting height + start raycast position).")]
	FirstBone
}


using UnityEngine;

public enum ERaycastStyle
{
	[Tooltip("Launching raycast from foot above origin point. Good for bipeds with whole body step down/up features.")]
	StraightDown,
	[Tooltip("Launching raycast from pelvis towards foot, good for spider like creatures to detect steep ground more effectively. Body step down/up will not work as precise with this option.")]
	OriginToFoot,
	[Tooltip("Doing raycast like OriginToFoot : but if no ground is found - using another raycast in StraightDown style to find ground below and allow to execute body step down/up feature.")]
	OriginToFoot_DownOnNeed,
	[Tooltip("Doing raycasts per bone : from start bone towards mid bone, mid bone towards end bone, then down. Best precision for insect creatures.")]
	AlongBones,
	[Tooltip("No Raycasting : provide raycast hits custom using code, or leave it custom for just gluing legs animation.")]
	NoRaycasting
}


public enum ERaycastMode
{
	Linecast,
	Spherecast
}


using UnityEngine;

public enum ENoRaycastBehviour
{
	[Tooltip("If ground raycast is lost, leg will detach and switch to ungrounded state")]
	Detach,
	[Tooltip("If no raycast hit detected, should character still animate leg steps in air on zero height floor level? (fake floor)")]
	ZeroFloorSteps,
	[Tooltip("If ground raycast is lost, leg will stick to lastest found raycast hit until leg get stretched")]
	KeepAttached
}


using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public abstract class LAM_FadeOnAnimatorStatusBase : LegsAnimatorControlModuleBase
{
	private enum ELayerSelectMode
	{
		ByIndex,
		Auto
	}

	private LegsAnimator.Variable _fadeSpeedV;

	private LegsAnimator.Variable _layerV;

	private float enabledMultiplier = 1f;

	private float sd_eneMul;

	private List<int> stateHashes;

	private List<int> tagHashes;

	private LegsAnimator.Variable _layerMode;

	private LegsAnimator.Variable _layerSkip;

	private List<int> layersToCheck;

	private int lastAutoWeightIndex;

	private bool InitLayerCheck(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)helper.Parent.Mecanim == (Object)null)
		{
			return false;
		}
		if (_layerMode.GetInt() == 0)
		{
			return false;
		}
		if (_layerMode == null || _layerSkip == null)
		{
			return false;
		}
		layersToCheck = new List<int>();
		string[] array = _layerSkip.GetString().Split(',');
		for (int i = 0; i < helper.Parent.Mecanim.layerCount; i++)
		{
			layersToCheck.Add(i);
		}
		for (int j = 0; j < array.Length; j++)
		{
			if (int.TryParse(array[j], out var result))
			{
				layersToCheck.Remove(result);
				continue;
			}
			int num = -1;
			for (int k = 0; k < helper.Parent.Mecanim.layerCount; k++)
			{
				if (helper.Parent.Mecanim.GetLayerName(k) == array[j])
				{
					num = k;
					break;
				}
			}
			if (num != -1)
			{
				layersToCheck.Remove(num);
			}
		}
		return true;
	}

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if ((Object)(object)base.LA.Mecanim == (Object)null)
		{
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: Not found animator reference in legs animator Extra/Control!");
			helper.Enabled = false;
			return;
		}
		_layerV = helper.RequestVariable("Animation Layer", 0);
		_fadeSpeedV = helper.RequestVariable("Fade Speed", 0.75f);
		LegsAnimator.Variable variable = helper.RequestVariable("Animation State Tag", "");
		string[] array = helper.RequestVariable("Animation State Name", "").GetString().Split(',');
		stateHashes = new List<int>();
		if (array.Length != 0)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (!string.IsNullOrWhiteSpace(array[i]))
				{
					stateHashes.Add(Animator.StringToHash(array[i]));
				}
			}
		}
		string[] array2 = variable.GetString().Split(',');
		tagHashes = new List<int>();
		if (array2.Length != 0)
		{
			for (int j = 0; j < array2.Length; j++)
			{
				if (!string.IsNullOrWhiteSpace(array2[j]))
				{
					tagHashes.Add(Animator.StringToHash(array2[j]));
				}
			}
		}
		if (stateHashes.Count == 0 && tagHashes.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No assigned animation state names/tags to control module on!");
			return;
		}
		if (_layerV.GetInt() < 0)
		{
			_layerV.SetValue(0);
		}
		if (_layerV.GetInt() > base.LA.Mecanim.layerCount - 1)
		{
			_layerV.SetValue(base.LA.Mecanim.layerCount - 1);
		}
		_layerMode = helper.RequestVariable("Mode", 0);
		_layerSkip = helper.RequestVariable("Skip", "");
		if (_layerMode.GetInt() == 1 && !InitLayerCheck(helper))
		{
			_layerMode.SetValue(0);
		}
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		Animator mecanim = base.LA.Mecanim;
		if ((Object)(object)mecanim == (Object)null)
		{
			return;
		}
		int num = _layerV.GetInt();
		if (_layerMode.GetInt() == 1)
		{
			float num2 = 0f;
			int num3 = -1;
			for (int num4 = layersToCheck.Count - 1; num4 >= 0; num4--)
			{
				int num5 = layersToCheck[num4];
				float layerWeight = helper.Parent.Mecanim.GetLayerWeight(num5);
				if (layerWeight > 0.95f)
				{
					num3 = num5;
					break;
				}
				if (layerWeight > num2)
				{
					num2 = layerWeight;
					num3 = num5;
				}
			}
			num = (lastAutoWeightIndex = num3);
		}
		AnimatorStateInfo val = (mecanim.IsInTransition(num) ? mecanim.GetNextAnimatorStateInfo(num) : mecanim.GetCurrentAnimatorStateInfo(num));
		bool flag = false;
		for (int i = 0; i < stateHashes.Count; i++)
		{
			if (((AnimatorStateInfo)(ref val)).shortNameHash == stateHashes[i])
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			for (int j = 0; j < tagHashes.Count; j++)
			{
				if (((AnimatorStateInfo)(ref val)).tagHash == tagHashes[j])
				{
					flag = true;
					break;
				}
			}
		}
		float num6 = 0.3f - _fadeSpeedV.GetFloat() * 0.299f;
		if (flag)
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, -0.001f, ref sd_eneMul, num6 * 0.9f, 100000f, base.LA.DeltaTime);
		}
		else
		{
			enabledMultiplier = Mathf.SmoothDamp(enabledMultiplier, 1.01f, ref sd_eneMul, num6, 100000f, base.LA.DeltaTime);
		}
		enabledMultiplier = Mathf.Clamp01(enabledMultiplier);
		OnFadeAction(helper, enabledMultiplier);
	}

	protected abstract void OnFadeAction(LegsAnimator.LegsAnimatorCustomModuleHelper helper, float fadeValue);
}


private enum ELayerSelectMode
{
	ByIndex,
	Auto
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public abstract class LegsAnimatorControlModuleBase : ScriptableObject
{
	protected Transform Transform => Owner.BaseTransform;

	protected LegsAnimator LA => Owner;

	protected LegsAnimator LegsAnim => Owner;

	protected LegsAnimator Owner { get; private set; }

	protected bool Initialized { get; private set; }

	public virtual bool AskForSpineBone => false;

	public virtual bool AskForChestBone => false;

	public float ModuleBlend { get; set; }

	public float EffectBlend => ModuleBlend * LA._MainBlend;

	public void Base_Init(LegsAnimator legs, LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		ModuleBlend = 1f;
		Owner = legs;
		OnInit(helper);
		Initialized = true;
	}

	public virtual void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnPostLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void OnValidateAfterManualChanges(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
	}

	public virtual void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
	}

	public virtual void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
	}
}


using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_AnimationCurvesGlueCondition : LegsAnimatorControlModuleBase
{
	private LegsAnimator.LegsAnimatorCustomModuleHelper _useHelper;

	private LegsAnimator.Variable _play_FloorValueBelow;

	private LegsAnimator.Variable _play_IgnoreMidConditions;

	private LegsAnimator.Variable _play_AllowHeightGlueOnLevels;

	private List<int> animatorHashes;

	private bool initialized;

	private LegsAnimator.Variable FloorValueBelowVar => _useHelper.RequestVariable("Floor Value Below", 0.01f);

	private LegsAnimator.Variable IgnoreMidConditionsVar => _useHelper.RequestVariable("Ignore Mid Conditions", false);

	private LegsAnimator.Variable AllowHeightGlueOnLevelVar => _useHelper.RequestVariable("Allow Height Glue On Level", -1f);

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (!((Object)(object)base.LA.Mecanim == (Object)null) && helper.customStringList != null)
		{
			_useHelper = helper;
			_play_FloorValueBelow = FloorValueBelowVar;
			_play_IgnoreMidConditions = IgnoreMidConditionsVar;
			_play_AllowHeightGlueOnLevels = AllowHeightGlueOnLevelVar;
			animatorHashes = new List<int>();
			for (int i = 0; i < base.LA.Legs.Count && i < helper.customStringList.Count; i++)
			{
				animatorHashes.Add(Animator.StringToHash(helper.customStringList[i]));
			}
			initialized = true;
		}
	}

	public override void Leg_LateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		if (!initialized || leg.G_CustomForceAttach)
		{
			return;
		}
		float num = base.LA.Mecanim.GetFloat(animatorHashes[leg.PlaymodeIndex]);
		if (num <= _play_AllowHeightGlueOnLevels.GetFloat() && leg.A_PreWasAligning)
		{
			num = _play_FloorValueBelow.GetFloat() - 0.01f;
		}
		if (num <= _play_FloorValueBelow.GetFloat())
		{
			leg.G_CustomForceAttach = base.LA.GroundedTime > 0.2f;
			if (_play_IgnoreMidConditions.GetBool())
			{
				leg.G_CustomForceNOTDetach = true;
			}
		}
		else
		{
			leg.G_CustomForceNOTAttach = true;
			if (_play_IgnoreMidConditions.GetBool())
			{
				leg.G_CustomForceDetach = true;
			}
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_AutoGroundAlignBodyMatrix : LegsAnimatorControlModuleBase
{
	private Vector3 averageNormal;

	private Vector3 animatedAverageNormal;

	private Quaternion lastOrientation;

	private LegsAnimator.Variable _blendV;

	private LegsAnimator.Variable _rotateV;

	private LegsAnimator.Variable _alignSpdV;

	private LegsAnimator.Variable _alignDownV;

	private LegsAnimator.Variable _AxisBlendV;

	private float _blend = 1f;

	public override bool AskForSpineBone => true;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		animatedAverageNormal = base.LA.Up;
		lastOrientation = base.LA.BaseTransform.rotation;
		_blendV = helper.RequestVariable("Matrix Blend", 1f);
		_rotateV = helper.RequestVariable("Rotate Hips", 1f);
		_alignSpdV = helper.RequestVariable("Aligning Speed", 0.7f);
		_alignDownV = helper.RequestVariable("Spine Restore", 0.5f);
		_AxisBlendV = helper.RequestVariable("Rotation Axis Blend", Vector3.one);
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		_blend = base.EffectBlend;
		if (leg.RaycastHitted)
		{
			Vector3 val = averageNormal;
			RaycastHit lastGroundHit = leg.LastGroundHit;
			averageNormal = val + ((RaycastHit)(ref lastGroundHit)).normal;
		}
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = lastOrientation;
		float num = _blend * _blendV.GetFloat();
		if (num < 1f)
		{
			val = Quaternion.SlerpUnclamped(Quaternion.identity, lastOrientation, num);
		}
		Matrix4x4 mx = Matrix4x4.TRS(base.LA.BaseTransform.position, val * base.LA.BaseTransform.rotation, base.LA.BaseTransform.lossyScale);
		base.LA.User_OverwriteCastMatrix(mx);
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		float num = _blend * _rotateV.GetFloat();
		if (!(num < 0.001f))
		{
			Vector3 eulerAngles = ((Quaternion)(ref lastOrientation)).eulerAngles;
			eulerAngles.x = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.x);
			eulerAngles.y = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.y);
			eulerAngles.z = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.z);
			Quaternion identity = Quaternion.identity;
			identity *= Quaternion.AngleAxis(eulerAngles.x * num, Vector3.right);
			identity *= Quaternion.AngleAxis(eulerAngles.y * num, Vector3.up);
			identity *= Quaternion.AngleAxis(eulerAngles.z * num, Vector3.forward);
			LegsAnimator lA = base.LA;
			lA._LastHipsRotationOffsetOutsideInfo *= identity;
			if (Object.op_Implicit((Object)(object)base.LA.SpineBone))
			{
				Quaternion rotation = base.LA.SpineBone.rotation;
				base.LA.HipsSetup.bone.rotation = identity * base.LA.HipsSetup.bone.rotation;
				base.LA.SpineBone.rotation = Quaternion.Slerp(base.LA.SpineBone.rotation, rotation, _alignDownV.GetFloat());
			}
			else
			{
				base.LA.HipsSetup.bone.rotation = identity * base.LA.HipsSetup.bone.rotation;
			}
		}
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		if (averageNormal == Vector3.zero)
		{
			averageNormal = base.LA.Up;
		}
		else
		{
			((Vector3)(ref averageNormal)).Normalize();
		}
		if (_alignSpdV.GetFloat() < 0.999f)
		{
			float num = Mathf.LerpUnclamped(5f, 20f, _alignSpdV.GetFloat());
			animatedAverageNormal = Vector3.Slerp(animatedAverageNormal, averageNormal, base.LA.DeltaTime * num);
		}
		else
		{
			animatedAverageNormal = averageNormal;
		}
		lastOrientation = Quaternion.FromToRotation(Vector3.up, animatedAverageNormal);
		Vector3 vector = _AxisBlendV.GetVector3();
		if (vector != Vector3.one)
		{
			Vector3 eulerAngles = ((Quaternion)(ref lastOrientation)).eulerAngles;
			vector = helper.Parent.BaseTransform.TransformDirection(vector);
			lastOrientation = Quaternion.Euler(eulerAngles.x * vector.x, eulerAngles.y * vector.y, eulerAngles.z * vector.z);
		}
		averageNormal = Vector3.zero;
	}
}


using System;
using System.Collections.Generic;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_BasicPoseAdjust : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _AdjustPowerX;

	private LegsAnimator.Variable _AdjustPowerZ;

	[NonSerialized]
	private LegsAnimator.Leg[] legs;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_AdjustPowerX = helper.RequestVariable("Adjust X Positioning", 1f);
		_AdjustPowerZ = helper.RequestVariable("Adjust Z Positioning", 1f);
		List<LegsAnimator.Leg> list = new List<LegsAnimator.Leg>();
		if (helper.customStringList == null || helper.customStringList.Count == 0)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				list.Add(base.LA.Legs[i]);
			}
		}
		else
		{
			for (int j = 0; j < helper.customStringList.Count; j++)
			{
				if (helper.customStringList[j] == "1")
				{
					list.Add(base.LA.Legs[j]);
				}
			}
		}
		if (list.Count == 0)
		{
			helper.Enabled = false;
			Debug.Log((object)"[Legs Animator] Fade On Animation Module: No legs definition!");
		}
		else
		{
			legs = list.ToArray();
		}
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (legs == null)
		{
			return;
		}
		float effectBlend = base.EffectBlend;
		for (int i = 0; i < legs.Length; i++)
		{
			LegsAnimator.Leg leg = legs[i];
			Vector3 val = base.LA.ToRootLocalSpace(leg._AnimatorEndBonePos);
			Vector3 val2 = val;
			val2.x *= _AdjustPowerX.GetFloat();
			val2.z *= _AdjustPowerZ.GetFloat();
			if (effectBlend < 1f)
			{
				val2 = Vector3.LerpUnclamped(val, val2, effectBlend);
			}
			leg.OverrideAnimatorAnklePosition(base.LA.RootToWorldSpace(val2));
		}
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_DesiredDirectionFromTransform : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable _Reaction;

	private LegsAnimator.Variable _Thres;

	private LegsAnimator.Variable _IsMov;

	private Vector3 calculatedVelo = Vector3.zero;

	private Vector3 _sd_average = Vector3.zero;

	private Vector3 previousPosition = Vector3.zero;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		_Reaction = helper.RequestVariable("Reaction Speed", 0.8f);
		_IsMov = helper.RequestVariable("Control 'IsMoving'", false);
		_Thres = helper.RequestVariable("Not Moving Threshold", 0.2f);
		previousPosition = base.LA.BaseTransform.position;
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = base.LA.BaseTransform.position - previousPosition;
		previousPosition = base.LA.BaseTransform.position;
		Vector3 val2 = val / base.LA.DeltaTime;
		val2 = base.LA.ToRootLocalSpaceVec(val2);
		val2.y = 0f;
		val2 = base.LA.RootToWorldSpaceVec(val2);
		float magnitude = ((Vector3)(ref calculatedVelo)).magnitude;
		val2 = Vector3.Slerp(val2, ((Vector3)(ref val2)).normalized, Mathf.InverseLerp(0f, magnitude, base.LA.ScaleReference));
		calculatedVelo = Vector3.SmoothDamp(calculatedVelo, val2, ref _sd_average, 5E-05f + (1f - _Reaction.GetFloat()) * 0.15f, 100000f, base.LA.DeltaTime);
		if (_IsMov.GetBool())
		{
			base.LA.User_SetIsMoving(magnitude > base.LA.ScaleReference * _Thres.GetFloat());
		}
		base.LA.User_SetDesiredMovementDirection(calculatedVelo);
	}
}


using System;
using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "LAM_DirectionalMovement", menuName = "FImpossible Creations/Legs Animator/Module - 360 Movement Animation", order = 2)]
public class LAM_DirectionalMovement : LegsAnimatorControlModuleBase
{
	[Serializable]
	public class AnglesSetup
	{
		public Vector3 AnglesOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips rotations on reaching 45 angle movement")]
		public Vector3 AnglesOn45 = new Vector3(-10f, 14f, -5f);

		[Tooltip(" Hips rotations on reaching 90 angle movement")]
		public Vector3 AnglesOn90 = new Vector3(-7f, 40f, -3f);

		[Tooltip(" Hips rotations on reaching 135 angle movement")]
		public Vector3 AnglesOn135 = new Vector3(-8f, -25f, -4f);

		[Tooltip(" Hips rotations on reaching 180 angle movement")]
		public Vector3 AnglesOn180 = new Vector3(-20f, 0f, 0f);

		[Space(8f)]
		public Vector3 HipsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips position offset on reaching 45 angle movement")]
		public Vector3 HipsOffsetOn45 = new Vector3(-0.05f, 0f, -0.05f);

		[Tooltip(" Hips position offset on reaching 90 angle movement")]
		public Vector3 HipsOffsetOn90 = new Vector3(-0.1f, 0f, 0.05f);

		[Tooltip(" Hips position offset on reaching 135 angle movement")]
		public Vector3 HipsOffsetOn135 = new Vector3(-0.1f, 0f, 0.1f);

		[Tooltip(" Hips position offset on reaching 180 angle movement")]
		public Vector3 HipsOffsetOn180 = new Vector3(0f, 0.05f, 0.2f);

		[Space(8f)]
		public Vector3 IKsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Foot IK position offset on reaching 45 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn45 = new Vector3(0f, 0f, -0.04f);

		[Tooltip(" Foot IK position offset on reaching 90 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn90 = new Vector3(0f, 0f, -0.08f);

		[Tooltip(" Foot IK position offset on reaching 135 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn135 = new Vector3(0f, 0f, 0.08f);

		[Tooltip(" Foot IK position offset on reaching 180 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn180 = new Vector3(0f, 0f, 0f);
	}

	private class LegRedirectHelper
	{
		private LAM_DirectionalMovement parent;

		private LegsAnimator.Leg leg;

		internal LegRedirectHelper oppositeHelper;

		private Vector3 computedPosLocal = Vector3.zero;

		private Quaternion _footRedirCache = Quaternion.identity;

		private LegsAnimator LA => parent.LA;

		public Vector3 LastComputedWorldSpaceLegPos { get; private set; }

		public LegRedirectHelper(LAM_DirectionalMovement parent, LegsAnimator.Leg leg)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			this.parent = parent;
			this.leg = leg;
			LastComputedWorldSpaceLegPos = leg.BoneEnd.position;
			computedPosLocal = leg.Owner.ToRootLocalSpace(LastComputedWorldSpaceLegPos);
		}

		public Vector3 ComputeIKOffset(Vector3 localPos, float smoother = 1f)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_016d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_027a: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012b: Unknown result type (might be due to invalid IL or missing references)
			//IL_012c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			float @float = parent._play_TrDur.GetFloat();
			Vector3 val = parent._calc_LocalRotDir * localPos;
			float num = Vector3.Magnitude(val - computedPosLocal);
			float num2 = num / leg.Owner.ScaleReferenceNoScale;
			float num3 = 0f;
			if (num > 0.2f)
			{
				num3 = Mathf.InverseLerp(0.2f, 1f, num);
				num3 *= 0.1f;
				if (@float < 0.1f)
				{
					num3 *= @float / 0.1f;
				}
			}
			if (parent._calc_toNegativeXProgress > 0f)
			{
				Vector3 val2 = localPos;
				val2.x *= -1f;
				Vector3 val3 = parent._calc_LocalRotDir * val2;
				val = Vector3.Lerp(val, val3, parent._calc_toNegativeXProgress);
			}
			float num4 = 0f;
			if (!(smoother >= 3f))
			{
				if (smoother > 0f)
				{
					if (num2 < 0.1f / smoother)
					{
						computedPosLocal = val;
					}
					else
					{
						num4 = Mathf.InverseLerp(1.5f * smoother, 0.1f / smoother, num2) * 6f;
					}
					num4 = Mathf.Max(0f, num4);
				}
				else
				{
					computedPosLocal = val;
				}
			}
			computedPosLocal = Vector3.Lerp(computedPosLocal, val, LA.DeltaTime * (Mathf.Lerp(20f, 4f, (parent._calc_angleDiffFactor * @float + num3) * 1.5f) + num4));
			computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, val.y, 0.5f);
			if (parent._var_raiseLimit > 0f)
			{
				float c_AnimatedAnkleFlatHeight = leg.C_AnimatedAnkleFlatHeight;
				float num5 = 0f;
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorR);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorL);
				}
				if (parent._calc_toNegativeXProgress > 0f)
				{
					num5 = Mathf.Lerp(num5, 1f, parent._calc_toNegativeXProgress);
				}
				computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, c_AnimatedAnkleFlatHeight, num5 * parent._var_raiseLimit);
			}
			LastComputedWorldSpaceLegPos = LA.RootToWorldSpace(computedPosLocal);
			return computedPosLocal;
		}

		internal Quaternion FootRedirectSmoother(Quaternion target)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			_footRedirCache = Quaternion.Lerp(_footRedirCache, target, parent._calc_deltaSpeedSlow);
			return _footRedirCache;
		}
	}

	private LegsAnimator.LegsAnimatorCustomModuleHelper _useHelper;

	private LegsAnimator.Variable _play_HipsRedir;

	private LegsAnimator.Variable _play_FeetRedir;

	private LegsAnimator.Variable _play_KneesRedir;

	private LegsAnimator.Variable _play_TrDur;

	private LegsAnimator.Variable _play_LimitRaise;

	private LegsAnimator.Variable _play_FixFeet;

	private LegsAnimator.Variable _play_AdjustStretch;

	private LegsAnimator.Variable _play_RestoreSpine;

	private LegsAnimator.Variable _play_Smoother;

	private LegsAnimator.Variable _play_reAdj;

	private LegsAnimator.Variable _play_offInAir;

	private int _hash_xDir = -1;

	private int _hash_zDir = -1;

	private Vector3 _calc_WorldDir = Vector3.zero;

	private Vector3 _calc_LocalDir = Vector3.zero;

	private Quaternion _calc_LocalRotDir = Quaternion.identity;

	private float _localTargetAngle;

	private float _wrappedAngle;

	private float _smoothedWrappedAngle;

	private float _calc_smoothedTargetAngle;

	private float _calc_angleDiffFactor;

	private float _calc_toNegativeXProgress;

	internal float _calc_backAngleOff;

	private float _calc_sideFactorL;

	private float _calc_sideFactorR;

	internal float _calc_sideFactor;

	private float _calc_deltaSpeed;

	private float _calc_deltaSpeedSlow;

	private float _var_raiseLimit;

	private float _var_fixFeet;

	private Vector3 _calc_hipsPositionOffsets = Vector3.zero;

	private Vector3 _calc_hipsRotationOffsets = Vector3.zero;

	private Vector3 _calc_hipsStretchOffset = Vector3.zero;

	private Vector3 _sd_hipsStretchOff = Vector3.zero;

	private Vector3 _calc_ikOff = Vector3.zero;

	private List<LegRedirectHelper> legRedirectHelpers;

	[NonSerialized]
	public Transform SpineBone;

	[NonSerialized]
	public Vector3 User_MultiplyHipsOffsets = Vector3.one;

	[FPD_Header("Angles setup to drive procedural animation", 6f, 4f, 2)]
	public AnglesSetup Animation360Angles;

	[NonSerialized]
	public float User_StretchRotatorAnglePower = 30f;

	[NonSerialized]
	public float User_StretchPositionMultiplier = 1f;

	private float _mainBlend = 1f;

	private bool _wasUpdated;

	private Vector3 overridingDirection = Vector3.zero;

	private bool useOverridingDirection;

	[NonSerialized]
	public float overrideDirectionFadeSpeed = 6f;

	private float overrideDirectionBlend;

	private float _calc_lStretch;

	private float _calc_rStretch;

	private LegsAnimator.Variable HipsRedirVar => _useHelper.RequestVariable("Redirect Hips", 0.8f);

	private LegsAnimator.Variable FeetRedirVar => _useHelper.RequestVariable("Redirect Feet", 0.8f);

	private LegsAnimator.Variable KneesRedirVar => _useHelper.RequestVariable("Redirect Knees", 0.4f);

	private LegsAnimator.Variable TrDurationVar => _useHelper.RequestVariable("Transitions Duration", 0.25f);

	private LegsAnimator.Variable LimitRaiseVar => _useHelper.RequestVariable("Limit Leg Raise", 0.1f);

	private LegsAnimator.Variable FixFeetVar => _useHelper.RequestVariable("Fix Backward Feet", 1f);

	private LegsAnimator.Variable AdjustStretchVar => _useHelper.RequestVariable("Adjust Stretched", 0.2f);

	private LegsAnimator.Variable RestoreSpineVar => _useHelper.RequestVariable("Restore Spine", 0.5f);

	private LegsAnimator.Variable ExtraSmootherVar => _useHelper.RequestVariable("Extra Smoother", 0f);

	private LegsAnimator.Variable ReAdjVar => _useHelper.RequestVariable("Re-adjust with hips offset", false);

	private LegsAnimator.Variable FadeOffInAirVar => _useHelper.RequestVariable("Disable When Jumping", false);

	private LegsAnimator.Variable XDirAnimVarVar => _useHelper.RequestVariable("Animator World X Dir", "");

	private LegsAnimator.Variable ZDirAnimVarVar => _useHelper.RequestVariable("Animator World Z Dir", "");

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_useHelper = helper;
		_play_HipsRedir = HipsRedirVar;
		_play_TrDur = TrDurationVar;
		_play_LimitRaise = LimitRaiseVar;
		_play_FeetRedir = FeetRedirVar;
		_play_KneesRedir = KneesRedirVar;
		_play_FixFeet = FixFeetVar;
		_play_AdjustStretch = AdjustStretchVar;
		_play_RestoreSpine = RestoreSpineVar;
		_play_Smoother = ExtraSmootherVar;
		_play_offInAir = FadeOffInAirVar;
		_play_reAdj = ReAdjVar;
		_wasUpdated = false;
		legRedirectHelpers = new List<LegRedirectHelper>();
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegRedirectHelper item = new LegRedirectHelper(this, base.LA.Legs[i]);
			legRedirectHelpers.Add(item);
		}
		for (int j = 0; j < base.LA.Legs.Count; j++)
		{
			if (base.LA.Legs[j].OppositeLegIndex >= 0)
			{
				legRedirectHelpers[j].oppositeHelper = legRedirectHelpers[base.LA.Legs[j].OppositeLegIndex];
			}
		}
		if ((Object)(object)SpineBone == (Object)null && base.LA.Hips.childCount > 0)
		{
			if (base.LA.Hips.childCount == 1)
			{
				SpineBone = base.LA.Hips.GetChild(0);
			}
			else
			{
				for (int k = 0; k < base.LA.Hips.childCount; k++)
				{
					if (((Object)base.LA.Hips.GetChild(k)).name.ToLower().Contains("spin"))
					{
						SpineBone = base.LA.Hips.GetChild(k);
						break;
					}
				}
				if ((Object)(object)SpineBone == (Object)null)
				{
					SpineBone = base.LA.Hips.GetChild(0);
				}
			}
		}
		if (Object.op_Implicit((Object)(object)base.LA.Mecanim))
		{
			LegsAnimator.Variable xDirAnimVarVar = XDirAnimVarVar;
			if (!string.IsNullOrWhiteSpace(xDirAnimVarVar.GetString()))
			{
				_hash_xDir = Animator.StringToHash(xDirAnimVarVar.GetString());
				LegsAnimator.Variable zDirAnimVarVar = ZDirAnimVarVar;
				_hash_zDir = Animator.StringToHash(zDirAnimVarVar.GetString());
			}
		}
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a3: Unknown result type (might be due to invalid IL or missing references)
		_mainBlend = base.LA._MainBlend * base.ModuleBlend;
		if (_play_offInAir.GetBool())
		{
			_mainBlend *= base.LA.IsGroundedBlend;
		}
		float @float = _play_TrDur.GetFloat();
		if (_mainBlend < 0.001f)
		{
			return;
		}
		if (useOverridingDirection)
		{
			if (overrideDirectionFadeSpeed < 0.0001f)
			{
				overrideDirectionBlend = 1f;
			}
			else
			{
				overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 1f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
			}
		}
		else if (overrideDirectionFadeSpeed < 0.0001f)
		{
			overrideDirectionBlend = 0f;
		}
		else
		{
			overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 0f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
		}
		Vector3 calc_WorldDir;
		if (_hash_zDir != -1)
		{
			Vector3 val = new Vector3(base.LA.Mecanim.GetFloat(_hash_xDir), 0f, base.LA.Mecanim.GetFloat(_hash_zDir));
			calc_WorldDir = ((Vector3)(ref val)).normalized;
		}
		else
		{
			calc_WorldDir = base.LA.DesiredMovementDirection;
			calc_WorldDir.y = 0f;
			if (((Vector3)(ref calc_WorldDir)).magnitude < 0.1f)
			{
				calc_WorldDir = Vector3.zero;
			}
		}
		_calc_WorldDir = calc_WorldDir;
		if (overrideDirectionBlend > 0.0001f)
		{
			if (overrideDirectionBlend >= 1f)
			{
				_calc_WorldDir = overridingDirection;
			}
			else
			{
				_calc_WorldDir = Vector3.Slerp(_calc_WorldDir, overridingDirection, overrideDirectionBlend);
			}
		}
		_calc_LocalDir = base.LA.ToRootLocalSpaceVec(_calc_WorldDir);
		_var_raiseLimit = _play_LimitRaise.GetFloat();
		_var_fixFeet = _play_FixFeet.GetFloat();
		if (((Vector3)(ref _calc_LocalDir)).sqrMagnitude < 1E-05f)
		{
			_localTargetAngle = 0f;
		}
		_localTargetAngle = FEngineering.GetAngleRad(_calc_LocalDir.x, _calc_LocalDir.z);
		float num = ((!(@float <= 0f)) ? (3f * Mathf.Lerp(5f, 0.5f, @float / 0.6f)) : 1000f);
		_calc_deltaSpeed = base.LA.DeltaTime * num;
		_calc_deltaSpeedSlow = base.LA.DeltaTime * (num * 0.6f);
		_calc_smoothedTargetAngle = Mathf.LerpAngle(_calc_smoothedTargetAngle, _localTargetAngle, _calc_deltaSpeedSlow);
		_calc_angleDiffFactor = Mathf.InverseLerp(0.0001f, 0.25f, Mathf.Abs((_localTargetAngle - _calc_smoothedTargetAngle) / MathF.PI));
		_localTargetAngle *= 57.29578f;
		_wrappedAngle = FormatAngleToPM180(_localTargetAngle);
		_smoothedWrappedAngle = Mathf.LerpAngle(_smoothedWrappedAngle, _wrappedAngle, _calc_deltaSpeed * 1.25f);
		_smoothedWrappedAngle = FormatAngleToPM180(_smoothedWrappedAngle);
		if (_smoothedWrappedAngle < -179.9f && _wrappedAngle > 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		if (_smoothedWrappedAngle > 179.9f && _wrappedAngle < 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		float wrappedAngle = _wrappedAngle;
		float num2 = ((!(_wrappedAngle < 90f)) ? Mathf.InverseLerp(180f, 90f, wrappedAngle) : Mathf.InverseLerp(0f, 90f, wrappedAngle));
		_calc_sideFactorR = Mathf.Lerp(_calc_sideFactorR, num2, _calc_deltaSpeed * 2f);
		num2 = ((!(_wrappedAngle > -90f)) ? Mathf.InverseLerp(-180f, -90f, wrappedAngle) : Mathf.InverseLerp(0f, -90f, wrappedAngle));
		_calc_sideFactorL = Mathf.Lerp(_calc_sideFactorL, num2, _calc_deltaSpeed * 2f);
		if (_wrappedAngle < 0f)
		{
			_calc_sideFactor = _calc_sideFactorL;
		}
		else
		{
			_calc_sideFactor = _calc_sideFactorR;
		}
		_calc_toNegativeXProgress = 0f;
		float wrappedAngle2 = _wrappedAngle;
		if (wrappedAngle2 < -90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(-90f, -135f, wrappedAngle2);
		}
		else if (wrappedAngle2 > 90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(90f, 135f, wrappedAngle2);
		}
		_calc_LocalRotDir = Quaternion.Euler(0f, _localTargetAngle, 0f);
		_wasUpdated = true;
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		if (!_wasUpdated)
		{
			return;
		}
		float smoother = _play_Smoother.GetFloat() + 1f;
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			Vector3 animatorEndBonePos = leg._AnimatorEndBonePos;
			Vector3 localPos = base.LA.ToRootLocalSpace(animatorEndBonePos);
			LegRedirectHelper legRedirectHelper = legRedirectHelpers[leg.PlaymodeIndex];
			legRedirectHelper.ComputeIKOffset(localPos, smoother);
			Vector3 val = legRedirectHelper.LastComputedWorldSpaceLegPos;
			if (_mainBlend < 1f)
			{
				val = Vector3.LerpUnclamped(animatorEndBonePos, val, _mainBlend);
			}
			Vector3 calc_ikOff = _calc_ikOff;
			if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Left)
			{
				calc_ikOff.x = 0f - calc_ikOff.x;
			}
			else if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Right)
			{
				calc_ikOff.z = 0f - calc_ikOff.z;
			}
			calc_ikOff = base.LA.RootToWorldSpaceVec(calc_ikOff);
			val += calc_ikOff;
			leg.OverrideAnimatorAnklePosition(val);
		}
	}

	public void OverrideMoveDirection(Vector3? direction)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!direction.HasValue)
		{
			useOverridingDirection = false;
			return;
		}
		useOverridingDirection = true;
		overridingDirection = direction.Value;
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06de: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0724: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_074c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0751: Unknown result type (might be due to invalid IL or missing references)
		//IL_0756: Unknown result type (might be due to invalid IL or missing references)
		//IL_0758: Unknown result type (might be due to invalid IL or missing references)
		//IL_0777: Unknown result type (might be due to invalid IL or missing references)
		//IL_077c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0781: Unknown result type (might be due to invalid IL or missing references)
		//IL_0786: Unknown result type (might be due to invalid IL or missing references)
		//IL_0788: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_0819: Unknown result type (might be due to invalid IL or missing references)
		//IL_0820: Unknown result type (might be due to invalid IL or missing references)
		//IL_0822: Unknown result type (might be due to invalid IL or missing references)
		//IL_0854: Unknown result type (might be due to invalid IL or missing references)
		//IL_0859: Unknown result type (might be due to invalid IL or missing references)
		//IL_0865: Unknown result type (might be due to invalid IL or missing references)
		//IL_086f: Unknown result type (might be due to invalid IL or missing references)
		//IL_087f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0884: Unknown result type (might be due to invalid IL or missing references)
		//IL_088f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0894: Unknown result type (might be due to invalid IL or missing references)
		//IL_089d: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_080d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_045c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0470: Unknown result type (might be due to invalid IL or missing references)
		//IL_0484: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_0525: Unknown result type (might be due to invalid IL or missing references)
		//IL_0539: Unknown result type (might be due to invalid IL or missing references)
		//IL_058e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0596: Unknown result type (might be due to invalid IL or missing references)
		//IL_0598: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0563: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0900: Unknown result type (might be due to invalid IL or missing references)
		//IL_0905: Unknown result type (might be due to invalid IL or missing references)
		//IL_0907: Unknown result type (might be due to invalid IL or missing references)
		if (!_wasUpdated)
		{
			return;
		}
		float @float = _play_HipsRedir.GetFloat();
		float float2 = _play_FeetRedir.GetFloat();
		float float3 = _play_KneesRedir.GetFloat();
		float float4 = _play_AdjustStretch.GetFloat();
		float num = Mathf.Abs(_wrappedAngle);
		float num2 = Mathf.InverseLerp(0f, 45f, num);
		float wrappedAngle = _wrappedAngle;
		float num3 = wrappedAngle;
		if (float2 > 0f)
		{
			if (wrappedAngle < -90f)
			{
				num3 = ((!(wrappedAngle > -135f)) ? Mathf.Lerp(40f, 0f, Mathf.InverseLerp(-135f, -180f, wrappedAngle)) : Mathf.Lerp(-90f, 40f, Mathf.InverseLerp(-90f, -135f, wrappedAngle)));
			}
			else if (wrappedAngle > 90f)
			{
				num3 = ((!(wrappedAngle < 135f)) ? Mathf.Lerp(-40f, 0f, Mathf.InverseLerp(135f, 180f, wrappedAngle)) : Mathf.Lerp(90f, -40f, Mathf.InverseLerp(90f, 135f, wrappedAngle)));
			}
		}
		Vector3 val = Vector3.zero;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		num6 = ((!(num > 135f)) ? Mathf.InverseLerp(90f, 135f, num) : Mathf.InverseLerp(180f, 135f, num));
		num6 = Mathf.Lerp(1f, -0.5f, num6);
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			if (float2 > 0f)
			{
				float num7 = num3;
				float num8 = 1f - float2;
				num8 = num8 * num8 * num8;
				Quaternion target = Quaternion.AngleAxis(num7 * (1f - num8) * 0.8f * _mainBlend, base.LA.BaseTransform.up);
				target = legRedirectHelpers[i].FootRedirectSmoother(target);
				leg.OverrideFinalIKRot(target * leg.GetFinalIKRot());
			}
			if (float3 > 0f)
			{
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorR) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorL) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
			}
			else
			{
				leg.IKProcessor.StartBoneRotationOffset = Quaternion.identity;
			}
			if (!(float4 > 0.01f))
			{
				continue;
			}
			float stretchValue = leg.IKProcessor.GetStretchValue(legRedirectHelpers[i].LastComputedWorldSpaceLegPos);
			if (stretchValue > 0.9f)
			{
				float num9 = Mathf.InverseLerp(0.9f, 1.125f, stretchValue);
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num4 += num9;
				}
				else
				{
					num5 += num9;
				}
				Vector3 vec = leg._PreviousFinalIKPos - base.LA.BaseTransform.position;
				vec = base.LA.ToRootLocalSpaceVec(vec);
				vec.y *= -0.8f;
				vec = base.LA.RootToWorldSpaceVec(vec);
				val += vec * (num9 * 1f);
			}
		}
		Vector3 val2 = Animation360Angles.AnglesOn0;
		Vector3 val3 = Animation360Angles.HipsOffsetOn0;
		Vector3 val4 = Animation360Angles.IKsOffsetOn0;
		if (num > 0f)
		{
			if (num < 90f)
			{
				float t = InverseLerpDoubleSide(0f, 45f, num, 90f);
				LerpIt(ref val2, Animation360Angles.AnglesOn45, t);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn45, t);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn45, t);
			}
			if (num > 45f && num < 135f)
			{
				float t2 = InverseLerpDoubleSide(45f, 90f, num, 135f);
				LerpIt(ref val2, Animation360Angles.AnglesOn90, t2);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn90, t2);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn90, t2);
			}
			if (num > 90f)
			{
				float t3 = InverseLerpDoubleSide(90f, 135f, num, 180f);
				LerpIt(ref val2, Animation360Angles.AnglesOn135, t3);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn135, t3);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn135, t3);
			}
			if (num > 135f)
			{
				float t4 = Mathf.InverseLerp(135f, 180f, num);
				LerpIt(ref val2, Animation360Angles.AnglesOn180, t4);
				LerpIt(ref val3, Animation360Angles.HipsOffsetOn180, t4);
				LerpIt(ref val4, Animation360Angles.IKsOffsetOn180, t4);
			}
			if (_wrappedAngle < 0f)
			{
				val2.y = 0f - val2.y;
				val2.z = 0f - val2.z;
				val3.x = 0f - val3.x;
				val4.z = 0f - val4.z;
			}
			val2 *= @float;
			val3 *= 0.7f * @float;
			val2 = Vector3.Scale(val2, User_MultiplyHipsOffsets);
		}
		val4 *= @float * _mainBlend * base.LA.ScaleReference;
		_calc_ikOff = val4;
		float num10 = 0.25f + float4 * 0.75f;
		_calc_lStretch = Mathf.Lerp(_calc_lStretch, num4, _calc_deltaSpeed);
		_calc_rStretch = Mathf.Lerp(_calc_rStretch, num5, _calc_deltaSpeed);
		val2.y -= _calc_lStretch * User_StretchRotatorAnglePower * @float * num10;
		val2.y += _calc_rStretch * User_StretchRotatorAnglePower * @float * num10;
		_calc_hipsRotationOffsets.x = Mathf.LerpAngle(_calc_hipsRotationOffsets.x, val2.x, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.y = Mathf.LerpAngle(_calc_hipsRotationOffsets.y, val2.y, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.z = Mathf.LerpAngle(_calc_hipsRotationOffsets.z, val2.z, _calc_deltaSpeed);
		_calc_hipsPositionOffsets = Vector3.Lerp(_calc_hipsPositionOffsets, val3, _calc_deltaSpeed);
		val3 *= User_StretchPositionMultiplier;
		Quaternion val5 = Quaternion.identity;
		float num11 = _play_RestoreSpine.GetFloat();
		if ((Object)(object)SpineBone != (Object)null)
		{
			val5 = SpineBone.rotation;
		}
		else
		{
			num11 = 0f;
		}
		Quaternion val6 = Quaternion.AngleAxis(_calc_hipsRotationOffsets.y * _mainBlend, base.LA.BaseTransform.up);
		val6 *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.z * _mainBlend, base.LA.BaseTransform.forward);
		val6 *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.x * _mainBlend, base.LA.BaseTransform.right);
		base.LA.Hips.rotation = val6 * base.LA.Hips.rotation;
		if (num11 > 0f)
		{
			SpineBone.rotation = Quaternion.Slerp(SpineBone.rotation, val5, Mathf.Lerp(1f, num11, _mainBlend));
		}
		_calc_hipsStretchOffset = Vector3.SmoothDamp(_calc_hipsStretchOffset, num2 * val, ref _sd_hipsStretchOff, 0.2f + 0.3f * _play_TrDur.GetFloat(), 100000f, base.LA.DeltaTime);
		Vector3 val7 = base.LA.RootToWorldSpaceVec(_calc_hipsPositionOffsets * 0.5f * base.LA.ScaleReference) * _mainBlend;
		LegsAnimator lA = base.LA;
		lA._Hips_Modules_ExtraWOffset += val7 + _calc_hipsStretchOffset * float4 * _mainBlend;
		if (_play_reAdj.GetBool())
		{
			for (int j = 0; j < base.LA.Legs.Count; j++)
			{
				base.LA.Legs[j].OverrideFinalIKPos(base.LA.Legs[j].GetFinalIKPos() - val7);
			}
		}
	}

	public override void OnPostLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		if (!(_mainBlend < 0.001f) && _wasUpdated && _var_fixFeet > 0f)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				LegsAnimator.Leg leg = base.LA.Legs[i];
				Quaternion rotation = leg.IKProcessor.EndIKBone.transform.rotation;
				Quaternion val = leg.IKProcessor.EndIKBone.transform.parent.rotation * leg.IKProcessor.EndIKBone.InitialLocalRotation;
				val = Quaternion.LerpUnclamped(rotation, val, (1f - leg.A_AligningHelperBlend) * _var_fixFeet * base.LA.IsMovingBlend * _calc_toNegativeXProgress);
				leg.IKProcessor.EndIKBone.transform.rotation = val;
			}
		}
	}

	public static float FormatAngleToPM180(float angle)
	{
		float num = angle % 360f;
		if (num > 180f)
		{
			num -= 360f;
		}
		if (num < -180f)
		{
			num += 360f;
		}
		return num;
	}

	private static float InverseLerpDoubleSide(float from, float to, float t, float toRange)
	{
		if (t > to)
		{
			return Mathf.InverseLerp(toRange, to, t);
		}
		return Mathf.InverseLerp(from, to, t);
	}

	private static void LerpIt(ref Vector3 val, Vector3 to, float t)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		val = Vector3.LerpUnclamped(val, to, t);
	}
}


using System;
using UnityEngine;

[Serializable]
public class AnglesSetup
{
	public Vector3 AnglesOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Hips rotations on reaching 45 angle movement")]
	public Vector3 AnglesOn45 = new Vector3(-10f, 14f, -5f);

	[Tooltip(" Hips rotations on reaching 90 angle movement")]
	public Vector3 AnglesOn90 = new Vector3(-7f, 40f, -3f);

	[Tooltip(" Hips rotations on reaching 135 angle movement")]
	public Vector3 AnglesOn135 = new Vector3(-8f, -25f, -4f);

	[Tooltip(" Hips rotations on reaching 180 angle movement")]
	public Vector3 AnglesOn180 = new Vector3(-20f, 0f, 0f);

	[Space(8f)]
	public Vector3 HipsOffsetOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Hips position offset on reaching 45 angle movement")]
	public Vector3 HipsOffsetOn45 = new Vector3(-0.05f, 0f, -0.05f);

	[Tooltip(" Hips position offset on reaching 90 angle movement")]
	public Vector3 HipsOffsetOn90 = new Vector3(-0.1f, 0f, 0.05f);

	[Tooltip(" Hips position offset on reaching 135 angle movement")]
	public Vector3 HipsOffsetOn135 = new Vector3(-0.1f, 0f, 0.1f);

	[Tooltip(" Hips position offset on reaching 180 angle movement")]
	public Vector3 HipsOffsetOn180 = new Vector3(0f, 0.05f, 0.2f);

	[Space(8f)]
	public Vector3 IKsOffsetOn0 = new Vector3(0f, 0f, 0f);

	[Tooltip(" Foot IK position offset on reaching 45 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn45 = new Vector3(0f, 0f, -0.04f);

	[Tooltip(" Foot IK position offset on reaching 90 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn90 = new Vector3(0f, 0f, -0.08f);

	[Tooltip(" Foot IK position offset on reaching 135 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn135 = new Vector3(0f, 0f, 0.08f);

	[Tooltip(" Foot IK position offset on reaching 180 angle movement (x on left leg goes negative)")]
	public Vector3 IKsOffsetOn180 = new Vector3(0f, 0f, 0f);
}


using UnityEngine;

private class LegRedirectHelper
{
	private LAM_DirectionalMovement parent;

	private LegsAnimator.Leg leg;

	internal LegRedirectHelper oppositeHelper;

	private Vector3 computedPosLocal = Vector3.zero;

	private Quaternion _footRedirCache = Quaternion.identity;

	private LegsAnimator LA => parent.LA;

	public Vector3 LastComputedWorldSpaceLegPos { get; private set; }

	public LegRedirectHelper(LAM_DirectionalMovement parent, LegsAnimator.Leg leg)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		this.parent = parent;
		this.leg = leg;
		LastComputedWorldSpaceLegPos = leg.BoneEnd.position;
		computedPosLocal = leg.Owner.ToRootLocalSpace(LastComputedWorldSpaceLegPos);
	}

	public Vector3 ComputeIKOffset(Vector3 localPos, float smoother = 1f)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		float @float = parent._play_TrDur.GetFloat();
		Vector3 val = parent._calc_LocalRotDir * localPos;
		float num = Vector3.Magnitude(val - computedPosLocal);
		float num2 = num / leg.Owner.ScaleReferenceNoScale;
		float num3 = 0f;
		if (num > 0.2f)
		{
			num3 = Mathf.InverseLerp(0.2f, 1f, num);
			num3 *= 0.1f;
			if (@float < 0.1f)
			{
				num3 *= @float / 0.1f;
			}
		}
		if (parent._calc_toNegativeXProgress > 0f)
		{
			Vector3 val2 = localPos;
			val2.x *= -1f;
			Vector3 val3 = parent._calc_LocalRotDir * val2;
			val = Vector3.Lerp(val, val3, parent._calc_toNegativeXProgress);
		}
		float num4 = 0f;
		if (!(smoother >= 3f))
		{
			if (smoother > 0f)
			{
				if (num2 < 0.1f / smoother)
				{
					computedPosLocal = val;
				}
				else
				{
					num4 = Mathf.InverseLerp(1.5f * smoother, 0.1f / smoother, num2) * 6f;
				}
				num4 = Mathf.Max(0f, num4);
			}
			else
			{
				computedPosLocal = val;
			}
		}
		computedPosLocal = Vector3.Lerp(computedPosLocal, val, LA.DeltaTime * (Mathf.Lerp(20f, 4f, (parent._calc_angleDiffFactor * @float + num3) * 1.5f) + num4));
		computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, val.y, 0.5f);
		if (parent._var_raiseLimit > 0f)
		{
			float c_AnimatedAnkleFlatHeight = leg.C_AnimatedAnkleFlatHeight;
			float num5 = 0f;
			if (leg.Side == LegsAnimator.ELegSide.Left)
			{
				num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorR);
			}
			else if (leg.Side == LegsAnimator.ELegSide.Right)
			{
				num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorL);
			}
			if (parent._calc_toNegativeXProgress > 0f)
			{
				num5 = Mathf.Lerp(num5, 1f, parent._calc_toNegativeXProgress);
			}
			computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, c_AnimatedAnkleFlatHeight, num5 * parent._var_raiseLimit);
		}
		LastComputedWorldSpaceLegPos = LA.RootToWorldSpace(computedPosLocal);
		return computedPosLocal;
	}

	internal Quaternion FootRedirectSmoother(Quaternion target)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		_footRedirCache = Quaternion.Lerp(_footRedirCache, target, parent._calc_deltaSpeedSlow);
		return _footRedirCache;
	}
}


using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_EdgeStepDetector : LegsAnimatorControlModuleBase
{
	private LegsAnimator.Variable iterationsV;

	private float initTime;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		initTime = Time.time;
		iterationsV = helper.RequestVariable("Iterations", 5);
	}

	public override void OnReInitialize(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		initTime = Time.time;
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time - initTime < 0.1f)
		{
			return;
		}
		if (leg.User_RaycastHittedSource)
		{
			leg.User_RestoreRaycasting();
			return;
		}
		Vector3 val = base.LegsAnim.ToRootLocalSpace(leg.ParentHub.LastKeyframePosition);
		Vector3 val2 = base.LegsAnim.ToRootLocalSpace(leg.lastRaycastingOrigin);
		val.y = val2.y;
		val.z = val2.z;
		RaycastHit hit = default(RaycastHit);
		float num = Vector3.Distance(leg.lastRaycastingOrigin, leg.lastRaycastingEndPoint);
		float num2 = iterationsV.GetInt();
		for (float num3 = 1f; num3 <= num2; num3 += 1f)
		{
			Vector3 localPos = Vector3.LerpUnclamped(val2, val, 0.1f + num3 / num2);
			localPos = base.LegsAnim.RootToWorldSpace(localPos);
			if (Physics.Raycast(localPos, -base.LegsAnim.Up, ref hit, num * 1.01f, LayerMask.op_Implicit(base.LegsAnim.GroundMask), (QueryTriggerInteraction)1))
			{
				break;
			}
		}
		if ((Object)(object)((RaycastHit)(ref hit)).transform == (Object)null)
		{
			leg.User_RestoreRaycasting();
		}
		else
		{
			leg.User_OverrideRaycastHit(hit, disableSourceRaycast: false);
		}
	}
}


