using System;
using System.Collections.Generic;
using UnityEngine;

public class PathList
{
	public enum Side
	{
		Both,
		Left,
		Right,
		Any
	}

	public enum Placement
	{
		Center,
		Side
	}

	public enum Alignment
	{
		None,
		Neighbor,
		Forward,
		Inward
	}

	[Serializable]
	public class BasicObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Placement Placement;

		public bool AlignToNormal = true;

		public bool HeightToTerrain = true;

		public float Offset;
	}

	[Serializable]
	public class SideObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Side Side;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 25f;

		public float Offset = 2f;
	}

	[Serializable]
	public class PathObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 5f;

		public float Dithering = 5f;
	}

	[Serializable]
	public class BridgeObject
	{
		public string Folder;

		public float Distance = 10f;
	}

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private static Quaternion rot180 = Quaternion.Euler(0f, 180f, 0f);

	public string Name;

	public PathInterpolator Path;

	public bool Spline;

	public bool Start;

	public bool End;

	public float Width;

	public float Offset;

	public float Padding;

	public float Fade;

	public float Scaling;

	public int Topology;

	public int Splat;

	public const float StepSize = 1f;

	public const float MeshStepSize = 16f;

	public const float MeshNormalSmoothing = 0.1f;

	private static float[] placements = new float[3] { 0f, -1f, 1f };

	public PathList(string name, Vector3[] points, float width = 0f, float offset = 0f, float padding = 0f, float fade = 0f, int topology = 0, int splat = 0, bool spline = false, bool start = false, bool end = false, float scaling = 1f)
	{
		Name = name;
		Path = new PathInterpolator(points);
		Width = width;
		Offset = offset;
		Padding = padding;
		Fade = fade;
		Scaling = scaling;
		Topology = topology;
		Splat = splat;
		Spline = spline;
		Start = start;
		End = end;
	}

	private void SpawnObjectsNeighborAligned(ref uint seed, Prefab[] prefabs, List<Vector3> positions)
	{
		if (positions.Count >= 2)
		{
			for (int i = 0; i < positions.Count; i++)
			{
				int index = Mathf.Max(i - 1, 0);
				int index2 = Mathf.Min(i + 1, positions.Count - 1);
				Vector3 position = positions[i];
				Vector3 forward = (positions[index2] - positions[index]).XZ3D();
				Quaternion rotation = Quaternion.LookRotation(forward);
				SpawnObject(ref seed, prefabs, position, rotation);
			}
		}
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation = default(Quaternion), SpawnFilter filter = null)
	{
		Prefab random = ArrayEx.GetRandom(prefabs, ref seed);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = random.Object.transform.localScale;
		random.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!random.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		random.ApplyTerrainPlacements(pos, rot, scale);
		random.ApplyTerrainModifiers(pos, rot, scale);
		World.Serialization.AddPrefab(Name, random.ID, pos, rot, scale);
		return true;
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation = default(Quaternion), SpawnFilter filter = null)
	{
		foreach (Prefab prefab in prefabs)
		{
			Vector3 pos = position;
			Vector3 localScale = prefab.Object.transform.localScale;
			if (!prefab.ApplyTerrainAnchors(ref pos, rotation, localScale, filter))
			{
				return false;
			}
		}
		return true;
	}

	private void SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		if (!obj.AlignToNormal)
		{
			dir = dir.XZ3D().normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 vector = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 vector2 = pos + placements[i] * vector;
			if (obj.HeightToTerrain)
			{
				vector2.y = TerrainMeta.HeightMap.GetHeight(vector2);
			}
			if (filter.Test(vector2))
			{
				Quaternion rotation = ((i != 2) ? Quaternion.LookRotation(dir) : Quaternion.LookRotation(rot180 * dir));
				if (SpawnObject(ref seed, prefabs, vector2, rotation, filter))
				{
					break;
				}
			}
		}
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		if (!obj.AlignToNormal)
		{
			dir = dir.XZ3D().normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 vector = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 vector2 = pos + placements[i] * vector;
			if (obj.HeightToTerrain)
			{
				vector2.y = TerrainMeta.HeightMap.GetHeight(vector2);
			}
			if (filter.Test(vector2))
			{
				Quaternion rotation = ((i != 2) ? Quaternion.LookRotation(dir) : Quaternion.LookRotation(rot180 * dir));
				if (CheckObjects(prefabs, vector2, rotation, filter))
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SpawnSide(ref uint seed, SideObject obj)
	{
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError("Empty decor folder: " + obj.Folder);
			return;
		}
		Side side = obj.Side;
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float num = Width * 0.5f + obj.Offset;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		float[] array2 = new float[2]
		{
			0f - num,
			num
		};
		int num2 = 0;
		Vector3 vector = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num3 = distance * 0.25f;
		float num4 = distance * 0.5f;
		float num5 = Path.StartOffset + num4;
		float num6 = Path.Length - Path.EndOffset - num4;
		for (float num7 = num5; num7 <= num6; num7 += num3)
		{
			Vector3 vector2 = ((!Spline) ? Path.GetPoint(num7) : Path.GetPointCubicHermite(num7));
			if ((vector2 - vector).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num7);
			Vector3 vector3 = rot90 * tangent;
			for (int i = 0; i < array2.Length; i++)
			{
				int num8 = (num2 + i) % array2.Length;
				if ((side == Side.Left && num8 != 0) || (side == Side.Right && num8 != 1))
				{
					continue;
				}
				float num9 = array2[num8];
				Vector3 vector4 = vector2;
				vector4.x += vector3.x * num9;
				vector4.z += vector3.z * num9;
				float normX = TerrainMeta.NormalizeX(vector4.x);
				float normZ = TerrainMeta.NormalizeZ(vector4.z);
				if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
				{
					continue;
				}
				if (density >= SeedRandom.Value(ref seed))
				{
					vector4.y = heightMap.GetHeight(normX, normZ);
					if (obj.Alignment == Alignment.None)
					{
						SpawnObject(ref seed, array, vector4);
					}
					else if (obj.Alignment == Alignment.Forward)
					{
						SpawnObject(ref seed, array, vector4, Quaternion.LookRotation(tangent * num9));
					}
					else if (obj.Alignment == Alignment.Inward)
					{
						SpawnObject(ref seed, array, vector4, Quaternion.LookRotation(-vector3 * num9));
					}
					else
					{
						list.Add(vector4);
					}
				}
				num2 = num8;
				vector = vector2;
				if (side == Side.Any)
				{
					break;
				}
			}
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list);
		}
	}

	public void SpawnAlong(ref uint seed, PathObject obj)
	{
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError("Empty decor folder: " + obj.Folder);
			return;
		}
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float dithering = obj.Dithering;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 vector = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num = distance * 0.25f;
		float num2 = distance * 0.5f;
		float num3 = Path.StartOffset + num2;
		float num4 = Path.Length - Path.EndOffset - num2;
		for (float num5 = num3; num5 <= num4; num5 += num)
		{
			Vector3 vector2 = ((!Spline) ? Path.GetPoint(num5) : Path.GetPointCubicHermite(num5));
			if ((vector2 - vector).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num5);
			Vector3 forward = rot90 * tangent;
			Vector3 vector3 = vector2;
			vector3.x += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			vector3.z += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			float normX = TerrainMeta.NormalizeX(vector3.x);
			float normZ = TerrainMeta.NormalizeZ(vector3.z);
			if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
			{
				continue;
			}
			if (density >= SeedRandom.Value(ref seed))
			{
				vector3.y = heightMap.GetHeight(normX, normZ);
				if (obj.Alignment == Alignment.None)
				{
					SpawnObject(ref seed, array, vector3);
				}
				else if (obj.Alignment == Alignment.Forward)
				{
					SpawnObject(ref seed, array, vector3, Quaternion.LookRotation(tangent));
				}
				else if (obj.Alignment == Alignment.Inward)
				{
					SpawnObject(ref seed, array, vector3, Quaternion.LookRotation(forward));
				}
				else
				{
					list.Add(vector3);
				}
			}
			vector = vector2;
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list);
		}
	}

	public void SpawnBridge(ref uint seed, BridgeObject obj)
	{
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError("Empty decor folder: " + obj.Folder);
			return;
		}
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 vector = endPoint - startPoint;
		float magnitude = vector.magnitude;
		Vector3 vector2 = vector / magnitude;
		float num = magnitude / obj.Distance;
		int num2 = Mathf.RoundToInt(num);
		float num3 = 0.5f * (num - (float)num2);
		Vector3 vector3 = obj.Distance * vector2;
		Vector3 vector4 = startPoint + (0.5f + num3) * vector3;
		Quaternion rotation = Quaternion.LookRotation(vector2);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainWaterMap waterMap = TerrainMeta.WaterMap;
		for (int i = 0; i < num2; i++)
		{
			float num4 = Mathf.Max(heightMap.GetHeight(vector4), waterMap.GetHeight(vector4)) - 1f;
			if (vector4.y > num4)
			{
				SpawnObject(ref seed, array, vector4, rotation);
			}
			vector4 += vector3;
		}
	}

	public void SpawnStart(ref uint seed, BasicObject obj)
	{
		if (Start && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError("Empty decor folder: " + obj.Folder);
				return;
			}
			Vector3 startPoint = Path.GetStartPoint();
			Vector3 startTangent = Path.GetStartTangent();
			SpawnObject(ref seed, array, startPoint, startTangent, obj);
		}
	}

	public void SpawnEnd(ref uint seed, BasicObject obj)
	{
		if (End && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError("Empty decor folder: " + obj.Folder);
				return;
			}
			Vector3 endPoint = Path.GetEndPoint();
			Vector3 dir = -Path.GetEndTangent();
			SpawnObject(ref seed, array, endPoint, dir, obj);
		}
	}

	public void TrimStart(BasicObject obj)
	{
		if (!Start || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError("Empty decor folder: " + obj.Folder);
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MinIndex + i];
			Vector3 dir = tangents[Path.MinIndex + i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MinIndex += i;
				break;
			}
		}
	}

	public void TrimEnd(BasicObject obj)
	{
		if (!End || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError("Empty decor folder: " + obj.Folder);
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MaxIndex - i];
			Vector3 dir = -tangents[Path.MaxIndex - i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MaxIndex -= i;
				break;
			}
		}
	}

	public void ResetTrims()
	{
		Path.MinIndex = Path.DefaultMinIndex;
		Path.MaxIndex = Path.DefaultMaxIndex;
	}

	public void AdjustTerrainHeight()
	{
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		float num = 1f;
		float scaling = Scaling;
		float padding = Padding;
		float fade = Fade;
		float offset01 = Offset * TerrainMeta.OneOverSize.y;
		float normfac = 1f / ((float)heightmap.res - 1f);
		float num2 = Width * 0.5f + padding;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 vector = rot90 * startTangent;
		Vector3 v = startPoint - vector * num2;
		Vector3 v2 = startPoint + vector * num2;
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 vector2 = ((!Spline) ? Path.GetPoint(num4) : Path.GetPointCubicHermite(num4));
			float a = (startPoint - vector2).Magnitude2D();
			float b = (endPoint - vector2).Magnitude2D();
			float opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(a, b));
			float radius = Mathf.Lerp(num2, num2 * scaling, Noise.Billow(vector2.x, vector2.z, 2, 0.004999999888241291));
			startTangent = Path.GetTangent(num4).XZ3D().normalized;
			vector = rot90 * startTangent;
			Ray ray = new Ray(vector2, startTangent);
			Vector3 vector3 = vector2 - vector * radius;
			Vector3 vector4 = vector2 + vector * radius;
			float height01 = TerrainMeta.NormalizeY(vector2.y);
			heightmap.ForEach(v, v2, vector3, vector4, delegate(int x, int z)
			{
				height01 = Mathf.Min(height01, heightmap.GetHeight01(x, z));
			});
			heightmap.ForEach(v, v2, vector3, vector4, delegate(int x, int z)
			{
				float x2 = (float)x * normfac;
				float z2 = (float)z * normfac;
				Vector3 pos = TerrainMeta.Denormalize(new Vector3(x2, height01, z2));
				float value = RayEx.Distance(ray, pos);
				float num5 = Mathf.InverseLerp(radius, radius - fade, value);
				heightmap.LowerHeight(x, z, height01 + offset01, num5 * opacity);
			});
			v = vector3;
			v2 = vector4;
		}
	}

	public void AdjustTerrainTexture()
	{
		if (Splat == 0)
		{
			return;
		}
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		float num = 1f;
		float scaling = Scaling;
		float padding = Padding;
		float fade = Fade;
		float normfac = 1f / ((float)splatmap.res - 1f);
		float num2 = Width * 0.5f + padding;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 vector = rot90 * startTangent;
		Vector3 v = startPoint - vector * num2;
		Vector3 v2 = startPoint + vector * num2;
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 cur = ((!Spline) ? Path.GetPoint(num4) : Path.GetPointCubicHermite(num4));
			float a = (startPoint - cur).Magnitude2D();
			float b = (endPoint - cur).Magnitude2D();
			float opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(a, b));
			float radius = Mathf.Lerp(num2, num2 * scaling, Noise.Billow(cur.x, cur.z, 2, 0.004999999888241291));
			startTangent = Path.GetTangent(num4).XZ3D().normalized;
			vector = rot90 * startTangent;
			Ray ray = new Ray(cur, startTangent);
			Vector3 vector2 = cur - vector * radius;
			Vector3 vector3 = cur + vector * radius;
			splatmap.ForEach(v, v2, vector2, vector3, delegate(int x, int z)
			{
				float x2 = (float)x * normfac;
				float z2 = (float)z * normfac;
				Vector3 pos = TerrainMeta.Denormalize(new Vector3(x2, 0f, z2));
				pos.y = cur.y;
				float value = RayEx.Distance(ray, pos);
				float num5 = Mathf.InverseLerp(radius, radius - fade, value);
				splatmap.SetSplat(x, z, Splat, num5 * opacity);
			});
			v = vector2;
			v2 = vector3;
		}
	}

	public void AdjustTerrainTopology()
	{
		if (Topology == 0)
		{
			return;
		}
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		float num = 1f;
		float scaling = Scaling;
		float padding = Padding;
		float fade = Fade;
		float normfac = 1f / ((float)topomap.res - 1f);
		float num2 = Width * 0.5f + padding;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 vector = rot90 * startTangent;
		Vector3 v = startPoint - vector * num2;
		Vector3 v2 = startPoint + vector * num2;
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 cur = ((!Spline) ? Path.GetPoint(num4) : Path.GetPointCubicHermite(num4));
			float a = (startPoint - cur).Magnitude2D();
			float b = (endPoint - cur).Magnitude2D();
			float opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(a, b));
			float radius = Mathf.Lerp(num2, num2 * scaling, Noise.Billow(cur.x, cur.z, 2, 0.004999999888241291));
			startTangent = Path.GetTangent(num4).XZ3D().normalized;
			vector = rot90 * startTangent;
			Ray ray = new Ray(cur, startTangent);
			Vector3 vector2 = cur - vector * radius;
			Vector3 vector3 = cur + vector * radius;
			topomap.ForEach(v, v2, vector2, vector3, delegate(int x, int z)
			{
				float x2 = (float)x * normfac;
				float z2 = (float)z * normfac;
				Vector3 pos = TerrainMeta.Denormalize(new Vector3(x2, 0f, z2));
				pos.y = cur.y;
				float value = RayEx.Distance(ray, pos);
				float num5 = Mathf.InverseLerp(radius, radius - fade, value);
				if (num5 * opacity > 0.3f)
				{
					topomap.SetTopology(x, z, Topology);
				}
			});
			v = vector2;
			v2 = vector3;
		}
	}

	public List<Mesh> CreateMesh()
	{
		List<Mesh> list = new List<Mesh>();
		float num = 16f;
		float scaling = Scaling;
		float num2 = 1.5f;
		float num3 = Offset * 0.3f;
		float num4 = Width * 0.5f + num2;
		int num5 = 100;
		int capacity = (int)(Path.Length / num) * 2;
		int capacity2 = (int)(Path.Length / num) * 3;
		List<Vector3> list2 = new List<Vector3>(capacity);
		List<Color> list3 = new List<Color>(capacity);
		List<Vector2> list4 = new List<Vector2>(capacity);
		List<Vector3> list5 = new List<Vector3>(capacity);
		List<Vector4> list6 = new List<Vector4>(capacity);
		List<int> list7 = new List<int>(capacity2);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector2 item = new Vector2(0f, 0f);
		Vector2 item2 = new Vector2(1f, 0f);
		Vector3 vector = Vector3.zero;
		Vector3 vector2 = Vector3.zero;
		Vector3 vector3 = Vector3.zero;
		Vector3 rhs = Vector3.zero;
		int num6 = -1;
		int num7 = -1;
		float num8 = Path.Length + num;
		for (float num9 = 0f; num9 < num8; num9 += num)
		{
			Vector3 vector4 = ((!Spline) ? Path.GetPoint(num9) : Path.GetPointCubicHermite(num9));
			float num10 = Mathf.Lerp(num4, num4 * scaling, Noise.Billow(vector4.x, vector4.z, 2, 0.004999999888241291));
			Vector3 tangent = Path.GetTangent(num9);
			Vector3 normalized = tangent.XZ3D().normalized;
			Vector3 rhs2 = rot90 * normalized;
			Vector4 item3 = new Vector4(rhs2.x, rhs2.y, rhs2.z, 1f);
			Vector3 item4 = Vector3.Slerp(Vector3.Cross(tangent, rhs2), Vector3.up, 0.1f);
			Vector3 vector5 = new Vector3(vector4.x - rhs2.x * num10, 0f, vector4.z - rhs2.z * num10);
			vector5.y = Mathf.Min(vector4.y, heightMap.GetHeight(vector5)) + num3;
			Vector3 vector6 = new Vector3(vector4.x + rhs2.x * num10, 0f, vector4.z + rhs2.z * num10);
			vector6.y = Mathf.Min(vector4.y, heightMap.GetHeight(vector6)) + num3;
			if (num9 != 0f)
			{
				float num11 = (vector4 - vector3).Magnitude2D() / (2f * num10);
				item.y += num11;
				item2.y += num11;
				Vector3 lhs = (vector5 - vector).XZ3D();
				if (Vector3.Dot(lhs, rhs) <= 0f)
				{
					vector5 = vector;
				}
				Vector3 lhs2 = (vector6 - vector2).XZ3D();
				if (Vector3.Dot(lhs2, rhs) <= 0f)
				{
					vector6 = vector2;
				}
			}
			Color item5 = ((!(num9 > 0f) || !(num9 + num < num8)) ? new Color(1f, 1f, 1f, 0f) : new Color(1f, 1f, 1f, 1f));
			list4.Add(item);
			list3.Add(item5);
			list2.Add(vector5);
			list5.Add(item4);
			list6.Add(item3);
			int num12 = list2.Count - 1;
			if (num6 != -1 && num7 != -1)
			{
				list7.Add(num12);
				list7.Add(num7);
				list7.Add(num6);
			}
			num6 = num12;
			vector = vector5;
			list4.Add(item2);
			list3.Add(item5);
			list2.Add(vector6);
			list5.Add(item4);
			list6.Add(item3);
			int num13 = list2.Count - 1;
			if (num6 != -1 && num7 != -1)
			{
				list7.Add(num13);
				list7.Add(num7);
				list7.Add(num6);
			}
			num7 = num13;
			vector2 = vector6;
			vector3 = vector4;
			rhs = normalized;
			if (list2.Count >= num5)
			{
				Mesh mesh = new Mesh();
				mesh.SetVertices(list2);
				mesh.SetColors(list3);
				mesh.SetUVs(0, list4);
				mesh.SetTriangles(list7, 0);
				mesh.SetNormals(list5);
				mesh.SetTangents(list6);
				list.Add(mesh);
				list2.Clear();
				list3.Clear();
				list4.Clear();
				list5.Clear();
				list6.Clear();
				list7.Clear();
				num6 = -1;
				num7 = -1;
				num9 -= num;
			}
		}
		if (list7.Count > 0)
		{
			Mesh mesh2 = new Mesh();
			mesh2.SetVertices(list2);
			mesh2.SetColors(list3);
			mesh2.SetUVs(0, list4);
			mesh2.SetTriangles(list7, 0);
			mesh2.SetNormals(list5);
			mesh2.SetTangents(list6);
			list.Add(mesh2);
		}
		return list;
	}
}
