using System.Collections.Generic;
using UnityEngine;

public class PlaceMonuments : ProceduralComponent
{
	private struct SpawnInfo
	{
		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int Distance = 500;

	public int MinSize;

	private const int Candidates = 10;

	private const int Attempts = 10000;

	public override void Process(uint seed)
	{
		if (World.Size < MinSize)
		{
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab<MonumentInfo>[] array = Prefab.Load<MonumentInfo>("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		ArrayEx.Shuffle(array, seed);
		ArrayEx.BubbleSort(array);
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float max = position.x + size.x;
		float max2 = position.z + size.z;
		int num = 0;
		List<SpawnInfo> a = new List<SpawnInfo>();
		int num2 = 0;
		List<SpawnInfo> b = new List<SpawnInfo>();
		for (int i = 0; i < 10; i++)
		{
			num = 0;
			a.Clear();
			Prefab<MonumentInfo>[] array2 = array;
			foreach (Prefab<MonumentInfo> prefab in array2)
			{
				int num3 = (int)((!prefab.Parameters) ? PrefabPriority.Low : (prefab.Parameters.Priority + 1));
				int num4 = num3 * num3 * num3 * num3;
				for (int k = 0; k < 10000; k++)
				{
					float x2 = SeedRandom.Range(ref seed, x, max);
					float z2 = SeedRandom.Range(ref seed, z, max2);
					float normX = TerrainMeta.NormalizeX(x2);
					float normZ = TerrainMeta.NormalizeZ(z2);
					float num5 = SeedRandom.Value(ref seed);
					float factor = Filter.GetFactor(normX, normZ);
					if (factor * factor < num5)
					{
						continue;
					}
					float height = heightMap.GetHeight(normX, normZ);
					Vector3 pos = new Vector3(x2, height, z2);
					Quaternion rot = prefab.Object.transform.localRotation;
					Vector3 scale = prefab.Object.transform.localScale;
					if (!CheckRadius(a, pos, Distance))
					{
						prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
						if ((!prefab.Component || prefab.Component.CheckPlacement(pos, rot, scale)) && prefab.ApplyTerrainAnchors(ref pos, rot, scale, Filter) && prefab.ApplyTerrainChecks(pos, rot, scale, Filter) && prefab.ApplyTerrainFilters(pos, rot, scale) && prefab.ApplyWaterChecks(pos, rot, scale) && !prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground))
						{
							SpawnInfo item = default(SpawnInfo);
							item.prefab = prefab;
							item.position = pos;
							item.rotation = rot;
							item.scale = scale;
							a.Add(item);
							num += num4;
							break;
						}
					}
				}
			}
			if (num > num2)
			{
				num2 = num;
				GenericsUtil.Swap(ref a, ref b);
			}
		}
		foreach (SpawnInfo item2 in b)
		{
			Prefab prefab2 = item2.prefab;
			Vector3 position2 = item2.position;
			Quaternion rotation = item2.rotation;
			Vector3 scale2 = item2.scale;
			prefab2.ApplyTerrainPlacements(position2, rotation, scale2);
			prefab2.ApplyTerrainModifiers(position2, rotation, scale2);
			World.AddPrefab("Monument", prefab2.ID, position2, rotation, scale2);
		}
	}

	private bool CheckRadius(List<SpawnInfo> spawns, Vector3 pos, float radius)
	{
		float num = radius * radius;
		foreach (SpawnInfo spawn in spawns)
		{
			float sqrMagnitude = (spawn.position - pos).sqrMagnitude;
			if (sqrMagnitude < num)
			{
				return true;
			}
		}
		return false;
	}
}
