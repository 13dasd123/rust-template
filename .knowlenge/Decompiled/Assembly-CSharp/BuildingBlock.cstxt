#define UNITY_ASSERTIONS
using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class BuildingBlock : StabilityEntity
{
	public static class BlockFlags
	{
		public const Flags CanRotate = Flags.Reserved1;

		public const Flags CanDemolish = Flags.Reserved2;
	}

	public class UpdateSkinWorkQueue : ObjectWorkQueue<BuildingBlock>
	{
		protected override void RunJob(BuildingBlock entity)
		{
			if (ShouldAdd(entity))
			{
				entity.UpdateSkin(force: true);
			}
		}

		protected override bool ShouldAdd(BuildingBlock entity)
		{
			return entity.IsValid();
		}
	}

	[NonSerialized]
	public uint buildingID;

	[NonSerialized]
	public Construction blockDefinition;

	private static uint maxBuildingID = 0u;

	public BuildingGrade.Enum grade;

	protected ConstructionSkin currentSkin;

	protected BuildingGrade.Enum lastSkinGrade = BuildingGrade.Enum.None;

	private DeferredAction skinChange;

	private MeshRenderer placeholderRenderer;

	private MeshCollider placeholderCollider;

	public static UpdateSkinWorkQueue updateSkinQueueServer = new UpdateSkinWorkQueue();

	public ConstructionGrade currentGrade
	{
		get
		{
			ConstructionGrade constructionGrade = GetGrade(grade);
			if (constructionGrade != null)
			{
				return constructionGrade;
			}
			for (int i = 0; i < blockDefinition.grades.Length; i++)
			{
				if (blockDefinition.grades[i] != null)
				{
					return blockDefinition.grades[i];
				}
			}
			Debug.LogWarning("currentGrade returning NULL");
			return null;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("BuildingBlock.OnRpcMessage"))
		{
			if (rpc == 3916846720u && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - DoDemolish "));
				}
				using (TimeWarning.New("DoDemolish"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("DoDemolish", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoDemolish(msg2);
						}
					}
					catch (Exception exception)
					{
						player.Kick("RPC Error in DoDemolish");
						Debug.LogException(exception);
					}
				}
				return true;
			}
			if (rpc == 848803451 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - DoImmediateDemolish "));
				}
				using (TimeWarning.New("DoImmediateDemolish"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("DoImmediateDemolish", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							DoImmediateDemolish(msg3);
						}
					}
					catch (Exception exception2)
					{
						player.Kick("RPC Error in DoImmediateDemolish");
						Debug.LogException(exception2);
					}
				}
				return true;
			}
			if (rpc == 3019202825u && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - DoRotation "));
				}
				using (TimeWarning.New("DoRotation"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("DoRotation", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							DoRotation(msg4);
						}
					}
					catch (Exception exception3)
					{
						player.Kick("RPC Error in DoRotation");
						Debug.LogException(exception3);
					}
				}
				return true;
			}
			if (rpc == 1059213803 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - DoUpgradeToGrade "));
				}
				using (TimeWarning.New("DoUpgradeToGrade"))
				{
					using (TimeWarning.New("Conditions"))
					{
						if (!RPC_Server.MaxDistance.Test("DoUpgradeToGrade", this, player, 3f))
						{
							return true;
						}
					}
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							DoUpgradeToGrade(msg5);
						}
					}
					catch (Exception exception4)
					{
						player.Kick("RPC Error in DoUpgradeToGrade");
						Debug.LogException(exception4);
					}
				}
				return true;
			}
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		buildingID = 0u;
		blockDefinition = null;
		lastSkinGrade = BuildingGrade.Enum.None;
		DestroySkin();
		UpdatePlaceholder(state: true);
	}

	public override void InitShared()
	{
		base.InitShared();
		placeholderRenderer = GetComponent<MeshRenderer>();
		placeholderCollider = GetComponent<MeshCollider>();
	}

	public override void PostInitShared()
	{
		baseProtection = currentGrade.gradeBase.damageProtecton;
		grade = currentGrade.gradeBase.type;
		base.PostInitShared();
	}

	public override void DestroyShared()
	{
		RefreshNeighbours(linkToNeighbours: false);
		base.DestroyShared();
	}

	public override void OnKilled(HitInfo info)
	{
		Kill(DestroyMode.Gib);
	}

	public static uint NewBuildingID()
	{
		return ++maxBuildingID;
	}

	public void AttachToBuilding(BuildingBlock other)
	{
		buildingID = ((!other) ? NewBuildingID() : other.buildingID);
	}

	public override string Categorize()
	{
		return "building";
	}

	public override bool SupportsPooling()
	{
		return true;
	}

	public override float BoundsPadding()
	{
		return 1f;
	}

	private bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsDemolishable() && HasDemolishPrivilege(player);
	}

	private bool IsDemolishable()
	{
		if (!ConVar.Server.pve && !HasFlag(Flags.Reserved2))
		{
			return false;
		}
		return true;
	}

	private bool HasDemolishPrivilege(BasePlayer player)
	{
		return player.IsBuildingAuthed(base.transform.position, base.transform.rotation, bounds);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("IOnStructureDemolish", this, msg.player) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void DoImmediateDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && msg.player.IsAdmin && Interface.CallHook("IOnStructureImmediateDemolish", this, msg.player) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

	private void StopBeingDemolishable()
	{
		SetFlag(Flags.Reserved2, b: false);
		SendNetworkUpdate();
	}

	private void StartBeingDemolishable()
	{
		SetFlag(Flags.Reserved2, b: true);
		Invoke(StopBeingDemolishable, 600f);
	}

	private ConstructionGrade GetGrade(BuildingGrade.Enum iGrade)
	{
		if ((int)grade >= blockDefinition.grades.Length)
		{
			Debug.LogWarning(string.Concat("Grade out of range ", base.gameObject, " ", grade, " / ", blockDefinition.grades.Length));
			return blockDefinition.defaultGrade;
		}
		return blockDefinition.grades[(int)iGrade];
	}

	private bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return HasUpgradePrivilege(iGrade, player) && !IsUpgradeBlocked();
	}

	private bool HasUpgradePrivilege(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		if (iGrade == grade)
		{
			return false;
		}
		if ((int)iGrade >= blockDefinition.grades.Length)
		{
			return false;
		}
		if (iGrade < BuildingGrade.Enum.Twigs)
		{
			return false;
		}
		if (iGrade < grade)
		{
			return false;
		}
		return !player.IsBuildingBlocked(base.transform.position, base.transform.rotation, bounds);
	}

	private bool IsUpgradeBlocked()
	{
		if (!blockDefinition.checkVolumeOnUpgrade)
		{
			return false;
		}
		DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
		return DeployVolume.Check(base.transform.position, base.transform.rotation, volumes, ~(1 << base.gameObject.layer));
	}

	private bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ConstructionGrade constructionGrade = GetGrade(iGrade);
		foreach (ItemAmount item in constructionGrade.costToBuild)
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

	public void SetGrade(BuildingGrade.Enum iGradeID)
	{
		if (blockDefinition.grades == null || (int)iGradeID >= blockDefinition.grades.Length)
		{
			Debug.LogError("Tried to set to undefined grade! " + blockDefinition.fullName, base.gameObject);
			return;
		}
		grade = iGradeID;
		grade = currentGrade.gradeBase.type;
		UpdateGrade();
	}

	private void UpdateGrade()
	{
		baseProtection = currentGrade.gradeBase.damageProtecton;
	}

	public void SetHealthToMax()
	{
		base.health = MaxHealth();
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoUpgradeToGrade(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
			ConstructionGrade constructionGrade = GetGrade(@enum);
			if (!(constructionGrade == null) && CanChangeToGrade(@enum, msg.player) && CanAffordUpgrade(@enum, msg.player) && !(base.SecondsSinceAttacked < 8f) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum) == null)
			{
				PayForUpgrade(constructionGrade, msg.player);
				SetGrade(@enum);
				SetHealthToMax();
				StartBeingRotatable();
				SendNetworkUpdate();
				UpdateSkin();
				Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + @enum.ToString().ToLower() + ".prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

	private void PayForUpgrade(ConstructionGrade g, BasePlayer player)
	{
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in g.costToBuild)
		{
			player.inventory.Take(list, item.itemid, (int)item.amount);
			player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

	private bool NeedsSkinChange(bool force = false)
	{
		if (currentSkin == null)
		{
			return true;
		}
		if (force)
		{
			return true;
		}
		return lastSkinGrade != grade;
	}

	public void UpdateSkin(bool force = false)
	{
		if (!NeedsSkinChange(force))
		{
			return;
		}
		if (cachedStability <= 0f || base.isServer)
		{
			ChangeSkin();
			return;
		}
		if (lastSkinGrade == BuildingGrade.Enum.None)
		{
			lastSkinGrade = grade;
		}
		if (!skinChange)
		{
			skinChange = new DeferredAction(this, ChangeSkin);
		}
		if (skinChange.Idle)
		{
			skinChange.Invoke();
		}
	}

	private void DestroySkin()
	{
		if (currentSkin != null)
		{
			currentSkin.Destroy(this);
			currentSkin = null;
		}
	}

	private void RefreshNeighbours(bool linkToNeighbours)
	{
		List<EntityLink> entityLinks = GetEntityLinks(linkToNeighbours);
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				BuildingBlock buildingBlock = entityLink.connections[j].owner as BuildingBlock;
				if (!(buildingBlock == null))
				{
					if (Rust.Application.isLoading)
					{
						buildingBlock.UpdateSkin(force: true);
					}
					else if (buildingBlock.isServer)
					{
						updateSkinQueueServer.Add(buildingBlock);
					}
				}
			}
		}
	}

	private void UpdatePlaceholder(bool state)
	{
		if ((bool)placeholderRenderer)
		{
			placeholderRenderer.enabled = state;
		}
		if ((bool)placeholderCollider)
		{
			placeholderCollider.enabled = state;
		}
	}

	private void ChangeSkin()
	{
		if (base.IsDestroyed)
		{
			return;
		}
		if (currentSkin == null)
		{
			UpdatePlaceholder(state: false);
		}
		else
		{
			DestroySkin();
		}
		ConstructionGrade constructionGrade = currentGrade;
		if (constructionGrade.skinObject.isValid)
		{
			ChangeSkin(constructionGrade.skinObject);
			return;
		}
		ConstructionGrade[] grades = blockDefinition.grades;
		foreach (ConstructionGrade constructionGrade2 in grades)
		{
			if (constructionGrade2.skinObject.isValid)
			{
				ChangeSkin(constructionGrade2.skinObject);
				return;
			}
		}
		Debug.LogWarning("No skins found for " + base.gameObject);
	}

	private void ChangeSkin(GameObjectRef prefab)
	{
		GameObject gameObject = base.gameManager.CreatePrefab(prefab.resourcePath, base.transform, active: false);
		PrefabInfoEx.AwakeFromInstantiate(gameObject);
		currentSkin = gameObject.GetComponent<ConstructionSkin>();
		Model component = currentSkin.GetComponent<Model>();
		SetModel(component);
		Assert.IsTrue(model == component, "Didn't manage to set model successfully!");
		currentSkin.Refresh(this);
		if (lastSkinGrade != grade)
		{
			lastSkinGrade = grade;
			RefreshNeighbours(linkToNeighbours: true);
		}
	}

	public override bool ShouldBlockProjectiles()
	{
		return grade != BuildingGrade.Enum.Twigs;
	}

	private void OnHammered()
	{
	}

	public override float MaxHealth()
	{
		return currentGrade.maxHealth;
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		if (Mathf.RoundToInt(oldvalue) != Mathf.RoundToInt(newvalue))
		{
			SendNetworkUpdate(BasePlayer.NetworkQueue.UpdateDistance);
		}
	}

	public override float RepairCostFraction()
	{
		return 1f;
	}

	public override List<ItemAmount> BuildCost()
	{
		return currentGrade.costToBuild;
	}

	private bool CanRotate(BasePlayer player)
	{
		return IsRotatable() && HasRotationPrivilege(player) && !IsRotationBlocked();
	}

	private bool IsRotatable()
	{
		if (blockDefinition.grades == null)
		{
			return false;
		}
		if (!blockDefinition.canRotate)
		{
			return false;
		}
		if (!HasFlag(Flags.Reserved1))
		{
			return false;
		}
		return true;
	}

	private bool IsRotationBlocked()
	{
		if (!blockDefinition.checkVolumeOnRotate)
		{
			return false;
		}
		DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(prefabID);
		return DeployVolume.Check(base.transform.position, base.transform.rotation, volumes, ~(1 << base.gameObject.layer));
	}

	private bool HasRotationPrivilege(BasePlayer player)
	{
		return !player.IsBuildingBlocked(base.transform.position, base.transform.rotation, bounds);
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotate && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			if ((bool)currentSkin)
			{
				currentSkin.Refresh(this);
			}
			SendNetworkUpdateImmediate();
			ClientRPC(null, "RefreshSkin");
		}
	}

	private void StopBeingRotatable()
	{
		SetFlag(Flags.Reserved1, b: false);
		SendNetworkUpdate();
	}

	private void StartBeingRotatable()
	{
		if (blockDefinition.grades != null && blockDefinition.canRotate)
		{
			SetFlag(Flags.Reserved1, b: true);
			Invoke(StopBeingRotatable, 600f);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingBlock = Facepunch.Pool.Get<ProtoBuf.BuildingBlock>();
		info.msg.buildingBlock.grade = (int)grade;
		info.msg.buildingBlock.buildingID = buildingID;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.buildingBlock != null)
		{
			buildingID = info.msg.buildingBlock.buildingID;
			SetGrade((BuildingGrade.Enum)info.msg.buildingBlock.grade);
		}
		if (info.fromDisk)
		{
			maxBuildingID = Mathx.Max(maxBuildingID, buildingID);
			SetFlag(Flags.Reserved2, b: false);
			SetFlag(Flags.Reserved1, b: false);
			UpdateSkin();
		}
	}

	public override void ServerInit()
	{
		blockDefinition = PrefabAttribute.server.Find<Construction>(prefabID);
		if (blockDefinition == null)
		{
			Debug.LogError("Couldn't find Construction for prefab " + prefabID);
		}
		base.ServerInit();
		UpdateSkin();
		if (HasFlag(Flags.Reserved1) || !Rust.Application.isLoadingSave)
		{
			StartBeingRotatable();
		}
		if (HasFlag(Flags.Reserved2) || !Rust.Application.isLoadingSave)
		{
			StartBeingDemolishable();
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			basePlayer.Hurt(info.damageTypes.Total(), DamageType.Generic);
		}
		else
		{
			base.Hurt(info);
		}
	}
}
