using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class MissionInstance : Pool.IPooled
{
	[Serializable]
	public class ObjectiveStatus
	{
		public bool started;

		public bool completed;

		public bool failed;

		public int genericInt1;

		public float genericFloat1;
	}

	public enum ObjectiveType
	{
		MOVE,
		KILL
	}

	private BaseEntity _cachedProviderEntity;

	private BaseMission _cachedMission;

	public NetworkableId providerID;

	public uint missionID;

	public MissionStatus status;

	public float completionScale;

	public float startTime;

	public float endTime;

	public Vector3 missionLocation;

	public float timePassed;

	public Dictionary<string, Vector3> missionPoints = new Dictionary<string, Vector3>();

	public ObjectiveStatus[] objectiveStatuses;

	public List<MissionEntity> createdEntities;

	public ItemAmount[] rewards;

	public BaseEntity ProviderEntity()
	{
		if (_cachedProviderEntity == null)
		{
			_cachedProviderEntity = BaseNetworkable.serverEntities.Find(providerID) as BaseEntity;
		}
		return _cachedProviderEntity;
	}

	public BaseMission GetMission()
	{
		if (_cachedMission == null)
		{
			_cachedMission = MissionManifest.GetFromID(missionID);
		}
		return _cachedMission;
	}

	public bool ShouldShowOnMap()
	{
		if (status == MissionStatus.Active || status == MissionStatus.Accomplished)
		{
			return missionLocation != Vector3.zero;
		}
		return false;
	}

	public bool ShouldShowOnCompass()
	{
		return ShouldShowOnMap();
	}

	public virtual void ProcessMissionEvent(BasePlayer playerFor, MissionEventType type, string identifier, float amount)
	{
		if (status == MissionStatus.Active)
		{
			BaseMission mission = GetMission();
			for (int i = 0; i < mission.objectives.Length; i++)
			{
				mission.objectives[i].objective.ProcessMissionEvent(playerFor, this, i, type, identifier, amount);
			}
		}
	}

	public void Think(BasePlayer assignee, float delta)
	{
		if (status != MissionStatus.Failed && status != MissionStatus.Completed)
		{
			BaseMission mission = GetMission();
			timePassed += delta;
			mission.Think(this, assignee, delta);
			if (mission.timeLimitSeconds > 0f && timePassed >= mission.timeLimitSeconds)
			{
				mission.MissionFailed(this, assignee, MissionFailReason.TimeOut);
			}
		}
	}

	public Vector3 GetMissionPoint(string identifier, BasePlayer playerFor)
	{
		if (missionPoints.ContainsKey(identifier))
		{
			return missionPoints[identifier];
		}
		if ((bool)playerFor)
		{
			GetMission().SetupPositions(this, playerFor);
			Debug.Log("Mission point not found, regenerating");
			if (missionPoints.ContainsKey(identifier))
			{
				return missionPoints[identifier];
			}
			return Vector3.zero;
		}
		Debug.Log("Massive mission failure to get point, correct mission definition of : " + GetMission().shortname);
		return Vector3.zero;
	}

	public void EnterPool()
	{
		providerID = default(NetworkableId);
		missionID = 0u;
		status = MissionStatus.Default;
		completionScale = 0f;
		startTime = -1f;
		endTime = -1f;
		missionLocation = Vector3.zero;
		_cachedMission = null;
		timePassed = 0f;
		rewards = null;
		missionPoints.Clear();
		if (createdEntities != null)
		{
			Pool.FreeList(ref createdEntities);
		}
	}

	public void LeavePool()
	{
		createdEntities = Pool.GetList<MissionEntity>();
	}
}
