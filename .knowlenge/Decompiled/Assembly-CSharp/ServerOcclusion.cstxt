using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using UnityEngine;

public static class ServerOcclusion
{
	public readonly struct Grid : IEquatable<Grid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 16f;

		public Grid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 16f);
		}

		public Vector3 GetCenterPoint()
		{
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
		}

		public override string ToString()
		{
			return $"(x: {x}, y: {y}, z: {z})";
		}

		public bool Equals(Grid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608);
		}

		public int GetIndex()
		{
			return GetGridIndex(x, y, z);
		}
	}

	public readonly struct SubGrid : IEquatable<SubGrid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 2f;

		public SubGrid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 2f);
		}

		public Vector3 GetCenterPoint()
		{
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
		}

		public override string ToString()
		{
			return $"(x: {x}, y: {y}, z: {z})";
		}

		public bool Equals(SubGrid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			return AntiHack.TestInsideTerrain(GetCenterPoint());
		}

		public int GetIndex()
		{
			return GetSubGridIndex(x, y, z);
		}

		public float GetDistance(SubGrid other)
		{
			return Vector3.Distance(GetCenterPoint(), other.GetCenterPoint());
		}
	}

	public static float MaxY = 200f;

	public static int ChunkCountX;

	public static int ChunkCountY;

	public static int ChunkCountZ;

	public static int SubChunkCountX;

	public static int SubChunkCountY;

	public static int SubChunkCountZ;

	public static LimitDictionary<(SubGrid, SubGrid), bool> OcclusionCache = new LimitDictionary<(SubGrid, SubGrid), bool>(32768);

	public static BitArray[] OcclusionSubGridBlocked;

	public const int OcclusionChunkSize = 16;

	public const int OcclusionChunkResolution = 8;

	public static (int, int, int)[] neighbours = new(int, int, int)[18]
	{
		(1, 0, 0),
		(-1, 0, 0),
		(0, 1, 0),
		(0, -1, 0),
		(0, 0, 1),
		(0, 0, -1),
		(1, 0, 1),
		(1, 0, -1),
		(-1, 0, 1),
		(-1, 0, -1),
		(-1, 1, 0),
		(-1, -1, 0),
		(1, 1, 0),
		(1, -1, 0),
		(0, 1, 1),
		(0, -1, 1),
		(0, 1, -1),
		(0, -1, -1)
	};

	public static (int, int, int)[] neighboursAndOrigin = new(int, int, int)[19]
	{
		(0, 0, 0),
		(1, 0, 0),
		(-1, 0, 0),
		(0, 1, 0),
		(0, -1, 0),
		(0, 0, 1),
		(0, 0, -1),
		(1, 0, 1),
		(1, 0, -1),
		(-1, 0, 1),
		(-1, 0, -1),
		(-1, 1, 0),
		(-1, -1, 0),
		(1, 1, 0),
		(1, -1, 0),
		(0, 1, 1),
		(0, -1, 1),
		(0, 1, -1),
		(0, -1, -1)
	};

	private static Queue<SubGrid> floodFillQueue = new Queue<SubGrid>();

	private static Dictionary<SubGrid, bool> visited = new Dictionary<SubGrid, bool>();

	public static HashSet<SubGrid> gridArea = new HashSet<SubGrid>();

	public static bool OcclusionEnabled { get; set; } = false;

	public static float OcclusionFade => 1.5f;

	public static float OcclusionPollRate => 5f;

	public static float MinOcclusionDistance => 10f;

	public static int OcclusionMaxBFSIterations => 512;

	public static int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCountX * ChunkCountY + y * ChunkCountZ + x;
	}

	public static int GetSubGridIndex(int x, int y, int z)
	{
		return z * SubChunkCountX * SubChunkCountY + y * SubChunkCountX + x;
	}

	public static int GetGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 16f + axis / 16f);
	}

	public static Grid GetGrid(Vector3 position)
	{
		int grid = GetGrid(position.x, TerrainMeta.Size.x / 2f);
		int grid2 = GetGrid(position.y, MaxY / 2f);
		int grid3 = GetGrid(position.z, TerrainMeta.Size.z / 2f);
		if (IsValidGrid(grid, grid2, grid3))
		{
			return new Grid(grid, grid2, grid3);
		}
		return default(Grid);
	}

	public static int GetSubGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 2f + axis / 2f);
	}

	public static SubGrid GetSubGrid(Vector3 position)
	{
		int subGrid = GetSubGrid(position.x, TerrainMeta.Size.x / 2f);
		int subGrid2 = GetSubGrid(position.y, MaxY / 2f);
		int subGrid3 = GetSubGrid(position.z, TerrainMeta.Size.z / 2f);
		if (IsValidSubGrid(subGrid, subGrid2, subGrid3))
		{
			return new SubGrid(subGrid, subGrid2, subGrid3);
		}
		return default(SubGrid);
	}

	public static bool IsBlocked(int x, int y, int z)
	{
		int result;
		int x2 = Math.DivRem(x, 8, out result);
		int result2;
		int y2 = Math.DivRem(y, 8, out result2);
		int result3;
		int z2 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(x2, y2, z2);
		BitArray bitArray = (IsValidGrid(x2, y2, z2) ? OcclusionSubGridBlocked[gridIndex] : null);
		int index = result3 * 8 * 8 + result2 * 8 + result;
		return bitArray?[index] ?? false;
	}

	public static bool IsBlocked(SubGrid sub)
	{
		return IsBlocked(sub.x, sub.y, sub.z);
	}

	public static bool IsValidGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= ChunkCountX || y >= ChunkCountY || z >= ChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidSubGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= SubChunkCountX || y >= SubChunkCountY || z >= SubChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static bool PathBetweenFloodFill(SubGrid start, SubGrid end)
	{
		floodFillQueue.Clear();
		visited.Clear();
		foreach (SubGrid item in gridArea)
		{
			visited.TryAdd(item, value: false);
		}
		visited.TryAdd(start, value: true);
		floodFillQueue.Enqueue(start);
		int num = 0;
		while (floodFillQueue.Count > 0)
		{
			if (num++ > OcclusionMaxBFSIterations)
			{
				return true;
			}
			SubGrid subGrid = floodFillQueue.Dequeue();
			if (subGrid.Equals(end))
			{
				return true;
			}
			for (int i = 0; i < neighbours.Length; i++)
			{
				int x = subGrid.x + neighbours[i].Item1;
				int y = subGrid.y + neighbours[i].Item2;
				int z = subGrid.z + neighbours[i].Item3;
				if (IsValidSubGrid(x, y, z))
				{
					SubGrid subGrid2 = new SubGrid(x, y, z);
					if (!(visited.TryGetValue(subGrid2, out var value) && value) && !IsBlocked(subGrid2) && gridArea.Contains(subGrid2))
					{
						visited[subGrid2] = true;
						floodFillQueue.Enqueue(subGrid2);
					}
				}
			}
		}
		return false;
	}

	public static bool PathBetweenDirect(SubGrid start, SubGrid end)
	{
		int f = Mathf.Abs(Mathf.RoundToInt((end.GetCenterPoint().x - start.GetCenterPoint().x) / 2f));
		int f2 = Mathf.Abs(Mathf.RoundToInt((end.GetCenterPoint().y - start.GetCenterPoint().y) / 2f));
		int f3 = Mathf.Abs(Mathf.RoundToInt((end.GetCenterPoint().z - start.GetCenterPoint().z) / 2f));
		int num = Mathx.Max(f, f2, f3);
		for (int i = 0; i < num; i++)
		{
			float t = (float)i / (float)(num - 1);
			if (IsBlocked(GetSubGrid(Vector3.LerpUnclamped(start.GetCenterPoint(), end.GetCenterPoint(), t))))
			{
				return false;
			}
		}
		return true;
	}

	public static bool PathBetweenDirectBresenham(SubGrid start, SubGrid end)
	{
		int num = start.x;
		int num2 = start.y;
		int num3 = start.z;
		int num4 = end.x - start.x;
		int num5 = end.y - start.y;
		int num6 = end.z - start.z;
		int num7 = Mathf.Abs(num4);
		int num8 = Mathf.Abs(num5);
		int num9 = Mathf.Abs(num6);
		int num10 = num7 << 1;
		int num11 = num8 << 1;
		int num12 = num9 << 1;
		int num13 = ((num4 >= 0) ? 1 : (-1));
		int num14 = ((num5 >= 0) ? 1 : (-1));
		int num15 = ((num6 >= 0) ? 1 : (-1));
		if (num7 >= num8 && num7 >= num9)
		{
			int num16 = num11 - num7;
			int num17 = num12 - num7;
			for (int i = 0; i < num7; i++)
			{
				if (IsBlocked(num, num2, num3))
				{
					return false;
				}
				if (num16 > 0)
				{
					num2 += num14;
					num16 -= num10;
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num10;
				}
				num16 += num11;
				num17 += num12;
				num += num13;
			}
		}
		else if (num8 >= num7 && num8 >= num9)
		{
			int num16 = num10 - num8;
			int num17 = num12 - num8;
			for (int j = 0; j < num8; j++)
			{
				if (IsBlocked(num, num2, num3))
				{
					return false;
				}
				if (num16 > 0)
				{
					num += num13;
					num16 -= num11;
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num11;
				}
				num16 += num10;
				num17 += num12;
				num2 += num14;
			}
		}
		else
		{
			int num16 = num11 - num9;
			int num17 = num10 - num9;
			for (int k = 0; k < num9; k++)
			{
				if (IsBlocked(num, num2, num3))
				{
					return false;
				}
				if (num16 > 0)
				{
					num2 += num14;
					num16 -= num12;
				}
				if (num17 > 0)
				{
					num += num13;
					num17 -= num12;
				}
				num16 += num11;
				num17 += num10;
				num3 += num15;
			}
		}
		return true;
	}

	public static void SetFromGrids(SubGrid grid1, SubGrid grid2, int power = 2)
	{
		gridArea.Clear();
		for (int i = 1; i < power; i++)
		{
			for (int j = 0; j < neighboursAndOrigin.Length; j++)
			{
				int x = grid1.x + neighboursAndOrigin[j].Item1 * i;
				int y = grid1.y + neighboursAndOrigin[j].Item2 * i;
				int z = grid1.z + neighboursAndOrigin[j].Item3 * i;
				if (!IsValidSubGrid(x, y, z))
				{
					continue;
				}
				SubGrid subGrid = new SubGrid(x, y, z);
				int num = subGrid.x;
				int num2 = subGrid.y;
				int num3 = subGrid.z;
				int num4 = grid2.x + neighboursAndOrigin[j].Item1 * i * -1;
				int y2 = grid2.y;
				int num5 = grid2.z + neighboursAndOrigin[j].Item3 * i * -1;
				int num6 = num4 - subGrid.x;
				int num7 = y2 - subGrid.y;
				int num8 = num5 - subGrid.z;
				int num9 = Mathf.Abs(num6);
				int num10 = Mathf.Abs(num7);
				int num11 = Mathf.Abs(num8);
				int num12 = num9 << 1;
				int num13 = num10 << 1;
				int num14 = num11 << 1;
				int num15 = ((num6 >= 0) ? 1 : (-1));
				int num16 = ((num7 >= 0) ? 1 : (-1));
				int num17 = ((num8 >= 0) ? 1 : (-1));
				int num18;
				int num19;
				if (num9 >= num10 && num9 >= num11)
				{
					num18 = num13 - num9;
					num19 = num14 - num9;
					for (int k = 0; k < num9; k++)
					{
						gridArea.Add(new SubGrid(num, num2, num3));
						if (num18 > 0)
						{
							num2 += num16;
							num18 -= num12;
						}
						if (num19 > 0)
						{
							num3 += num17;
							num19 -= num12;
						}
						num18 += num13;
						num19 += num14;
						num += num15;
					}
					continue;
				}
				if (num10 >= num9 && num10 >= num11)
				{
					num18 = num12 - num10;
					num19 = num14 - num10;
					for (int l = 0; l < num10; l++)
					{
						gridArea.Add(new SubGrid(num, num2, num3));
						if (num18 > 0)
						{
							num += num15;
							num18 -= num13;
						}
						if (num19 > 0)
						{
							num3 += num17;
							num19 -= num13;
						}
						num18 += num12;
						num19 += num14;
						num2 += num16;
					}
					continue;
				}
				num18 = num13 - num11;
				num19 = num12 - num11;
				for (int m = 0; m < num11; m++)
				{
					gridArea.Add(new SubGrid(num, num2, num3));
					if (num18 > 0)
					{
						num2 += num16;
						num18 -= num14;
					}
					if (num19 > 0)
					{
						num += num15;
						num19 -= num14;
					}
					num18 += num13;
					num19 += num12;
					num3 += num17;
				}
			}
		}
	}

	public static void SetupGrid()
	{
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		Vector3 size = TerrainMeta.Size;
		ChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 16f), 1);
		ChunkCountY = Mathf.Max(Mathf.CeilToInt(MaxY / 16f), 1);
		ChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 16f), 1);
		SubChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 2f), 1);
		SubChunkCountY = Mathf.Max(Mathf.CeilToInt(MaxY / 2f), 1);
		SubChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 2f), 1);
		OcclusionSubGridBlocked = new BitArray[ChunkCountX * ChunkCountY * ChunkCountZ];
		UnityEngine.Debug.Log($"Preparing Occlusion Grid ({SubChunkCountX}, {SubChunkCountY}, {SubChunkCountZ})");
		for (int i = 0; i < ChunkCountX; i++)
		{
			for (int j = 0; j < ChunkCountY; j++)
			{
				for (int k = 0; k < ChunkCountZ; k++)
				{
					Grid cell2 = new Grid(i, j, k);
					if (cell2.IsBlocked())
					{
						PopulateSubGrid(cell2);
					}
				}
			}
		}
		UnityEngine.Debug.Log($"Initialized {SubChunkCountX * SubChunkCountY * SubChunkCountZ} occlusion sub-chunks - took {stopwatch.Elapsed.TotalMilliseconds / 1000.0} seconds");
		static void PopulateSubGrid(Grid cell)
		{
			int num = cell.x * 8;
			int num2 = cell.y * 8;
			int num3 = cell.z * 8;
			int index = cell.GetIndex();
			ref BitArray reference = ref OcclusionSubGridBlocked[index];
			BitArray bitArray = reference ?? (reference = new BitArray(512));
			for (int l = 0; l < 8; l++)
			{
				for (int m = 0; m < 8; m++)
				{
					for (int n = 0; n < 8; n++)
					{
						int index2 = n * 8 * 8 + m * 8 + l;
						bitArray[index2] = new SubGrid(num + l, num2 + m, num3 + n).IsBlocked();
					}
				}
			}
		}
	}
}
