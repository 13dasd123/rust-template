using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class TimedExplosive : BaseEntity
{
	public float timerAmountMin = 10f;

	public float timerAmountMax = 20f;

	public float minExplosionRadius;

	public float explosionRadius = 10f;

	public bool canStick;

	public bool onlyDamageParent;

	public GameObjectRef explosionEffect;

	public GameObjectRef stickEffect;

	public GameObjectRef bounceEffect;

	public bool explosionUsesForward;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	[NonSerialized]
	private float lastBounceTime;

	public override void ServerInit()
	{
		lastBounceTime = Time.time;
		base.ServerInit();
		SetFuse(GetRandomTimerTime());
		ReceiveCollisionMessages(b: true);
	}

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			Invoke(Explode, fuseLength);
		}
	}

	public virtual float GetRandomTimerTime()
	{
		return UnityEngine.Random.Range(timerAmountMin, timerAmountMax);
	}

	public virtual void ProjectileImpact(RaycastHit info)
	{
		Explode();
	}

	public virtual void Explode()
	{
		GetComponent<Collider>().enabled = false;
		Effect.server.Run(explosionEffect.resourcePath, PivotPoint(), (!explosionUsesForward) ? Vector3.up : base.transform.forward, null, broadcast: true);
		if (onlyDamageParent)
		{
			DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), CenterPoint(), minExplosionRadius, explosionRadius, damageTypes, 141568, useLineOfSight: true);
			BaseCombatEntity baseCombatEntity = GetParentEntity() as BaseCombatEntity;
			if ((bool)baseCombatEntity)
			{
				HitInfo hitInfo = new HitInfo();
				hitInfo.Initiator = creatorEntity;
				hitInfo.WeaponPrefab = LookupPrefab();
				hitInfo.damageTypes.Add(damageTypes);
				baseCombatEntity.Hurt(hitInfo);
			}
		}
		else
		{
			DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), CenterPoint(), minExplosionRadius, explosionRadius, damageTypes, 2238720, useLineOfSight: true);
		}
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (canStick)
		{
			bool flag = true;
			if ((bool)hitEntity)
			{
				flag = CanStickTo(hitEntity);
				if (!flag)
				{
					Collider component = GetComponent<Collider>();
					if (collision.collider != null && component != null)
					{
						Physics.IgnoreCollision(collision.collider, component);
					}
				}
			}
			if (flag)
			{
				DoCollisionStick(collision, hitEntity);
			}
		}
		DoBounceEffect();
	}

	private bool CanStickTo(BaseEntity entity)
	{
		return entity.GetComponent<DecorDeployable>() == null;
	}

	private void DoBounceEffect()
	{
		if (bounceEffect.isValid && !(Time.time - lastBounceTime < 0.2f))
		{
			Rigidbody component = GetComponent<Rigidbody>();
			if (!component || !(component.velocity.magnitude < 1f))
			{
				Effect.server.Run(bounceEffect.resourcePath, GetEstimatedWorldPosition(), Vector3.up, null, broadcast: true);
				lastBounceTime = Time.time;
			}
		}
	}

	private void DoCollisionStick(Collision collision, BaseEntity ent)
	{
		DoStick(collision.contacts[0].point, collision.contacts[0].normal, ent);
	}

	public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent)
	{
		if (!(ent == null) && !(ent is TimedExplosive))
		{
			Rigidbody component = GetComponent<Rigidbody>();
			if ((bool)component)
			{
				component.useGravity = false;
				component.isKinematic = true;
			}
			if (!HasChild(ent))
			{
				base.transform.position = ent.transform.worldToLocalMatrix.MultiplyPoint3x4(position);
				base.transform.rotation = Quaternion.Inverse(ent.transform.rotation) * Quaternion.LookRotation(normal, base.transform.up);
				SetParent(ent, StringPool.closest);
				Vector3 estimatedWorldPosition = GetEstimatedWorldPosition();
				Effect.server.Run(stickEffect.resourcePath, estimatedWorldPosition, Vector3.up, null, broadcast: true);
				ReceiveCollisionMessages(b: false);
			}
		}
	}

	private void UnStick()
	{
		if ((bool)GetParentEntity())
		{
			Vector3 estimatedWorldPosition = GetEstimatedWorldPosition();
			SetParent(null);
			base.transform.position = estimatedWorldPosition;
			Rigidbody component = GetComponent<Rigidbody>();
			if ((bool)component)
			{
				component.useGravity = true;
				component.isKinematic = false;
			}
			SendNetworkUpdate_Position();
			ReceiveCollisionMessages(b: true);
		}
	}

	internal override void OnParentRemoved()
	{
		UnStick();
	}
}
