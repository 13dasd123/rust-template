using System;
using UnityEngine;

public class PathInterpolator
{
	public Vector3[] Points;

	public Vector3[] Tangents;

	private bool initialized;

	public int MinIndex { get; set; }

	public int MaxIndex { get; set; }

	public float Length { get; private set; }

	public float StepSize { get; private set; }

	public int DefaultMinIndex => 0;

	public int DefaultMaxIndex => Points.Length - 1;

	public float StartOffset => Length * (float)(MinIndex - DefaultMinIndex) / (float)(DefaultMaxIndex - DefaultMinIndex);

	public float EndOffset => Length * (float)(DefaultMaxIndex - MaxIndex) / (float)(DefaultMaxIndex - DefaultMinIndex);

	public PathInterpolator(Vector3[] points)
	{
		if (points.Length < 2)
		{
			throw new ArgumentException("Point list too short.");
		}
		Points = points;
		MinIndex = DefaultMinIndex;
		MaxIndex = DefaultMaxIndex;
	}

	public void RecalculateTangents()
	{
		if (Tangents == null || Tangents.Length != Points.Length)
		{
			Tangents = new Vector3[Points.Length];
		}
		float num = 0f;
		for (int i = 0; i < Tangents.Length; i++)
		{
			Vector3 vector = Points[Mathf.Max(i - 1, 0)];
			Vector3 vector2 = Points[Mathf.Min(i + 1, Tangents.Length - 1)] - vector;
			float magnitude = vector2.magnitude;
			num += magnitude;
			Tangents[i] = vector2 / magnitude;
		}
		Length = num;
		StepSize = num / (float)Points.Length;
		initialized = true;
	}

	public void Resample(float distance)
	{
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		Vector3[] array = new Vector3[Mathf.RoundToInt(Length / distance)];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = GetPointCubicHermite((float)i * distance);
		}
		Points = array;
		initialized = false;
	}

	public void Smoothen(int iterations = 1)
	{
		float num = 0.25f;
		for (int i = 0; i < iterations; i++)
		{
			Vector3 vector = Points[0];
			for (int j = 1; j < Points.Length - 1; j++)
			{
				Vector3 vector2 = Points[j];
				Vector3 vector3 = Points[j + 1];
				Points[j] = (vector + vector2 + vector2 + vector3) * num;
				vector = vector2;
			}
		}
		initialized = false;
	}

	public Vector3 GetStartPoint()
	{
		return Points[MinIndex];
	}

	public Vector3 GetEndPoint()
	{
		return Points[MaxIndex];
	}

	public Vector3 GetStartTangent()
	{
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		return Tangents[MinIndex];
	}

	public Vector3 GetEndTangent()
	{
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		return Tangents[MaxIndex];
	}

	public Vector3 GetPoint(float distance)
	{
		float num = distance / Length * (float)Points.Length;
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartPoint();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndPoint();
		}
		Vector3 a = Points[num2];
		Vector3 b = Points[num2 + 1];
		float t = num - (float)num2;
		return Vector3.Lerp(a, b, t);
	}

	public Vector3 GetTangent(float distance)
	{
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		float num = distance / Length * (float)Tangents.Length;
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartTangent();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndTangent();
		}
		Vector3 a = Tangents[num2];
		Vector3 b = Tangents[num2 + 1];
		float t = num - (float)num2;
		return Vector3.Lerp(a, b, t);
	}

	public Vector3 GetPointCubicHermite(float distance)
	{
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		float num = distance / Length * (float)Points.Length;
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartPoint();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndPoint();
		}
		Vector3 vector = Points[num2];
		Vector3 vector2 = Points[num2 + 1];
		Vector3 vector3 = Tangents[num2] * StepSize;
		Vector3 vector4 = Tangents[num2 + 1] * StepSize;
		float num3 = num - (float)num2;
		float num4 = num3 * num3;
		float num5 = num3 * num4;
		return (2f * num5 - 3f * num4 + 1f) * vector + (num5 - 2f * num4 + num3) * vector3 + (-2f * num5 + 3f * num4) * vector2 + (num5 - num4) * vector4;
	}
}
