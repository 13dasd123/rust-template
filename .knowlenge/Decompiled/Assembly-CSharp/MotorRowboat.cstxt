#define UNITY_ASSERTIONS
using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class MotorRowboat : MotorBoat
{
	protected const Flags Flag_EngineOn = Flags.Reserved1;

	protected const Flags Flag_ThrottleOn = Flags.Reserved2;

	protected const Flags Flag_TurnLeft = Flags.Reserved3;

	protected const Flags Flag_TurnRight = Flags.Reserved4;

	protected const Flags Flag_Submerged = Flags.Reserved5;

	protected const Flags Flag_HasFuel = Flags.Reserved6;

	protected const Flags Flag_RecentlyPushed = Flags.Reserved8;

	public const float submergeFractionMinimum = 0.85f;

	[Header("Fuel")]
	public GameObjectRef fuelStoragePrefab;

	public Transform fuelStoragePoint;

	public EntityRef fuelStorageInstance;

	public float fuelPerSec;

	[Header("Storage")]
	public GameObjectRef storageUnitPrefab;

	public Transform storageUnitPoint;

	public EntityRef storageUnitInstance;

	[Header("Effects")]
	public Transform boatRear;

	public ParticleSystemContainer wakeEffect;

	public ParticleSystemContainer engineEffectIdle;

	public ParticleSystemContainer engineEffectThrottle;

	public Projector causticsProjector;

	public Transform causticsDepthTest;

	public Transform engineLeftHandPosition;

	public Transform engineRotate;

	public Transform propellerRotate;

	[ServerVar(Help = "Population active on the server")]
	public static float population = 4f;

	[ServerVar(Help = "How long before a boat is killed while outside")]
	public static float outsidedecayminutes = 180f;

	public Transform[] stationaryDismounts;

	public Collider mainCollider;

	private float nextFuelCheckTime;

	private bool cachedHasFuel;

	private float pendingFuel;

	private float lastUsedFuelTime;

	private float nextPushTime;

	public float lastHadDriverTime;

	public float angularDragBase = 0.5f;

	public float angularDragVelocity = 0.5f;

	public float landDrag = 0.2f;

	public float waterDrag = 0.8f;

	public float offAxisDrag = 1f;

	public float offAxisDot = 0.25f;

	public bool dying;

	public const float maxVelForStationaryDismount = 4f;

	[Header("Audio")]
	public BlendedSoundLoops engineLoops;

	public BlendedSoundLoops waterLoops;

	public SoundDefinition engineStartSoundDef;

	public SoundDefinition engineStopSoundDef;

	public SoundDefinition movementSplashAccentSoundDef;

	public SoundDefinition engineSteerSoundDef;

	public GameObjectRef pushLandEffect;

	public GameObjectRef pushWaterEffect;

	public float waterSpeedDivisor = 10f;

	public float turnPitchModScale = -0.25f;

	public float tiltPitchModScale = 0.3f;

	public float splashAccentFrequencyMin = 1f;

	public float splashAccentFrequencyMax = 10f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("MotorRowboat.OnRpcMessage"))
		{
			if (rpc == 1873751172 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - RPC_EngineToggle "));
				}
				using (TimeWarning.New("RPC_EngineToggle"))
				{
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_EngineToggle(msg2);
						}
					}
					catch (Exception exception)
					{
						player.Kick("RPC Error in RPC_EngineToggle");
						Debug.LogException(exception);
					}
				}
				return true;
			}
			if (rpc == 1851540757 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - RPC_OpenFuel "));
				}
				using (TimeWarning.New("RPC_OpenFuel"))
				{
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_OpenFuel(msg3);
						}
					}
					catch (Exception exception2)
					{
						player.Kick("RPC Error in RPC_OpenFuel");
						Debug.LogException(exception2);
					}
				}
				return true;
			}
			if (rpc == 2115395408 && player != null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (ConVar.Global.developer > 2)
				{
					Debug.Log(string.Concat("SV_RPCMessage: ", player, " - RPC_WantsPush "));
				}
				using (TimeWarning.New("RPC_WantsPush"))
				{
					try
					{
						using (TimeWarning.New("Call"))
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_WantsPush(msg4);
						}
					}
					catch (Exception exception3)
					{
						player.Kick("RPC Error in RPC_WantsPush");
						Debug.LogException(exception3);
					}
				}
				return true;
			}
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		InvokeRandomized(BoatDecay, UnityEngine.Random.Range(30f, 60f), 60f, 6f);
	}

	public override void SpawnSubEntities()
	{
		base.SpawnSubEntities();
		if (!Rust.Application.isLoadingSave)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(storageUnitPrefab.resourcePath, storageUnitPoint.localPosition, storageUnitPoint.localRotation);
			baseEntity.Spawn();
			baseEntity.SetParent(this);
			storageUnitInstance.Set(baseEntity);
			UnityEngine.Physics.IgnoreCollision(baseEntity.GetComponent<Collider>(), mainCollider, ignore: true);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(fuelStoragePrefab.resourcePath, fuelStoragePoint.localPosition, fuelStoragePoint.localRotation);
			baseEntity2.Spawn();
			baseEntity2.SetParent(this);
			fuelStorageInstance.Set(baseEntity2);
			UnityEngine.Physics.IgnoreCollision(baseEntity2.GetComponent<Collider>(), mainCollider, ignore: true);
		}
	}

	public void BoatDecay()
	{
		if (!dying && base.healthFraction != 0f && !(UnityEngine.Time.time < lastUsedFuelTime + 600f))
		{
			float num = 1f / outsidedecayminutes;
			if (IsOutside())
			{
				Hurt(MaxHealth() * num, DamageType.Decay, this, useProtection: false);
			}
		}
	}

	public int GetFuelAmount()
	{
		if (!fuelStorageInstance.IsValid(base.isServer))
		{
			return 0;
		}
		StorageContainer component = fuelStorageInstance.Get(base.isServer).GetComponent<StorageContainer>();
		if (component == null)
		{
			return 0;
		}
		Item slot = component.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		return slot.amount;
	}

	public virtual bool HasFuel(bool forceCheck = false)
	{
		if (UnityEngine.Time.time > nextFuelCheckTime || forceCheck)
		{
			cachedHasFuel = (float)GetFuelAmount() > 0f;
			nextFuelCheckTime = UnityEngine.Time.time + UnityEngine.Random.Range(1f, 2f);
		}
		return cachedHasFuel;
	}

	public virtual bool UseFuel(float seconds)
	{
		if (!fuelStorageInstance.IsValid(base.isServer))
		{
			return false;
		}
		StorageContainer component = fuelStorageInstance.Get(base.isServer).GetComponent<StorageContainer>();
		if (component == null)
		{
			return false;
		}
		Item slot = component.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return false;
		}
		pendingFuel += seconds * fuelPerSec;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			pendingFuel -= num;
		}
		return true;
	}

	public bool RecentlyPushed()
	{
		return UnityEngine.Time.realtimeSinceStartup < nextPushTime;
	}

	[RPC_Server]
	public void RPC_WantsPush(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.isMounted || RecentlyPushed() || !HasFlag(Flags.Reserved7) || (!(player.WaterFactor() <= 0.6f) && !IsFlipped()) || Vector3.Distance(player.transform.position, base.transform.position) > 5f || dying)
		{
			return;
		}
		player.metabolism.calories.Subtract(2f);
		player.metabolism.SendChangesToClient();
		if (IsFlipped())
		{
			rigidBody.AddRelativeTorque(Vector3.forward * 5f, ForceMode.VelocityChange);
		}
		else
		{
			Vector3 vector = Vector3Ex.Direction2D(player.transform.position, base.transform.position);
			Vector3 vector2 = Vector3Ex.Direction2D(player.transform.position + player.eyes.BodyForward() * 3f, player.transform.position);
			vector2 = (Vector3.up * 0.1f + vector2).normalized;
			Vector3 position = base.transform.position + vector * 2f;
			float num = 3f;
			float value = Vector3.Dot(base.transform.forward, vector2);
			num += Mathf.InverseLerp(0.8f, 1f, value) * 3f;
			rigidBody.AddForceAtPosition(vector2 * num, position, ForceMode.VelocityChange);
		}
		nextPushTime = UnityEngine.Time.realtimeSinceStartup + 1f;
		if (HasFlag(Flags.Reserved5))
		{
			if (pushWaterEffect.isValid)
			{
				Effect.server.Run(pushWaterEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		else if (pushLandEffect.isValid)
		{
			Effect.server.Run(pushLandEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

	[RPC_Server]
	public void RPC_OpenFuel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsDriver(player) && fuelStorageInstance.IsValid(base.isServer))
		{
			fuelStorageInstance.Get(base.isServer).GetComponent<StorageContainer>().PlayerOpenLoot(player);
		}
	}

	public bool IsDriver(BasePlayer player)
	{
		return GetPlayerSeat(player) == 0;
	}

	[RPC_Server]
	public void RPC_EngineToggle(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null))
		{
			bool flag = msg.read.Bit();
			if (InDryDock())
			{
				flag = false;
			}
			if (IsDriver(player) && flag != EngineOn())
			{
				EngineToggle(flag);
			}
		}
	}

	public void EngineToggle(bool wantsOn)
	{
		if (HasFuel(forceCheck: true))
		{
			SetFlag(Flags.Reserved1, wantsOn);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Invoke(CheckInvalidBoat, 1f);
		if (base.health <= 0f)
		{
			Invoke(ActualDeath, vehicle.boat_corpse_seconds);
			buoyancy.buoyancyScale = 0f;
			dying = true;
		}
	}

	public void CheckInvalidBoat()
	{
		if (!fuelStorageInstance.IsValid(base.isServer) || !storageUnitInstance.IsValid(base.isServer))
		{
			Debug.Log("Destroying invalid boat ");
			Invoke(ActualDeath, 1f);
		}
	}

	public override void AttemptMount(BasePlayer player)
	{
		if (!dying)
		{
			base.AttemptMount(player);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
	}

	public override float GetSteering(BasePlayer player)
	{
		return 0f;
	}

	public override bool EngineOn()
	{
		return HasFlag(Flags.Reserved1);
	}

	public float TimeSinceDriver()
	{
		return UnityEngine.Time.time - lastHadDriverTime;
	}

	public override void DriverInput(InputState inputState, BasePlayer player)
	{
		base.DriverInput(inputState, player);
		lastHadDriverTime = UnityEngine.Time.time;
	}

	public override void VehicleFixedUpdate()
	{
		base.VehicleFixedUpdate();
		float num = TimeSinceDriver();
		bool b = EngineOn() && !IsFlipped() && base.healthFraction > 0f && HasFuel() && num < 75f;
		if (num > 15f)
		{
			steering += Mathf.InverseLerp(15f, 30f, num);
			steering = Mathf.Clamp(-1f, 1f, steering);
			if (num > 75f)
			{
				gasPedal = 0f;
			}
		}
		SetFlag(Flags.Reserved3, steering > 0f, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved4, steering < 0f, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved1, b, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, EngineOn() && gasPedal != 0f, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved5, buoyancy.submergedFraction > 0.85f, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved6, HasFuel(), recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved7, rigidBody.velocity.magnitude < 1f, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved8, RecentlyPushed(), recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		UpdateDrag();
		if (dying)
		{
			buoyancy.buoyancyScale = Mathf.Lerp(buoyancy.buoyancyScale, 0f, UnityEngine.Time.fixedDeltaTime * 0.1f);
		}
		else
		{
			float num2 = 1f;
			float value = rigidBody.velocity.Magnitude2D();
			float num3 = Mathf.InverseLerp(1f, 10f, value) * 0.5f * base.healthFraction;
			if (!EngineOn())
			{
				num3 = 0f;
			}
			float num4 = 1f - 0.3f * (1f - base.healthFraction);
			buoyancy.buoyancyScale = (num2 + num3) * num4;
		}
		if (EngineOn())
		{
			float num5 = (HasFlag(Flags.Reserved2) ? 1f : 0.0333f);
			UseFuel(UnityEngine.Time.fixedDeltaTime * num5);
			lastUsedFuelTime = UnityEngine.Time.time;
		}
	}

	public override void SeatClippedWorld(BaseMountable mountable)
	{
		BasePlayer mounted = mountable.GetMounted();
		if (!(mounted == null))
		{
			if (IsDriver(mounted))
			{
				steering = 0f;
				gasPedal = 0f;
			}
			float num = Mathf.InverseLerp(4f, 20f, rigidBody.velocity.magnitude);
			if (num > 0f)
			{
				mounted.Hurt(num * 100f, DamageType.Blunt, this, useProtection: false);
			}
			if (mounted != null && mounted.isMounted)
			{
				base.SeatClippedWorld(mountable);
			}
		}
	}

	public void UpdateDrag()
	{
		float value = rigidBody.velocity.SqrMagnitude2D();
		float num = Mathf.InverseLerp(0f, 2f, value);
		rigidBody.angularDrag = angularDragBase + angularDragVelocity * num;
		rigidBody.drag = landDrag + waterDrag * Mathf.InverseLerp(0f, 1f, buoyancy.submergedFraction);
		if (offAxisDrag > 0f)
		{
			float value2 = Vector3.Dot(base.transform.forward, rigidBody.velocity.normalized);
			float num2 = Mathf.InverseLerp(0.98f, 0.92f, value2);
			rigidBody.drag += num2 * offAxisDrag * buoyancy.submergedFraction;
		}
	}

	public override void OnKilled(HitInfo info)
	{
		if (!dying)
		{
			dying = true;
			repair.enabled = false;
			Invoke(DismountAllPlayers, 10f);
			Invoke(ActualDeath, vehicle.boat_corpse_seconds);
		}
	}

	public void ActualDeath()
	{
		Kill();
	}

	public override bool MountEligable()
	{
		if (rigidBody.velocity.magnitude >= 5f && HasDriver())
		{
			return false;
		}
		return base.MountEligable();
	}

	public override bool HasValidDismountPosition(BasePlayer player)
	{
		if (rigidBody.velocity.magnitude <= 4f)
		{
			Transform[] array = stationaryDismounts;
			foreach (Transform transform in array)
			{
				if (ValidDismountPosition(transform.transform.position))
				{
					return true;
				}
			}
		}
		return base.HasValidDismountPosition(player);
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res)
	{
		if (rigidBody.velocity.magnitude <= 4f)
		{
			List<Vector3> obj = Facepunch.Pool.GetList<Vector3>();
			Transform[] array = stationaryDismounts;
			foreach (Transform transform in array)
			{
				if (ValidDismountPosition(transform.transform.position))
				{
					obj.Add(transform.transform.position);
				}
			}
			if (obj.Count > 0)
			{
				Vector3 pos = player.transform.position;
				obj.Sort((Vector3 a, Vector3 b) => Vector3.Distance(a, pos).CompareTo(Vector3.Distance(b, pos)));
				res = obj[0];
				Facepunch.Pool.FreeList(ref obj);
				return true;
			}
			Facepunch.Pool.FreeList(ref obj);
		}
		return base.GetDismountPosition(player, out res);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.motorBoat = Facepunch.Pool.Get<Motorboat>();
		info.msg.motorBoat.storageid = storageUnitInstance.uid;
		info.msg.motorBoat.fuelStorageID = fuelStorageInstance.uid;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.motorBoat != null)
		{
			fuelStorageInstance.uid = info.msg.motorBoat.fuelStorageID;
			storageUnitInstance.uid = info.msg.motorBoat.storageid;
		}
	}
}
