using Oxide.Core;
using Rust;
using UnityEngine;

public class CH47HelicopterAIController : CH47Helicopter
{
	public GameObjectRef scientistPrefab;

	public float maxTiltAngle = 0.3f;

	public float AiAltitudeForce = 10000f;

	public GameObjectRef lockedCratePrefab;

	public const Flags Flag_Damaged = Flags.Reserved7;

	public const Flags Flag_NearDeath = Flags.OnFire;

	public const Flags Flag_DropDoorOpen = Flags.Reserved8;

	public int numCrates = 1;

	public bool aimDirOverride;

	public Vector3 _aimDirection = Vector3.forward;

	public Vector3 _moveTarget = Vector3.zero;

	public int lastAltitudeCheckFrame;

	public float altOverride;

	public float currentDesiredAltitude;

	public float hoverHeight = 30f;

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

	public void TriggeredEventSpawn()
	{
		float x = TerrainMeta.Size.x;
		float y = 30f;
		Vector3 position = Vector3Ex.Range(-1f, 1f);
		position.y = 0f;
		position.Normalize();
		position *= x * 1f;
		position.y = y;
		base.transform.position = position;
	}

	public override void AttemptMount(BasePlayer player)
	{
		if (Interface.CallHook("CanUseHelicopter", player, this) == null)
		{
			base.AttemptMount(player);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Invoke(SpawnScientists, 1f);
		SetMoveTarget(base.transform.position);
	}

	public void SpawnScientist(Vector3 spawnPos)
	{
		Quaternion identity = Quaternion.identity;
		NPCPlayerApex component = GameManager.server.CreateEntity(scientistPrefab.resourcePath, spawnPos, identity).GetComponent<NPCPlayerApex>();
		component.Spawn();
		component.Mount(this);
		component.Stats.VisionRange = 203f;
		component.Stats.DeaggroRange = 202f;
		component.Stats.AggressionRange = 201f;
		component.Stats.LongRange = 200f;
		component.Stats.Hostility = 0f;
		component.Stats.Defensiveness = 0f;
		component.Stats.OnlyAggroMarkedTargets = true;
		component.InitFacts();
	}

	public void SpawnScientists()
	{
		for (int i = 0; i < 4; i++)
		{
			Vector3 spawnPos = base.transform.position + base.transform.forward * 10f;
			SpawnScientist(spawnPos);
		}
		for (int j = 0; j < 1; j++)
		{
			Vector3 spawnPos2 = base.transform.position - base.transform.forward * 15f;
			SpawnScientist(spawnPos2);
		}
	}

	public void EnableFacingOverride(bool enabled)
	{
		aimDirOverride = enabled;
	}

	public void SetMoveTarget(Vector3 position)
	{
		_moveTarget = position;
	}

	public Vector3 GetMoveTarget()
	{
		return _moveTarget;
	}

	public void SetAimDirection(Vector3 dir)
	{
		_aimDirection = dir;
	}

	public Vector3 GetAimDirectionOverride()
	{
		return _aimDirection;
	}

	public Vector3 GetPosition()
	{
		return base.transform.position;
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		InitiateAnger();
	}

	public void CancelAnger()
	{
		if (base.SecondsSinceAttacked > 120f)
		{
			UnHostile();
			CancelInvoke(UnHostile);
		}
	}

	public void InitiateAnger()
	{
		CancelInvoke(UnHostile);
		Invoke(UnHostile, 120f);
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			if (!(mountPointInfo.mountable != null))
			{
				continue;
			}
			BasePlayer mounted = mountPointInfo.mountable.GetMounted();
			if ((bool)mounted)
			{
				NPCPlayerApex nPCPlayerApex = mounted as NPCPlayerApex;
				if ((bool)nPCPlayerApex)
				{
					nPCPlayerApex.Stats.Hostility = 1f;
					nPCPlayerApex.Stats.Defensiveness = 1f;
				}
			}
		}
	}

	public void UnHostile()
	{
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			if (!(mountPointInfo.mountable != null))
			{
				continue;
			}
			BasePlayer mounted = mountPointInfo.mountable.GetMounted();
			if ((bool)mounted)
			{
				NPCPlayerApex nPCPlayerApex = mounted as NPCPlayerApex;
				if ((bool)nPCPlayerApex)
				{
					nPCPlayerApex.Stats.Hostility = 0f;
					nPCPlayerApex.Stats.Defensiveness = 0f;
				}
			}
		}
	}

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterKilled", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttacked", this) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved7, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

	public void DelayedKill()
	{
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			if (mountPointInfo.mountable != null)
			{
				BasePlayer mounted = mountPointInfo.mountable.GetMounted();
				if ((bool)mounted && mounted.transform != null && !mounted.IsDestroyed && !mounted.IsDead() && mounted.IsNpc)
				{
					mounted.Kill();
				}
			}
		}
		Kill();
	}

	public override void DismountAllPlayers()
	{
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			if (mountPointInfo.mountable != null)
			{
				BasePlayer mounted = mountPointInfo.mountable.GetMounted();
				if ((bool)mounted)
				{
					mounted.Hurt(10000f, DamageType.Explosion, this, useProtection: false);
				}
			}
		}
	}

	public float GetDesiredAltitude()
	{
		CalculateOverrideAltitude();
		if (altOverride > currentDesiredAltitude)
		{
			currentDesiredAltitude = altOverride;
		}
		else
		{
			currentDesiredAltitude = Mathf.MoveTowards(currentDesiredAltitude, altOverride, Time.fixedDeltaTime * 5f);
		}
		return currentDesiredAltitude;
	}

	public float CalculateOverrideAltitude()
	{
		if (Time.frameCount == lastAltitudeCheckFrame)
		{
			return altOverride;
		}
		lastAltitudeCheckFrame = Time.frameCount;
		float y = GetMoveTarget().y;
		float num = Mathf.Max(TerrainMeta.WaterMap.GetHeight(GetMoveTarget()), TerrainMeta.HeightMap.GetHeight(GetMoveTarget()));
		float num2 = Mathf.Max(y, num + hoverHeight);
		Vector3 rhs = ((!(rigidBody.velocity.magnitude < 0.1f)) ? rigidBody.velocity.normalized : base.transform.forward);
		Vector3 lhs = Vector3.Cross(base.transform.up, rhs);
		Vector3 vector = Vector3.Cross(lhs, Vector3.up);
		Vector3 normalized = (vector + Vector3.down * 0.3f).normalized;
		if (Physics.SphereCast(base.transform.position - normalized * 20f, 20f, normalized, out var hitInfo, 75f, 1218511105) && Physics.SphereCast(hitInfo.point + Vector3.up * 200f, 20f, Vector3.down, out var hitInfo2, 200f, 1218511105))
		{
			num2 = hitInfo2.point.y + hoverHeight;
		}
		altOverride = num2;
		return altOverride;
	}

	public override HelicopterInputState_t GetDefaultInputState()
	{
		HelicopterInputState_t result = default(HelicopterInputState_t);
		Vector3 moveTarget = GetMoveTarget();
		Vector3 vector = Vector3.Cross(base.transform.right, Vector3.up);
		Vector3 vector2 = Vector3.Cross(Vector3.up, vector);
		float num = 0f - Vector3.Dot(Vector3.up, base.transform.right);
		float num2 = Vector3.Dot(Vector3.up, base.transform.forward);
		float num3 = Vector3Ex.Distance2D(base.transform.position, moveTarget);
		float y = base.transform.position.y;
		float desiredAltitude = GetDesiredAltitude();
		Vector3 vector3 = base.transform.position + base.transform.forward * 10f;
		vector3.y = desiredAltitude;
		Vector3 lhs = Vector3Ex.Direction2D(moveTarget, base.transform.position);
		float num4 = 0f - Vector3.Dot(lhs, vector2);
		float num5 = Vector3.Dot(lhs, vector);
		float num6 = Mathf.InverseLerp(3f, 12f, num3);
		if (num5 > 0f)
		{
			float num7 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num2);
			result.pitch = 1f * num5 * num7 * num6;
		}
		else
		{
			float num8 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num2);
			result.pitch = 1f * num5 * num8 * num6;
		}
		if (num4 > 0f)
		{
			float num9 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num);
			result.roll = 1f * num4 * num9 * num6;
		}
		else
		{
			float num10 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num);
			result.roll = 1f * num4 * num10 * num6;
		}
		float value = Mathf.Abs(desiredAltitude - y);
		float num11 = 1f - Mathf.InverseLerp(10f, 30f, value);
		result.pitch *= num11;
		result.roll *= num11;
		float num12 = maxTiltAngle;
		float num13 = Mathf.InverseLerp(Mathf.Abs(result.pitch) * num12, num12 + Mathf.Abs(result.pitch) * num12, Mathf.Abs(num2));
		result.pitch += num13 * ((!(num2 < 0f)) ? 1f : (-1f));
		float num14 = Mathf.InverseLerp(Mathf.Abs(result.roll) * num12, num12 + Mathf.Abs(result.roll) * num12, Mathf.Abs(num));
		result.roll += num14 * ((!(num < 0f)) ? 1f : (-1f));
		if (aimDirOverride || num3 > 30f)
		{
			Vector3 rhs = ((!aimDirOverride) ? Vector3Ex.Direction2D(GetMoveTarget(), base.transform.position) : GetAimDirectionOverride());
			float num15 = Vector3.Dot(vector2, rhs);
			float f = Vector3.Angle(vector, Vector3Ex.Direction2D(GetMoveTarget(), base.transform.position));
			float num16 = Mathf.InverseLerp(0f, 70f, Mathf.Abs(f));
			result.yaw = ((!(num15 > 0f)) ? 0f : 1f);
			result.yaw -= ((!(num15 < 0f)) ? 0f : 1f);
			result.yaw *= num16;
		}
		float throttle = Mathf.InverseLerp(5f, 30f, num3);
		result.throttle = throttle;
		return result;
	}

	public void MaintainAIAltutide()
	{
		Vector3 vector = base.transform.position + rigidBody.velocity;
		float desiredAltitude = GetDesiredAltitude();
		float y = vector.y;
		float value = Mathf.Abs(desiredAltitude - y);
		bool flag = desiredAltitude > y;
		float num = Mathf.InverseLerp(0f, 10f, value) * AiAltitudeForce * ((!flag) ? (-1f) : 1f);
		rigidBody.AddForce(Vector3.up * num, ForceMode.Force);
	}

	public override void VehicleFixedUpdate()
	{
		hoverForceScale = 1f;
		base.VehicleFixedUpdate();
		SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
		MaintainAIAltutide();
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			MountPointInfo[] array = mountPoints;
			foreach (MountPointInfo mountPointInfo in array)
			{
				if (mountPointInfo.mountable != null)
				{
					BasePlayer mounted = mountPointInfo.mountable.GetMounted();
					if ((bool)mounted && mounted.transform != null && !mounted.IsDestroyed && !mounted.IsDead() && mounted.IsNpc)
					{
						mounted.Kill();
					}
				}
			}
		}
		base.DestroyShared();
	}
}
