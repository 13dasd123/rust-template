using System;
using UnityEngine;

public class PositionLerp : ListComponent<PositionLerp>
{
	public static bool DebugLog;

	public static bool DebugDraw;

	private Action idleDisable;

	private TransformInterpolator interpolator = new TransformInterpolator();

	private ILerpTarget target;

	private float timeOffset0 = float.MaxValue;

	private float timeOffset1 = float.MaxValue;

	private float timeOffset2 = float.MaxValue;

	private float timeOffset3 = float.MaxValue;

	private float lastClientTime;

	private float lastServerTime;

	private float extrapolatedTime;

	public void Initialize(ILerpTarget target)
	{
		this.target = target;
	}

	public void Snapshot(Vector3 position, Quaternion rotation, float serverTime)
	{
		float interpolationDelay = target.GetInterpolationDelay();
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		float num = interpolationDelay + interpolationSmoothing + 1f;
		float time = Time.time;
		timeOffset0 = timeOffset1;
		timeOffset1 = timeOffset2;
		timeOffset2 = timeOffset3;
		timeOffset3 = time - serverTime;
		float num2 = Mathx.Min(timeOffset0, timeOffset1, timeOffset2, timeOffset3);
		time = serverTime + num2;
		if (DebugLog && interpolator.list.Count > 0 && serverTime < lastServerTime)
		{
			Debug.LogWarning(target.ToString() + " adding tick from the past: server time " + serverTime + " < " + lastServerTime);
		}
		else if (DebugLog && interpolator.list.Count > 0 && time < lastClientTime)
		{
			Debug.LogWarning(target.ToString() + " adding tick from the past: client time " + time + " < " + lastClientTime);
		}
		else
		{
			lastClientTime = time;
			lastServerTime = serverTime;
			interpolator.Add(new TransformInterpolator.Entry
			{
				time = time,
				pos = position,
				rot = rotation
			});
		}
		interpolator.Cull(time - num);
	}

	public void SnapTo(Vector3 position, Quaternion rotation, float serverTime)
	{
		interpolator.Clear();
		Snapshot(position, rotation, serverTime);
		target.SetNetworkPosition(position);
		target.SetNetworkRotation(rotation);
	}

	public void SnapToEnd()
	{
		float interpolationDelay = target.GetInterpolationDelay();
		TransformInterpolator.Segment segment = interpolator.Query(Time.time, interpolationDelay, 0f, 0f);
		target.SetNetworkPosition(segment.tick.pos);
		target.SetNetworkRotation(segment.tick.rot);
		interpolator.Clear();
	}

	protected void DoCycle()
	{
		if (target == null)
		{
			return;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay();
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		TransformInterpolator.Segment segment = interpolator.Query(Time.time, interpolationDelay, extrapolationTime, interpolationSmoothing);
		if (segment.next.time >= interpolator.last.time)
		{
			extrapolatedTime = Mathf.Min(extrapolatedTime + Time.deltaTime, extrapolationTime);
		}
		else
		{
			extrapolatedTime = Mathf.Max(extrapolatedTime - Time.deltaTime, 0f);
		}
		if (extrapolatedTime > 0f && extrapolationTime > 0f && interpolationSmoothing > 0f)
		{
			float t = Time.deltaTime / (extrapolatedTime / extrapolationTime * interpolationSmoothing);
			segment.tick.pos = Vector3.Lerp(target.GetNetworkPosition(), segment.tick.pos, t);
			segment.tick.rot = Quaternion.Slerp(target.GetNetworkRotation(), segment.tick.rot, t);
		}
		target.SetNetworkPosition(segment.tick.pos);
		target.SetNetworkRotation(segment.tick.rot);
		if (DebugDraw)
		{
			target.DrawInterpolationState(segment, interpolator.list);
		}
		if (Time.time - lastClientTime > 10f)
		{
			if (idleDisable == null)
			{
				idleDisable = IdleDisable;
			}
			InvokeHandler.Invoke(this, idleDisable, 0f);
		}
	}

	private void IdleDisable()
	{
		base.enabled = false;
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		Quaternion rotation = matrix.rotation;
		for (int i = 0; i < interpolator.list.Count; i++)
		{
			TransformInterpolator.Entry value = interpolator.list[i];
			value.pos = matrix.MultiplyPoint3x4(value.pos);
			value.rot = rotation * value.rot;
			interpolator.list[i] = value;
		}
		interpolator.last.pos = matrix.MultiplyPoint3x4(interpolator.last.pos);
		interpolator.last.rot = rotation * interpolator.last.rot;
	}

	public Quaternion GetEstimatedAngularVelocity()
	{
		if (target == null)
		{
			return Quaternion.identity;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay();
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		TransformInterpolator.Segment segment = interpolator.Query(Time.time, interpolationDelay, extrapolationTime, interpolationSmoothing);
		TransformInterpolator.Entry next = segment.next;
		TransformInterpolator.Entry prev = segment.prev;
		if (next.time == prev.time)
		{
			return Quaternion.identity;
		}
		return Quaternion.Euler((prev.rot.eulerAngles - next.rot.eulerAngles) / (prev.time - next.time));
	}

	public Vector3 GetEstimatedVelocity()
	{
		if (target == null)
		{
			return Vector3.zero;
		}
		float extrapolationTime = target.GetExtrapolationTime();
		float interpolationDelay = target.GetInterpolationDelay();
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		TransformInterpolator.Segment segment = interpolator.Query(Time.time, interpolationDelay, extrapolationTime, interpolationSmoothing);
		TransformInterpolator.Entry next = segment.next;
		TransformInterpolator.Entry prev = segment.prev;
		if (next.time == prev.time)
		{
			return Vector3.zero;
		}
		return (prev.pos - next.pos) / (prev.time - next.time);
	}

	public static void Cycle()
	{
		PositionLerp[] buffer = ListComponent<PositionLerp>.InstanceList.Values.Buffer;
		int count = ListComponent<PositionLerp>.InstanceList.Count;
		for (int i = 0; i < count; i++)
		{
			buffer[i].DoCycle();
		}
	}
}
