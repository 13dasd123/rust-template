using System.Collections.Generic;
using Facepunch;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;

public class GunTrap : StorageContainer
{
	public static class GunTrapFlags
	{
		public const Flags Triggered = Flags.Reserved1;
	}

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public GameObjectRef triggeredEffect;

	public Transform muzzlePos;

	public Transform eyeTransform;

	public int numPellets = 15;

	public int aimCone = 30;

	public float sensorRadius = 1.25f;

	public ItemDefinition ammoType;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("GunTrap.OnRpcMessage"))
		{
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool UseAmmo()
	{
		foreach (Item item in inventory.itemList)
		{
			if (item.info == ammoType && item.amount > 0)
			{
				item.UseItem();
				return true;
			}
		}
		return false;
	}

	public void FireWeapon()
	{
		if (UseAmmo())
		{
			Effect.server.Run(gun_fire_effect.resourcePath, this, StringPool.Get(muzzlePos.gameObject.name), Vector3.zero, Vector3.zero);
			for (int i = 0; i < numPellets; i++)
			{
				FireBullet();
			}
		}
	}

	public void FireBullet()
	{
		float damageAmount = 10f;
		Vector3 vector = muzzlePos.transform.position - muzzlePos.forward * 0.25f;
		Vector3 forward = muzzlePos.transform.forward;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, forward);
		Vector3 arg = vector + modifiedAimConeDirection * 300f;
		ClientRPC(null, "CLIENT_FireGun", arg);
		List<RaycastHit> list = Pool.GetList<RaycastHit>();
		GamePhysics.TraceAll(new Ray(vector, modifiedAimConeDirection), 0.1f, list, 300f, 1219701521);
		for (int i = 0; i < list.Count; i++)
		{
			RaycastHit hit = list[i];
			BaseEntity entity = RaycastHitEx.GetEntity(hit);
			if (entity != null && (entity == this || entity.EqualNetID(this)))
			{
				continue;
			}
			BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				HitInfo info = new HitInfo(this, entity, DamageType.Bullet, damageAmount, hit.point);
				entity.OnAttacked(info);
				if (entity is BasePlayer || entity is BaseNpc)
				{
					HitInfo hitInfo = new HitInfo();
					hitInfo.HitPositionWorld = hit.point;
					hitInfo.HitNormalWorld = -hit.normal;
					hitInfo.HitMaterial = StringPool.Get("Flesh");
					Effect.server.ImpactEffect(hitInfo);
				}
			}
			if (!(entity != null) || entity.ShouldBlockProjectiles())
			{
				arg = hit.point;
				break;
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		InvokeRandomized(TriggerCheck, UnityEngine.Random.Range(0f, 1f), 0.5f, 0.1f);
	}

	public void TriggerCheck()
	{
		if (CheckTrigger(3f, sensorRadius) || CheckTrigger(1.25f, sensorRadius * 0.4f))
		{
			FireWeapon();
		}
	}

	public bool CheckTrigger(float offset, float radius)
	{
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		List<BasePlayer> obj2 = Pool.GetList<BasePlayer>();
		Vis.Entities(GetEyePosition() + base.transform.forward * offset, radius, obj2, 131072);
		bool flag = false;
		foreach (BasePlayer item in obj2)
		{
			if (item.IsSleeping() || !item.IsAlive() || item.IsBuildingAuthed())
			{
				continue;
			}
			object obj3 = Interface.CallHook("CanBeTargeted", item, this);
			if (obj3 is bool)
			{
				Pool.FreeList(ref obj);
				Pool.FreeList(ref obj2);
				return (bool)obj3;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1218519297);
			for (int i = 0; i < obj.Count; i++)
			{
				RaycastHit hit = obj[i];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		return flag;
	}

	public bool IsTriggered()
	{
		return HasFlag(Flags.Reserved1);
	}

	public Vector3 GetEyePosition()
	{
		return eyeTransform.position;
	}
}
