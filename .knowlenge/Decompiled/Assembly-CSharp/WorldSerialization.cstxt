using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text.RegularExpressions;
using ConVar;
using LZ4;
using UnityEngine;

public class WorldSerialization
{
	[Serializable]
	private class WorldData
	{
		public List<MapData> maps = new List<MapData>();

		public List<PrefabData> prefabs = new List<PrefabData>();

		public List<PathData> paths = new List<PathData>();
	}

	[Serializable]
	private class MapData
	{
		public string name;

		public byte[] data;
	}

	[Serializable]
	private class PrefabData
	{
		public string category;

		public uint id;

		public VectorData position;

		public VectorData rotation;

		public VectorData scale;
	}

	[Serializable]
	private class PathData
	{
		public string name;

		public bool spline;

		public bool start;

		public bool end;

		public float width;

		public float innerPadding;

		public float outerPadding;

		public float innerFade;

		public float outerFade;

		public float randomScale;

		public float meshOffset;

		public float terrainOffset;

		public int splat;

		public int topology;

		public VectorData[] nodes;

		public void FromPathList(PathList src)
		{
			name = src.Name;
			spline = src.Spline;
			start = src.Start;
			end = src.End;
			width = src.Width;
			innerPadding = src.InnerPadding;
			outerPadding = src.OuterPadding;
			innerFade = src.InnerFade;
			outerFade = src.OuterFade;
			randomScale = src.RandomScale;
			meshOffset = src.MeshOffset;
			terrainOffset = src.TerrainOffset;
			splat = src.Splat;
			topology = src.Topology;
			nodes = Array.ConvertAll(src.Path.Points, (Converter<Vector3, VectorData>)((Vector3 item) => item));
		}

		public PathList ToPathList()
		{
			PathList pathList = new PathList(name, Array.ConvertAll(nodes, (Converter<VectorData, Vector3>)((VectorData item) => item)));
			pathList.Spline = spline;
			pathList.Start = start;
			pathList.End = end;
			pathList.Width = width;
			pathList.InnerPadding = innerPadding;
			pathList.OuterPadding = outerPadding;
			pathList.InnerFade = innerFade;
			pathList.OuterFade = outerFade;
			pathList.RandomScale = randomScale;
			pathList.MeshOffset = meshOffset;
			pathList.TerrainOffset = terrainOffset;
			pathList.Splat = splat;
			pathList.Topology = topology;
			pathList.Path.RecalculateTangents();
			return pathList;
		}
	}

	[Serializable]
	private class VectorData
	{
		public float x;

		public float y;

		public float z;

		public VectorData(float x, float y, float z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public static implicit operator VectorData(Vector3 v)
		{
			return new VectorData(v.x, v.y, v.z);
		}

		public static implicit operator VectorData(Quaternion q)
		{
			return q.eulerAngles;
		}

		public static implicit operator Vector3(VectorData v)
		{
			return new Vector3(v.x, v.y, v.z);
		}

		public static implicit operator Quaternion(VectorData v)
		{
			return Quaternion.Euler(v);
		}
	}

	private WorldData world = new WorldData();

	public static string SaveFolder => Server.rootFolder;

	public static string SaveFileName => SaveFolder + "/" + World.FileName + ".map";

	public static string SaveFileRegex => World.FileRegex + "\\.map";

	public uint Version { get; private set; }

	public bool Cached { get; private set; }

	public string Checksum { get; private set; }

	public WorldSerialization()
	{
		Version = 5u;
		Checksum = null;
		Cached = false;
	}

	public byte[] GetMap(string name)
	{
		for (int i = 0; i < world.maps.Count; i++)
		{
			if (world.maps[i].name == name)
			{
				return world.maps[i].data;
			}
		}
		return null;
	}

	public void AddMap(string name, byte[] data)
	{
		MapData mapData = new MapData();
		mapData.name = name;
		mapData.data = data;
		world.maps.Add(mapData);
	}

	public void AddPrefab(string category, uint id, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		PrefabData prefabData = new PrefabData();
		prefabData.category = category;
		prefabData.id = id;
		prefabData.position = position;
		prefabData.rotation = rotation;
		prefabData.scale = scale;
		world.prefabs.Add(prefabData);
		if (!Cached)
		{
			Spawn(category, id, position, rotation, scale);
		}
	}

	public IEnumerable<PathList> GetPaths(string name)
	{
		return from p in world.paths
			where p.name.Contains(name)
			select p.ToPathList();
	}

	public void AddPaths(IEnumerable<PathList> paths)
	{
		foreach (PathList path in paths)
		{
			AddPath(path);
		}
	}

	public void AddPath(PathList source)
	{
		PathData pathData = new PathData();
		pathData.FromPathList(source);
		world.paths.Add(pathData);
	}

	public IEnumerator Spawn(float deltaTime, Action<string> statusFunction = null)
	{
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < world.prefabs.Count; i++)
		{
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == world.prefabs.Count - 1)
			{
				Status(statusFunction, "Spawning World ({0}/{1})", i + 1, world.prefabs.Count);
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			Spawn(world.prefabs[i]);
		}
	}

	public void Spawn()
	{
		for (int i = 0; i < world.prefabs.Count; i++)
		{
			Spawn(world.prefabs[i]);
		}
	}

	private void Spawn(PrefabData prefab)
	{
		Spawn(prefab.category, prefab.id, prefab.position, prefab.rotation, prefab.scale);
	}

	private void Spawn(string category, uint id, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		GameObject gameObject = Prefab.DefaultManager.CreatePrefab(StringPool.Get(id), position, rotation, scale);
		if ((bool)gameObject)
		{
			GameObjectEx.SetHierarchyGroup(gameObject, category);
		}
	}

	public void Clear()
	{
		world.maps.Clear();
		world.prefabs.Clear();
		world.paths.Clear();
		Version = 5u;
		Checksum = null;
		Cached = false;
	}

	public void CleanupOldFiles()
	{
		Regex regex = new Regex(SaveFileRegex);
		IEnumerable<string> enumerable = from path in Directory.GetFiles(SaveFolder, "*.map")
			where !regex.IsMatch(path)
			select path;
		foreach (string item in enumerable)
		{
			try
			{
				File.Delete(item);
			}
			catch (Exception ex)
			{
				UnityEngine.Debug.LogError(ex.Message);
			}
		}
	}

	public bool CanLoadFromDisk()
	{
		return CanLoadFromDisk(SaveFileName);
	}

	public bool CanLoadFromDisk(string fileName)
	{
		return File.Exists(fileName);
	}

	public void Save()
	{
		Save(SaveFileName);
	}

	public void Save(string fileName)
	{
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		try
		{
			using (FileStream fileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write, FileShare.None))
			{
				using BinaryWriter binaryWriter = new BinaryWriter(fileStream);
				binaryWriter.Write(Version);
				using LZ4Stream serializationStream = new LZ4Stream(fileStream, LZ4StreamMode.Compress);
				binaryFormatter.Serialize(serializationStream, world);
			}
			Checksum = Hash();
			Cached = true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message);
		}
	}

	public void Load()
	{
		Load(SaveFileName);
	}

	public void Load(string fileName)
	{
		BinaryFormatter binaryFormatter = new BinaryFormatter();
		try
		{
			using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				using BinaryReader binaryReader = new BinaryReader(fileStream);
				Version = binaryReader.ReadUInt32();
				if (Version == 5)
				{
					using LZ4Stream serializationStream = new LZ4Stream(fileStream, LZ4StreamMode.Decompress);
					world = (WorldData)binaryFormatter.Deserialize(serializationStream);
				}
			}
			Checksum = Hash();
			Cached = true;
		}
		catch (Exception ex)
		{
			UnityEngine.Debug.LogError(ex.Message);
		}
	}

	public void CalculateChecksum()
	{
		Checksum = Hash();
	}

	private string Hash()
	{
		Checksum checksum = new Checksum();
		byte[] map = GetMap("terrain");
		if (map != null)
		{
			for (int i = 0; i < map.Length; i += 2)
			{
				checksum.Add(map[i]);
			}
		}
		List<PrefabData> prefabs = world.prefabs;
		if (prefabs != null)
		{
			for (int j = 0; j < prefabs.Count; j++)
			{
				PrefabData prefabData = prefabs[j];
				checksum.Add(prefabData.id);
				checksum.Add(prefabData.position.x, 3);
				checksum.Add(prefabData.position.y, 3);
				checksum.Add(prefabData.position.z, 3);
				checksum.Add(prefabData.scale.x, 3);
				checksum.Add(prefabData.scale.y, 3);
				checksum.Add(prefabData.scale.z, 3);
			}
		}
		return checksum.MD5();
	}

	private static void Status(Action<string> statusFunction, string status, object obj1)
	{
		statusFunction?.Invoke(string.Format(status, obj1));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2, object obj3)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2, obj3));
	}

	private static void Status(Action<string> statusFunction, string status, params object[] objs)
	{
		statusFunction?.Invoke(string.Format(status, objs));
	}
}
