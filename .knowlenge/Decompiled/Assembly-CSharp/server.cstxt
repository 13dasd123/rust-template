using Network;
using Rust;
using UnityEngine;

public static class server
{
	public static void Run(Type fxtype, BaseEntity ent, uint boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection = null, bool broadcast = false)
	{
		reusableInstace.Init(fxtype, ent, boneID, posLocal, normLocal, sourceConnection);
		reusableInstace.broadcast = broadcast;
		EffectNetwork.Send(reusableInstace);
	}

	public static void Run(string strName, BaseEntity ent, uint boneID, Vector3 posLocal, Vector3 normLocal, Connection sourceConnection = null, bool broadcast = false)
	{
		if (!string.IsNullOrEmpty(strName))
		{
			reusableInstace.Init(Type.Generic, ent, boneID, posLocal, normLocal, sourceConnection);
			reusableInstace.pooledString = strName;
			reusableInstace.broadcast = broadcast;
			EffectNetwork.Send(reusableInstace);
		}
	}

	public static void Run(Type fxtype, Vector3 posWorld, Vector3 normWorld, Connection sourceConnection = null, bool broadcast = false)
	{
		reusableInstace.Init(fxtype, posWorld, normWorld, sourceConnection);
		reusableInstace.broadcast = broadcast;
		EffectNetwork.Send(reusableInstace);
	}

	public static void Run(string strName, Vector3 posWorld = default(Vector3), Vector3 normWorld = default(Vector3), Connection sourceConnection = null, bool broadcast = false)
	{
		if (!string.IsNullOrEmpty(strName))
		{
			reusableInstace.Init(Type.Generic, posWorld, normWorld, sourceConnection);
			reusableInstace.pooledString = strName;
			reusableInstace.broadcast = broadcast;
			EffectNetwork.Send(reusableInstace);
		}
	}

	public static void DoAdditiveImpactEffect(HitInfo info, string effectName)
	{
		if (info.HitEntity.IsValid())
		{
			Run(effectName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
		}
		else
		{
			Run(effectName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
		}
	}

	public static void ImpactEffect(HitInfo info)
	{
		if (!info.DoHitEffects)
		{
			return;
		}
		string materialName = StringPool.Get(info.HitMaterial);
		if (TerrainMeta.WaterMap != null && info.HitMaterial != Projectile.WaterMaterialID() && info.HitMaterial != Projectile.FleshMaterialID() && info.HitPositionWorld.y < WaterLevel.GetWaterDepth(info.HitPositionWorld))
		{
			return;
		}
		string strName = EffectDictionary.GetParticle(info.damageTypes.GetMajorityDamageType(), materialName);
		string decal = EffectDictionary.GetDecal(info.damageTypes.GetMajorityDamageType(), materialName);
		if (info.HitEntity.IsValid())
		{
			GameObjectRef impactEffect = info.HitEntity.GetImpactEffect(info);
			if (impactEffect.isValid)
			{
				strName = impactEffect.resourcePath;
			}
			Run(strName, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
			Run(decal, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
		}
		else
		{
			Run(strName, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
			Run(decal, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
		}
		if ((bool)info.WeaponPrefab)
		{
			BaseMelee baseMelee = info.WeaponPrefab as BaseMelee;
			if (baseMelee != null)
			{
				string strikeEffectPath = baseMelee.GetStrikeEffectPath(materialName);
				if (info.HitEntity.IsValid())
				{
					Run(strikeEffectPath, info.HitEntity, info.HitBone, info.HitPositionLocal, info.HitNormalLocal, info.Predicted);
				}
				else
				{
					Run(strikeEffectPath, info.HitPositionWorld, info.HitNormalWorld, info.Predicted);
				}
			}
		}
		if (info.damageTypes.Has(DamageType.Explosion))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/explosion.prefab");
		}
		if (info.damageTypes.Has(DamageType.Heat))
		{
			DoAdditiveImpactEffect(info, "assets/bundled/prefabs/fx/impacts/additive/fire.prefab");
		}
	}
}
