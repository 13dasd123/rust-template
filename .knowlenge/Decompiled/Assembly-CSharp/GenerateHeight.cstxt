using UnityEngine;

public class GenerateHeight : ProceduralComponent
{
	private NoiseParameters Shape = new NoiseParameters(6, 0.5f, 0.5f, -0f);

	private NoiseParameters Base = new NoiseParameters(6, 1f, 5f, -0.4f);

	private NoiseParameters Lake = new NoiseParameters(6, 0.5f, 0.4f, -0.2f);

	private NoiseParameters Dune = new NoiseParameters(8, 1f, 0.03f, -0.02f);

	private NoiseParameters Plain = new NoiseParameters(8, 1f, 0.03f, -0.01f);

	private NoiseParameters Hill = new NoiseParameters(8, 1.2f, 0.05f, -0f);

	private NoiseParameters Mountain = new NoiseParameters(8, 1f, 0.07f, -0f);

	public override void Process(uint seed)
	{
		TerrainHeightMap map = TerrainMeta.HeightMap;
		int res = TerrainMeta.HeightMap.res;
		Vector3 size = TerrainMeta.Size;
		float centerFalloff = 200f / (0.5f * size.x);
		float centerPadding = 0.2f;
		float borderFalloff = 400f / (0.5f * size.x);
		float borderPadding = 0f;
		float num = SeedRandom.Range(ref seed, 0.0009f, 0.0011f);
		float shapeX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float shapeZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		int shapeO = Shape.Octaves;
		float shapeK = Shape.Offset;
		float shapeF = Shape.Frequency * num;
		float shapeA = Shape.Amplitude * borderFalloff;
		float baseX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float baseZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		int baseO = Base.Octaves;
		float baseK = Base.Offset;
		float baseF = Base.Frequency * num;
		float baseA = Base.Amplitude;
		float lakeX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float lakeZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		int lakeO = Lake.Octaves;
		float lakeK = Lake.Offset;
		float lakeF = Lake.Frequency * num;
		float lakeA = Lake.Amplitude;
		float duneX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float duneZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		int duneO = Dune.Octaves;
		float duneK = Dune.Offset;
		float duneF = Dune.Frequency * num;
		float duneA = Dune.Amplitude;
		float hillX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float hillZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		int hillO = Hill.Octaves;
		float hillK = Hill.Offset;
		float hillF = Hill.Frequency * num;
		float hillA = Hill.Amplitude;
		float mountX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float mountZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		int mountO = Mountain.Octaves;
		float mountK = Mountain.Offset;
		float mountF = Mountain.Frequency * num;
		float mountA = Mountain.Amplitude;
		float plainX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float plainZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		int plainO = Plain.Octaves;
		float plainK = Plain.Offset;
		float plainF = Plain.Frequency * num;
		float plainA = Plain.Amplitude;
		float distortX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float distortZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		int distortO = 4;
		float distortF = 0.01f;
		float distortA = 5f;
		float normfac = 1f / (float)(res - 1);
		float oceanLevel0 = TerrainMeta.NormalizeY(-0.1f);
		float oceanLevel1 = TerrainMeta.NormalizeY(0.1f);
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float num2 = (float)i * normfac;
				float num3 = (float)z * normfac;
				float num4 = num2 * size.x;
				float num5 = num3 * size.z;
				num4 += Noise.Turbulence(distortX + num4, distortZ + num5, distortO, distortF, distortA);
				num5 += Noise.Turbulence(distortX + num4, distortZ + num5, distortO, distortF, distortA);
				float num6 = num2 * 2f - 1f;
				float num7 = num3 * 2f - 1f;
				float a = (num6 * num6 + num7 * num7) * 0.75f;
				float b = Mathf.Max(Mathf.Abs(num6), Mathf.Abs(num7));
				float num8 = shapeK + Noise.Sharp(shapeX + num4, shapeZ + num5, shapeO, shapeF, shapeA);
				float value = Mathf.Max(a, b) + num8;
				float num9 = 0f;
				float num10 = 0f;
				float num11 = 0f;
				float num12 = 0f;
				float num13 = 0f;
				float b2 = 0f;
				float num14 = Mathf.InverseLerp(1f - borderPadding - borderFalloff, 1f - borderPadding, value);
				float num15 = Mathf.InverseLerp(1f - borderPadding - borderFalloff - centerPadding, 1f - borderPadding - borderFalloff - centerPadding - centerFalloff, value);
				num9 -= num14;
				num9 += num15 * 0.75f;
				num9 += (1f - num14) * (baseK + Noise.Jordan(baseX + num4, baseZ + num5, baseO, baseF, baseA));
				num9 += (1f - num14) * (lakeK + Noise.Ridge(lakeX + num4, lakeZ + num5, lakeO, lakeF, lakeA));
				num10 = Mathf.SmoothStep(0.5f, 0.45f, 0f - num9);
				if (num9 < 0f)
				{
					map.SetHeight(i, z, num10);
				}
				else
				{
					num11 = Mathf.InverseLerp(0f, 0.05f, num9);
					num11 = 0.002f * num11 * num11;
					if (num9 < 0.05f)
					{
						map.SetHeight(i, z, num10 + num11);
					}
					else
					{
						float num16 = Mathx.Above(num3, 0.7f);
						float num17 = Mathx.Below(num3, 0.3f);
						float num18 = 1f - num16 - num17;
						float num19 = Mathf.InverseLerp(0.05f, 0.2f, num9);
						float num20 = Mathf.InverseLerp(0.5f, 1.15f, num9);
						float num21 = Mathf.InverseLerp(0f, 2.75f, num9);
						if (num19 > 0f)
						{
							if (num17 > 0f)
							{
								float num22 = num17;
								float num23 = duneK + Noise.Ridge(duneX + num4, duneZ + num5, duneO, duneF, duneA);
								if (num23 > 0f)
								{
									num12 += num23 * num22;
								}
							}
							if (num16 + num18 > 0f)
							{
								float num24 = num16 + num18;
								float num25 = plainK + Noise.Billow(plainX + num4, plainZ + num5, plainO, plainF, plainA);
								if (num25 > 0f)
								{
									num12 += num25 * num24;
								}
							}
							if (num12 > 0f)
							{
								num12 = Mathf.SmoothStep(0f, num12, num19);
							}
						}
						if (num20 > 0f)
						{
							float num26 = hillK + Noise.TurbulenceWarp(hillX + num4, hillZ + num5, hillO, hillF, hillA);
							if (num26 > 0f)
							{
								num13 = Mathf.SmoothStep(0f, num26, num20);
							}
						}
						if (num21 > 0f)
						{
							float num27 = mountK + Noise.RidgeWarp(mountX + num4, mountZ + num5, mountO, mountF, mountA);
							if (num27 > 0f)
							{
								b2 = Mathf.SmoothStep(0f, num27, num21);
							}
						}
						float num28 = num10 + num11 + Mathx.SmoothMax(num12 + num13, b2);
						if (num28 > oceanLevel0 && num28 < oceanLevel1)
						{
							num28 = Mathf.SmoothStep(oceanLevel0, oceanLevel1, Mathf.InverseLerp(oceanLevel0, oceanLevel1, num28));
						}
						map.SetHeight(i, z, num28);
					}
				}
			}
		});
	}
}
