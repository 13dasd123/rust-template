using System.Collections.Generic;
using UnityEngine;

public class GenerateRiverLayout : ProceduralComponent
{
	public const float DefaultWidth = 40f;

	public const float DefaultOffset = -3f;

	public const float DefaultPadding = 5f;

	public const float DefaultFade = 20f;

	public float Width = 40f;

	public float Offset = -3f;

	public float Padding = 5f;

	public float Fade = 20f;

	public override void Process(uint seed)
	{
		List<PathList> list = new List<PathList>();
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		List<Vector3> list2 = new List<Vector3>();
		for (float num = TerrainMeta.Position.z; num < TerrainMeta.Position.z + TerrainMeta.Size.z; num += 50f)
		{
			for (float num2 = TerrainMeta.Position.x; num2 < TerrainMeta.Position.x + TerrainMeta.Size.x; num2 += 50f)
			{
				Vector3 vector = new Vector3(num2, 0f, num);
				float num3 = (vector.y = heightmap.GetHeight(vector));
				Vector3 normal = heightmap.GetNormal(vector);
				if (normal.y <= 0.01f)
				{
					continue;
				}
				Vector2 normalized = new Vector2(normal.x, normal.z).normalized;
				list2.Add(vector);
				int num4 = (int)(0.5f * Width);
				for (int i = 0; i < 10000; i++)
				{
					vector.x += normalized.x;
					vector.z += normalized.y;
					float slope = heightmap.GetSlope(vector);
					if (slope > 30f)
					{
						break;
					}
					float height = heightmap.GetHeight(vector);
					if (height > num3 + 10f)
					{
						break;
					}
					vector.y = Mathf.Min(height, num3);
					list2.Add(vector);
					int topology = topologyMap.GetTopology(vector);
					int num5 = 2163716;
					int num6 = 128;
					if ((topology & num5) != 0)
					{
						break;
					}
					if ((topology & num6) != 0 && --num4 <= 0)
					{
						if (list2.Count >= 300)
						{
							PathList item = new PathList("River " + list.Count, list2.ToArray(), Width, Offset, Padding, Fade, 16384, 64);
							list.Add(item);
						}
						break;
					}
					normal = heightmap.GetNormal(vector);
					normalized = new Vector2(normalized.x + 0.15f * normal.x, normalized.y + 0.15f * normal.z).normalized;
					num3 = vector.y;
				}
				list2.Clear();
			}
		}
		list.Sort((PathList a, PathList b) => b.Path.Points.Length.CompareTo(a.Path.Points.Length));
		int num7 = Mathf.RoundToInt(10f * TerrainMeta.Size.x * TerrainMeta.Size.z * 1E-06f);
		int num8 = Mathf.NextPowerOfTwo((int)((float)World.Size / Width));
		bool[,] array = new bool[num8, num8];
		for (int j = 0; j < list.Count; j++)
		{
			if (j >= num7)
			{
				list.RemoveUnordered(j--);
				continue;
			}
			PathList pathList = list[j];
			int num9 = -1;
			int num10 = -1;
			for (int k = 0; k < pathList.Path.Points.Length; k++)
			{
				Vector3 vector2 = pathList.Path.Points[k];
				int num11 = Mathf.Clamp((int)(TerrainMeta.NormalizeX(vector2.x) * (float)num8), 0, num8 - 1);
				int num12 = Mathf.Clamp((int)(TerrainMeta.NormalizeZ(vector2.z) * (float)num8), 0, num8 - 1);
				if (num9 != num11 || num10 != num12)
				{
					if (array[num12, num11])
					{
						list.RemoveUnordered(j--);
						break;
					}
					num9 = num11;
					num10 = num12;
					array[num12, num11] = true;
				}
			}
		}
		foreach (PathList item2 in list)
		{
			item2.Start = true;
			item2.End = true;
		}
		TerrainMeta.Path.Rivers.AddRange(list);
		list = TerrainMeta.Path.Rivers;
		foreach (PathList item3 in list)
		{
			item3.Scaling = 0.75f;
		}
		foreach (PathList item4 in list)
		{
			item4.Path.RecalculateTangents();
		}
		heightmap.Push();
		foreach (PathList item5 in list)
		{
			item5.AdjustTerrainHeight();
			item5.AdjustTerrainTexture();
			item5.AdjustTerrainTopology();
		}
		heightmap.Pop();
		int[,] map = topologyMap.dst;
		float fac = 1f / (float)(topologyMap.res - 1);
		ImageProcessing.Dilate2D(map, 49152, 6, delegate(int x, int y)
		{
			if ((map[x, y] & 0x31) != 0)
			{
				map[x, y] |= 32768;
			}
			float normX = (float)x * fac;
			float normZ = (float)y * fac;
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				map[x, y] |= 2;
			}
		});
	}
}
