using System.Collections.Generic;
using Rust;
using UnityEngine;

public class BaseHelicopterVehicle : BaseVehicle
{
	public struct HelicopterInputState_t
	{
		public float throttle;

		public float roll;

		public float yaw;

		public float pitch;
	}

	[Header("Helicopter")]
	public Rigidbody rigidBody;

	public float engineThrustMax;

	public Vector3 torqueScale;

	public Transform com;

	[Header("Effects")]
	public Transform[] GroundPoints;

	public Transform[] GroundEffects;

	public GameObjectRef explosionEffect;

	public GameObjectRef fireBall;

	public const Flags Flag_InternalLights = Flags.Reserved6;

	private HelicopterInputState_t currentInputState = default(HelicopterInputState_t);

	private float lastPlayerInputTime;

	public float currentThrottle;

	public float avgThrust;

	public float liftDotMax = 0.75f;

	public float altForceDotMin = 0.85f;

	public float liftFraction = 0.25f;

	protected float hoverForceScale = 0.99f;

	public override Vector3 GetLocalVelocityServer()
	{
		return rigidBody.velocity;
	}

	public override Quaternion GetAngularVelocityServer()
	{
		return Quaternion.LookRotation(rigidBody.angularVelocity, base.transform.up);
	}

	public override float MaxVelocity()
	{
		return 50f;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		rigidBody.centerOfMass = com.localPosition;
	}

	public float MouseToBinary(float amount)
	{
		return Mathf.Clamp(amount, -1f, 1f);
	}

	public virtual void PilotInput(InputState inputState, BasePlayer player)
	{
		HelicopterInputState_t helicopterInputState_t = default(HelicopterInputState_t);
		helicopterInputState_t.throttle = ((!inputState.IsDown(BUTTON.FORWARD)) ? 0f : 1f);
		helicopterInputState_t.throttle -= ((!inputState.IsDown(BUTTON.BACKWARD)) ? 0f : 1f);
		helicopterInputState_t.pitch = inputState.current.mouseDelta.y;
		helicopterInputState_t.roll = 0f - inputState.current.mouseDelta.x;
		helicopterInputState_t.yaw = ((!inputState.IsDown(BUTTON.RIGHT)) ? 0f : 1f);
		helicopterInputState_t.yaw -= ((!inputState.IsDown(BUTTON.LEFT)) ? 0f : 1f);
		helicopterInputState_t.pitch = MouseToBinary(helicopterInputState_t.pitch);
		helicopterInputState_t.roll = MouseToBinary(helicopterInputState_t.roll);
		currentInputState = helicopterInputState_t;
		lastPlayerInputTime = Time.time;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (GetPlayerSeat(player) == 0)
		{
			PilotInput(inputState, player);
		}
	}

	public virtual HelicopterInputState_t GetDefaultInputState()
	{
		HelicopterInputState_t result = default(HelicopterInputState_t);
		if (IsMounted())
		{
			float num = Vector3.Dot(Vector3.up, base.transform.right);
			float num2 = Vector3.Dot(Vector3.up, base.transform.forward);
			result.roll = ((!(num < 0f)) ? 0f : 1f);
			result.roll -= ((!(num > 0f)) ? 0f : 1f);
			if (num2 < -0f)
			{
				result.pitch = -1f;
			}
			else if (num2 > 0f)
			{
				result.pitch = 1f;
			}
		}
		else
		{
			result.throttle = -1f;
		}
		return result;
	}

	public override void VehicleFixedUpdate()
	{
		base.VehicleFixedUpdate();
		if (!base.isClient)
		{
			if (Time.time > lastPlayerInputTime + 0.5f)
			{
				currentInputState = GetDefaultInputState();
			}
			MovementUpdate();
			SetFlag(Flags.Reserved6, TOD_Sky.Instance.IsNight);
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (GetPlayerSeat(player) == 0)
		{
			SetFlag(Flags.Reserved5, !HasFlag(Flags.Reserved5));
		}
	}

	public void MovementUpdate()
	{
		HelicopterInputState_t helicopterInputState_t = currentInputState;
		currentThrottle = Mathf.Lerp(currentThrottle, helicopterInputState_t.throttle, 2f * Time.fixedDeltaTime);
		currentThrottle = Mathf.Clamp(currentThrottle, -0.8f, 1f);
		rigidBody.AddRelativeTorque(new Vector3(helicopterInputState_t.pitch * torqueScale.x, helicopterInputState_t.yaw * torqueScale.y, helicopterInputState_t.roll * torqueScale.z), ForceMode.Force);
		avgThrust = Mathf.Lerp(avgThrust, engineThrustMax * currentThrottle, Time.fixedDeltaTime);
		float value = Mathf.Clamp01(Vector3.Dot(base.transform.up, Vector3.up));
		float num = Mathf.InverseLerp(liftDotMax, 1f, value);
		float num2 = 1f - Mathf.InverseLerp(altForceDotMin, 1f, value);
		Vector3 force = Vector3.up * engineThrustMax * liftFraction * currentThrottle * num;
		Vector3 force2 = (base.transform.up - Vector3.up).normalized * engineThrustMax * currentThrottle * num2;
		float num3 = rigidBody.mass * (0f - Physics.gravity.y);
		rigidBody.AddForce(base.transform.up * num3 * num * hoverForceScale, ForceMode.Force);
		rigidBody.AddForce(force, ForceMode.Force);
		rigidBody.AddForce(force2, ForceMode.Force);
	}

	public void DelayedImpactDamage()
	{
		Hurt(100000f, DamageType.Explosion, this, useProtection: false);
	}

	public virtual bool CollisionDamageEnabled()
	{
		return true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		if (!base.isClient && CollisionDamageEnabled())
		{
			float magnitude = collision.relativeVelocity.magnitude;
			if ((!collision.gameObject || (collision.gameObject.layer & 0x48A12101) <= 0) && magnitude > 20f && !IsInvoking(DelayedImpactDamage))
			{
				Invoke(DelayedImpactDamage, 0.015f);
			}
		}
	}

	public override void OnKilled(HitInfo info)
	{
		if (base.isClient)
		{
			base.OnKilled(info);
			return;
		}
		Effect.server.Run(explosionEffect.resourcePath, base.transform.position, Vector3.up, null, broadcast: true);
		Vector3 vector = rigidBody.velocity * 0.25f;
		GameObject gibSource = serverGibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(serverGibs.resourcePath, base.gameObject, gibSource, vector, 3f);
		for (int i = 0; i < 12; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireBall.resourcePath, base.transform.position, base.transform.rotation);
			if (!baseEntity)
			{
				continue;
			}
			float min = 3f;
			float max = 10f;
			Vector3 onUnitSphere = Random.onUnitSphere;
			baseEntity.transform.position = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * Random.Range(-4f, 4f);
			Collider component = baseEntity.GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(vector + onUnitSphere * Random.Range(min, max));
			foreach (ServerGib item in list)
			{
				Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);
			}
		}
		base.OnKilled(info);
	}
}
