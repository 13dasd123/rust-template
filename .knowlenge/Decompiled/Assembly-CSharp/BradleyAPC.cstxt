using System;
using System.Collections;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class BradleyAPC : BaseCombatEntity, TriggerHurtNotChild.IHurtTriggerUser, IPathListener
{
	[Serializable]
	public class ScientistSpawnGroup
	{
		public float BradleyHealth;

		public List<GameObjectRef> SpawnPrefabs;

		public bool Spawned;
	}

	[Serializable]
	public class TargetInfo : IPooled
	{
		public float damageReceivedFrom;

		public BaseEntity entity;

		public float lastSeenTime;

		public Vector3 lastSeenPosition;

		public void EnterPool()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			entity = null;
			lastSeenPosition = Vector3.zero;
			lastSeenTime = 0f;
		}

		public void Setup(BaseEntity ent, float time)
		{
			entity = ent;
			lastSeenTime = time;
		}

		public void LeavePool()
		{
		}

		public float GetPriorityScore(BradleyAPC apc)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			BasePlayer basePlayer = entity as BasePlayer;
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				float num = Vector3.Distance(((Component)entity).transform.position, ((Component)apc).transform.position);
				float num2 = (1f - Mathf.InverseLerp(10f, 80f, num)) * 50f;
				float num3 = (((Object)(object)basePlayer.GetHeldEntity() == (Object)null) ? 0f : basePlayer.GetHeldEntity().hostileScore);
				float num4 = Mathf.InverseLerp(4f, 20f, num3) * 100f;
				float num5 = Mathf.InverseLerp(10f, 3f, Time.time - lastSeenTime) * 100f;
				float num6 = Mathf.InverseLerp(0f, 100f, damageReceivedFrom) * 50f;
				return num2 + num4 + num6 + num5;
			}
			return 0f;
		}

		public bool IsVisible()
		{
			if (lastSeenTime != -1f)
			{
				return Time.time - lastSeenTime < sightUpdateRate * 2f;
			}
			return false;
		}

		public bool IsValid()
		{
			return (Object)(object)entity != (Object)null;
		}
	}

	[Header("Sound")]
	public BlendedLoopEngineSound engineSound;

	public SoundDefinition treadLoopDef;

	public AnimationCurve treadGainCurve;

	public AnimationCurve treadPitchCurve;

	public AnimationCurve treadFreqCurve;

	private Sound treadLoop;

	private SoundModulation.Modulator treadGain;

	private SoundModulation.Modulator treadPitch;

	public SoundDefinition chasisLurchSoundDef;

	public float chasisLurchAngleDelta = 2f;

	public float chasisLurchSpeedDelta = 2f;

	public float lastAngle;

	public float lastSpeed;

	public SoundDefinition turretTurnLoopDef;

	public float turretLoopGainSpeed = 3f;

	public float turretLoopPitchSpeed = 3f;

	public float turretLoopMinAngleDelta;

	public float turretLoopMaxAngleDelta = 10f;

	public float turretLoopPitchMin = 0.5f;

	public float turretLoopPitchMax = 1f;

	public float turretLoopGainThreshold = 0.0001f;

	private Sound turretTurnLoop;

	private SoundModulation.Modulator turretTurnLoopGain;

	private SoundModulation.Modulator turretTurnLoopPitch;

	public float enginePitch = 0.9f;

	public float rpmMultiplier = 0.6f;

	private TreadAnimator treadAnimator;

	[Header("Wheels")]
	public WheelCollider[] leftWheels;

	public WheelCollider[] rightWheels;

	[Header("Movement Config")]
	public float moveForceMax = 2000f;

	public float brakeForce = 100f;

	public float turnForce = 2000f;

	public float sideStiffnessMax = 1f;

	public float sideStiffnessMin = 0.5f;

	public Transform centerOfMass;

	public float stoppingDist = 5f;

	[Header("Control")]
	public float throttle = 1f;

	public float turning;

	public float rightThrottle;

	public float leftThrottle;

	public bool brake;

	[Header("Other")]
	public Rigidbody myRigidBody;

	public Collider myCollider;

	public Vector3 destination;

	public Vector3 finalDestination;

	public Transform followTest;

	public TriggerHurtEx impactDamager;

	[Header("Weapons")]
	public Transform mainTurretEyePos;

	public Transform mainTurret;

	public Transform CannonPitch;

	public Transform CannonMuzzle;

	public Transform coaxPitch;

	public Transform coaxMuzzle;

	public Transform topTurretEyePos;

	public Transform topTurretYaw;

	public Transform topTurretPitch;

	public Transform topTurretMuzzle;

	public GameObjectRef SmokeGrenadePrefab;

	public Vector3 turretAimVector = Vector3.forward;

	public Vector3 desiredAimVector = Vector3.forward;

	public Vector3 topTurretAimVector = Vector3.forward;

	public Vector3 desiredTopTurretAimVector = Vector3.forward;

	[Header("Effects")]
	public GameObjectRef explosionEffect;

	public GameObjectRef servergibs;

	public GameObjectRef fireBall;

	public GameObjectRef crateToDrop;

	public GameObjectRef debrisFieldMarker;

	[Header("Loot")]
	public int maxCratesToSpawn;

	[Header("Spline")]
	public float splineMovementSpeed = 2f;

	public Vector3 splineOffset;

	[Header("Other")]
	public int patrolPathIndex;

	public IAIPath patrolPath;

	public bool DoAI = true;

	public GameObjectRef mainCannonMuzzleFlash;

	public GameObjectRef mainCannonProjectile;

	public float recoilScale = 200f;

	public NavMeshPath navMeshPath;

	public int navMeshPathIndex;

	private SimpleSplineTranslator splineTranslator;

	private LayerMask obstacleHitMask;

	private TimeSince timeSinceSeemingStuck;

	private TimeSince timeSinceStuckReverseStart;

	public const string PREFAB_PATH = "assets/prefabs/npc/m2bradley/bradleyapc.prefab";

	public float nextFireTime = 10f;

	public int numBursted;

	public float nextPatrolTime;

	public float nextEngagementPathTime;

	public float currentSpeedZoneLimit;

	[Header("Pathing")]
	public List<Vector3> currentPath;

	public int currentPathIndex;

	public bool pathLooping;

	private bool followingSpine;

	private int splineId = -1;

	private WorldSpline spline;

	private int entryDirection = 1;

	private TimeSince lastJoinedSpline;

	private float lastDist;

	[Header("Scientists")]
	public GameObject AIRoot;

	public GameObjectRef MonumentScientistPrefab;

	public GameObjectRef RoadScientistPrefab;

	public int ScientistSpawnCount = 4;

	public float ScientistSpawnRadius = 3f;

	public List<GameObject> ScientistSpawnPoints = new List<GameObject>();

	public List<ScientistSpawnGroup> ScientistSpawns = new List<ScientistSpawnGroup>();

	public bool SetScientistChaseBasedOnWeapon = true;

	[ServerVar]
	public static float DeployHealthRangeMin = 0.4f;

	[ServerVar]
	public static float DeployHealthRangeMax = 0.5f;

	[ServerVar]
	public static float DeployAttackDistanceMax = 50f;

	[ServerVar]
	public static float DeployInterval = 1f;

	[ServerVar]
	public static float DeployOnDamageCheckInterval = 1f;

	[ServerVar]
	public static float ScientistRedeploymentMinInterval = 60f;

	[ServerVar]
	public static float MountAfterNotAttackedDuration = 180f;

	[ServerVar]
	public static float MountAfterNotTargetsDuration = 60f;

	[ServerVar]
	public static float MountAfterNotFiredDuration = 60f;

	[ServerVar]
	public static bool UseSmokeGrenades = true;

	[ServerVar]
	public static bool KillScientistsOnBradleyDeath = false;

	[HideInInspector]
	public bool RoadSpawned = true;

	private List<ScientistNPC> activeScientists = new List<ScientistNPC>();

	private List<GameObjectRef> mountedScientistPrefabs = new List<GameObjectRef>();

	private List<Vector3> scientistSpawnPositions = new List<Vector3>();

	private int numberOfScientistsToSpawn;

	private TimeSince timeSinceScientistDeploy;

	private TimeSince timeSinceDeployCheck;

	private TimeSince timeSinceValidTarget;

	private TimeSince deployedTimeSinceBradleyAttackedTarget;

	private static int walkableAreaMask;

	private bool mountingScientists;

	private bool inDeployedState;

	private bool deployingScientists;

	private Dictionary<uint, GameObjectRef> scientistPrefabLookUp = new Dictionary<uint, GameObjectRef>();

	[Header("Targeting")]
	public float viewDistance = 100f;

	public float searchRange = 100f;

	public float searchFrequency = 2f;

	public float memoryDuration = 20f;

	public static float sightUpdateRate = 0.5f;

	public List<TargetInfo> targetList = new List<TargetInfo>();

	public BaseCombatEntity mainGunTarget;

	[Header("Coax")]
	public float coaxFireRate = 0.06667f;

	public int coaxBurstLength = 10;

	public float coaxAimCone = 3f;

	public float bulletDamage = 15f;

	[Header("TopTurret")]
	public float topTurretFireRate = 0.25f;

	public float nextCoaxTime;

	public int numCoaxBursted;

	public float nextTopTurretTime = 0.3f;

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public float lastLateUpdate;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.1f;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BradleyAPC.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.bradley != null && !info.fromDisk)
		{
			throttle = info.msg.bradley.engineThrottle;
			rightThrottle = info.msg.bradley.throttleRight;
			leftThrottle = info.msg.bradley.throttleLeft;
			desiredAimVector = info.msg.bradley.mainGunVec;
			desiredTopTurretAimVector = info.msg.bradley.topTurretVec;
		}
	}

	public void BuildingCheck()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(WorldSpaceBounds(), list, 256, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!(item is Barricade barricade))
			{
				if (item is ConstructableEntity { isServer: not false } constructableEntity && constructableEntity.IsAlive())
				{
					constructableEntity.Kill(DestroyMode.Gib);
				}
			}
			else if (barricade.IsAlive() && barricade.isServer)
			{
				barricade.Kill(DestroyMode.Gib);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public override void Save(SaveInfo info)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.bradley = Pool.Get<BradleyAPC>();
			info.msg.bradley.engineThrottle = throttle;
			info.msg.bradley.throttleLeft = leftThrottle;
			info.msg.bradley.throttleRight = rightThrottle;
			info.msg.bradley.mainGunVec = turretAimVector;
			info.msg.bradley.topTurretVec = topTurretAimVector;
		}
	}

	public static BradleyAPC SpawnRoadDrivingBradley(Vector3 spawnPos, Quaternion spawnRot)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		RuntimePath runtimePath = new RuntimePath();
		PathList pathList = null;
		float num = float.PositiveInfinity;
		foreach (PathList road in TerrainMeta.Path.Roads)
		{
			_ = Vector3.zero;
			float num2 = float.PositiveInfinity;
			Vector3[] points = road.Path.Points;
			foreach (Vector3 val in points)
			{
				float num3 = Vector3.Distance(val, spawnPos);
				if (num3 < num2)
				{
					num2 = num3;
				}
			}
			if (num2 < num)
			{
				pathList = road;
				num = num2;
			}
		}
		if (pathList == null)
		{
			return null;
		}
		Vector3 startPoint = pathList.Path.GetStartPoint();
		Vector3 endPoint = pathList.Path.GetEndPoint();
		bool flag = startPoint == endPoint;
		int num4 = (flag ? (pathList.Path.Points.Length - 1) : pathList.Path.Points.Length);
		IAIPathNode[] nodes = new RuntimePathNode[num4];
		runtimePath.Nodes = nodes;
		IAIPathNode iAIPathNode = null;
		int num5 = 0;
		int num6 = (flag ? (pathList.Path.MaxIndex - 1) : pathList.Path.MaxIndex);
		for (int j = pathList.Path.MinIndex; j <= num6; j++)
		{
			IAIPathNode iAIPathNode2 = new RuntimePathNode(pathList.Path.Points[j] + Vector3.up * 1f);
			if (iAIPathNode != null)
			{
				iAIPathNode2.AddLink(iAIPathNode);
				iAIPathNode.AddLink(iAIPathNode2);
			}
			runtimePath.Nodes[num5] = iAIPathNode2;
			iAIPathNode = iAIPathNode2;
			num5++;
		}
		if (flag)
		{
			runtimePath.Nodes[0].AddLink(runtimePath.Nodes[runtimePath.Nodes.Length - 1]);
			runtimePath.Nodes[runtimePath.Nodes.Length - 1].AddLink(runtimePath.Nodes[0]);
		}
		else
		{
			RuntimeInterestNode interestNode = new RuntimeInterestNode(startPoint + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode);
			RuntimeInterestNode interestNode2 = new RuntimeInterestNode(endPoint + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode2);
		}
		int num7 = Mathf.CeilToInt(pathList.Path.Length / 500f);
		num7 = Mathf.Clamp(num7, 1, 3);
		if (flag)
		{
			num7++;
		}
		for (int k = 0; k < num7; k++)
		{
			int num8 = Random.Range(0, pathList.Path.Points.Length);
			RuntimeInterestNode interestNode3 = new RuntimeInterestNode(pathList.Path.Points[num8] + Vector3.up * 1f);
			runtimePath.AddInterestNode(interestNode3);
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/m2bradley/bradleyapc.prefab", spawnPos, spawnRot);
		BradleyAPC bradleyAPC = null;
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			bradleyAPC = ((Component)baseEntity).GetComponent<BradleyAPC>();
			if (Object.op_Implicit((Object)(object)bradleyAPC))
			{
				bradleyAPC.RoadSpawned = true;
				bradleyAPC.Spawn();
				bradleyAPC.InstallPatrolPath(runtimePath);
			}
			else
			{
				baseEntity.Kill();
			}
		}
		return bradleyAPC;
	}

	[ServerVar(Name = "spawnroadbradley")]
	public static string svspawnroadbradley(Vector3 pos, Vector3 dir)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)SpawnRoadDrivingBradley(pos, Quaternion.LookRotation(dir, Vector3.up)) != (Object)null))
		{
			return "Failed to spawn road-driving Bradley.";
		}
		return "Spawned road-driving Bradley.";
	}

	public void SetDestination(Vector3 dest)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		destination = dest;
	}

	public override void ServerInit()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		CacheSpawnPrefabIDS();
		walkableAreaMask = 1 << NavMesh.GetAreaFromName("Walkable");
		deployedTimeSinceBradleyAttackedTarget = TimeSince.op_Implicit(0f);
		timeSinceScientistDeploy = TimeSince.op_Implicit(float.PositiveInfinity);
		timeSinceDeployCheck = TimeSince.op_Implicit(float.PositiveInfinity);
		numberOfScientistsToSpawn = ScientistSpawnCount;
		Initialize();
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateTargetList, 0f, 2f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateTargetVisibilities, 0f, sightUpdateRate);
		((FacepunchBehaviour)this).InvokeRepeating((Action)BuildingCheck, 1f, 5f);
		AIRoot.SetActive(false);
		obstacleHitMask = LayerMask.op_Implicit(LayerMask.GetMask(new string[1] { "Vehicle World" }));
		timeSinceSeemingStuck = TimeSince.op_Implicit(0f);
		timeSinceStuckReverseStart = TimeSince.op_Implicit(float.MaxValue);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
	}

	public void Initialize()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnBradleyApcInitialize", (object)this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = ((Component)this).transform.position;
			finalDestination = ((Component)this).transform.position;
		}
	}

	public BasePlayer FollowPlayer()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (current.IsAdmin && current.IsAlive() && !current.IsSleeping() && current.GetActiveItem() != null && current.GetActiveItem().info.shortname == "tool.binoculars")
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public static Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3(aimAt.x, 0f, aimAt.z) - new Vector3(aimFrom.x, 0f, aimFrom.z);
		return ((Vector3)(ref val)).normalized;
	}

	public bool IsAtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) <= stoppingDist;
	}

	public bool IsAtFinalDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, finalDestination) <= stoppingDist;
	}

	public Vector3 ClosestPointAlongPath(Vector3 start, Vector3 end, Vector3 fromPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = end - start;
		Vector3 val2 = fromPos - start;
		float num = Vector3.Dot(val, val2);
		float num2 = Vector3.SqrMagnitude(end - start);
		float num3 = Mathf.Clamp01(num / num2);
		return start + val * num3;
	}

	public void FireGunTest()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		if (Time.time < nextFireTime)
		{
			return;
		}
		deployedTimeSinceBradleyAttackedTarget = TimeSince.op_Implicit(0f);
		nextFireTime = Time.time + 0.25f;
		numBursted++;
		if (numBursted >= 4)
		{
			nextFireTime = Time.time + 5f;
			numBursted = 0;
		}
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(2f, CannonMuzzle.rotation * Vector3.forward);
		Vector3 val = ((Component)CannonPitch).transform.rotation * Vector3.back + ((Component)this).transform.up * -1f;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		myRigidBody.AddForceAtPosition(normalized * recoilScale, ((Component)CannonPitch).transform.position, (ForceMode)1);
		Effect.server.Run(mainCannonMuzzleFlash.resourcePath, this, StringPool.Get(((Object)((Component)CannonMuzzle).gameObject).name), Vector3.zero, Vector3.zero);
		BaseEntity baseEntity = GameManager.server.CreateEntity(mainCannonProjectile.resourcePath, ((Component)CannonMuzzle).transform.position, Quaternion.LookRotation(modifiedAimConeDirection));
		if (!((Object)(object)baseEntity == (Object)null))
		{
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.InitializeVelocity(modifiedAimConeDirection * component.speed);
			}
			TimedExplosive timedExplosive = default(TimedExplosive);
			if (((Component)baseEntity).TryGetComponent<TimedExplosive>(ref timedExplosive))
			{
				timedExplosive.creatorEntity = this;
			}
			baseEntity.Spawn();
		}
	}

	public void InstallPatrolPath(IAIPath path)
	{
		patrolPath = path;
		currentPath = new List<Vector3>();
		currentPathIndex = -1;
	}

	public void UpdateMovement_Patrol()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		if (patrolPath == null || Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", (object)this) != null)
		{
			return;
		}
		IAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(((Component)this).transform.position);
		IAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);
		bool flag = false;
		List<IAIPathNode> nodes = Pool.Get<List<IAIPathNode>>();
		IAIPathNode iAIPathNode;
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			iAIPathNode = nodes[nodes.Count - 1];
		}
		else
		{
			iAIPathNode = patrolPath.GetClosestToPoint(((Component)this).transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.Position) > 2f))
		{
			return;
		}
		if (closestToPoint == iAIPathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.Position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
		else
		{
			if (!AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].Position);
				}
			}
			foreach (IAIPathNode item in path)
			{
				currentPath.Add(item.Position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
	}

	private void EnterSpline()
	{
		myRigidBody.isKinematic = true;
	}

	private void LeaveSpline()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		lastJoinedSpline = TimeSince.op_Implicit(0f);
		myRigidBody.isKinematic = false;
	}

	public void DoSplineMove()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		splineTranslator.SetOffset(splineOffset);
		Vector3 tangent;
		if (targetList.Count > 0)
		{
			TargetInfo targetInfo = targetList[0];
			if (targetInfo.IsValid() && targetInfo.IsVisible())
			{
				tangent = targetInfo.lastSeenPosition - ((Component)this).transform.position;
				Vector3 normalized = ((Vector3)(ref tangent)).normalized;
				float num = Vector3.Dot(((Component)this).transform.forward, normalized);
				if (num > 0f)
				{
					splineTranslator.SetDirection(entryDirection);
				}
				else if (num < 0f)
				{
					splineTranslator.SetDirection(-entryDirection);
				}
			}
		}
		splineTranslator.Update(Time.deltaTime);
		splineTranslator.GetCurrentPositionAndTangent(out var position, out tangent);
		((Component)this).transform.position = Vector3.Lerp(((Component)this).transform.position, position, Time.deltaTime * splineMovementSpeed * 10f);
		tangent = splineTranslator.PeekNextPosition(0.1f, entryDirection) - position;
		Vector3 normalized2 = ((Vector3)(ref tangent)).normalized;
		((Component)this).transform.forward = normalized2;
		if (Math.Abs(splineTranslator.CurrentDistance - splineTranslator.GetEnd()) < 1f)
		{
			followingSpine = false;
			LeaveSpline();
		}
	}

	public void UpdateMovement_Hunt()
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnBradleyApcHunt", (object)this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			IAIPathNode start = patrolPath.GetClosestToPoint(((Component)this).transform.position);
			List<IAIPathNode> nodes = Pool.Get<List<IAIPathNode>>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			IAIPathNode iAIPathNode = null;
			List<IAIPathNode> nearNodes = Pool.Get<List<IAIPathNode>>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<IAIPathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (IAIPathNode item2 in nearNodes)
			{
				Stack<IAIPathNode> path = new Stack<IAIPathNode>();
				if (targetInfo.entity.IsVisible(item2.Position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					iAIPathNode = item2;
				}
			}
			if (stack == null && nearNodes.Count > 0)
			{
				Stack<IAIPathNode> path2 = new Stack<IAIPathNode>();
				IAIPathNode iAIPathNode2 = nearNodes[Random.Range(0, nearNodes.Count)];
				if (AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) && pathCost2 < num)
				{
					stack = path2;
					iAIPathNode = iAIPathNode2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].Position);
					}
				}
				foreach (IAIPathNode item3 in stack)
				{
					currentPath.Add(item3.Position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = iAIPathNode.Position;
			}
			Pool.FreeUnmanaged<IAIPathNode>(ref nearNodes);
			Pool.FreeUnmanaged<IAIPathNode>(ref nodes);
			nextEngagementPathTime = Time.time + 5f;
		}
	}

	public void DoSimpleAI()
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
		if (Interface.CallHook("OnBradleyApcThink", (object)this) != null || !DoAI)
		{
			return;
		}
		SetTarget();
		if (mountingScientists || inDeployedState)
		{
			ClearPath();
		}
		else if (!IsOnSpline())
		{
			if (targetList.Count > 0)
			{
				UpdateMovement_Hunt();
			}
			else
			{
				UpdateMovement_Patrol();
			}
		}
		if (!IsOnSpline())
		{
			AdvancePathMovement(force: false);
			float num = Vector3.Distance(((Component)this).transform.position, destination);
			float num2 = Vector3.Distance(((Component)this).transform.position, finalDestination);
			if (num > stoppingDist)
			{
				Vector3 val = Direction2D(destination, ((Component)this).transform.position);
				float num3 = Vector3.Dot(val, ((Component)this).transform.right);
				float num4 = Vector3.Dot(val, ((Component)this).transform.right);
				float num5 = Vector3.Dot(val, -((Component)this).transform.right);
				if (Vector3.Dot(val, -((Component)this).transform.forward) > num3)
				{
					if (num4 >= num5)
					{
						turning = 1f;
					}
					else
					{
						turning = -1f;
					}
				}
				else
				{
					turning = Mathf.Clamp(num3 * 3f, -1f, 1f);
				}
				float throttleScaleFromTurn = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));
				AvoidObstacles(ref throttleScaleFromTurn);
				float num6 = Vector3.Dot(myRigidBody.velocity, ((Component)this).transform.forward);
				if (!(throttle > 0f) || !(num6 < 0.5f))
				{
					timeSinceSeemingStuck = TimeSince.op_Implicit(0f);
				}
				else if (TimeSince.op_Implicit(timeSinceSeemingStuck) > 10f)
				{
					timeSinceStuckReverseStart = TimeSince.op_Implicit(0f);
					timeSinceSeemingStuck = TimeSince.op_Implicit(0f);
				}
				float num7 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(((Component)this).transform.forward, Vector3.up));
				if (TimeSince.op_Implicit(timeSinceStuckReverseStart) < 3f)
				{
					throttle = -0.75f;
					turning = 1f;
				}
				else
				{
					throttle = (0.1f + Mathf.InverseLerp(0f, 20f, num2) * 1f) * throttleScaleFromTurn + num7;
				}
			}
		}
		DoWeaponAiming();
		SendNetworkUpdate();
	}

	private void SetTarget()
	{
		if (targetList.Count == 0)
		{
			mainGunTarget = null;
		}
		else if (targetList[0].IsValid() && targetList[0].IsVisible())
		{
			mainGunTarget = targetList[0].entity as BaseCombatEntity;
		}
		else
		{
			mainGunTarget = null;
		}
	}

	public void FixedUpdate()
	{
		if (mountingScientists)
		{
			UpdateMountScientists();
		}
		else if (inDeployedState)
		{
			UpdateDeployed();
		}
		DoSimpleAI();
		if (IsOnSpline())
		{
			DoSplineMove();
		}
		else
		{
			DoPhysicsMove();
		}
		DoWeapons();
		DoHealing();
	}

	private void AvoidObstacles(ref float throttleScaleFromTurn)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		Ray ray = default(Ray);
		((Ray)(ref ray))..ctor(((Component)this).transform.position + ((Component)this).transform.forward * (((Bounds)(ref bounds)).extents.z - 1f), ((Component)this).transform.forward);
		if (!GamePhysics.Trace(ray, 3f, out var hitInfo, 20f, LayerMask.op_Implicit(obstacleHitMask), (QueryTriggerInteraction)1, this))
		{
			return;
		}
		if (((RaycastHit)(ref hitInfo)).point == Vector3.zero)
		{
			((RaycastHit)(ref hitInfo)).point = ((RaycastHit)(ref hitInfo)).collider.ClosestPointOnBounds(((Ray)(ref ray)).origin);
		}
		float num = TransformEx.AngleToPos(((Component)this).transform, ((RaycastHit)(ref hitInfo)).point);
		float num2 = Mathf.Abs(num);
		if (num2 > 75f || !(((RaycastHit)(ref hitInfo)).collider.ToBaseEntity() is BradleyAPC))
		{
			return;
		}
		bool flag = false;
		if (num2 < 5f)
		{
			float num3 = ((throttle < 0f) ? 150f : 50f);
			if (Vector3.SqrMagnitude(((Component)this).transform.position - ((RaycastHit)(ref hitInfo)).point) < num3)
			{
				flag = true;
			}
		}
		if (num > 30f)
		{
			turning = -1f;
		}
		else
		{
			turning = 1f;
		}
		throttleScaleFromTurn = (flag ? (-1f) : 1f);
		int num4 = currentPathIndex;
		_ = currentPathIndex;
		float num5 = Vector3.Distance(((Component)this).transform.position, destination);
		while (HasPath() && (double)num5 < 26.6 && currentPathIndex >= 0)
		{
			int num6 = currentPathIndex;
			AdvancePathMovement(force: true);
			num5 = Vector3.Distance(((Component)this).transform.position, destination);
			if (currentPathIndex == num4 || currentPathIndex == num6)
			{
				break;
			}
		}
	}

	public void DoPhysicsMove()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		Vector3 velocity = myRigidBody.velocity;
		throttle = Mathf.Clamp(throttle, -1f, 1f);
		leftThrottle = throttle;
		rightThrottle = throttle;
		if (turning > 0f)
		{
			rightThrottle = 0f - turning;
			leftThrottle = turning;
		}
		else if (turning < 0f)
		{
			leftThrottle = turning;
			rightThrottle = turning * -1f;
		}
		Vector3.Distance(((Component)this).transform.position, GetFinalDestination());
		float num = Vector3.Distance(((Component)this).transform.position, GetCurrentPathDestination());
		float num2 = 15f;
		if (num < 20f)
		{
			float num3 = Vector3.Dot(PathDirection(currentPathIndex), PathDirection(currentPathIndex + 1));
			float num4 = Mathf.InverseLerp(2f, 10f, num);
			float num5 = Mathf.InverseLerp(0.5f, 0.8f, num3);
			num2 = 15f - 14f * ((1f - num5) * (1f - num4));
		}
		_ = 20f;
		if (patrolPath != null)
		{
			float num6 = num2;
			foreach (IAIPathSpeedZone speedZone in patrolPath.SpeedZones)
			{
				OBB val = speedZone.WorldSpaceBounds();
				if (((OBB)(ref val)).Contains(((Component)this).transform.position))
				{
					num6 = Mathf.Min(num6, speedZone.GetMaxSpeed());
				}
			}
			currentSpeedZoneLimit = Mathf.Lerp(currentSpeedZoneLimit, num6, Time.deltaTime);
			num2 = Mathf.Min(num2, currentSpeedZoneLimit);
		}
		if (PathComplete())
		{
			num2 = 0f;
		}
		brake = ((Vector3)(ref velocity)).magnitude >= num2;
		ApplyBrakes(brake ? 1f : 0f);
		float num7 = throttle;
		leftThrottle = Mathf.Clamp(leftThrottle + num7, -1f, 1f);
		rightThrottle = Mathf.Clamp(rightThrottle + num7, -1f, 1f);
		float num8 = Mathf.InverseLerp(2f, 1f, ((Vector3)(ref velocity)).magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		float torqueAmount = Mathf.Lerp(moveForceMax, turnForce, num8);
		float num9 = Mathf.InverseLerp(5f, 1.5f, ((Vector3)(ref velocity)).magnitude * Mathf.Abs(Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward)));
		ScaleSidewaysFriction(1f - num9);
		SetMotorTorque(leftThrottle, rightSide: false, torqueAmount);
		SetMotorTorque(rightThrottle, rightSide: true, torqueAmount);
		TriggerHurtEx triggerHurtEx = impactDamager;
		Vector3 velocity2 = myRigidBody.velocity;
		triggerHurtEx.damageEnabled = ((Vector3)(ref velocity2)).magnitude > 2f;
	}

	public void ApplyBrakes(float amount)
	{
		ApplyBrakeTorque(amount, rightSide: true);
		ApplyBrakeTorque(amount, rightSide: false);
	}

	public float GetMotorTorque(bool rightSide)
	{
		float num = 0f;
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		foreach (WheelCollider val in array)
		{
			num += val.motorTorque;
		}
		return num / (float)rightWheels.Length;
	}

	public void ScaleSidewaysFriction(float scale)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		float stiffness = 0.75f + 0.75f * scale;
		WheelCollider[] array = rightWheels;
		foreach (WheelCollider obj in array)
		{
			WheelFrictionCurve sidewaysFriction = obj.sidewaysFriction;
			((WheelFrictionCurve)(ref sidewaysFriction)).stiffness = stiffness;
			obj.sidewaysFriction = sidewaysFriction;
		}
		array = leftWheels;
		foreach (WheelCollider obj2 in array)
		{
			WheelFrictionCurve sidewaysFriction2 = obj2.sidewaysFriction;
			((WheelFrictionCurve)(ref sidewaysFriction2)).stiffness = stiffness;
			obj2.sidewaysFriction = sidewaysFriction2;
		}
	}

	public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
	{
		newThrottle = Mathf.Clamp(newThrottle, -1f, 1f);
		float num = torqueAmount * newThrottle;
		int num2 = (rightSide ? rightWheels.Length : leftWheels.Length);
		int num3 = 0;
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		WheelHit val = default(WheelHit);
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].GetGroundHit(ref val))
			{
				num3++;
			}
		}
		float num4 = 1f;
		if (num3 > 0)
		{
			num4 = num2 / num3;
		}
		array = (rightSide ? rightWheels : leftWheels);
		WheelHit val3 = default(WheelHit);
		foreach (WheelCollider val2 in array)
		{
			if (val2.GetGroundHit(ref val3))
			{
				val2.motorTorque = num * num4;
			}
			else
			{
				val2.motorTorque = num;
			}
		}
	}

	public void ApplyBrakeTorque(float amount, bool rightSide)
	{
		WheelCollider[] array = (rightSide ? rightWheels : leftWheels);
		for (int i = 0; i < array.Length; i++)
		{
			array[i].brakeTorque = brakeForce * amount;
		}
	}

	public void CreateExplosionMarker(float durationMinutes)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(debrisFieldMarker.resourcePath, ((Component)this).transform.position, Quaternion.identity);
		baseEntity.Spawn();
		((Component)baseEntity).SendMessage("SetDuration", (object)durationMinutes, (SendMessageOptions)1);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || Interface.CallHook("OnEntityDestroy", (object)this) != null)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, ((Component)mainTurretEyePos).transform.position, Vector3.up, null, broadcast: true);
		Vector3 zero = Vector3.zero;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, ((Component)this).gameObject, gibSource, zero, 3f);
		for (int i = 0; i < 12 - maxCratesToSpawn; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
			if (!Object.op_Implicit((Object)(object)baseEntity))
			{
				continue;
			}
			float num = 3f;
			float num2 = 10f;
			Vector3 onUnitSphere = Random.onUnitSphere;
			((Component)baseEntity).transform.position = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * Random.Range(-4f, 4f);
			Collider component = ((Component)baseEntity).GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(zero + onUnitSphere * Random.Range(num, num2));
			foreach (ServerGib item in list)
			{
				Physics.IgnoreCollision(component, (Collider)(object)item.GetCollider(), true);
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = Random.onUnitSphere;
			onUnitSphere2.y = 0f;
			((Vector3)(ref onUnitSphere2)).Normalize();
			Vector3 pos = ((Component)this).transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if (Object.op_Implicit((Object)(object)lootContainer))
			{
				((FacepunchBehaviour)lootContainer).Invoke((Action)lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = ((Component)baseEntity2).GetComponent<Collider>();
			Rigidbody val = ((Component)baseEntity2).gameObject.AddComponent<Rigidbody>();
			val.useGravity = true;
			val.collisionDetectionMode = (CollisionDetectionMode)2;
			val.mass = 2f;
			val.interpolation = (RigidbodyInterpolation)1;
			val.velocity = zero + onUnitSphere2 * Random.Range(1f, 3f);
			val.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			val.drag = 0.5f * (val.mass / 5f);
			val.angularDrag = 0.2f * (val.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if (Object.op_Implicit((Object)(object)fireBall))
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				((Component)fireBall).GetComponent<Rigidbody>().isKinematic = true;
				((Component)fireBall).GetComponent<Collider>().enabled = false;
			}
			((Component)baseEntity2).SendMessage("SetLockingEnt", (object)((Component)fireBall).gameObject, (SendMessageOptions)1);
			foreach (ServerGib item2 in list)
			{
				Physics.IgnoreCollision(component2, (Collider)(object)item2.GetCollider(), true);
			}
		}
		KillSpawnedScientists();
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && info.InitiatorPlayer.serverClan != null)
		{
			info.InitiatorPlayer.AddClanScore((ClanScoreEventType)7);
		}
		base.OnDied(info);
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		base.OnAttacked(info);
		if (!base.isClient)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			if (!(basePlayer is ScientistNPC) && (Object)(object)basePlayer != (Object)null)
			{
				TrySpawnScientists(basePlayer);
				AddOrUpdateTarget(basePlayer, info.PointStart, info.damageTypes.Total());
			}
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (!((Object)(object)info.Initiator != (Object)null) || !(info.Initiator is ScientistNPC))
		{
			base.Hurt(info);
		}
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer)
		{
			SetFlag(Flags.Reserved2, base.healthFraction <= 0.75f);
			SetFlag(Flags.Reserved3, base.healthFraction < 0.4f);
		}
	}

	public void DoHealing()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && base.SecondsSinceAttacked > 600f)
		{
			if (base.healthFraction < 1f)
			{
				float amount = MaxHealth() / 300f * Time.fixedDeltaTime;
				Heal(amount);
			}
			if (numberOfScientistsToSpawn < ScientistSpawnCount && base.healthFraction >= 0.95f && TimeSince.op_Implicit(timeSinceScientistDeploy) > 30f)
			{
				numberOfScientistsToSpawn = ScientistSpawnCount;
			}
		}
	}

	public BasePlayer GetPlayerDamageInitiator()
	{
		return null;
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		float num = ((throttle > 0f) ? 10f : 0f);
		float num2 = Vector3.Dot(myRigidBody.velocity, ((Component)this).transform.forward);
		if (num2 > 0f)
		{
			num += num2 * 0.5f;
		}
		if (ent is BaseVehicle)
		{
			num *= 10f;
		}
		return num;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	private void CheckForSplineStart()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float start = splineTranslator.GetStart();
		Vector3 positionAtDistance = splineTranslator.GetPositionAtDistance(start, out var _);
		positionAtDistance += splineOffset;
		Vector3 val = ((Component)spline).transform.TransformPoint(positionAtDistance);
		float num = Vector3Ex.Distance2D(((Component)this).transform.position, val);
		if (num < 1.5f)
		{
			followingSpine = true;
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckForSplineStart);
			EnterSpline();
		}
		lastDist = num;
	}

	private bool ShouldJoinSpline(WorldSpline spline)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (targetList.Count > 0)
		{
			TargetInfo targetInfo = targetList[0];
			if (targetInfo.IsValid() && targetInfo.IsVisible())
			{
				Vector3 val = targetInfo.lastSeenPosition - ((Component)this).transform.position;
				Vector3 normalized = ((Vector3)(ref val)).normalized;
				val = ((Component)spline).transform.position - ((Component)this).transform.position;
				float num = Vector3.Dot(((Vector3)(ref val)).normalized, normalized);
				if (num > 0f)
				{
					return true;
				}
				if (num < 0f)
				{
					return false;
				}
			}
		}
		return true;
	}

	public void OnSplinePathTrigger(int pathId, WorldSpline spline, int direction)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (followingSpine || TimeSince.op_Implicit(lastJoinedSpline) <= 5f)
		{
			return;
		}
		lastJoinedSpline = TimeSince.op_Implicit(0f);
		if (ShouldJoinSpline(spline))
		{
			if (splineTranslator == null)
			{
				splineTranslator = new SimpleSplineTranslator();
			}
			splineTranslator.SetSpline(spline).SetSpeed(splineMovementSpeed).SetDirection(direction)
				.CalculateStartingDistance();
			splineId = pathId;
			this.spline = spline;
			entryDirection = direction;
			followingSpine = true;
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CheckForSplineStart))
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForSplineStart, 0f, 1f);
			}
		}
	}

	public void OnBasePathTrigger(int pathId, BasePath path)
	{
	}

	private bool IsOnSpline()
	{
		return followingSpine;
	}

	public bool HasPath()
	{
		if (currentPath != null)
		{
			return currentPath.Count > 0;
		}
		return false;
	}

	public void ClearPath()
	{
		currentPath.Clear();
		currentPathIndex = -1;
	}

	public bool IndexValid(int index)
	{
		if (!HasPath())
		{
			return false;
		}
		if (index >= 0)
		{
			return index < currentPath.Count;
		}
		return false;
	}

	public Vector3 GetFinalDestination()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		return finalDestination;
	}

	public Vector3 GetCurrentPathDestination()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		return currentPath[currentPathIndex];
	}

	public bool PathComplete()
	{
		if (HasPath())
		{
			if (currentPathIndex == currentPath.Count - 1)
			{
				return AtCurrentPathNode();
			}
			return false;
		}
		return true;
	}

	public bool AtCurrentPathNode()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (currentPathIndex < 0 || currentPathIndex >= currentPath.Count)
		{
			return false;
		}
		return Vector3.Distance(((Component)this).transform.position, currentPath[currentPathIndex]) <= stoppingDist;
	}

	public int GetLoopedIndex(int index)
	{
		if (!HasPath())
		{
			Debug.LogWarning((object)"Warning, GetLoopedIndex called without a path");
			return 0;
		}
		if (!pathLooping)
		{
			return Mathf.Clamp(index, 0, currentPath.Count - 1);
		}
		if (index >= currentPath.Count)
		{
			return index % currentPath.Count;
		}
		if (index < 0)
		{
			return currentPath.Count - Mathf.Abs(index % currentPath.Count);
		}
		return index;
	}

	public Vector3 PathDirection(int index)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath() || currentPath.Count <= 1)
		{
			return ((Component)this).transform.forward;
		}
		index = GetLoopedIndex(index);
		Vector3 val;
		Vector3 val2;
		if (pathLooping)
		{
			int loopedIndex = GetLoopedIndex(index - 1);
			val = currentPath[loopedIndex];
			val2 = currentPath[GetLoopedIndex(index)];
		}
		else
		{
			val = ((index - 1 >= 0) ? currentPath[index - 1] : ((Component)this).transform.position);
			val2 = currentPath[index];
		}
		Vector3 val3 = val2 - val;
		return ((Vector3)(ref val3)).normalized;
	}

	public Vector3 IdealPathPosition()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if (!HasPath())
		{
			return ((Component)this).transform.position;
		}
		int loopedIndex = GetLoopedIndex(currentPathIndex - 1);
		if (loopedIndex == currentPathIndex)
		{
			return currentPath[currentPathIndex];
		}
		return ClosestPointAlongPath(currentPath[loopedIndex], currentPath[currentPathIndex], ((Component)this).transform.position);
	}

	public void AdvancePathMovement(bool force)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		if (HasPath())
		{
			if (force || AtCurrentPathNode() || currentPathIndex == -1)
			{
				currentPathIndex = GetLoopedIndex(currentPathIndex + 1);
			}
			if (PathComplete())
			{
				ClearPath();
				return;
			}
			Vector3 val = IdealPathPosition();
			Vector3 val2 = currentPath[currentPathIndex];
			float num = Vector3.Distance(val, val2);
			float num2 = Vector3.Distance(((Component)this).transform.position, val);
			float num3 = Mathf.InverseLerp(8f, 0f, num2);
			val += Direction2D(val2, val) * Mathf.Min(num, num3 * 20f);
			SetDestination(val);
		}
	}

	public bool GetPathToClosestTurnableNode(IAIPathNode start, Vector3 forward, ref List<IAIPathNode> nodes)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		float num = float.NegativeInfinity;
		IAIPathNode iAIPathNode = null;
		Vector3 val;
		foreach (IAIPathNode item in start.Linked)
		{
			val = item.Position - start.Position;
			float num2 = Vector3.Dot(forward, ((Vector3)(ref val)).normalized);
			if (num2 > num)
			{
				num = num2;
				iAIPathNode = item;
			}
		}
		if (iAIPathNode != null)
		{
			nodes.Add(iAIPathNode);
			if (!iAIPathNode.Straightaway)
			{
				return true;
			}
			IAIPathNode start2 = iAIPathNode;
			val = iAIPathNode.Position - start.Position;
			return GetPathToClosestTurnableNode(start2, ((Vector3)(ref val)).normalized, ref nodes);
		}
		return false;
	}

	public bool GetEngagementPath(ref List<IAIPathNode> nodes)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		IAIPathNode closestToPoint = patrolPath.GetClosestToPoint(((Component)this).transform.position);
		Vector3 val = closestToPoint.Position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		if (Vector3.Dot(((Component)this).transform.forward, normalized) > 0f)
		{
			nodes.Add(closestToPoint);
			if (!closestToPoint.Straightaway)
			{
				return true;
			}
		}
		return GetPathToClosestTurnableNode(closestToPoint, ((Component)this).transform.forward, ref nodes);
	}

	private void CacheSpawnPrefabIDS()
	{
		scientistPrefabLookUp.Clear();
		foreach (ScientistSpawnGroup scientistSpawn in ScientistSpawns)
		{
			foreach (GameObjectRef spawnPrefab in scientistSpawn.SpawnPrefabs)
			{
				uint key = spawnPrefab.GetEntity().prefabID;
				if (!scientistPrefabLookUp.ContainsKey(key))
				{
					scientistPrefabLookUp.Add(key, spawnPrefab);
				}
			}
		}
	}

	private void TrySpawnScientists(BasePlayer triggeringPlayer)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)triggeringPlayer == (Object)null) && !deployingScientists && !mountingScientists && !(TimeSince.op_Implicit(timeSinceDeployCheck) <= DeployOnDamageCheckInterval))
		{
			timeSinceDeployCheck = TimeSince.op_Implicit(0f);
			List<ScientistSpawnGroup> triggereringSpawnGroups = GetTriggereringSpawnGroups();
			List<GameObjectRef> list = Pool.Get<List<GameObjectRef>>();
			AddMountedScientistsToSpawn(list);
			AddSpawnGroupSpawns(triggereringSpawnGroups, list);
			if (list.Count == 0)
			{
				Pool.FreeUnmanaged<GameObjectRef>(ref list);
				Pool.FreeUnmanaged<ScientistSpawnGroup>(ref triggereringSpawnGroups);
			}
			else if (CanDeployScientists(triggeringPlayer, list, scientistSpawnPositions))
			{
				SetSpawnGroupsAsSpawned(triggereringSpawnGroups);
				Pool.FreeUnmanaged<ScientistSpawnGroup>(ref triggereringSpawnGroups);
				ClearMountedScientists();
				((MonoBehaviour)this).StartCoroutine(DeployScientists(triggeringPlayer, list, scientistSpawnPositions));
			}
			else
			{
				Pool.FreeUnmanaged<GameObjectRef>(ref list);
				Pool.FreeUnmanaged<ScientistSpawnGroup>(ref triggereringSpawnGroups);
			}
		}
	}

	private List<ScientistSpawnGroup> GetTriggereringSpawnGroups()
	{
		List<ScientistSpawnGroup> list = Pool.Get<List<ScientistSpawnGroup>>();
		foreach (ScientistSpawnGroup scientistSpawn in ScientistSpawns)
		{
			if (!scientistSpawn.Spawned && !(base.healthFraction > scientistSpawn.BradleyHealth))
			{
				list.Add(scientistSpawn);
			}
		}
		return list;
	}

	private void AddMountedScientistsToSpawn(List<GameObjectRef> scientists)
	{
		if (mountedScientistPrefabs.Count != 0)
		{
			scientists.AddRange(mountedScientistPrefabs);
		}
	}

	private void ClearMountedScientists()
	{
		mountedScientistPrefabs.Clear();
	}

	private void AddSpawnGroupSpawns(List<ScientistSpawnGroup> spawnGroups, List<GameObjectRef> scientists)
	{
		if (spawnGroups == null)
		{
			return;
		}
		foreach (ScientistSpawnGroup spawnGroup in spawnGroups)
		{
			if (spawnGroup != null)
			{
				scientists.AddRange(spawnGroup.SpawnPrefabs);
			}
		}
	}

	private void SetSpawnGroupsAsSpawned(List<ScientistSpawnGroup> spawnGroups)
	{
		if (spawnGroups == null)
		{
			return;
		}
		foreach (ScientistSpawnGroup spawnGroup in spawnGroups)
		{
			if (spawnGroup != null)
			{
				spawnGroup.Spawned = true;
			}
		}
	}

	private void UpdateDeployed()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!mountingScientists)
		{
			bool flag = false;
			float num = (UseSmokeGrenades ? 8f : 5f);
			if (TimeSince.op_Implicit(timeSinceScientistDeploy) > num && AliveScientistCount() == 0)
			{
				flag = true;
			}
			else if (targetList.Count == 0 && TimeSince.op_Implicit(timeSinceValidTarget) > MountAfterNotTargetsDuration)
			{
				flag = true;
			}
			else if (base.SecondsSinceAttacked > MountAfterNotAttackedDuration && TimeSince.op_Implicit(timeSinceScientistDeploy) > MountAfterNotAttackedDuration)
			{
				flag = true;
			}
			else if (UnableToFireAtPlayers())
			{
				flag = true;
			}
			if (flag)
			{
				((MonoBehaviour)this).StartCoroutine(RecallSpawnedScientists());
			}
		}
	}

	private bool UnableToFireAtPlayers()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(deployedTimeSinceBradleyAttackedTarget) < MountAfterNotFiredDuration)
		{
			return false;
		}
		foreach (ScientistNPC activeScientist in activeScientists)
		{
			if (!((Object)(object)activeScientist == (Object)null) && activeScientist.SecondsSinceDealtDamage < MountAfterNotFiredDuration)
			{
				return false;
			}
		}
		return true;
	}

	private void UpdateMountScientists()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		if (ActiveScientistCount() <= 0)
		{
			AIRoot.SetActive(false);
			SetMountingScientists(flag: false);
			inDeployedState = false;
			SetDeployingScientists(flag: false);
			activeScientists.Clear();
			timeSinceScientistDeploy = TimeSince.op_Implicit(0f);
		}
	}

	public int ActiveScientistCount()
	{
		int num = 0;
		foreach (ScientistNPC activeScientist in activeScientists)
		{
			if (!((Object)(object)activeScientist == (Object)null))
			{
				num++;
			}
		}
		return num;
	}

	public int AliveScientistCount()
	{
		if (inDeployedState)
		{
			return ActiveScientistCount();
		}
		return numberOfScientistsToSpawn;
	}

	private bool CanDeployScientists(BaseEntity attacker, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanDeployScientists", (object)this, (object)attacker, (object)scientistPrefabs, (object)spawnPositions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int count = scientistPrefabs.Count;
		if (!inDeployedState && Vector3.Distance(((Component)attacker).transform.position, ((Component)this).transform.position) > DeployAttackDistanceMax)
		{
			return false;
		}
		spawnPositions.Clear();
		bool flag = false;
		int num = 0;
		int num2 = 0;
		int num3 = 8454144;
		RaycastHit val = default(RaycastHit);
		NavMeshHit val2 = default(NavMeshHit);
		while (!flag)
		{
			if (Physics.Raycast(ScientistSpawnPoints[num2 % ScientistSpawnPoints.Count].transform.position + Vector3.up * 1f, Vector3.down, ref val, 2f, num3) && NavMesh.SamplePosition(((RaycastHit)(ref val)).point + Vector3.up * 0.3f, ref val2, 6f, walkableAreaMask))
			{
				spawnPositions.Add(((RaycastHit)(ref val)).point + Vector3.up * 0.1f);
				num2++;
				if (num2 >= count)
				{
					break;
				}
			}
			else
			{
				num++;
				if (num > count * 2)
				{
					flag = true;
				}
			}
		}
		return !flag;
	}

	private IEnumerator DeployScientists(BasePlayer triggerPlayer, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
	{
		if (base.isClient || spawnPositions == null || spawnPositions.Count == 0)
		{
			Pool.FreeUnmanaged<GameObjectRef>(ref scientistPrefabs);
			yield break;
		}
		deployedTimeSinceBradleyAttackedTarget = TimeSince.op_Implicit(0f);
		timeSinceScientistDeploy = TimeSince.op_Implicit(0f);
		timeSinceValidTarget = TimeSince.op_Implicit(0f);
		AIRoot.SetActive(true);
		SetMountingScientists(flag: false);
		inDeployedState = true;
		SetDeployingScientists(flag: true);
		if (UseSmokeGrenades)
		{
			DropSmokeGrenade(spawnPositions[0], 6f);
			yield return (object)new WaitForSeconds(3f);
		}
		yield return (object)new WaitForEndOfFrame();
		yield return (object)new WaitForEndOfFrame();
		int index = 0;
		foreach (Vector3 spawnPos in spawnPositions)
		{
			ScientistNPC scientist = SpawnScientist(scientistPrefabs[index], spawnPos, RoadSpawned);
			index++;
			yield return (object)new WaitForEndOfFrame();
			InitScientist(scientist, spawnPos, triggerPlayer, RoadSpawned, index % 2 == 0);
			yield return (object)new WaitForSeconds(DeployInterval);
		}
		SetDeployingScientists(flag: false);
		Pool.FreeUnmanaged<GameObjectRef>(ref scientistPrefabs);
	}

	private void SetDeployingScientists(bool flag)
	{
		deployingScientists = flag;
	}

	private void SetMountingScientists(bool flag)
	{
		mountingScientists = flag;
	}

	private ScientistNPC SpawnScientist(GameObjectRef scientistPrefab, Vector3 spawnPos, bool roadSpawned)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		ScientistNPC scientistNPC = GameManager.server.CreateEntity(scientistPrefab.resourcePath, spawnPos, Quaternion.identity) as ScientistNPC;
		scientistNPC.VirtualInfoZone = AIRoot.GetComponent<AIInformationZone>();
		((Component)scientistNPC).GetComponent<ScientistBrain>().MovementTickStartDelay = 0f;
		NavMeshAgent component = ((Component)scientistNPC).GetComponent<NavMeshAgent>();
		if ((Object)(object)component != (Object)null)
		{
			NPCPlayerNavigator component2 = ((Component)scientistNPC).GetComponent<NPCPlayerNavigator>();
			component.agentTypeID = (roadSpawned ? BaseNavigator.GetNavMeshAgentID("Animal") : BaseNavigator.GetNavMeshAgentID("Humanoid"));
			component2.DefaultArea = (roadSpawned ? "Walkable" : "HumanNPC");
		}
		scientistNPC.Spawn();
		scientistNPC.EquipTest();
		activeScientists.Add(scientistNPC);
		return scientistNPC;
	}

	private void InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)scientist == (Object)null)
		{
			return;
		}
		((Component)scientist).transform.position = spawnPos;
		if (!scientist.Brain.Navigator.PlaceOnNavMesh(0.2f))
		{
			activeScientists.Remove(scientist);
			scientist.Kill();
			return;
		}
		if ((Object)(object)triggerPlayer != (Object)null)
		{
			scientist.Brain.Events.Memory.Entity.Set(triggerPlayer, 0);
			scientist.Brain.Senses.Memory.SetKnown(triggerPlayer, scientist, null);
			scientist.Brain.Events.Memory.Position.Set(((Component)scientist.Brain.Navigator).transform.position, 7);
			scientist.Brain.Events.Memory.Position.Set(((Component)scientist.Brain.Navigator).transform.position, 4);
			scientist.Brain.Events.Memory.Entity.Set(this, 7);
			AttackEntity attackEntity = scientist.GetAttackEntity();
			if (SetScientistChaseBasedOnWeapon && (Object)(object)attackEntity != (Object)null && !attackEntity.CanUseAtLongRange)
			{
				startChasing = true;
			}
			scientist.Brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint = startChasing;
			scientist.Brain.Navigator.CanUseRandomMovePointIfNonFound = !startChasing;
			if (startChasing)
			{
				scientist.Brain.SwitchToState(AIState.Chase, 6);
			}
			else
			{
				scientist.Brain.SwitchToState(AIState.TakeCover, 4);
			}
			scientist.Brain.Think(0f);
		}
		Interface.CallHook("OnScientistInitialized", (object)this, (object)scientist, (object)spawnPos);
	}

	private void DropSmokeGrenade(Vector3 position, float duration)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		SmokeGrenade component = ((Component)GameManager.server.CreateEntity(SmokeGrenadePrefab.resourcePath, position, Quaternion.identity)).GetComponent<SmokeGrenade>();
		component.smokeDuration = duration;
		component.Spawn();
	}

	private void KillSpawnedScientists()
	{
		foreach (ScientistNPC activeScientist in activeScientists)
		{
			if (!((Object)(object)activeScientist == (Object)null))
			{
				if (KillScientistsOnBradleyDeath)
				{
					activeScientist.Kill();
				}
				else
				{
					activeScientist.Brain.LoadAIDesignAtIndex(1);
				}
			}
		}
		activeScientists.Clear();
		numberOfScientistsToSpawn = 0;
	}

	private IEnumerator RecallSpawnedScientists()
	{
		if (!inDeployedState || mountingScientists)
		{
			yield break;
		}
		int num = 0;
		foreach (ScientistNPC activeScientist in activeScientists)
		{
			if (!((Object)(object)activeScientist == (Object)null) && activeScientist.IsAlive())
			{
				num++;
			}
		}
		numberOfScientistsToSpawn = 0;
		SetMountingScientists(flag: true);
		if (num > 0 && UseSmokeGrenades)
		{
			DropSmokeGrenade(ScientistSpawnPoints[0].transform.position, 10f);
			yield return (object)new WaitForSeconds(3f);
		}
		foreach (ScientistNPC activeScientist2 in activeScientists)
		{
			if (!((Object)(object)activeScientist2 == (Object)null))
			{
				activeScientist2.Brain.SwitchToState(AIState.MoveToVector3, 8);
				activeScientist2.Brain.Think(0f);
			}
		}
	}

	public void OnScientistMounted(ScientistNPC scientist)
	{
		if (!((Object)(object)scientist == (Object)null))
		{
			if (scientistPrefabLookUp.TryGetValue(scientist.prefabID, out var value))
			{
				mountedScientistPrefabs.Add(value);
			}
			activeScientists.Remove(scientist);
			numberOfScientistsToSpawn++;
			Interface.CallHook("OnScientistRecalled", (object)this, (object)scientist);
		}
	}

	public void AddOrUpdateTarget(BaseEntity ent, Vector3 pos, float damageFrom = 0f)
	{
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if ((AI.ignoreplayers && !ent.IsNpc) || !(ent is BasePlayer item) || SimpleAIMemory.PlayerIgnoreList.Contains(item) || ent is ScientistNPC)
		{
			return;
		}
		TargetInfo targetInfo = null;
		foreach (TargetInfo target in targetList)
		{
			if ((Object)(object)target.entity == (Object)(object)ent)
			{
				targetInfo = target;
				break;
			}
		}
		if (targetInfo == null)
		{
			targetInfo = Pool.Get<TargetInfo>();
			targetInfo.Setup(ent, Time.time - 1f);
			targetList.Add(targetInfo);
		}
		targetInfo.lastSeenPosition = pos;
		targetInfo.damageReceivedFrom += damageFrom;
	}

	public void UpdateTargetList()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(((Component)this).transform.position, searchRange, list, 133120, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if ((AI.ignoreplayers && !item.IsNpc) || !(item is BasePlayer))
			{
				continue;
			}
			BasePlayer basePlayer = item as BasePlayer;
			if (SimpleAIMemory.PlayerIgnoreList.Contains(basePlayer) || basePlayer.IsDead() || basePlayer is HumanNPC || basePlayer is NPCPlayer || (basePlayer.InSafeZone() && !basePlayer.IsHostile()) || !VisibilityTest(item))
			{
				continue;
			}
			bool flag = false;
			foreach (TargetInfo target in targetList)
			{
				if ((Object)(object)target.entity == (Object)(object)item)
				{
					target.lastSeenTime = Time.time;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				TargetInfo targetInfo = Pool.Get<TargetInfo>();
				targetInfo.Setup(item, Time.time);
				targetList.Add(targetInfo);
			}
		}
		for (int num = targetList.Count - 1; num >= 0; num--)
		{
			TargetInfo targetInfo2 = targetList[num];
			BasePlayer basePlayer2 = targetInfo2.entity as BasePlayer;
			if ((Object)(object)targetInfo2.entity == (Object)null || Time.time - targetInfo2.lastSeenTime > memoryDuration || basePlayer2.IsDead() || (basePlayer2.InSafeZone() && !basePlayer2.IsHostile()) || (AI.ignoreplayers && !basePlayer2.IsNpc) || SimpleAIMemory.PlayerIgnoreList.Contains(basePlayer2))
			{
				targetList.Remove(targetInfo2);
				Pool.Free<TargetInfo>(ref targetInfo2);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		targetList.Sort(SortTargets);
		if (targetList.Count > 0)
		{
			timeSinceValidTarget = TimeSince.op_Implicit(0f);
		}
	}

	public int SortTargets(TargetInfo t1, TargetInfo t2)
	{
		return t2.GetPriorityScore(this).CompareTo(t1.GetPriorityScore(this));
	}

	public Vector3 GetAimPoint(BaseEntity ent)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			return basePlayer.eyes.position;
		}
		return ent.CenterPoint();
	}

	public bool VisibilityTest(BaseEntity ent)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null)
		{
			return false;
		}
		if (!(Vector3.Distance(((Component)ent).transform.position, ((Component)this).transform.position) < viewDistance))
		{
			return false;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = ((Component)mainTurret).transform.position;
			flag = IsVisible(basePlayer.eyes.position, position) || IsVisible(((Component)basePlayer).transform.position + Vector3.up * 0.1f, position);
			if (!flag && basePlayer.isMounted && (Object)(object)basePlayer.GetMounted().VehicleParent() != (Object)null && basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)
			{
				flag = IsVisible(((Bounds)(ref basePlayer.GetMounted().VehicleParent().bounds)).center, position);
			}
			if (flag)
			{
				flag = !Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);
			}
		}
		else
		{
			Debug.LogWarning((object)"Standard vis test!");
			flag = IsVisible(ent.CenterPoint());
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", (object)this, (object)ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return flag;
	}

	public void UpdateTargetVisibilities()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		foreach (TargetInfo target in targetList)
		{
			if (target.IsValid() && VisibilityTest(target.entity))
			{
				target.lastSeenTime = Time.time;
				target.lastSeenPosition = ((Component)target.entity).transform.position;
			}
		}
	}

	public void DoWeaponAiming()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normalized;
		Vector3 val;
		if (!((Object)(object)mainGunTarget != (Object)null))
		{
			normalized = desiredAimVector;
		}
		else
		{
			val = GetAimPoint(mainGunTarget) - ((Component)mainTurretEyePos).transform.position;
			normalized = ((Vector3)(ref val)).normalized;
		}
		desiredAimVector = normalized;
		BaseEntity baseEntity = null;
		if (targetList.Count > 0)
		{
			if (targetList.Count > 1 && targetList[1].IsValid() && targetList[1].IsVisible())
			{
				baseEntity = targetList[1].entity;
			}
			else if (targetList[0].IsValid() && targetList[0].IsVisible())
			{
				baseEntity = targetList[0].entity;
			}
		}
		Vector3 val2;
		if (!((Object)(object)baseEntity != (Object)null))
		{
			val2 = ((Component)this).transform.forward;
		}
		else
		{
			val = GetAimPoint(baseEntity) - ((Component)topTurretEyePos).transform.position;
			val2 = ((Vector3)(ref val)).normalized;
		}
		desiredTopTurretAimVector = val2;
	}

	public void DoWeapons()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mainGunTarget != (Object)null)
		{
			Vector3 val = turretAimVector;
			Vector3 val2 = GetAimPoint(mainGunTarget) - ((Component)mainTurretEyePos).transform.position;
			if (Vector3.Dot(val, ((Vector3)(ref val2)).normalized) >= 0.99f)
			{
				bool flag = VisibilityTest(mainGunTarget);
				float num = Vector3.Distance(((Component)mainGunTarget).transform.position, ((Component)this).transform.position);
				if (Time.time > nextCoaxTime && flag && num <= 40f)
				{
					numCoaxBursted++;
					FireGun(GetAimPoint(mainGunTarget), 3f, isCoax: true);
					nextCoaxTime = Time.time + coaxFireRate;
					if (numCoaxBursted >= coaxBurstLength)
					{
						nextCoaxTime = Time.time + 1f;
						numCoaxBursted = 0;
					}
				}
				if (num >= 10f && flag)
				{
					FireGunTest();
				}
			}
		}
		if (targetList.Count > 1)
		{
			BaseEntity entity = targetList[1].entity;
			if ((Object)(object)entity != (Object)null && Time.time > nextTopTurretTime && VisibilityTest(entity))
			{
				FireGun(GetAimPoint(targetList[1].entity), 3f, isCoax: false);
				nextTopTurretTime = Time.time + topTurretFireRate;
			}
		}
	}

	public void FireGun(Vector3 targetPos, float aimCone, bool isCoax)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		deployedTimeSinceBradleyAttackedTarget = TimeSince.op_Implicit(0f);
		Transform val = (isCoax ? coaxMuzzle : topTurretMuzzle);
		Vector3 val2 = ((Component)val).transform.position - val.forward * 0.25f;
		Vector3 val3 = targetPos - val2;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, normalized);
		targetPos = val2 + modifiedAimConeDirection * 300f;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(val2, modifiedAimConeDirection), 0f, list, 300f, 1220225809, (QueryTriggerInteraction)0);
		for (int i = 0; i < list.Count; i++)
		{
			RaycastHit hit = list[i];
			BaseEntity entity = hit.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || (!((Object)(object)entity == (Object)(object)this) && !entity.EqualNetID((BaseNetworkable)this))) && !(entity is ScientistNPC))
			{
				BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
				if ((Object)(object)baseCombatEntity != (Object)null)
				{
					ApplyDamage(baseCombatEntity, ((RaycastHit)(ref hit)).point, modifiedAimConeDirection);
				}
				if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
				{
					targetPos = ((RaycastHit)(ref hit)).point;
					break;
				}
			}
		}
		ClientRPC<bool, Vector3>(RpcTarget.NetworkGroup("CLIENT_FireGun"), isCoax, targetPos);
		Pool.FreeUnmanaged<RaycastHit>(ref list);
	}

	public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		float damageAmount = bulletDamage * Random.Range(0.9f, 1.1f);
		HitInfo info = new HitInfo(this, entity, DamageType.Bullet, damageAmount, point);
		entity.OnAttacked(info);
		if (entity is BasePlayer || entity is BaseNpc)
		{
			Effect.server.ImpactEffect(new HitInfo
			{
				HitPositionWorld = point,
				HitNormalWorld = -normal,
				HitMaterial = StringPool.Get("Flesh")
			});
		}
	}

	public void AimWeaponAt(Transform weaponYaw, Transform weaponPitch, Vector3 direction, float minPitch = -360f, float maxPitch = 360f, float maxYaw = 360f, Transform parentOverride = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = direction;
		val = weaponYaw.parent.InverseTransformDirection(val);
		Quaternion localRotation = Quaternion.LookRotation(val);
		Vector3 eulerAngles = ((Quaternion)(ref localRotation)).eulerAngles;
		for (int i = 0; i < 3; i++)
		{
			((Vector3)(ref eulerAngles))[i] = ((Vector3)(ref eulerAngles))[i] - ((((Vector3)(ref eulerAngles))[i] > 180f) ? 360f : 0f);
		}
		Quaternion localRotation2 = Quaternion.Euler(0f, Mathf.Clamp(eulerAngles.y, 0f - maxYaw, maxYaw), 0f);
		Quaternion localRotation3 = Quaternion.Euler(Mathf.Clamp(eulerAngles.x, minPitch, maxPitch), 0f, 0f);
		if ((Object)(object)weaponYaw == (Object)null && (Object)(object)weaponPitch != (Object)null)
		{
			((Component)weaponPitch).transform.localRotation = localRotation3;
			return;
		}
		if ((Object)(object)weaponPitch == (Object)null && (Object)(object)weaponYaw != (Object)null)
		{
			((Component)weaponYaw).transform.localRotation = localRotation;
			return;
		}
		((Component)weaponYaw).transform.localRotation = localRotation2;
		((Component)weaponPitch).transform.localRotation = localRotation3;
	}

	public void LateUpdate()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - lastLateUpdate;
		lastLateUpdate = Time.time;
		if (base.isServer)
		{
			float num2 = MathF.PI * 2f / 3f;
			turretAimVector = Vector3.RotateTowards(turretAimVector, desiredAimVector, num2 * num, 0f);
		}
		else
		{
			turretAimVector = Vector3.Lerp(turretAimVector, desiredAimVector, Time.deltaTime * 10f);
		}
		AimWeaponAt(mainTurret, coaxPitch, turretAimVector, -90f, 90f);
		AimWeaponAt(mainTurret, CannonPitch, turretAimVector, -90f, 7f);
		topTurretAimVector = Vector3.Lerp(topTurretAimVector, desiredTopTurretAimVector, Time.deltaTime * 5f);
		AimWeaponAt(topTurretYaw, topTurretPitch, topTurretAimVector, -360f, 360f, 360f, mainTurret);
	}
}
