using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.AI;
using UnityEngine;
using UnityEngine.AI;

public class BradleyAPC : BaseCombatEntity
{
	private enum e_AIState
	{
		IDLE,
		PATROL,
		SEARCH,
		COMBAT,
		FLEE
	}

	[Serializable]
	public class TargetInfo : Facepunch.Pool.IPooled
	{
		public float damageReceivedFrom;

		public BaseEntity entity;

		public float lastSeenTime;

		public Vector3 lastSeenPosition;

		public void EnterPool()
		{
			entity = null;
			lastSeenPosition = Vector3.zero;
			lastSeenTime = 0f;
		}

		public void Setup(BaseEntity ent, float time)
		{
			entity = ent;
			lastSeenTime = time;
		}

		public void LeavePool()
		{
		}

		public float GetPriorityScore(BradleyAPC apc)
		{
			BasePlayer basePlayer = entity as BasePlayer;
			if ((bool)basePlayer)
			{
				float value = Vector3.Distance(entity.transform.position, apc.transform.position);
				float num = (1f - Mathf.InverseLerp(10f, 80f, value)) * 50f;
				float value2 = ((!(basePlayer.GetHeldEntity() == null)) ? basePlayer.GetHeldEntity().hostileScore : 0f);
				float num2 = Mathf.InverseLerp(4f, 20f, value2) * 100f;
				float num3 = Mathf.InverseLerp(10f, 3f, UnityEngine.Time.time - lastSeenTime) * 100f;
				float num4 = Mathf.InverseLerp(0f, 100f, damageReceivedFrom) * 50f;
				return num + num2 + num4 + num3;
			}
			return 0f;
		}

		public bool IsVisible()
		{
			return lastSeenTime != -1f && UnityEngine.Time.time - lastSeenTime < sightUpdateRate * 2f;
		}

		public bool IsValid()
		{
			return entity != null;
		}
	}

	[Header("Sound")]
	public EngineAudioClip engineAudioClip;

	public SlicedGranularAudioClip treadAudioClip;

	public float treadGrainFreqMin = 0.025f;

	public float treadGrainFreqMax = 0.5f;

	public AnimationCurve treadFreqCurve;

	public SoundDefinition chasisLurchSoundDef;

	public float chasisLurchAngleDelta = 2f;

	public float chasisLurchSpeedDelta = 2f;

	private float lastAngle;

	private float lastSpeed;

	public SoundDefinition turretTurnLoopDef;

	public float turretLoopGainSpeed = 3f;

	public float turretLoopPitchSpeed = 3f;

	public float turretLoopMinAngleDelta;

	public float turretLoopMaxAngleDelta = 10f;

	public float turretLoopPitchMin = 0.5f;

	public float turretLoopPitchMax = 1f;

	public float turretLoopGainThreshold = 0.0001f;

	private Sound turretTurnLoop;

	private SoundModulation.Modulator turretTurnLoopGain;

	private SoundModulation.Modulator turretTurnLoopPitch;

	public float enginePitch = 0.9f;

	public float rpmMultiplier = 0.6f;

	private TreadAnimator treadAnimator;

	private float lastTurretAngle;

	[Header("Wheels")]
	public WheelCollider[] leftWheels;

	public WheelCollider[] rightWheels;

	[Header("Movement Config")]
	public float moveForceMax = 2000f;

	public float brakeForce = 100f;

	public float turnForce = 2000f;

	public float sideStiffnessMax = 1f;

	public float sideStiffnessMin = 0.5f;

	public Transform centerOfMass;

	public float stoppingDist = 5f;

	[Header("Control")]
	public float throttle = 1f;

	public float turning;

	public float rightThrottle;

	public float leftThrottle;

	public bool brake;

	[Header("Other")]
	public Rigidbody myRigidBody;

	public Collider myCollider;

	public Vector3 destination;

	private Vector3 finalDestination;

	public Transform followTest;

	public TriggerHurtEx impactDamager;

	[Header("Weapons")]
	public Transform mainTurretEyePos;

	public Transform mainTurret;

	public Transform CannonPitch;

	public Transform CannonMuzzle;

	public Transform coaxPitch;

	public Transform coaxMuzzle;

	public Transform topTurretEyePos;

	public Transform topTurretYaw;

	public Transform topTurretPitch;

	public Transform topTurretMuzzle;

	public Vector3 turretAimVector = Vector3.forward;

	private Vector3 desiredAimVector = Vector3.forward;

	public Vector3 topTurretAimVector = Vector3.forward;

	private Vector3 desiredTopTurretAimVector = Vector3.forward;

	[Header("Effects")]
	public GameObjectRef explosionEffect;

	public GameObjectRef servergibs;

	public GameObjectRef fireBall;

	public GameObjectRef crateToDrop;

	[Header("Loot")]
	public int maxCratesToSpawn;

	private float nextDamageTime;

	public int patrolPathIndex;

	public BasePath patrolPath;

	public bool DoAI = true;

	public GameObjectRef mainCannonMuzzleFlash;

	public GameObjectRef mainCannonProjectile;

	private float nextFireTime = 10f;

	private int numBursted;

	public float recoilScale = 200f;

	public NavMeshPath navMeshPath;

	public int navMeshPathIndex;

	private e_AIState currentState = e_AIState.SEARCH;

	private float nextPatrolTime;

	private float nextEngagementPathTime;

	private float currentSpeedZoneLimit;

	private float stuckStartTime;

	[Header("Pathing")]
	public List<Vector3> currentPath;

	public int currentPathIndex;

	public bool pathLooping;

	[Header("Targeting")]
	public float viewDistance = 100f;

	public float searchRange = 100f;

	public float searchFrequency = 2f;

	public float memoryDuration = 20f;

	public static float sightUpdateRate = 0.5f;

	private BaseCombatEntity mainGunTarget;

	public List<TargetInfo> targetList = new List<TargetInfo>();

	private float nextCoaxTime;

	private float coaxFireRate = 0.06667f;

	private int numCoaxBursted;

	private float nextTopTurretTime;

	private float topTurretFireRate = 0.1f;

	private float bulletDamage = 7f;

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	private float lastLateUpdate;

	protected override float PositionTickRate => 0.1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		using (TimeWarning.New("BradleyAPC.OnRpcMessage"))
		{
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.bradley != null && !info.fromDisk)
		{
			throttle = info.msg.bradley.engineThrottle;
			rightThrottle = info.msg.bradley.throttleRight;
			leftThrottle = info.msg.bradley.throttleLeft;
			desiredAimVector = info.msg.bradley.mainGunVec;
			desiredTopTurretAimVector = info.msg.bradley.topTurretVec;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.bradley = Facepunch.Pool.Get<ProtoBuf.BradleyAPC>();
			info.msg.bradley.engineThrottle = throttle;
			info.msg.bradley.throttleLeft = leftThrottle;
			info.msg.bradley.throttleRight = rightThrottle;
			info.msg.bradley.mainGunVec = turretAimVector;
			info.msg.bradley.topTurretVec = topTurretAimVector;
		}
	}

	public void SetDestination(Vector3 dest)
	{
		destination = dest;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Initialize();
		InvokeRepeating(UpdateTargetList, 0f, 2f);
		InvokeRepeating(UpdateTargetVisibilities, 0f, sightUpdateRate);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
	}

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

	public BasePlayer FollowPlayer()
	{
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if (activePlayer.IsAdmin && activePlayer.IsAlive() && !activePlayer.IsSleeping() && activePlayer.GetActiveItem() != null && activePlayer.GetActiveItem().info.shortname == "tool.binoculars")
			{
				return activePlayer;
			}
		}
		return null;
	}

	public static Vector3 Direction2D(Vector3 aimAt, Vector3 aimFrom)
	{
		return (new Vector3(aimAt.x, 0f, aimAt.z) - new Vector3(aimFrom.x, 0f, aimFrom.z)).normalized;
	}

	public bool IsAtDestination()
	{
		return Vector3Ex.Distance2D(base.transform.position, destination) <= stoppingDist;
	}

	public bool IsAtFinalDestination()
	{
		return Vector3Ex.Distance2D(base.transform.position, finalDestination) <= stoppingDist;
	}

	public Vector3 ClosestPointAlongPath(Vector3 start, Vector3 end, Vector3 fromPos)
	{
		Vector3 vector = end - start;
		Vector3 rhs = fromPos - start;
		float num = Vector3.Dot(vector, rhs);
		float num2 = Vector3.SqrMagnitude(end - start);
		float num3 = Mathf.Clamp01(num / num2);
		return start + vector * num3;
	}

	public void FireGunTest()
	{
		if (!(UnityEngine.Time.time < nextFireTime))
		{
			nextFireTime = UnityEngine.Time.time + 0.25f;
			numBursted++;
			if (numBursted >= 4)
			{
				nextFireTime = UnityEngine.Time.time + 5f;
				numBursted = 0;
			}
			Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(2f, CannonMuzzle.rotation * Vector3.forward);
			Vector3 normalized = (CannonPitch.transform.rotation * Vector3.back + base.transform.up * -1f).normalized;
			myRigidBody.AddForceAtPosition(normalized * recoilScale, CannonPitch.transform.position, ForceMode.Impulse);
			Effect.server.Run(mainCannonMuzzleFlash.resourcePath, this, StringPool.Get(CannonMuzzle.gameObject.name), Vector3.zero, Vector3.zero);
			BaseEntity baseEntity = GameManager.server.CreateEntity(mainCannonProjectile.resourcePath, CannonMuzzle.transform.position, Quaternion.LookRotation(modifiedAimConeDirection));
			if (!(baseEntity == null))
			{
				baseEntity.SendMessage("InitializeVelocity", modifiedAimConeDirection);
				baseEntity.Spawn();
			}
		}
	}

	public void InstallPatrolPath(BasePath path)
	{
		patrolPath = path;
		currentPath = new List<Vector3>();
		currentPathIndex = -1;
	}

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		PathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		BasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);
		BasePathNode basePathNode = null;
		bool flag = false;
		List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			basePathNode = nodes[nodes.Count - 1];
		}
		else
		{
			basePathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) > 2f))
		{
			return;
		}
		if (closestToPoint == basePathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.transform.position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
		else
		{
			if (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].transform.position);
				}
			}
			foreach (BasePathNode item in path)
			{
				currentPath.Add(item.transform.position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
	}

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			BasePathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			BasePathNode basePathNode = null;
			List<BasePathNode> nearNodes = Facepunch.Pool.GetList<BasePathNode>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<BasePathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (BasePathNode item2 in nearNodes)
			{
				Stack<BasePathNode> path = new Stack<BasePathNode>();
				if (targetInfo.entity.IsVisible(item2.transform.position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					basePathNode = item2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].transform.position);
					}
				}
				foreach (BasePathNode item3 in stack)
				{
					currentPath.Add(item3.transform.position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = basePathNode.transform.position;
			}
			Facepunch.Pool.FreeList(ref nearNodes);
			Facepunch.Pool.FreeList(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

	public void DoSimpleAI()
	{
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
		if (!DoAI)
		{
			return;
		}
		if (targetList.Count > 0)
		{
			if (targetList[0].IsValid() && targetList[0].IsVisible())
			{
				mainGunTarget = targetList[0].entity as BaseCombatEntity;
			}
			else
			{
				mainGunTarget = null;
			}
			UpdateMovement_Hunt();
		}
		else
		{
			mainGunTarget = null;
			UpdateMovement_Patrol();
		}
		AdvancePathMovement();
		float num = Vector3.Distance(base.transform.position, destination);
		float value = Vector3.Distance(base.transform.position, finalDestination);
		if (num > stoppingDist)
		{
			Vector3 lhs = Direction2D(destination, base.transform.position);
			float num2 = Vector3.Dot(lhs, base.transform.right);
			float num3 = Vector3.Dot(lhs, base.transform.right);
			float num4 = Vector3.Dot(lhs, -base.transform.right);
			float num5 = Vector3.Dot(lhs, -base.transform.forward);
			if (num5 > num2)
			{
				if (num3 >= num4)
				{
					turning = 1f;
				}
				else
				{
					turning = -1f;
				}
			}
			else
			{
				turning = Mathf.Clamp(num2 * 3f, -1f, 1f);
			}
			float num6 = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));
			float num7 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(base.transform.forward, Vector3.up));
			throttle = (0.1f + Mathf.InverseLerp(0f, 20f, value) * 1f) * num6 + num7;
		}
		DoWeaponAiming();
		SendNetworkUpdate();
	}

	public void FixedUpdate()
	{
		DoSimpleAI();
		DoPhysicsMove();
		DoWeapons();
		DoHealing();
	}

	public void DoPhysicsMove()
	{
		if (base.isClient)
		{
			return;
		}
		Vector3 velocity = myRigidBody.velocity;
		throttle = Mathf.Clamp(throttle, -1f, 1f);
		leftThrottle = throttle;
		rightThrottle = throttle;
		if (turning > 0f)
		{
			rightThrottle = 0f - turning;
			leftThrottle = turning;
		}
		else if (turning < 0f)
		{
			leftThrottle = turning;
			rightThrottle = turning * -1f;
		}
		float num = Vector3.Distance(base.transform.position, GetFinalDestination());
		float num2 = Vector3.Distance(base.transform.position, GetCurrentPathDestination());
		float num3 = 15f;
		if (num2 < 20f)
		{
			float value = Vector3.Dot(PathDirection(currentPathIndex), PathDirection(currentPathIndex + 1));
			float num4 = Mathf.InverseLerp(2f, 10f, num2);
			float num5 = Mathf.InverseLerp(0.5f, 0.8f, value);
			num3 = 15f - 14f * ((1f - num5) * (1f - num4));
		}
		if (num < 20f)
		{
		}
		if (patrolPath != null)
		{
			float num6 = num3;
			foreach (PathSpeedZone speedZone in patrolPath.speedZones)
			{
				if (speedZone.WorldSpaceBounds().Contains(base.transform.position))
				{
					num6 = Mathf.Min(num6, speedZone.GetMaxSpeed());
				}
			}
			currentSpeedZoneLimit = Mathf.Lerp(currentSpeedZoneLimit, num6, UnityEngine.Time.deltaTime);
			num3 = Mathf.Min(num3, currentSpeedZoneLimit);
		}
		if (PathComplete())
		{
			num3 = 0f;
		}
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("velocity:" + velocity.magnitude + "max : " + num3);
		}
		brake = velocity.magnitude >= num3;
		ApplyBrakes((!brake) ? 0f : 1f);
		float num7 = throttle;
		leftThrottle = Mathf.Clamp(leftThrottle + num7, -1f, 1f);
		rightThrottle = Mathf.Clamp(rightThrottle + num7, -1f, 1f);
		float t = Mathf.InverseLerp(2f, 1f, velocity.magnitude * Mathf.Abs(Vector3.Dot(velocity.normalized, base.transform.forward)));
		float torqueAmount = Mathf.Lerp(moveForceMax, turnForce, t);
		float num8 = Mathf.InverseLerp(5f, 1.5f, velocity.magnitude * Mathf.Abs(Vector3.Dot(velocity.normalized, base.transform.forward)));
		ScaleSidewaysFriction(1f - num8);
		SetMotorTorque(leftThrottle, rightSide: false, torqueAmount);
		SetMotorTorque(rightThrottle, rightSide: true, torqueAmount);
		impactDamager.damageEnabled = myRigidBody.velocity.magnitude > 2f;
	}

	public void ApplyBrakes(float amount)
	{
		ApplyBrakeTorque(amount, rightSide: true);
		ApplyBrakeTorque(amount, rightSide: false);
	}

	public float GetMotorTorque(bool rightSide)
	{
		float num = 0f;
		WheelCollider[] array = ((!rightSide) ? leftWheels : rightWheels);
		foreach (WheelCollider wheelCollider in array)
		{
			num += wheelCollider.motorTorque;
		}
		return num / (float)rightWheels.Length;
	}

	public void ScaleSidewaysFriction(float scale)
	{
		float stiffness = 0.75f + 0.75f * scale;
		WheelCollider[] array = rightWheels;
		foreach (WheelCollider wheelCollider in array)
		{
			WheelFrictionCurve sidewaysFriction = wheelCollider.sidewaysFriction;
			sidewaysFriction.stiffness = stiffness;
			wheelCollider.sidewaysFriction = sidewaysFriction;
		}
		WheelCollider[] array2 = leftWheels;
		foreach (WheelCollider wheelCollider2 in array2)
		{
			WheelFrictionCurve sidewaysFriction2 = wheelCollider2.sidewaysFriction;
			sidewaysFriction2.stiffness = stiffness;
			wheelCollider2.sidewaysFriction = sidewaysFriction2;
		}
	}

	public void SetMotorTorque(float newThrottle, bool rightSide, float torqueAmount)
	{
		newThrottle = Mathf.Clamp(newThrottle, -1f, 1f);
		float num = torqueAmount * newThrottle;
		int num2 = ((!rightSide) ? leftWheels.Length : rightWheels.Length);
		float num3 = torqueAmount * (float)num2;
		int num4 = 0;
		WheelCollider[] array = ((!rightSide) ? leftWheels : rightWheels);
		foreach (WheelCollider wheelCollider in array)
		{
			if (wheelCollider.GetGroundHit(out var _))
			{
				num4++;
			}
		}
		float num5 = 1f;
		if (num4 > 0)
		{
			num5 = num2 / num4;
		}
		WheelCollider[] array2 = ((!rightSide) ? leftWheels : rightWheels);
		foreach (WheelCollider wheelCollider2 in array2)
		{
			if (wheelCollider2.GetGroundHit(out var _))
			{
				wheelCollider2.motorTorque = num * num5;
			}
			else
			{
				wheelCollider2.motorTorque = num;
			}
		}
	}

	public void ApplyBrakeTorque(float amount, bool rightSide)
	{
		float num = brakeForce;
		WheelCollider[] array = ((!rightSide) ? leftWheels : rightWheels);
		foreach (WheelCollider wheelCollider in array)
		{
			wheelCollider.brakeTorque = brakeForce * amount;
		}
	}

	public override void OnKilled(HitInfo info)
	{
		if (base.isClient)
		{
			return;
		}
		Effect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);
		Vector3 zero = Vector3.zero;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);
		for (int i = 0; i < 12 - maxCratesToSpawn; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);
			if (!baseEntity)
			{
				continue;
			}
			float min = 3f;
			float max = 10f;
			Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
			baseEntity.transform.position = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * UnityEngine.Random.Range(-4f, 4f);
			Collider component = baseEntity.GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(zero + onUnitSphere * UnityEngine.Random.Range(min, max));
			foreach (ServerGib item in list)
			{
				UnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;
			Vector3 pos = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if ((bool)lootContainer)
			{
				lootContainer.Invoke(lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = baseEntity2.GetComponent<Collider>();
			Rigidbody rigidbody = baseEntity2.gameObject.AddComponent<Rigidbody>();
			rigidbody.useGravity = true;
			rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
			rigidbody.mass = 2f;
			rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
			rigidbody.velocity = zero + onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);
			rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
			rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath, baseEntity2.transform.position) as FireBall;
			if ((bool)fireBall)
			{
				fireBall.transform.position = baseEntity2.transform.position;
				fireBall.Spawn();
				fireBall.GetComponent<Rigidbody>().isKinematic = true;
				fireBall.GetComponent<Collider>().enabled = false;
				fireBall.transform.parent = baseEntity2.transform;
			}
			baseEntity2.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);
			foreach (ServerGib item2 in list)
			{
				UnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);
			}
		}
		base.OnKilled(info);
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (basePlayer != null)
		{
			AddOrUpdateTarget(basePlayer, info.PointStart, info.damageTypes.Total());
		}
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		SetFlag(Flags.Reserved2, base.healthFraction <= 0.75f);
		SetFlag(Flags.Reserved3, base.healthFraction < 0.4f);
	}

	public void DoHealing()
	{
		if (!base.isClient && base.healthFraction < 1f && base.SecondsSinceAttacked > 300f)
		{
			float amount = MaxHealth() / 60f * UnityEngine.Time.fixedDeltaTime;
			Heal(amount);
		}
	}

	public bool HasPath()
	{
		return currentPath != null && currentPath.Count > 0;
	}

	public void ClearPath()
	{
		currentPath.Clear();
		currentPathIndex = -1;
	}

	public bool IndexValid(int index)
	{
		if (!HasPath())
		{
			return false;
		}
		return index >= 0 && index < currentPath.Count;
	}

	public Vector3 GetFinalDestination()
	{
		if (!HasPath())
		{
			return base.transform.position;
		}
		return finalDestination;
	}

	public Vector3 GetCurrentPathDestination()
	{
		if (!HasPath())
		{
			return base.transform.position;
		}
		return currentPath[currentPathIndex];
	}

	public bool PathComplete()
	{
		return !HasPath() || (currentPathIndex == currentPath.Count - 1 && AtCurrentPathNode());
	}

	public bool AtCurrentPathNode()
	{
		if (currentPathIndex < 0 || currentPathIndex >= currentPath.Count)
		{
			return false;
		}
		return Vector3.Distance(base.transform.position, currentPath[currentPathIndex]) <= stoppingDist;
	}

	public int GetLoopedIndex(int index)
	{
		if (!HasPath())
		{
			Debug.LogWarning("Warning, GetLoopedIndex called without a path");
			return 0;
		}
		if (!pathLooping)
		{
			return Mathf.Clamp(index, 0, currentPath.Count - 1);
		}
		if (index >= currentPath.Count)
		{
			return index % currentPath.Count;
		}
		if (index < 0)
		{
			return currentPath.Count - Mathf.Abs(index % currentPath.Count);
		}
		return index;
	}

	public Vector3 PathDirection(int index)
	{
		if (!HasPath() || currentPath.Count <= 1)
		{
			return base.transform.forward;
		}
		index = GetLoopedIndex(index);
		Vector3 zero = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		if (pathLooping)
		{
			int loopedIndex = GetLoopedIndex(index - 1);
			zero = currentPath[loopedIndex];
			zero2 = currentPath[GetLoopedIndex(index)];
		}
		else
		{
			zero = ((index - 1 >= 0) ? currentPath[index - 1] : base.transform.position);
			zero2 = currentPath[index];
		}
		return (zero2 - zero).normalized;
	}

	public Vector3 IdealPathPosition()
	{
		if (!HasPath())
		{
			return base.transform.position;
		}
		int loopedIndex = GetLoopedIndex(currentPathIndex - 1);
		if (loopedIndex == currentPathIndex)
		{
			return currentPath[currentPathIndex];
		}
		return ClosestPointAlongPath(currentPath[loopedIndex], currentPath[currentPathIndex], GetEstimatedWorldPosition());
	}

	public void AdvancePathMovement()
	{
		if (HasPath())
		{
			if (AtCurrentPathNode() || currentPathIndex == -1)
			{
				currentPathIndex = GetLoopedIndex(currentPathIndex + 1);
			}
			if (PathComplete())
			{
				ClearPath();
				return;
			}
			Vector3 vector = IdealPathPosition();
			float a = Vector3.Distance(vector, currentPath[currentPathIndex]);
			float value = Vector3.Distance(base.transform.position, vector);
			float num = Mathf.InverseLerp(8f, 0f, value);
			vector += Direction2D(currentPath[currentPathIndex], vector) * Mathf.Min(a, num * 20f);
			SetDestination(vector);
		}
	}

	public bool GetPathToClosestTurnableNode(BasePathNode start, Vector3 forward, ref List<BasePathNode> nodes)
	{
		float num = float.NegativeInfinity;
		BasePathNode basePathNode = null;
		foreach (BasePathNode item in start.linked)
		{
			float num2 = Vector3.Dot(forward, (item.transform.position - start.transform.position).normalized);
			if (num2 > num)
			{
				num = num2;
				basePathNode = item;
			}
		}
		if (basePathNode != null)
		{
			nodes.Add(basePathNode);
			if (!basePathNode.straightaway)
			{
				return true;
			}
			return GetPathToClosestTurnableNode(basePathNode, (basePathNode.transform.position - start.transform.position).normalized, ref nodes);
		}
		return false;
	}

	public bool GetEngagementPath(ref List<BasePathNode> nodes)
	{
		BasePathNode closestToPoint = patrolPath.GetClosestToPoint(base.transform.position);
		Vector3 normalized = (closestToPoint.transform.position - base.transform.position).normalized;
		float num = Vector3.Dot(base.transform.forward, normalized);
		if (num > 0f)
		{
			nodes.Add(closestToPoint);
			if (!closestToPoint.straightaway)
			{
				return true;
			}
		}
		return GetPathToClosestTurnableNode(closestToPoint, base.transform.forward, ref nodes);
	}

	public void AddOrUpdateTarget(BaseEntity ent, Vector3 pos, float damageFrom = 0f)
	{
		if (!(ent is BasePlayer))
		{
			return;
		}
		TargetInfo targetInfo = null;
		foreach (TargetInfo target in targetList)
		{
			if (target.entity == ent)
			{
				targetInfo = target;
				break;
			}
		}
		if (targetInfo == null)
		{
			targetInfo = Facepunch.Pool.Get<TargetInfo>();
			targetInfo.Setup(ent, UnityEngine.Time.time - 1f);
			targetList.Add(targetInfo);
		}
		targetInfo.lastSeenPosition = pos;
		targetInfo.damageReceivedFrom += damageFrom;
	}

	public void UpdateTargetList()
	{
		List<BaseEntity> obj = Facepunch.Pool.GetList<BaseEntity>();
		Vis.Entities(base.transform.position, searchRange, obj, 133120);
		foreach (BaseEntity item in obj)
		{
			if (!(item is BasePlayer))
			{
				continue;
			}
			BasePlayer basePlayer = item as BasePlayer;
			if (basePlayer.IsDead() || !VisibilityTest(item))
			{
				continue;
			}
			bool flag = false;
			foreach (TargetInfo target in targetList)
			{
				if (target.entity == item)
				{
					target.lastSeenTime = UnityEngine.Time.time;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				TargetInfo targetInfo = Facepunch.Pool.Get<TargetInfo>();
				targetInfo.Setup(item, UnityEngine.Time.time);
				targetList.Add(targetInfo);
			}
		}
		for (int num = targetList.Count - 1; num >= 0; num--)
		{
			TargetInfo obj2 = targetList[num];
			BasePlayer basePlayer2 = obj2.entity as BasePlayer;
			if (obj2.entity == null || UnityEngine.Time.time - obj2.lastSeenTime > memoryDuration || basePlayer2.IsDead())
			{
				targetList.Remove(obj2);
				Facepunch.Pool.Free(ref obj2);
			}
		}
		Facepunch.Pool.FreeList(ref obj);
		targetList.Sort(SortTargets);
	}

	public int SortTargets(TargetInfo t1, TargetInfo t2)
	{
		return t2.GetPriorityScore(this).CompareTo(t1.GetPriorityScore(this));
	}

	public Vector3 GetAimPoint(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if (basePlayer != null)
		{
			return basePlayer.eyes.position;
		}
		return ent.CenterPoint();
	}

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.GetEstimatedWorldPosition(), base.transform.position) < viewDistance))
		{
			return false;
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			return basePlayer.IsVisible(position, CenterPoint()) || basePlayer.IsVisible(position, basePlayer.eyes.position) || basePlayer.IsVisible(position, basePlayer.transform.position);
		}
		Debug.LogWarning("Standard vis test!");
		return IsVisible(ent.CenterPoint());
	}

	public void UpdateTargetVisibilities()
	{
		foreach (TargetInfo target in targetList)
		{
			if (target.IsValid() && VisibilityTest(target.entity))
			{
				target.lastSeenTime = UnityEngine.Time.time;
				target.lastSeenPosition = target.entity.GetEstimatedWorldPosition();
			}
		}
	}

	public void DoWeaponAiming()
	{
		desiredAimVector = ((!(mainGunTarget != null)) ? desiredAimVector : (GetAimPoint(mainGunTarget) - mainTurretEyePos.transform.position).normalized);
		BaseEntity baseEntity = null;
		if (targetList.Count > 0)
		{
			if (targetList.Count > 1 && targetList[1].IsValid() && targetList[1].IsVisible())
			{
				baseEntity = targetList[1].entity;
			}
			else if (targetList[0].IsValid() && targetList[0].IsVisible())
			{
				baseEntity = targetList[0].entity;
			}
		}
		desiredTopTurretAimVector = ((!(baseEntity != null)) ? base.transform.forward : (GetAimPoint(baseEntity) - topTurretEyePos.transform.position).normalized);
	}

	public void DoWeapons()
	{
		if (!(mainGunTarget != null) || !(Vector3.Dot(turretAimVector, (GetAimPoint(mainGunTarget) - mainTurretEyePos.transform.position).normalized) >= 0.99f))
		{
			return;
		}
		bool flag = VisibilityTest(mainGunTarget);
		float num = Vector3.Distance(mainGunTarget.transform.position, base.transform.position);
		if (UnityEngine.Time.time > nextCoaxTime && flag && num <= 40f)
		{
			numCoaxBursted++;
			FireGun(GetAimPoint(mainGunTarget), 3f, isCoax: true);
			nextCoaxTime = UnityEngine.Time.time + coaxFireRate;
			if (numCoaxBursted >= 10)
			{
				nextCoaxTime = UnityEngine.Time.time + 1f;
				numCoaxBursted = 0;
			}
		}
		if (num >= 10f && flag)
		{
			FireGunTest();
		}
	}

	public void FireGun(Vector3 targetPos, float aimCone, bool isCoax)
	{
		Transform transform = ((!isCoax) ? topTurretMuzzle : coaxMuzzle);
		Vector3 vector = transform.transform.position - transform.forward * 0.25f;
		Vector3 normalized = (targetPos - vector).normalized;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, normalized);
		targetPos = vector + modifiedAimConeDirection * 300f;
		List<RaycastHit> obj = Facepunch.Pool.GetList<RaycastHit>();
		GamePhysics.TraceAll(new Ray(vector, modifiedAimConeDirection), 0f, obj, 300f, 1084435201);
		for (int i = 0; i < obj.Count; i++)
		{
			RaycastHit hit = obj[i];
			BaseEntity entity = RaycastHitEx.GetEntity(hit);
			if (!(entity != null) || (!(entity == this) && !entity.EqualNetID(this)))
			{
				BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					ApplyDamage(baseCombatEntity, hit.point, modifiedAimConeDirection);
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					targetPos = hit.point;
					break;
				}
			}
		}
		ClientRPC(null, "CLIENT_FireGun", isCoax, targetPos);
		Facepunch.Pool.FreeList(ref obj);
	}

	private void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
	{
		float damageAmount = bulletDamage * UnityEngine.Random.Range(0.9f, 1.1f);
		HitInfo info = new HitInfo(this, entity, DamageType.Bullet, damageAmount, point);
		entity.OnAttacked(info);
		if (entity is BasePlayer || entity is BaseNpc)
		{
			HitInfo hitInfo = new HitInfo();
			hitInfo.HitPositionWorld = point;
			hitInfo.HitNormalWorld = -normal;
			hitInfo.HitMaterial = StringPool.Get("Flesh");
			Effect.server.ImpactEffect(hitInfo);
		}
	}

	public void AimWeaponAt(Transform weaponYaw, Transform weaponPitch, Vector3 direction, float minPitch = -360f, float maxPitch = 360f, float maxYaw = 360f, Transform parentOverride = null)
	{
		Vector3 direction2 = direction;
		Transform parent = weaponYaw.parent;
		direction2 = parent.InverseTransformDirection(direction2);
		Quaternion localRotation = Quaternion.LookRotation(direction2);
		Vector3 eulerAngles = localRotation.eulerAngles;
		for (int i = 0; i < 3; i++)
		{
			eulerAngles[i] -= ((!(eulerAngles[i] > 180f)) ? 0f : 360f);
		}
		Quaternion localRotation2 = Quaternion.Euler(0f, Mathf.Clamp(eulerAngles.y, 0f - maxYaw, maxYaw), 0f);
		Quaternion localRotation3 = Quaternion.Euler(Mathf.Clamp(eulerAngles.x, minPitch, maxPitch), 0f, 0f);
		if (weaponYaw == null && weaponPitch != null)
		{
			weaponPitch.transform.localRotation = localRotation3;
			return;
		}
		if (weaponPitch == null && weaponYaw != null)
		{
			weaponYaw.transform.localRotation = localRotation;
			return;
		}
		weaponYaw.transform.localRotation = localRotation2;
		weaponPitch.transform.localRotation = localRotation3;
	}

	public void LateUpdate()
	{
		float num = UnityEngine.Time.time - lastLateUpdate;
		lastLateUpdate = UnityEngine.Time.time;
		if (base.isServer)
		{
			float num2 = (float)Math.PI * 2f / 3f;
			turretAimVector = Vector3.RotateTowards(turretAimVector, desiredAimVector, num2 * num, 0f);
		}
		else
		{
			turretAimVector = Vector3.Lerp(turretAimVector, desiredAimVector, UnityEngine.Time.deltaTime * 10f);
		}
		AimWeaponAt(mainTurret, coaxPitch, turretAimVector, -90f, 90f);
		AimWeaponAt(mainTurret, CannonPitch, turretAimVector, -90f, 7f);
		topTurretAimVector = Vector3.Lerp(topTurretAimVector, desiredTopTurretAimVector, UnityEngine.Time.deltaTime * 5f);
		AimWeaponAt(topTurretYaw, topTurretPitch, topTurretAimVector, -360f, 360f, 360f, mainTurret);
	}
}
