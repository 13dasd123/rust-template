using UnityEngine;

public class GenerateTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		int res = TerrainMeta.TopologyMap.res;
		int[,] map = TerrainMeta.TopologyMap.dst;
		TerrainBiomeMap biomemap = TerrainMeta.BiomeMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		float noiseX = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float noiseZ = SeedRandom.Range(ref seed, -1E+09f, 1E+09f);
		float normfac = 1f / (float)(res - 1);
		Parallel.For(0, res, delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float num = (float)i * normfac;
				float num2 = (float)z * normfac;
				float height = heightmap.GetHeight01(num, num2);
				float slope = heightmap.GetSlope(num, num2);
				int num3 = map[z, i];
				if (height < 0.5f)
				{
					num3 |= 0x10000;
					float num4 = num * 2f - 1f;
					float num5 = num2 * 2f - 1f;
					float a = (num4 * num4 + num5 * num5) * 0.75f;
					float b = Mathf.Max(Mathf.Abs(num4), Mathf.Abs(num5));
					if (Mathf.Max(a, b) > 0.9f)
					{
						num3 |= 0x40000;
					}
				}
				else if (height < 0.502f)
				{
					num3 |= 0x10;
				}
				else if (height > 0.6f)
				{
					num3 |= 4;
				}
				else
				{
					switch (biomemap.GetBiomeMaxIndex(num, num2))
					{
					case 0:
					{
						float num8 = Noise.Ridge((float)i * 0.75f + noiseX, (float)z + noiseZ, 6, 0.006000000052154064);
						num3 |= ((!(num8 > 1.4f)) ? 1 : 32);
						break;
					}
					case 1:
					{
						float num7 = Noise.Ridge((float)i * 0.75f + noiseX, (float)z + noiseZ, 6, 0.003000000026077032);
						num3 |= ((!(num7 > 1.3f)) ? 1 : 32);
						break;
					}
					case 2:
					{
						float num9 = Noise.Ridge((float)i * 0.75f + noiseX, (float)z + noiseZ, 6, 0.003000000026077032);
						num3 |= ((!(num9 > 1.4f)) ? 1 : 32);
						break;
					}
					default:
					{
						float num6 = Noise.Ridge((float)i * 0.75f + noiseX, (float)z + noiseZ, 6, 0.006000000052154064);
						num3 |= ((!(num6 > 1.4f)) ? 1 : 32);
						break;
					}
					}
				}
				if ((num3 & 0x30198) != 0)
				{
					if (slope > 35f)
					{
						num3 |= 2;
					}
				}
				else if (slope > 40f)
				{
					num3 |= 2;
				}
				map[z, i] = num3;
			}
		});
		ImageProcessing.FloodFill2D(0, 0, map, 65536, (int v) => (v & -65537) | 0x80);
		ImageProcessing.Dilate2D(map, 24, 2, delegate(int x, int y)
		{
			if ((map[x, y] & 0x21) != 0)
			{
				map[x, y] |= 8;
			}
		});
		ImageProcessing.Dilate2D(map, 41, 2, delegate(int x, int y)
		{
			if ((map[x, y] & 0x10) != 0)
			{
				map[x, y] |= 8;
			}
		});
		ImageProcessing.Dilate2D(map, 384, 4, delegate(int x, int y)
		{
			if ((map[x, y] & 0x10) != 0)
			{
				map[x, y] |= 256;
			}
		});
		ImageProcessing.Dilate2D(map, 272, 4, delegate(int x, int y)
		{
			if ((map[x, y] & 0x80) != 0)
			{
				map[x, y] |= 256;
			}
		});
		ImageProcessing.Dilate2D(map, 196608, 4, delegate(int x, int y)
		{
			if ((map[x, y] & 0x10) != 0)
			{
				map[x, y] |= 131072;
			}
		});
		ImageProcessing.Dilate2D(map, 131088, 4, delegate(int x, int y)
		{
			if ((map[x, y] & 0x10000) != 0)
			{
				map[x, y] |= 131072;
			}
		});
		ImageProcessing.Dilate2D(map, 96, 4, delegate(int x, int y)
		{
			if ((map[x, y] & 1) != 0)
			{
				map[x, y] |= 64;
			}
		});
		Parallel.For(0, res, delegate(int z)
		{
			for (int j = 0; j < res; j++)
			{
				float normX = (float)j * normfac;
				float normZ = (float)z * normfac;
				float height2 = heightmap.GetHeight01(normX, normZ);
				if (height2 > 0.495f && height2 < 0.5f)
				{
					int num10 = map[z, j];
					if ((num10 & 0x80) != 0)
					{
						num10 |= 0x100;
					}
					if ((num10 & 0x10000) != 0)
					{
						num10 |= 0x20000;
					}
					map[z, j] = num10;
				}
			}
		});
	}
}
