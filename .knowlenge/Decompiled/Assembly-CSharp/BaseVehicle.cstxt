using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BaseVehicle : BaseMountable
{
	[Serializable]
	public class MountPointInfo
	{
		public Vector3 pos;

		public Vector3 rot;

		public string bone = "";

		public GameObjectRef prefab;

		public BaseMountable mountable;
	}

	public GameObjectRef serverGibs;

	[Tooltip("Allow players to mount other mountables/ladders from this vehicle")]
	public bool mountChaining = true;

	public bool shouldShowHudHealth;

	[Header("Rigidbody (Optional)")]
	public Rigidbody rigidBody;

	[Header("Mount Points")]
	public MountPointInfo[] mountPoints;

	public const Flags Flag_Headlights = Flags.Reserved5;

	public const Flags Flag_Stationary = Flags.Reserved7;

	public bool seatClipCheck;

	public override bool DirectlyMountable()
	{
		return true;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public bool HasAnyPassengers()
	{
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			if (mountPointInfo.mountable != null && (bool)mountPointInfo.mountable.GetMounted())
			{
				return true;
			}
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		base.VehicleFixedUpdate();
		if (seatClipCheck && HasAnyPassengers())
		{
			Vector3 center = base.transform.TransformPoint(bounds.center);
			int layerMask = 1210122497;
			if (Physics.OverlapBox(center, bounds.extents, base.transform.rotation, layerMask).Length != 0)
			{
				CheckSeatsForClipping();
			}
		}
		if ((bool)rigidBody)
		{
			SetFlag(Flags.Reserved7, rigidBody.IsSleeping() && !HasAnyPassengers());
		}
	}

	public virtual bool IsSeatVisible(BaseMountable mountable, Vector3 eyePos, int mask = 1218511105)
	{
		if (mountable == null)
		{
			return false;
		}
		Vector3 p = mountable.transform.position + base.transform.up * 0.15f;
		return GamePhysics.LineOfSight(eyePos, p, mask);
	}

	public virtual bool IsSeatClipping(BaseMountable mountable, int mask = 1218511105)
	{
		if (mountable == null)
		{
			return false;
		}
		Vector3 position = mountable.transform.position;
		Vector3 position2 = mountable.eyeOverride.transform.position;
		Vector3 end = position + base.transform.up * 0.15f;
		return GamePhysics.CheckCapsule(position2, end, 0.1f, mask);
	}

	public virtual void CheckSeatsForClipping()
	{
		MountPointInfo[] array = mountPoints;
		for (int i = 0; i < array.Length; i++)
		{
			BaseMountable mountable = array[i].mountable;
			if (!(mountable == null) && mountable.IsMounted() && IsSeatClipping(mountable, 1210122497))
			{
				SeatClippedWorld(mountable);
			}
		}
	}

	public virtual void SeatClippedWorld(BaseMountable mountable)
	{
		mountable.DismountPlayer(mountable.GetMounted());
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
	}

	public override void DismountAllPlayers()
	{
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			if (mountPointInfo.mountable != null)
			{
				mountPointInfo.mountable.DismountAllPlayers();
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public virtual void SpawnSubEntities()
	{
		for (int i = 0; i < mountPoints.Length; i++)
		{
			MountPointInfo mountPointInfo = mountPoints[i];
			Vector3 vector = Quaternion.Euler(mountPointInfo.rot) * Vector3.forward;
			Vector3 pos = mountPointInfo.pos;
			Vector3 up = Vector3.up;
			if (mountPointInfo.bone != "")
			{
				pos = model.FindBone(mountPointInfo.bone).transform.position + base.transform.TransformDirection(mountPointInfo.pos);
				vector = base.transform.TransformDirection(vector);
				up = base.transform.up;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(mountPointInfo.prefab.resourcePath, pos, Quaternion.LookRotation(vector, up));
			baseEntity.Spawn();
			if (mountPointInfo.bone != "")
			{
				baseEntity.SetParent(this, mountPointInfo.bone, worldPositionStays: true, sendImmediate: true);
			}
			else
			{
				baseEntity.SetParent(this);
			}
			mountPointInfo.mountable = baseEntity.GetComponent<BaseMountable>();
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		SpawnSubEntities();
	}

	public bool AnyMounted()
	{
		return NumMounted() > 0;
	}

	public int NumMounted()
	{
		if (!HasMountPoints())
		{
			if (!IsMounted())
			{
				return 0;
			}
			return 1;
		}
		int num = 0;
		for (int i = 0; i < mountPoints.Length; i++)
		{
			MountPointInfo mountPointInfo = mountPoints[i];
			if (mountPointInfo.mountable != null && mountPointInfo.mountable.GetMounted() != null)
			{
				num++;
			}
		}
		return num;
	}

	public bool HasDriver()
	{
		if (!HasMountPoints())
		{
			return IsMounted();
		}
		MountPointInfo mountPointInfo = mountPoints[0];
		if (mountPointInfo == null || mountPointInfo.mountable == null)
		{
			return false;
		}
		return mountPointInfo.mountable.IsMounted();
	}

	public BasePlayer GetDriver()
	{
		if (!HasMountPoints())
		{
			return _mounted;
		}
		MountPointInfo mountPointInfo = mountPoints[0];
		if (mountPointInfo == null || mountPointInfo.mountable == null)
		{
			return null;
		}
		return mountPointInfo.mountable.GetMounted();
	}

	public int GetPlayerSeat(BasePlayer player)
	{
		if (!HasMountPoints() && GetMounted() == player)
		{
			return 0;
		}
		for (int i = 0; i < mountPoints.Length; i++)
		{
			MountPointInfo mountPointInfo = mountPoints[i];
			if (mountPointInfo.mountable != null && mountPointInfo.mountable.GetMounted() == player)
			{
				return i;
			}
		}
		return -1;
	}

	public void SwapSeats(BasePlayer player, int targetSeat = 0)
	{
		if (!HasMountPoints())
		{
			return;
		}
		int playerSeat = GetPlayerSeat(player);
		if (playerSeat == -1)
		{
			return;
		}
		BaseMountable mountable = mountPoints[playerSeat].mountable;
		int num = playerSeat;
		BaseMountable baseMountable = null;
		if (baseMountable == null)
		{
			for (int i = 0; i < mountPoints.Length; i++)
			{
				num++;
				if (num >= mountPoints.Length)
				{
					num = 0;
				}
				MountPointInfo mountPointInfo = mountPoints[num];
				if (mountPointInfo.mountable != null && !mountPointInfo.mountable.IsMounted() && !IsSeatClipping(mountPointInfo.mountable) && IsSeatVisible(mountPointInfo.mountable, player.eyes.position))
				{
					baseMountable = mountPointInfo.mountable;
					break;
				}
			}
		}
		if (baseMountable != null && baseMountable != mountable)
		{
			mountable.DismountPlayer(player, lite: true);
			baseMountable.MountPlayer(player);
			player.MarkSwapSeat();
		}
	}

	public bool HasMountPoints()
	{
		return mountPoints.Length != 0;
	}

	public BaseMountable GetIdealMountPoint(Vector3 pos)
	{
		if (!HasMountPoints())
		{
			return this;
		}
		BaseMountable result = null;
		float num = float.PositiveInfinity;
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			float num2 = Vector3.Distance(mountPointInfo.mountable.mountAnchor.position, pos);
			if (num2 < num && !mountPointInfo.mountable.IsMounted() && !IsSeatClipping(mountPointInfo.mountable) && IsSeatVisible(mountPointInfo.mountable, pos))
			{
				result = mountPointInfo.mountable;
				num = num2;
			}
		}
		return result;
	}

	public override bool IsMounted()
	{
		return HasDriver();
	}

	public virtual bool MountEligable()
	{
		return true;
	}

	public int GetIndexFromSeat(BaseMountable seat)
	{
		for (int i = 0; i < mountPoints.Length; i++)
		{
			if (mountPoints[i].mountable == seat)
			{
				return i;
			}
		}
		return -1;
	}

	public virtual void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
	}

	public virtual void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
	}

	public override void AttemptMount(BasePlayer player)
	{
		if (_mounted != null || !MountEligable())
		{
			return;
		}
		BaseMountable idealMountPoint = GetIdealMountPoint(player.eyes.position);
		if (!(idealMountPoint == null))
		{
			if (idealMountPoint == this)
			{
				base.AttemptMount(player);
			}
			else
			{
				idealMountPoint.AttemptMount(player);
			}
			if (player.GetMountedVehicle() == this)
			{
				PlayerMounted(player, idealMountPoint);
			}
		}
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (baseVehicle != null)
		{
			return baseVehicle.GetDismountPosition(player, out res);
		}
		List<Vector3> obj = Pool.GetList<Vector3>();
		Transform[] array = dismountPositions;
		foreach (Transform transform in array)
		{
			if (ValidDismountPosition(transform.transform.position))
			{
				obj.Add(transform.transform.position);
			}
		}
		if (obj.Count == 0)
		{
			Debug.LogWarning("Failed to find dismount position for player :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			Pool.FreeList(ref obj);
			res = player.transform.position;
			return false;
		}
		Vector3 pos = player.transform.position;
		obj.Sort((Vector3 a, Vector3 b) => Vector3.Distance(a, pos).CompareTo(Vector3.Distance(b, pos)));
		res = obj[0];
		Pool.FreeList(ref obj);
		return true;
	}

	public override bool SupportsChildDeployables()
	{
		return false;
	}
}
