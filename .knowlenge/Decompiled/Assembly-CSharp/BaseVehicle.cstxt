using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BaseVehicle : BaseMountable
{
	[Serializable]
	public class MountPointInfo
	{
		public Vector3 pos;

		public Vector3 rot;

		public GameObjectRef prefab;

		public BaseMountable mountable;
	}

	public GameObjectRef serverGibs;

	[Header("Mount Points")]
	public MountPointInfo[] mountPoints;

	public const Flags Flag_Headlights = Flags.Reserved5;

	public bool seatClipCheck;

	public override bool DirectlyMountable()
	{
		return true;
	}

	public bool HasAnyPassengers()
	{
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			if (mountPointInfo.mountable != null && (bool)mountPointInfo.mountable.GetMounted())
			{
				return true;
			}
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		base.VehicleFixedUpdate();
		if (seatClipCheck && HasAnyPassengers())
		{
			Vector3 center = base.transform.TransformPoint(bounds.center);
			int layerMask = 1210122497;
			Collider[] array = Physics.OverlapBox(center, bounds.extents, base.transform.rotation, layerMask);
			if (array.Length > 0)
			{
				CheckSeatsForClipping();
			}
		}
	}

	public virtual bool IsSeatClipping(BaseMountable mountable, bool checkWhenEmpty = false)
	{
		if (!seatClipCheck)
		{
			return false;
		}
		if (mountable == null)
		{
			return false;
		}
		if (!mountable.IsMounted() && !checkWhenEmpty)
		{
			return false;
		}
		Vector3 position = mountable.transform.position;
		Vector3 localPosition = mountable.eyeOverride.transform.localPosition;
		Vector3 position2 = mountable.eyeOverride.transform.position;
		Vector3 vector = position + base.transform.up * 0.15f;
		int layerMask = 1210122497;
		float maxDistance = Vector3.Distance(vector, position2);
		Ray ray = new Ray(vector, base.transform.up);
		if (Physics.SphereCast(ray, 0.1f, maxDistance, layerMask))
		{
			return true;
		}
		return false;
	}

	public virtual void CheckSeatsForClipping()
	{
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			BaseMountable mountable = mountPointInfo.mountable;
			if (IsSeatClipping(mountable))
			{
				SeatClippedWorld(mountable);
			}
		}
	}

	public virtual void SeatClippedWorld(BaseMountable mountable)
	{
		mountable.DismountPlayer(mountable.GetMounted());
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
	}

	public override void DismountAllPlayers()
	{
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			if (mountPointInfo.mountable != null)
			{
				mountPointInfo.mountable.DismountAllPlayers();
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public virtual void SpawnSubEntities()
	{
		for (int i = 0; i < mountPoints.Length; i++)
		{
			MountPointInfo mountPointInfo = mountPoints[i];
			Vector3 forward = Quaternion.Euler(mountPointInfo.rot) * Vector3.forward;
			BaseEntity baseEntity = GameManager.server.CreateEntity(mountPointInfo.prefab.resourcePath, mountPointInfo.pos, Quaternion.LookRotation(forward, Vector3.up));
			baseEntity.Spawn();
			baseEntity.SetParent(this);
			mountPointInfo.mountable = baseEntity.GetComponent<BaseMountable>();
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		SpawnSubEntities();
	}

	public bool HasDriver()
	{
		if (!HasMountPoints())
		{
			return IsMounted();
		}
		MountPointInfo mountPointInfo = mountPoints[0];
		if (mountPointInfo == null || mountPointInfo.mountable == null)
		{
			return false;
		}
		return mountPointInfo.mountable.IsMounted();
	}

	public int GetPlayerSeat(BasePlayer player)
	{
		if (!HasMountPoints() && GetMounted() == player)
		{
			return 0;
		}
		for (int i = 0; i < mountPoints.Length; i++)
		{
			MountPointInfo mountPointInfo = mountPoints[i];
			if (mountPointInfo.mountable != null && mountPointInfo.mountable.GetMounted() == player)
			{
				return i;
			}
		}
		return -1;
	}

	public void SwapSeats(BasePlayer player, int targetSeat = 0)
	{
		if (!HasMountPoints())
		{
			return;
		}
		int playerSeat = GetPlayerSeat(player);
		if (playerSeat == -1)
		{
			return;
		}
		BaseMountable mountable = mountPoints[playerSeat].mountable;
		int num = playerSeat;
		BaseMountable baseMountable = null;
		if (baseMountable == null)
		{
			for (int i = 0; i < mountPoints.Length; i++)
			{
				num++;
				if (num >= mountPoints.Length)
				{
					num = 0;
				}
				MountPointInfo mountPointInfo = mountPoints[num];
				if (mountPointInfo.mountable != null && !mountPointInfo.mountable.IsMounted() && !IsSeatClipping(mountPointInfo.mountable, checkWhenEmpty: true))
				{
					baseMountable = mountPointInfo.mountable;
					break;
				}
			}
		}
		if (baseMountable != null && baseMountable != mountable)
		{
			mountable.DismountPlayer(player, lite: true);
			baseMountable.MountPlayer(player);
			player.MarkSwapSeat();
		}
	}

	public bool HasMountPoints()
	{
		return mountPoints.Length > 0;
	}

	public BaseMountable GetIdealMountPoint(Vector3 pos)
	{
		if (!HasMountPoints())
		{
			return null;
		}
		BaseMountable result = null;
		float num = float.PositiveInfinity;
		MountPointInfo[] array = mountPoints;
		foreach (MountPointInfo mountPointInfo in array)
		{
			float num2 = Vector3.Distance(mountPointInfo.mountable.mountAnchor.position, pos);
			if (num2 < num && !mountPointInfo.mountable.IsMounted() && !IsSeatClipping(mountPointInfo.mountable, checkWhenEmpty: true))
			{
				result = mountPointInfo.mountable;
				num = num2;
			}
		}
		return result;
	}

	public override bool IsMounted()
	{
		return HasDriver();
	}

	public virtual bool MountEligable()
	{
		return true;
	}

	public override void AttemptMount(BasePlayer player)
	{
		if (_mounted != null || !MountEligable())
		{
			return;
		}
		BaseMountable idealMountPoint = GetIdealMountPoint(player.transform.position);
		if (!(idealMountPoint == null))
		{
			if (idealMountPoint == this)
			{
				base.AttemptMount(player);
			}
			else
			{
				idealMountPoint.AttemptMount(player);
			}
		}
	}

	public override bool AttemptDismount(BasePlayer player)
	{
		if (player != _mounted)
		{
			return false;
		}
		DismountPlayer(player);
		return true;
	}

	public override Vector3 GetDismountPosition(BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (baseVehicle != null)
		{
			return baseVehicle.GetDismountPosition(player);
		}
		List<Vector3> obj = Pool.GetList<Vector3>();
		Transform[] array = dismountPositions;
		foreach (Transform transform in array)
		{
			if (ValidDismountPosition(transform.transform.position))
			{
				obj.Add(transform.transform.position);
			}
		}
		if (obj.Count == 0)
		{
			Debug.LogWarning("Failed to find dismount position for player :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			Pool.FreeList(ref obj);
			return BaseMountable.DISMOUNT_POS_INVALID;
		}
		Vector3 pos = player.transform.position;
		obj.Sort((Vector3 a, Vector3 b) => Vector3.Distance(a, pos).CompareTo(Vector3.Distance(b, pos)));
		Vector3 result = obj[0];
		Pool.FreeList(ref obj);
		return result;
	}

	public override bool SupportsChildDeployables()
	{
		return false;
	}
}
