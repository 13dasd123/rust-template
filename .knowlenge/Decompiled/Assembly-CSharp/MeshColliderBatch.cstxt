using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public class MeshColliderBatch : MeshBatch
{
	private Vector3 position;

	private UnityEngine.Mesh meshBatch;

	private MeshCollider meshCollider;

	private MeshColliderData meshData;

	private MeshColliderGroup meshGroup;

	private MeshColliderLookup meshLookup;

	public override int VertexCapacity => Batching.collider_capacity;

	public override int VertexCutoff => Batching.collider_vertices;

	public static GameObject CreateInstance()
	{
		GameObject gameObject = new GameObject("MeshColliderBatch");
		gameObject.tag = "MeshColliderBatch";
		gameObject.AddComponent<MeshCollider>();
		gameObject.AddComponent<MeshColliderBatch>();
		return gameObject;
	}

	public Transform LookupTransform(int triangleIndex)
	{
		return meshLookup.Get(triangleIndex).transform;
	}

	public Rigidbody LookupRigidbody(int triangleIndex)
	{
		return meshLookup.Get(triangleIndex).rigidbody;
	}

	public Collider LookupCollider(int triangleIndex)
	{
		return meshLookup.Get(triangleIndex).collider;
	}

	public void LookupColliders<T>(Vector3 position, float distance, List<T> list) where T : Collider
	{
		List<MeshColliderLookup.LookupEntry> data = meshLookup.src.data;
		float num = distance * distance;
		for (int i = 0; i < data.Count; i++)
		{
			MeshColliderLookup.LookupEntry lookupEntry = data[i];
			if ((bool)lookupEntry.collider && (lookupEntry.bounds.ClosestPoint(position) - position).sqrMagnitude <= num)
			{
				list.Add(lookupEntry.collider as T);
			}
		}
	}

	protected void Awake()
	{
		meshCollider = GetComponent<MeshCollider>();
		meshData = new MeshColliderData();
		meshGroup = new MeshColliderGroup();
		meshLookup = new MeshColliderLookup();
	}

	public void Setup(Vector3 position, LayerMask layer, PhysicMaterial material)
	{
		base.transform.position = position;
		this.position = position;
		base.gameObject.layer = layer;
		meshCollider.sharedMaterial = material;
	}

	public void Add(MeshColliderInstance instance)
	{
		instance.position -= position;
		meshGroup.data.Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup.Alloc();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		meshGroup.Free();
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshLookup.dst.Clear();
		meshData.Clear();
		meshData.Combine(meshGroup, meshLookup);
	}

	protected override void ApplyMesh()
	{
		if (!meshBatch)
		{
			meshBatch = AssetPool.Get<UnityEngine.Mesh>();
		}
		meshLookup.Apply();
		meshData.Apply(meshBatch);
	}

	protected override void ToggleMesh(bool state)
	{
		if (!Rust.Application.isLoading && !Rust.Application.isQuitting)
		{
			List<MeshColliderLookup.LookupEntry> data = meshLookup.src.data;
			for (int i = 0; i < data.Count; i++)
			{
				Collider collider = data[i].collider;
				if ((bool)collider)
				{
					collider.enabled = !state;
				}
			}
		}
		if (state)
		{
			if ((bool)meshCollider)
			{
				meshCollider.sharedMesh = meshBatch;
				meshCollider.enabled = false;
				meshCollider.enabled = true;
			}
		}
		else if ((bool)meshCollider)
		{
			meshCollider.sharedMesh = null;
			meshCollider.enabled = false;
		}
	}

	protected override void OnPooled()
	{
		if ((bool)meshCollider)
		{
			meshCollider.sharedMesh = null;
		}
		if ((bool)meshBatch)
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		meshGroup.Free();
		meshLookup.src.Clear();
		meshLookup.dst.Clear();
	}
}
