using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using Facepunch.Flexbox.Utility;
using UnityEngine;
using UnityEngine.EventSystems;

[ExecuteAlways]
[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
public class FlexElement : UIBehaviour, IFlexNode
{
	private struct ChildSizingParameters
	{
		public float Size;

		public float MinSize;

		public float MaxSize;

		public bool IsFlexible;

		public float Scale;
	}

	private static readonly List<IFlexNode> SizingChildren = new List<IFlexNode>();

	[Tooltip("The direction to layout children in. This determines which axis is the main axis.")]
	public FlexDirection FlexDirection;

	[Tooltip("Where to start laying out children on the main axis.")]
	public FlexJustify JustifyContent;

	[Tooltip("How to align child flex elements on the cross axis.")]
	public FlexAlign AlignItems = FlexAlign.Stretch;

	[Tooltip("Spacing to add from this elements borders to where children are laid out.")]
	public FlexPadding Padding;

	[Min(0f)]
	[Tooltip("Spacing to add between each child flex item.")]
	public float Gap;

	[Tooltip("Controls the initial size of the element before factoring in grow/shrink.")]
	public FlexLength Basis;

	[Min(0f)]
	[Tooltip("How much this flex element should grow relative to its siblings.")]
	public int Grow;

	[Tooltip("Optionally override the parent's cross axis alignment for this element.")]
	public FlexAlignSelf AlignSelf;

	[Min(0f)]
	[Tooltip("How much this flex element should shrink relative to its siblings.")]
	public int Shrink = 1;

	[Tooltip("Absolute elements act as the root container for any number of flex elements.")]
	public bool IsAbsolute;

	[Tooltip("Automatically resize an absolute element to match the size of its children.")]
	public bool AutoSizeX;

	[Tooltip("Automatically resize an absolute element to match the size of its children.")]
	public bool AutoSizeY;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MinWidth;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MaxWidth;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MinHeight;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MaxHeight;

	private bool _isDirty;

	private bool _isDoingLayout;

	private float _prefWidth;

	private float _prefHeight;

	private int _growSum;

	private int _shrinkSum;

	private readonly List<IFlexNode> _children = new List<IFlexNode>();

	private ChildSizingParameters[] _childSizes = Array.Empty<ChildSizingParameters>();

	private bool IsHorizontal
	{
		get
		{
			if (FlexDirection != 0)
			{
				return FlexDirection == FlexDirection.RowReverse;
			}
			return true;
		}
	}

	private bool IsReversed
	{
		get
		{
			if (FlexDirection != FlexDirection.RowReverse)
			{
				return FlexDirection == FlexDirection.ColumnReverse;
			}
			return true;
		}
	}

	RectTransform IFlexNode.Transform => (RectTransform)base.transform;

	bool IFlexNode.IsActive => IsActive();

	bool IFlexNode.IsAbsolute => IsAbsolute;

	bool IFlexNode.IsDirty => _isDirty;

	FlexLength IFlexNode.MinWidth => MinWidth;

	FlexLength IFlexNode.MaxWidth => MaxWidth;

	FlexLength IFlexNode.MinHeight => MinHeight;

	FlexLength IFlexNode.MaxHeight => MaxHeight;

	FlexLength IFlexNode.Basis => Basis;

	int IFlexNode.Grow => Grow;

	int IFlexNode.Shrink => Shrink;

	FlexAlignSelf IFlexNode.AlignSelf => AlignSelf;

	public void SetLayoutDirty(bool force = false)
	{
		if (force || (!_isDoingLayout && IsActive()))
		{
			_isDirty = true;
			Transform parent = base.transform.parent;
			if (IsAbsolute || parent == null || !parent.TryGetComponent<IFlexNode>(out var component))
			{
				FlexLayoutManager.EnqueueLayout(this);
			}
			else
			{
				component.SetLayoutDirty(force);
			}
		}
	}

	internal void PerformLayout()
	{
		RectTransform rectTransform = (RectTransform)base.transform;
		Rect rect = rectTransform.rect;
		float width = rect.width;
		float height = rect.height;
		bool flag = !IsAbsolute && FlexUtility.IsPrefabRoot(base.gameObject);
		bool flag2 = AutoSizeX || flag;
		bool flag3 = AutoSizeY || flag;
		((IFlexNode)this).MeasureHorizontal();
		((IFlexNode)this).LayoutHorizontal(flag2 ? _prefWidth : width, flag3 ? _prefHeight : height);
		((IFlexNode)this).MeasureVertical();
		((IFlexNode)this).LayoutVertical(flag2 ? _prefWidth : width, flag3 ? _prefHeight : height);
		_isDoingLayout = true;
		try
		{
			if (flag2)
			{
				rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, _prefWidth);
			}
			if (flag3)
			{
				rectTransform.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, _prefHeight);
			}
		}
		finally
		{
			_isDoingLayout = false;
		}
	}

	private void MeasureMainAxis()
	{
		bool isHorizontal = IsHorizontal;
		ref float reference = ref Pick(isHorizontal, ref _prefWidth, ref _prefHeight);
		float num = (isHorizontal ? (Padding.left + Padding.right) : (Padding.top + Padding.bottom));
		float num2 = 0f;
		int num3 = 0;
		int num4 = 0;
		bool flag = true;
		foreach (IFlexNode child in _children)
		{
			if (child.IsDirty)
			{
				if (isHorizontal)
				{
					child.MeasureHorizontal();
				}
				else
				{
					child.MeasureVertical();
				}
			}
			child.GetScale(out var scaleX, out var scaleY);
			child.GetPreferredSize(out var preferredWidth, out var preferredHeight);
			FlexLength flexLength = (isHorizontal ? child.MinWidth : child.MinHeight);
			FlexLength flexLength2 = (isHorizontal ? child.MaxWidth : child.MaxHeight);
			if (!flexLength.HasValue || !flexLength2.HasValue || flexLength.Unit != flexLength2.Unit || !(flexLength.Value >= flexLength2.Value))
			{
				num3 += child.Grow;
				num4 += child.Shrink;
			}
			float num5 = (flag ? 0f : Gap);
			num2 = ((!isHorizontal) ? (num2 + (preferredHeight * scaleY + num5)) : (num2 + (preferredWidth * scaleX + num5)));
			if (flag)
			{
				flag = false;
			}
		}
		FlexLength flexLength3 = (isHorizontal ? MinWidth : MinHeight);
		FlexLength flexLength4 = (isHorizontal ? MaxWidth : MaxHeight);
		float b = ((Basis.HasValue && Basis.Unit == FlexUnit.Pixels) ? Basis.Value : 0f);
		float a = ((flexLength3.HasValue && flexLength3.Unit == FlexUnit.Pixels) ? flexLength3.Value : 0f);
		float max = ((flexLength4.HasValue && flexLength4.Unit == FlexUnit.Pixels) ? flexLength4.Value : float.PositiveInfinity);
		reference = Mathf.Clamp(num2 + num, Mathf.Max(a, b), max);
		if (IsAbsolute)
		{
			Rect rect = ((RectTransform)base.transform).rect;
			if (isHorizontal && !AutoSizeX)
			{
				reference = rect.width;
			}
			else if (!isHorizontal && !AutoSizeY)
			{
				reference = rect.height;
			}
		}
		_growSum = num3;
		_shrinkSum = num4;
	}

	private void LayoutMainAxis(float maxWidth, float maxHeight)
	{
		bool isHorizontal2 = IsHorizontal;
		bool isReversed2 = IsReversed;
		float innerSize = (isHorizontal2 ? (maxWidth - Padding.left - Padding.right) : (maxHeight - Padding.top - Padding.bottom));
		float fillValue = innerSize - (float)Mathf.Max(_children.Count - 1, 0) * Gap;
		SizingChildren.Clear();
		if (_childSizes.Length < _children.Count)
		{
			Array.Resize(ref _childSizes, _children.Count);
		}
		float num = 0f;
		bool flag = true;
		for (int i = 0; i < _children.Count; i++)
		{
			IFlexNode flexNode = _children[i];
			ref ChildSizingParameters reference = ref _childSizes[i];
			float num2 = CalculateLengthValue(isHorizontal2 ? flexNode.MinWidth : flexNode.MinHeight, fillValue, 0f);
			float num3 = CalculateLengthValue(isHorizontal2 ? flexNode.MaxWidth : flexNode.MaxHeight, fillValue, float.PositiveInfinity);
			bool flag2 = num2 < num3;
			flexNode.GetPreferredSize(out var preferredWidth, out var preferredHeight);
			float defaultValue = (isHorizontal2 ? preferredWidth : preferredHeight);
			flexNode.GetScale(out var scaleX, out var scaleY);
			float num4 = (isHorizontal2 ? scaleX : scaleY);
			float num5 = (reference.Size = Mathf.Clamp(CalculateLengthValue(flexNode.Basis, fillValue, defaultValue), num2, num3));
			reference.MinSize = num2;
			reference.MaxSize = num3;
			reference.IsFlexible = flag2;
			reference.Scale = num4;
			SizingChildren.Add(flag2 ? flexNode : null);
			num += num5 * num4;
			if (flag)
			{
				flag = false;
			}
			else
			{
				num += Gap;
			}
		}
		float growthAllowance = Mathf.Max(innerSize - num, 0f);
		float shrinkAllowance = Mathf.Max(num - innerSize, 0f);
		float actualMainSize = num;
		if (_growSum > 0 && growthAllowance > 0f)
		{
			actualMainSize = innerSize;
		}
		else if (_shrinkSum > 0 && shrinkAllowance > 0f)
		{
			actualMainSize = innerSize;
		}
		while (SizingChildren.Exists((IFlexNode n) => n != null))
		{
			int growSum = _growSum;
			int shrinkSum = _shrinkSum;
			for (int j = 0; j < SizingChildren.Count; j++)
			{
				IFlexNode child = SizingChildren[j];
				if (child != null)
				{
					ref ChildSizingParameters reference2 = ref _childSizes[j];
					bool flag3 = true;
					if (growthAllowance > 0f && child.Grow > 0 && reference2.IsFlexible)
					{
						flag3 = TakeGrowth(ref reference2.Size, reference2.MaxSize, reference2.Scale);
					}
					else if (shrinkAllowance > 0f && child.Shrink > 0 && reference2.IsFlexible)
					{
						flag3 = TakeShrink(ref reference2.Size, reference2.MinSize, reference2.Scale);
					}
					if (flag3)
					{
						SizingChildren[j] = null;
					}
				}
				bool TakeGrowth(ref float value, float maxValue, float scale)
				{
					float max = (float)child.Grow / (float)growSum * growthAllowance;
					float num8 = Mathf.Clamp(maxValue - value, 0f, max);
					value += num8 / scale;
					growthAllowance -= num8;
					growSum -= child.Grow;
					return num8 <= float.Epsilon;
				}
				bool TakeShrink(ref float value, float minValue, float scale)
				{
					float max2 = (float)child.Shrink / (float)shrinkSum * shrinkAllowance;
					float num9 = Mathf.Clamp(value - minValue, 0f, max2);
					value -= num9 / scale;
					shrinkAllowance -= num9;
					shrinkSum -= child.Shrink;
					return num9 <= float.Epsilon;
				}
			}
		}
		float num6 = GetMainAxisStart(isHorizontal2, isReversed2);
		for (int k = 0; k < _children.Count; k++)
		{
			IFlexNode flexNode2 = _children[k];
			ref ChildSizingParameters reference3 = ref _childSizes[k];
			if (isHorizontal2)
			{
				flexNode2.LayoutHorizontal(reference3.Size, float.PositiveInfinity);
			}
			else
			{
				flexNode2.LayoutVertical(float.PositiveInfinity, reference3.Size);
			}
			flexNode2.GetScale(out var scaleX2, out var scaleY2);
			float num7 = reference3.Size * (isHorizontal2 ? scaleX2 : scaleY2);
			RectTransform rectTransform = flexNode2.Transform;
			Vector2 sizeDelta = rectTransform.sizeDelta;
			rectTransform.sizeDelta = (isHorizontal2 ? new Vector2(reference3.Size, sizeDelta.y) : new Vector2(sizeDelta.x, reference3.Size));
			Vector2 anchoredPosition = rectTransform.anchoredPosition;
			rectTransform.anchoredPosition = (isHorizontal2 ? new Vector2(num6, anchoredPosition.y) : new Vector2(anchoredPosition.x, num6));
			num6 += (isHorizontal2 ? (num7 + Gap) : (0f - num7 - Gap));
		}
		float GetMainAxisStart(bool isHorizontal, bool isReversed)
		{
			switch (JustifyContent)
			{
			case FlexJustify.Start:
				if (!isHorizontal)
				{
					return 0f - (isReversed ? (innerSize - actualMainSize + Padding.top) : Padding.top);
				}
				if (!isReversed)
				{
					return Padding.left;
				}
				return innerSize - actualMainSize + Padding.left;
			case FlexJustify.End:
				if (!isHorizontal)
				{
					return 0f - (isReversed ? Padding.top : (innerSize - actualMainSize + Padding.top));
				}
				if (!isReversed)
				{
					return innerSize - actualMainSize + Padding.left;
				}
				return Padding.left;
			case FlexJustify.Center:
				if (!isHorizontal)
				{
					return 0f - (innerSize - actualMainSize) / 2f - Padding.top;
				}
				return (innerSize - actualMainSize) / 2f + Padding.left;
			default:
				throw new NotSupportedException(JustifyContent.ToString());
			}
		}
	}

	private void MeasureCrossAxis()
	{
		bool isHorizontal = IsHorizontal;
		ref float reference = ref Pick(isHorizontal, ref _prefHeight, ref _prefWidth);
		float num = (isHorizontal ? (Padding.top + Padding.bottom) : (Padding.left + Padding.right));
		float num2 = 0f;
		foreach (IFlexNode child in _children)
		{
			if (child.IsDirty)
			{
				if (isHorizontal)
				{
					child.MeasureVertical();
				}
				else
				{
					child.MeasureHorizontal();
				}
			}
			child.GetScale(out var scaleX, out var scaleY);
			child.GetPreferredSize(out var preferredWidth, out var preferredHeight);
			num2 = ((!isHorizontal) ? Mathf.Max(num2, preferredWidth * scaleX) : Mathf.Max(num2, preferredHeight * scaleY));
		}
		if (IsAbsolute)
		{
			Rect rect = ((RectTransform)base.transform).rect;
			reference = (isHorizontal ? rect.height : rect.width);
			return;
		}
		FlexLength flexLength = (isHorizontal ? MinHeight : MinWidth);
		FlexLength flexLength2 = (isHorizontal ? MaxHeight : MaxWidth);
		float min = ((flexLength.HasValue && flexLength.Unit == FlexUnit.Pixels) ? flexLength.Value : 0f);
		float max = ((flexLength2.HasValue && flexLength2.Unit == FlexUnit.Pixels) ? flexLength2.Value : float.PositiveInfinity);
		reference = Mathf.Clamp(num2 + num, min, max);
	}

	private void LayoutCrossAxis(float maxWidth, float maxHeight)
	{
		bool isHorizontal2 = IsHorizontal;
		float innerSize = (isHorizontal2 ? (maxHeight - Padding.top - Padding.bottom) : (maxWidth - Padding.left - Padding.right));
		foreach (IFlexNode child in _children)
		{
			child.GetScale(out var scaleX, out var scaleY);
			child.GetPreferredSize(out var preferredWidth, out var preferredHeight);
			float num = (isHorizontal2 ? scaleY : scaleX);
			float num2 = innerSize / num;
			FlexAlign valueOrDefault = child.AlignSelf.GetValueOrDefault(AlignItems);
			float min = CalculateLengthValue(isHorizontal2 ? child.MinHeight : child.MinWidth, num2, 0f);
			float max = CalculateLengthValue(isHorizontal2 ? child.MaxHeight : child.MaxWidth, num2, float.PositiveInfinity);
			float num3 = (isHorizontal2 ? preferredHeight : preferredWidth);
			float num4 = Mathf.Clamp((valueOrDefault == FlexAlign.Stretch) ? num2 : num3, min, max);
			float num5 = (isHorizontal2 ? float.PositiveInfinity : num4);
			float num6 = (isHorizontal2 ? num4 : float.PositiveInfinity);
			if (isHorizontal2)
			{
				child.LayoutVertical(num5, num6);
			}
			else
			{
				child.LayoutHorizontal(num5, num6);
			}
			float num7 = GetCrossAxis(valueOrDefault, isHorizontal2, num5 * scaleX, num6 * scaleY);
			RectTransform rectTransform = child.Transform;
			Vector2 sizeDelta = rectTransform.sizeDelta;
			rectTransform.sizeDelta = (isHorizontal2 ? new Vector2(sizeDelta.x, num4) : new Vector2(num4, sizeDelta.y));
			Vector2 anchoredPosition = rectTransform.anchoredPosition;
			rectTransform.anchoredPosition = (isHorizontal2 ? new Vector2(anchoredPosition.x, num7) : new Vector2(num7, anchoredPosition.y));
		}
		float GetCrossAxis(FlexAlign align, bool isHorizontal, float childWidth, float childHeight)
		{
			switch (align)
			{
			case FlexAlign.Start:
			case FlexAlign.Stretch:
				if (!isHorizontal)
				{
					return Padding.left;
				}
				return 0f - Padding.top;
			case FlexAlign.End:
				if (!isHorizontal)
				{
					return innerSize + Padding.left - childWidth;
				}
				return 0f - innerSize - Padding.top + childHeight;
			case FlexAlign.Center:
				if (!isHorizontal)
				{
					return innerSize / 2f - childWidth / 2f + Padding.left;
				}
				return 0f - (innerSize / 2f - childHeight / 2f + Padding.top);
			default:
				throw new NotSupportedException(AlignItems.ToString());
			}
		}
	}

	private static ref T Pick<T>(bool value, ref T ifTrue, ref T ifFalse)
	{
		if (value)
		{
			return ref ifTrue;
		}
		return ref ifFalse;
	}

	private static float CalculateLengthValue(in FlexLength length, float fillValue, float defaultValue)
	{
		if (!length.HasValue)
		{
			return defaultValue;
		}
		if (length.Unit != FlexUnit.Percent)
		{
			return length.Value;
		}
		return length.Value / 100f * fillValue;
	}

	private void SetupTransform()
	{
		if (!IsAbsolute)
		{
			RectTransform obj = (RectTransform)base.transform;
			obj.localRotation = Quaternion.identity;
			obj.pivot = new Vector2(0f, 1f);
			obj.anchorMin = new Vector2(0f, 1f);
			obj.anchorMax = new Vector2(0f, 1f);
		}
	}

	void IFlexNode.MeasureHorizontal()
	{
		_children.Clear();
		foreach (IFlexNode item in new FlexChildEnumerable(this, IsReversed))
		{
			_children.Add(item);
		}
		if (IsHorizontal)
		{
			MeasureMainAxis();
		}
		else
		{
			MeasureCrossAxis();
		}
	}

	void IFlexNode.LayoutHorizontal(float maxWidth, float maxHeight)
	{
		_isDoingLayout = true;
		SetupTransform();
		try
		{
			if (IsHorizontal)
			{
				LayoutMainAxis(maxWidth, maxHeight);
			}
			else
			{
				LayoutCrossAxis(maxWidth, maxHeight);
			}
		}
		finally
		{
			_isDoingLayout = false;
		}
	}

	void IFlexNode.MeasureVertical()
	{
		if (IsHorizontal)
		{
			MeasureCrossAxis();
		}
		else
		{
			MeasureMainAxis();
		}
	}

	void IFlexNode.LayoutVertical(float maxWidth, float maxHeight)
	{
		_isDoingLayout = true;
		try
		{
			if (IsHorizontal)
			{
				LayoutCrossAxis(maxWidth, maxHeight);
			}
			else
			{
				LayoutMainAxis(maxWidth, maxHeight);
			}
			_isDirty = false;
		}
		finally
		{
			_isDoingLayout = false;
		}
	}

	void IFlexNode.GetScale(out float scaleX, out float scaleY)
	{
		Vector3 localScale = ((RectTransform)base.transform).localScale;
		scaleX = localScale.x;
		scaleY = localScale.y;
	}

	void IFlexNode.GetPreferredSize(out float preferredWidth, out float preferredHeight)
	{
		preferredWidth = _prefWidth;
		preferredHeight = _prefHeight;
	}

	protected override void OnEnable()
	{
		SetupTransform();
		SetLayoutDirty(force: true);
	}

	protected override void OnDisable()
	{
		SetLayoutDirty(force: true);
	}

	protected override void OnRectTransformDimensionsChange()
	{
		SetLayoutDirty();
	}

	protected override void OnBeforeTransformParentChanged()
	{
		SetLayoutDirty();
	}

	protected override void OnTransformParentChanged()
	{
		SetLayoutDirty();
	}

	protected virtual void OnTransformChildrenChanged()
	{
		SetLayoutDirty();
	}
}
