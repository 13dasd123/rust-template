using Facepunch.Flexbox;
using TMPro;
using UnityEngine;

[ExecuteAlways]
[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
public class FlexText : TextMeshProUGUI, IFlexNode
{
	[Tooltip("Controls the initial size of the element before factoring in grow/shrink.")]
	public FlexLength Basis;

	[Min(0f)]
	[Tooltip("How much this flex element should grow relative to its siblings.")]
	public int Grow = 1;

	[Min(0f)]
	[Tooltip("How much this flex element should shrink relative to its siblings.")]
	public int Shrink = 1;

	[Tooltip("Optionally override the parent's cross axis alignment for this element.")]
	public FlexAlignSelf AlignSelf;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MinWidth;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MaxWidth;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MinHeight;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MaxHeight;

	private bool _isDirty;

	private float _preferredWidth;

	private float _preferredHeight;

	RectTransform IFlexNode.Transform => (RectTransform)base.transform;

	bool IFlexNode.IsActive => base.isActiveAndEnabled;

	bool IFlexNode.IsAbsolute => false;

	bool IFlexNode.IsDirty => _isDirty;

	FlexLength IFlexNode.MinWidth => MinWidth;

	FlexLength IFlexNode.MaxWidth => MaxWidth;

	FlexLength IFlexNode.MinHeight => MinHeight;

	FlexLength IFlexNode.MaxHeight => MaxHeight;

	FlexLength IFlexNode.Basis => Basis;

	int IFlexNode.Grow => Grow;

	int IFlexNode.Shrink => Shrink;

	FlexAlignSelf IFlexNode.AlignSelf => AlignSelf;

	protected override void OnEnable()
	{
		base.OnEnable();
		SetupTransform();
		SetLayoutDirty();
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		SetLayoutDirty();
	}

	public override void SetLayoutDirty()
	{
		_isDirty = true;
		base.SetLayoutDirty();
		Transform parent = base.transform.parent;
		if (parent != null && parent.TryGetComponent<IFlexNode>(out var component) && component.IsActive)
		{
			component.SetLayoutDirty();
		}
	}

	private void SetupTransform()
	{
		RectTransform obj = (RectTransform)base.transform;
		obj.localScale = Vector3.one;
		obj.localRotation = Quaternion.identity;
		obj.pivot = new Vector2(0f, 1f);
		obj.anchorMin = new Vector2(0f, 1f);
		obj.anchorMax = new Vector2(0f, 1f);
	}

	void IFlexNode.SetLayoutDirty(bool force)
	{
		if (force || IsActive())
		{
			SetLayoutDirty();
		}
	}

	void IFlexNode.MeasureHorizontal()
	{
		Vector2 preferredValues = GetPreferredValues();
		_preferredWidth = preferredValues.x;
		_preferredHeight = preferredValues.y;
	}

	void IFlexNode.LayoutHorizontal(float maxWidth, float maxHeight)
	{
		SetupTransform();
	}

	void IFlexNode.MeasureVertical()
	{
		Vector2 preferredValues = GetPreferredValues(((RectTransform)base.transform).sizeDelta.x, float.PositiveInfinity);
		_preferredWidth = preferredValues.x;
		_preferredHeight = preferredValues.y;
	}

	void IFlexNode.LayoutVertical(float maxWidth, float maxHeight)
	{
		_isDirty = false;
	}

	void IFlexNode.GetScale(out float scaleX, out float scaleY)
	{
		Vector3 localScale = ((RectTransform)base.transform).localScale;
		scaleX = localScale.x;
		scaleY = localScale.y;
	}

	void IFlexNode.GetPreferredSize(out float preferredWidth, out float preferredHeight)
	{
		preferredWidth = _preferredWidth;
		preferredHeight = _preferredHeight;
	}
}
