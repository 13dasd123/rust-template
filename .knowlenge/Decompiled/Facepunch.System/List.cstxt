using System;
using System.Collections.Generic;
using Facepunch;

public static class List
{
	public static void Compare<T, TListA, TListB>(this TListA a, TListB b, List<T> added, List<T> removed, List<T> remained) where TListA : IList<T> where TListB : IList<T>
	{
		if (a == null && b == null)
		{
			return;
		}
		if (a == null)
		{
			added?.AddRange(b);
		}
		else if (b == null)
		{
			removed?.AddRange(a);
		}
		else
		{
			if (a.Count == 0 && b.Count == 0)
			{
				return;
			}
			added?.AddRange(b);
			removed?.AddRange(a);
			foreach (T item in b)
			{
				if (!a.Contains(item))
				{
					continue;
				}
				remained?.Add(item);
				if (added != null)
				{
					while (added.Remove(item))
					{
					}
				}
				if (removed != null)
				{
					while (removed.Remove(item))
					{
					}
				}
			}
		}
	}

	public static void Compare<TListA, TListB, TItemA, TItemB, TKey>(this TListA a, TListB b, HashSet<TKey> added, HashSet<TKey> removed, HashSet<TKey> remained, Func<TItemA, TKey> selectorA, Func<TItemB, TKey> selectorB) where TListA : IEnumerable<TItemA> where TListB : IEnumerable<TItemB> where TKey : IEquatable<TKey>
	{
		if (a == null)
		{
			throw new ArgumentNullException("a");
		}
		if (b == null)
		{
			throw new ArgumentNullException("b");
		}
		if (added == null)
		{
			throw new ArgumentNullException("added");
		}
		if (removed == null)
		{
			throw new ArgumentNullException("removed");
		}
		if (remained == null)
		{
			throw new ArgumentNullException("remained");
		}
		HashSet<TKey> obj = Pool.Get<HashSet<TKey>>();
		obj.Clear();
		foreach (TItemA item in a)
		{
			obj.Add(selectorA(item));
		}
		HashSet<TKey> obj2 = Pool.Get<HashSet<TKey>>();
		obj2.Clear();
		foreach (TItemB item2 in b)
		{
			obj2.Add(selectorB(item2));
		}
		InitializeWith(remained, obj2);
		added.IntersectWith(obj);
		InitializeWith(added, obj2);
		added.ExceptWith(obj);
		InitializeWith(removed, obj);
		removed.ExceptWith(obj2);
		obj.Clear();
		Pool.Free(ref obj);
		obj2.Clear();
		Pool.Free(ref obj2);
		static void InitializeWith(HashSet<TKey> set, HashSet<TKey> values)
		{
			set.Clear();
			foreach (TKey value in values)
			{
				set.Add(value);
			}
		}
	}

	public static TItem FindWith<TItem, TKey>(this IReadOnlyCollection<TItem> items, Func<TItem, TKey> selector, TKey search, IEqualityComparer<TKey> comparer = null)
	{
		comparer = comparer ?? EqualityComparer<TKey>.Default;
		foreach (TItem item in items)
		{
			if (comparer.Equals(selector(item), search))
			{
				return item;
			}
		}
		return default(TItem);
	}

	public static TItem? TryFindWith<TItem, TKey>(this IReadOnlyCollection<TItem> items, Func<TItem, TKey> selector, TKey search, IEqualityComparer<TKey> comparer = null) where TItem : struct
	{
		comparer = comparer ?? EqualityComparer<TKey>.Default;
		foreach (TItem item in items)
		{
			if (comparer.Equals(selector(item), search))
			{
				return item;
			}
		}
		return null;
	}

	public static int FindIndexWith<TItem, TKey>(this IReadOnlyList<TItem> items, Func<TItem, TKey> selector, TKey search) where TKey : IEquatable<TKey>
	{
		for (int i = 0; i < items.Count; i++)
		{
			TItem arg = items[i];
			if (selector(arg).Equals(search))
			{
				return i;
			}
		}
		return -1;
	}
}
