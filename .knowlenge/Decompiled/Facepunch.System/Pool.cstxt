using System;
using System.Collections.Generic;
using System.IO;
using Facepunch;

public static class Pool
{
	public interface IPooled
	{
		void EnterPool();

		void LeavePool();
	}

	public interface ICollection
	{
		long ItemsInStack { get; }

		long ItemsInUse { get; }

		long ItemsCreated { get; }

		long ItemsTaken { get; }

		long ItemsSpilled { get; }
	}

	public class PoolCollection<T> : ICollection
	{
		public T[] buffer = new T[512];

		public long ItemsInStack { get; set; }

		public long ItemsInUse { get; set; }

		public long ItemsCreated { get; set; }

		public long ItemsTaken { get; set; }

		public long ItemsSpilled { get; set; }
	}

	public static Dictionary<Type, object> directory = new Dictionary<Type, object>();

	public static void FreeList<T>(ref List<T> obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Clear();
		Free(ref obj);
		if (obj != null)
		{
			throw new SystemException("Pool.Free is not setting object to NULL");
		}
	}

	public static void FreeMemoryStream(ref MemoryStream obj)
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		obj.Position = 0L;
		obj.SetLength(0L);
		Free(ref obj);
		if (obj != null)
		{
			throw new SystemException("Pool.Free is not setting object to NULL");
		}
	}

	public static void Free<T>(ref T obj) where T : class
	{
		if (obj == null)
		{
			throw new ArgumentNullException();
		}
		PoolCollection<T> poolCollection = FindCollection<T>();
		if (poolCollection.ItemsInStack >= poolCollection.buffer.Length)
		{
			poolCollection.ItemsSpilled++;
			poolCollection.ItemsInUse--;
			obj = (T)null;
			return;
		}
		poolCollection.buffer[poolCollection.ItemsInStack] = obj;
		poolCollection.ItemsInStack++;
		poolCollection.ItemsInUse--;
		if (obj is IPooled pooled)
		{
			pooled.EnterPool();
		}
		obj = (T)null;
	}

	public static T Get<T>() where T : class, new()
	{
		PoolCollection<T> poolCollection = FindCollection<T>();
		if (poolCollection.ItemsInStack > 0)
		{
			poolCollection.ItemsInStack--;
			poolCollection.ItemsInUse++;
			T val = poolCollection.buffer[poolCollection.ItemsInStack];
			poolCollection.buffer[poolCollection.ItemsInStack] = (T)null;
			if (val is IPooled pooled)
			{
				pooled.LeavePool();
			}
			poolCollection.ItemsTaken++;
			return val;
		}
		poolCollection.ItemsCreated++;
		poolCollection.ItemsInUse++;
		return new T();
	}

	public static List<T> GetList<T>()
	{
		return Get<List<T>>();
	}

	public static void ResizeBuffer<T>(int size)
	{
		PoolCollection<T> poolCollection = FindCollection<T>();
		Array.Resize(ref poolCollection.buffer, size);
	}

	public static void FillBuffer<T>(int count = int.MaxValue) where T : class, new()
	{
		PoolCollection<T> poolCollection = FindCollection<T>();
		for (int i = 0; i < count; i++)
		{
			if (poolCollection.ItemsInStack >= poolCollection.buffer.Length)
			{
				break;
			}
			poolCollection.buffer[poolCollection.ItemsInStack] = new T();
			poolCollection.ItemsInStack++;
		}
	}

	public static PoolCollection<T> FindCollection<T>()
	{
		if (!directory.TryGetValue(typeof(T), out var value))
		{
			value = new PoolCollection<T>();
			directory.Add(typeof(T), value);
		}
		return (PoolCollection<T>)value;
	}

	public static void Clear()
	{
		directory.Clear();
		directory = new Dictionary<Type, object>();
	}
}
