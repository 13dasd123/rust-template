#define UNITY_ASSERTIONS
using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;
using UnityEngine.Assertions;

public class MaterialReplacement : MonoBehaviour
{
	private bool initialized;

	public Material[] Default;

	public Mesh DefaultMesh;

	public Material[] Override;

	public Mesh OverrideMesh;

	public Renderer Renderer;

	public static void ReplaceRecursive(GameObject go, Material mat)
	{
		List<Renderer> obj = Pool.GetList<Renderer>();
		go.transform.GetComponentsInChildren(includeInactive: true, obj);
		foreach (Renderer item in obj)
		{
			if (!(item is ParticleSystemRenderer))
			{
				MaterialReplacement orAddComponent = item.transform.GetOrAddComponent<MaterialReplacement>();
				orAddComponent.Init();
				orAddComponent.Replace(mat);
			}
		}
		Pool.FreeList(ref obj);
	}

	public static void ReplaceRecursive(GameObject obj, Material[] find, Material[] replace, MeshSwap[] meshes)
	{
		Assert.AreEqual(find.Length, replace.Length);
		List<Renderer> obj2 = Pool.GetList<Renderer>();
		obj.GetComponentsInChildren(includeInactive: true, obj2);
		foreach (Renderer item in obj2)
		{
			if (!(item is ParticleSystemRenderer) && (MaterialsContainAny(item.sharedMaterials, find) || MeshContainsAny(item, meshes)))
			{
				MaterialReplacement orAddComponent = item.transform.GetOrAddComponent<MaterialReplacement>();
				orAddComponent.Init();
				orAddComponent.Revert();
				orAddComponent.Replace(find, replace);
				orAddComponent.Replace(meshes);
			}
		}
		Pool.FreeList(ref obj2);
	}

	public static void Prepare(GameObject go)
	{
		List<Renderer> obj = Pool.GetList<Renderer>();
		go.GetComponentsInChildren(includeInactive: true, obj);
		foreach (Renderer item in obj)
		{
			if (!(item is ParticleSystemRenderer))
			{
				item.transform.GetOrAddComponent<MaterialReplacement>().Init();
			}
		}
		Pool.FreeList(ref obj);
	}

	private static bool MaterialsContainAny(Material[] source, Material[] find)
	{
		for (int i = 0; i < source.Length; i++)
		{
			if (find.Contains(source[i]))
			{
				return true;
			}
		}
		return false;
	}

	private static bool MeshContainsAny(Renderer r, MeshSwap[] swaps)
	{
		if (swaps == null || swaps.Length == 0)
		{
			return false;
		}
		if (r is MeshRenderer)
		{
			MeshFilter component = r.GetComponent<MeshFilter>();
			if ((object)component == null)
			{
				return false;
			}
			return MeshSwap.GetDest(swaps, component.sharedMesh) != null;
		}
		if (r is SkinnedMeshRenderer skinnedMeshRenderer)
		{
			return MeshSwap.GetDest(swaps, skinnedMeshRenderer.sharedMesh) != null;
		}
		return false;
	}

	public static void Reset(GameObject go)
	{
		List<MaterialReplacement> obj = Pool.GetList<MaterialReplacement>();
		go.GetComponentsInChildren(includeInactive: true, obj);
		foreach (MaterialReplacement item in obj)
		{
			item.Revert();
		}
		Pool.FreeList(ref obj);
	}

	private void Init()
	{
		if (initialized)
		{
			return;
		}
		initialized = true;
		Renderer = GetComponent<Renderer>();
		Default = Renderer.sharedMaterials;
		Override = new Material[Default.Length];
		Array.Copy(Default, Override, Default.Length);
		if (Renderer is MeshRenderer)
		{
			MeshFilter component = Renderer.GetComponent<MeshFilter>();
			if (component != null)
			{
				DefaultMesh = component.sharedMesh;
			}
		}
		if (Renderer is SkinnedMeshRenderer skinnedMeshRenderer)
		{
			DefaultMesh = skinnedMeshRenderer.sharedMesh;
		}
	}

	private void Replace(Material mat)
	{
		if ((bool)Renderer)
		{
			for (int i = 0; i < Override.Length; i++)
			{
				Override[i] = mat;
			}
			Renderer.sharedMaterials = Override;
		}
	}

	private void Replace(Material find, Material replace)
	{
		if (!Renderer)
		{
			return;
		}
		for (int i = 0; i < Default.Length; i++)
		{
			if (find == Default[i])
			{
				Override[i] = replace;
			}
		}
		Renderer.sharedMaterials = Override;
	}

	private void Replace(Material[] find, Material[] replace)
	{
		if (!Renderer)
		{
			return;
		}
		int num = Mathf.Min(find.Length, replace.Length);
		for (int i = 0; i < Default.Length; i++)
		{
			for (int j = 0; j < num; j++)
			{
				if (find[j] == Default[i])
				{
					Override[i] = replace[j];
				}
			}
		}
		Renderer.sharedMaterials = Override;
	}

	private void Replace(MeshSwap[] swaps)
	{
		if ((object)Renderer == null || swaps == null || swaps.Length == 0)
		{
			return;
		}
		if (Renderer is MeshRenderer)
		{
			MeshFilter component = Renderer.GetComponent<MeshFilter>();
			if ((object)component == null)
			{
				return;
			}
			Mesh dest = MeshSwap.GetDest(swaps, component.sharedMesh);
			if ((object)dest == null)
			{
				return;
			}
			OverrideMesh = dest;
			component.sharedMesh = dest;
		}
		if (Renderer is SkinnedMeshRenderer skinnedMeshRenderer)
		{
			Mesh dest2 = MeshSwap.GetDest(swaps, skinnedMeshRenderer.sharedMesh);
			if ((object)dest2 != null)
			{
				OverrideMesh = dest2;
				skinnedMeshRenderer.sharedMesh = dest2;
			}
		}
	}

	private void Revert()
	{
		if ((object)Renderer == null)
		{
			return;
		}
		Renderer.sharedMaterials = Default;
		Array.Copy(Default, Override, Default.Length);
		if (!(OverrideMesh != null))
		{
			return;
		}
		if (Renderer is MeshRenderer)
		{
			MeshFilter component = Renderer.GetComponent<MeshFilter>();
			if (component != null)
			{
				component.sharedMesh = DefaultMesh;
			}
		}
		if (Renderer is SkinnedMeshRenderer skinnedMeshRenderer)
		{
			skinnedMeshRenderer.sharedMesh = DefaultMesh;
		}
		OverrideMesh = null;
	}
}
