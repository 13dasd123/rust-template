using UnityEngine;

public class WorldSpaceGrid<T>
{
	public T[] Cells;

	public float CellSize;

	public float CellSizeHalf;

	public float CellSizeInverse;

	public float CellArea;

	public int CellCount;

	public int CellCountHalf;

	public T this[Vector3 worldPos]
	{
		get
		{
			return this[WorldToGridCoords(worldPos)];
		}
		set
		{
			this[WorldToGridCoords(worldPos)] = value;
		}
	}

	public T this[Vector2i cellCoords]
	{
		get
		{
			return this[cellCoords.x, cellCoords.y];
		}
		set
		{
			this[cellCoords.x, cellCoords.y] = value;
		}
	}

	public T this[int x, int y]
	{
		get
		{
			return Cells[y * CellCount + x];
		}
		set
		{
			Cells[y * CellCount + x] = value;
		}
	}

	public WorldSpaceGrid(float gridSize, float cellSize)
	{
		CellSize = cellSize;
		CellSizeHalf = cellSize * 0.5f;
		CellSizeInverse = 1f / cellSize;
		CellArea = cellSize * cellSize;
		CellCount = Mathf.CeilToInt(Mathf.Max(gridSize, 1000f) * CellSizeInverse);
		CellCountHalf = CellCount / 2;
		Cells = new T[CellCount * CellCount];
	}

	public Vector2i WorldToGridCoords(Vector3 worldPos)
	{
		int num = Mathf.CeilToInt(worldPos.x * CellSizeInverse);
		int num2 = Mathf.CeilToInt(worldPos.z * CellSizeInverse);
		int x = Mathx.Clamp(num + CellCountHalf, 0, CellCount - 1);
		num2 = Mathx.Clamp(num2 + CellCountHalf, 0, CellCount - 1);
		return new Vector2i(x, num2);
	}

	public Vector3 GridToWorldCoords(Vector2i cellPos)
	{
		float x = (float)(cellPos.x - CellCountHalf) * CellSize - CellSizeHalf;
		float z = (float)(cellPos.y - CellCountHalf) * CellSize - CellSizeHalf;
		return new Vector3(x, 0f, z);
	}
}
