using UnityEngine;

public struct Line
{
	public Vector3 point0;

	public Vector3 point1;

	public Line(Vector3 point0, Vector3 point1)
	{
		this.point0 = point0;
		this.point1 = point1;
	}

	public Line(Vector3 origin, Vector3 direction, float length)
	{
		point0 = origin;
		point1 = origin + direction * length;
	}

	public bool Trace(Ray ray, float radius, out RaycastHit hit, float maxDistance = float.PositiveInfinity)
	{
		hit = default(RaycastHit);
		if (radius <= 0f)
		{
			return false;
		}
		Vector3 vector = point1 - point0;
		Vector3 direction = ray.direction;
		Vector3 rhs = point0 - ray.origin;
		float num = Vector3.Dot(vector, vector);
		float num2 = Vector3.Dot(vector, direction);
		float num3 = Vector3.Dot(direction, rhs);
		float num4 = num - num2 * num2;
		float num5 = 0f;
		float num6 = num3;
		if (num4 >= Mathf.Epsilon)
		{
			float num7 = Vector3.Dot(vector, rhs);
			float num8 = 1f / num4;
			num5 = num8 * (num2 * num3 - num7);
			num6 = num8 * (num * num3 - num2 * num7);
			num5 = Mathf.Clamp01(num5);
		}
		if (num6 < 0f || num6 > maxDistance)
		{
			return false;
		}
		Vector3 vector2 = point0 + num5 * vector;
		Vector3 vector3 = ray.origin + num6 * direction;
		Vector3 vector4 = vector3 - vector2;
		float magnitude = vector4.magnitude;
		if (magnitude > radius)
		{
			return false;
		}
		hit.point = vector2;
		hit.normal = vector4 / magnitude;
		hit.distance = Vector3.Distance(ray.origin, hit.point);
		return true;
	}

	public Vector3 ClosestPoint(Vector3 pos)
	{
		Vector3 vector = point1 - point0;
		float magnitude = vector.magnitude;
		Vector3 vector2 = vector / magnitude;
		return point0 + Mathf.Clamp(Vector3.Dot(pos - point0, vector2), 0f, magnitude) * vector2;
	}

	public float Distance(Vector3 pos)
	{
		return (pos - ClosestPoint(pos)).magnitude;
	}

	public float SqrDistance(Vector3 pos)
	{
		return (pos - ClosestPoint(pos)).sqrMagnitude;
	}
}
