using System;
using System.Collections.Generic;
using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Mega Wire/Plant Poles List")]
public class MegaWirePlantPolesList : MonoBehaviour
{
	[Serializable]
	public class MegaWireSection
	{
		public Vector3 p;

		public Vector3 p1;

		public float length;

		public float seglength;
	}

	public List<Vector3> waypoints = new List<Vector3>();

	public bool closed;

	public int curve;

	public float start;

	public float length = 1f;

	public float spacing = 10f;

	public bool update;

	public GameObject pole;

	public Vector3 rotate = Vector3.zero;

	public float offset;

	public bool conform = true;

	public float upright;

	public bool addwires;

	public List<GameObject> poles = new List<GameObject>();

	public MegaWire copyfrom;

	public Material material;

	public Vector3 positionVariation = Vector3.zero;

	public Vector3 rotateVariation = Vector3.zero;

	public Vector3 scaleVariation = Vector3.zero;

	public float spacingVariation;

	public bool reverseWire;

	public int seed;

	public float wireSizeMult = 1f;

	public float stretch = 1f;

	public bool showgizmo = true;

	public bool showgizmoparams;

	public MegaWireGizmoType gizmoType;

	public float arrowwidth = 0.2f;

	public float arrowlength = 1.1f;

	public float vertStart = 0.2f;

	public float vertLength = 1.5f;

	public float arrowoff = 0.8f;

	public float dashdist = 2f;

	public Color arrowCol = new Color(1f, 1f, 1f, 1f);

	public Color lineCol = new Color(1f, 1f, 1f, 1f);

	public Color otherCol = new Color(0.75f, 0.75f, 0.75f, 1f);

	public Color dashCol = new Color(0.5f, 0.5f, 0.5f, 1f);

	public MegaWireUnits units;

	public float unitsScale = 1f;

	private List<MegaWireSection> knots = new List<MegaWireSection>();

	private float pathlength;

	public Vector3 Interpolate(float alpha)
	{
		int num = 0;
		float num2 = alpha * pathlength;
		for (num = 0; num < knots.Count && !(num2 <= knots[num].length); num++)
		{
		}
		alpha = 1f - (knots[num].length - num2) / knots[num].seglength;
		if (num < knots.Count)
		{
			return Vector3.Lerp(knots[num].p, knots[num].p1, alpha);
		}
		return Vector3.Lerp(knots[num].p, knots[num].p1, alpha);
	}

	public Vector3 InterpCurve3D(float alpha)
	{
		if (alpha < 0f)
		{
			if (!closed)
			{
				Vector3 vector = Interpolate(0f);
				Vector3 vector2 = Interpolate(0.01f);
				Vector3 vector3 = vector2 - vector;
				vector3.Normalize();
				return vector + pathlength * alpha * vector3;
			}
			alpha = Mathf.Repeat(alpha, 1f);
		}
		else if (alpha >= 1f)
		{
			if (!closed)
			{
				Vector3 vector4 = Interpolate(1f);
				Vector3 vector5 = Interpolate(0.99f);
				Vector3 vector6 = vector5 - vector4;
				vector6.Normalize();
				return vector4 + pathlength * (1f - alpha) * vector6;
			}
			alpha %= 1f;
		}
		return Interpolate(alpha);
	}

	private float CalcLength()
	{
		float num = 0f;
		knots.Clear();
		if (waypoints.Count > 1)
		{
			for (int i = 0; i < waypoints.Count - 1; i++)
			{
				Vector3 vector = base.transform.TransformPoint(waypoints[i]);
				Vector3 vector2 = base.transform.TransformPoint(waypoints[i + 1]);
				MegaWireSection megaWireSection = new MegaWireSection();
				megaWireSection.seglength = Vector3.Distance(vector2, vector);
				megaWireSection.p = vector;
				megaWireSection.p1 = vector2;
				num = (megaWireSection.length = num + megaWireSection.seglength);
				knots.Add(megaWireSection);
			}
			if (closed)
			{
				Vector3 vector3 = base.transform.TransformPoint(waypoints[waypoints.Count - 1]);
				Vector3 vector4 = base.transform.TransformPoint(waypoints[0]);
				MegaWireSection megaWireSection2 = new MegaWireSection();
				megaWireSection2.seglength = Vector3.Distance(vector4, vector3);
				megaWireSection2.p = vector3;
				megaWireSection2.p1 = vector4;
				num = (megaWireSection2.length = num + megaWireSection2.seglength);
				knots.Add(megaWireSection2);
			}
		}
		pathlength = num;
		return num;
	}

	public void Rebuild()
	{
		CalcLength();
		if (waypoints.Count <= 1 || !pole)
		{
			return;
		}
		update = false;
		MegaWire componentInChildren = base.transform.GetComponentInChildren<MegaWire>();
		Transform[] componentsInChildren = base.transform.GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (componentsInChildren[i] != null && componentsInChildren[i] != base.transform && componentsInChildren[i].name.Contains("Plant Poles"))
			{
				if (Application.isEditor)
				{
					UnityEngine.Object.DestroyImmediate(componentsInChildren[i].gameObject);
				}
				else
				{
					UnityEngine.Object.Destroy(componentsInChildren[i].gameObject);
				}
			}
		}
		int num = (int)(pathlength * length / spacing);
		float num2 = start;
		float num3 = length / (float)num;
		if (closed)
		{
			num--;
		}
		poles.Clear();
		UnityEngine.Random.seed = seed;
		float num4 = spacing / (pathlength * length) / 2f * spacingVariation;
		for (int j = 0; j <= num; j++)
		{
			float num5 = num2;
			if (j != 0 && j != num)
			{
				num5 = num2 + UnityEngine.Random.Range(-1f, 1f) * num4;
			}
			Vector3 vector = InterpCurve3D(num5);
			Vector3 vector2 = InterpCurve3D(num5 + 0.001f);
			Vector3 zero = Vector3.zero;
			zero.y = UnityEngine.Random.Range(0f, 1f) * positionVariation.y;
			zero.z = UnityEngine.Random.Range(-1f, 1f) * positionVariation.z;
			Vector3 normalized = (vector2 - vector).normalized;
			Vector3 vector3 = Vector3.Cross(normalized, Vector3.up) * (offset + zero.z);
			vector += vector3;
			vector2 += vector3;
			Quaternion quaternion = Quaternion.identity;
			if (conform)
			{
				Ray ray = default(Ray);
				Vector3 origin = vector;
				origin.y = 1000f;
				ray.origin = origin;
				ray.direction = Vector3.down;
				RaycastHit[] array = Physics.RaycastAll(ray);
				if (array.Length > 0)
				{
					int num6 = 0;
					vector = array[num6].point;
					for (int k = 1; k < array.Length; k++)
					{
						if (array[k].point.y > vector.y)
						{
							num6 = k;
							vector = array[num6].point;
						}
					}
					Vector3 normalized2 = Vector3.Lerp(array[num6].normal, Vector3.up, upright).normalized;
					quaternion = Quaternion.FromToRotation(Vector3.up, normalized2);
				}
			}
			Vector3 forward = vector2 - vector;
			forward.y = 0f;
			Quaternion quaternion2 = Quaternion.LookRotation(forward, Vector3.up);
			Vector3 zero2 = Vector3.zero;
			zero2.x = UnityEngine.Random.Range(-1f, 1f) * rotateVariation.x;
			zero2.y = UnityEngine.Random.Range(-1f, 1f) * rotateVariation.y;
			zero2.z = UnityEngine.Random.Range(-1f, 1f) * rotateVariation.z;
			Quaternion quaternion3 = Quaternion.Euler(rotate + zero2);
			vector.y -= zero.y;
			GameObject gameObject = UnityEngine.Object.Instantiate(pole, vector, quaternion * quaternion2 * quaternion3);
			gameObject.name = base.name + " Pole " + j;
			gameObject.transform.parent = base.transform;
			num2 += num3;
			poles.Add(gameObject);
		}
		if (length >= 0.99999f && closed)
		{
			poles.Add(poles[0]);
		}
		if (addwires)
		{
			if (reverseWire)
			{
				poles.Reverse();
			}
			MegaWire megaWire = MegaWire.Create(componentInChildren, poles, material, base.name + " Wires", copyfrom, wireSizeMult, stretch);
			if ((bool)megaWire)
			{
				megaWire.transform.parent = base.transform;
			}
		}
		else if ((bool)componentInChildren)
		{
			if (Application.isPlaying)
			{
				UnityEngine.Object.Destroy(componentInChildren);
			}
			else
			{
				UnityEngine.Object.DestroyImmediate(componentInChildren);
			}
			componentInChildren = null;
		}
	}
}
