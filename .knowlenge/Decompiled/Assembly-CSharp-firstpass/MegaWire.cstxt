using System.Collections.Generic;
using UnityEngine;

[AddComponentMenu("Procedural/Mega Wire")]
[ExecuteInEditMode]
public class MegaWire : MonoBehaviour
{
	public bool Rebuild;

	public float fudge = 2f;

	public MegaWireStrandedMesher strandedMesher = new MegaWireStrandedMesher();

	public float spring = 10f;

	public float damp = 1f;

	public float timeStep = 0.01f;

	public float Mass = 1f;

	public Vector3 gravity = new Vector3(0f, -9.81f, 0f);

	public float airdrag = 0.99f;

	public float massRand;

	public bool doCollisions;

	public bool useraycast;

	public LayerMask collisionmask;

	public float collisionoff;

	public float collisiondist = 100f;

	public float floor;

	public int points = 10;

	public int iters = 4;

	public int frameWait;

	public int frameNum;

	public bool stiffnessSprings;

	public float stiffrate = 10f;

	public float stiffdamp = 1f;

	public bool lengthConstraints;

	private Matrix4x4 wtm;

	public MegaWireSolver verletsolver = new MegaWireSolverVertlet();

	public bool showphysics;

	public bool showconnections;

	public bool showmeshparams;

	public List<MegaWireConnectionDef> connections = new List<MegaWireConnectionDef>();

	public List<MegaWireSpan> spans = new List<MegaWireSpan>();

	public static Vector3 windDir = Vector3.forward;

	public static float windFrc = 1f;

	public float windEffect = 1f;

	public MegaWireWind wind;

	public Material material;

	public bool uselod;

	public float disableDist = 10f;

	public bool disableOnNotVisible;

	public float lodreducesides = 0.5f;

	public float lodreducesegs = 0.5f;

	public GameObject startObj;

	public float startAlpha;

	public Vector3 startRot = Vector3.zero;

	public Vector3 startOffset = Vector3.zero;

	public GameObject endObj;

	public float endAlpha;

	public Vector3 endRot = Vector3.zero;

	public Vector3 endOffset = Vector3.zero;

	public List<MegaWireLodLevel> lods = new List<MegaWireLodLevel>();

	public bool hidespans = true;

	public bool disableOnDistance;

	public float distfromcamera;

	public float rbodyforce = 10f;

	public bool Enabled = true;

	public bool ShowWire = true;

	public float awakeTime = 2f;

	public bool displayGizmo = true;

	public Color gizmoColor = new Color(0.2f, 0.2f, 0.2f, 0.2f);

	public List<Transform> poles = new List<Transform>();

	public float stretch = 1f;

	public float warmPhysicsTime = 5f;

	public bool builduvs = true;

	public static bool DisableAll = false;

	public float startTime = 4f;

	public bool showWindParams;

	public bool showPhysicsAdv;

	public bool showAttach;

	public void Copy(MegaWire from, MegaWireConnectionHelper helper)
	{
		fudge = from.fudge;
		spring = from.spring;
		damp = from.damp;
		timeStep = from.timeStep;
		Mass = from.Mass;
		gravity = from.gravity;
		airdrag = from.airdrag;
		massRand = from.massRand;
		points = from.points;
		iters = from.iters;
		wind = from.wind;
		material = from.material;
		disableOnNotVisible = from.disableOnNotVisible;
		disableDist = from.disableDist;
		disableOnDistance = from.disableOnDistance;
		stretch = from.stretch;
		awakeTime = from.awakeTime;
		gizmoColor = from.gizmoColor;
		displayGizmo = from.displayGizmo;
		disableOnDistance = from.disableOnDistance;
		distfromcamera = from.distfromcamera;
		frameWait = from.frameWait;
		frameNum = from.frameNum;
		stiffnessSprings = from.stiffnessSprings;
		stiffrate = from.stiffrate;
		stiffdamp = from.stiffdamp;
		lengthConstraints = from.lengthConstraints;
		connections.Clear();
		if ((bool)helper)
		{
			for (int i = 0; i < helper.connections.Count; i++)
			{
				connections.Add(new MegaWireConnectionDef(helper.connections[i]));
			}
		}
		else
		{
			for (int j = 0; j < from.connections.Count; j++)
			{
				connections.Add(new MegaWireConnectionDef(from.connections[j]));
			}
		}
		strandedMesher.Copy(from.strandedMesher);
	}

	public static MegaWire Create(MegaWire wire, List<GameObject> objs, Material mat, string name, MegaWire copyfrom, float wiresize, float str)
	{
		if (objs != null && objs.Count > 1)
		{
			GameObject gameObject = null;
			if (wire == null)
			{
				gameObject = new GameObject();
				gameObject.name = name;
				wire = gameObject.AddComponent<MegaWire>();
				wire.material = mat;
				wire.stretch = str;
			}
			else
			{
				gameObject = wire.gameObject;
			}
			wire.poles.Clear();
			wire.spans.Clear();
			wire.connections.Clear();
			wire.poles.Add(objs[0].transform);
			wire.stretch = str;
			bool flag = true;
			if ((bool)copyfrom)
			{
				flag = copyfrom.hidespans;
			}
			for (int i = 0; i < objs.Count - 1; i++)
			{
				GameObject gameObject2 = new GameObject();
				if (flag)
				{
					gameObject2.hideFlags = HideFlags.HideInHierarchy | HideFlags.HideInInspector | HideFlags.NotEditable;
				}
				gameObject2.name = name + " Span Mesh " + i;
				gameObject2.transform.parent = gameObject.transform;
				MegaWireSpan megaWireSpan = gameObject2.AddComponent<MegaWireSpan>();
				megaWireSpan.start = objs[i].transform;
				megaWireSpan.end = objs[i + 1].transform;
				MeshFilter component = gameObject2.GetComponent<MeshFilter>();
				component.sharedMesh = new Mesh();
				MeshRenderer component2 = gameObject2.GetComponent<MeshRenderer>();
				component2.sharedMaterials = new Material[1] { wire.material };
				megaWireSpan.mesh = component.sharedMesh;
				megaWireSpan.mesh.name = name + " Wire Mesh " + i;
				megaWireSpan.Init(wire);
				wire.spans.Add(megaWireSpan);
				wire.poles.Add(objs[i + 1].transform);
			}
			MegaWireConnectionHelper component3 = objs[0].GetComponent<MegaWireConnectionHelper>();
			if ((bool)copyfrom)
			{
				wire.Copy(copyfrom, component3);
			}
			else if ((bool)component3)
			{
				wire.Copy(wire, component3);
			}
			else
			{
				MegaWireConnectionDef item = new MegaWireConnectionDef();
				wire.connections.Add(item);
			}
			if (wiresize != 1f)
			{
				for (int j = 0; j < wire.connections.Count; j++)
				{
					wire.connections[j].radius *= wiresize;
				}
			}
			wire.Init();
		}
		return wire;
	}

	public void ChangeStretch(float stretch)
	{
		for (int i = 0; i < spans.Count; i++)
		{
			MegaWireSpan megaWireSpan = spans[i];
			for (int j = 0; j < megaWireSpan.connections.Count; j++)
			{
				MegaWireConnection megaWireConnection = megaWireSpan.connections[j];
				for (int k = 0; k < megaWireConnection.springs.Count; k++)
				{
					megaWireConnection.springs[k].restlen = megaWireConnection.springs[k].initlen * stretch;
				}
			}
		}
	}

	public int GetVertexCount()
	{
		int num = 0;
		for (int i = 0; i < spans.Count; i++)
		{
			num += spans[i].vcount;
		}
		return num;
	}

	public void SetHidden(bool hide)
	{
		for (int i = 0; i < spans.Count; i++)
		{
			if (hide)
			{
				spans[i].gameObject.hideFlags = HideFlags.HideInHierarchy | HideFlags.HideInInspector | HideFlags.NotEditable;
			}
			else
			{
				spans[i].gameObject.hideFlags = HideFlags.None;
			}
		}
	}

	public void SetSelection(List<GameObject> objs, bool add)
	{
	}

	public void UpdateOffsets()
	{
		for (int i = 0; i < spans.Count; i++)
		{
			MegaWireSpan megaWireSpan = spans[i];
			for (int j = 0; j < megaWireSpan.connections.Count; j++)
			{
				MegaWireConnection megaWireConnection = megaWireSpan.connections[j];
				megaWireConnection.inOffset = connections[j].inOffset;
				megaWireConnection.outOffset = connections[j].outOffset;
				for (int k = 0; k < megaWireConnection.constraints.Count; k++)
				{
					MegaWireConstraint megaWireConstraint = megaWireConnection.constraints[k];
					if (megaWireConstraint.GetType() == typeof(MegaWirePointConstraint))
					{
						MegaWirePointConstraint megaWirePointConstraint = (MegaWirePointConstraint)megaWireConstraint;
						if (megaWirePointConstraint.p1 == 0)
						{
							megaWirePointConstraint.offset = megaWireConnection.inOffset;
						}
						else
						{
							megaWirePointConstraint.offset = megaWireConnection.outOffset;
						}
					}
				}
			}
		}
	}

	public void Init()
	{
		for (int i = 0; i < spans.Count; i++)
		{
			MegaWireSpan megaWireSpan = spans[i];
			megaWireSpan.connections.Clear();
			for (int j = 0; j < connections.Count; j++)
			{
				MegaWireConnection megaWireConnection = new MegaWireConnection();
				megaWireConnection.start = megaWireSpan.start;
				megaWireConnection.end = megaWireSpan.end;
				megaWireConnection.inOffset = connections[j].inOffset;
				megaWireConnection.outOffset = connections[j].outOffset;
				megaWireConnection.radius = connections[j].radius;
				MegaWireConnectionHelper component = megaWireSpan.start.GetComponent<MegaWireConnectionHelper>();
				MegaWireConnectionHelper component2 = megaWireSpan.end.GetComponent<MegaWireConnectionHelper>();
				megaWireConnection.inOffset = component2.connections[j].inOffset;
				megaWireConnection.outOffset = component.connections[j].outOffset;
				megaWireSpan.connections.Add(megaWireConnection);
				megaWireConnection.Init(this);
			}
		}
	}

	private void WireUpdate(float t)
	{
		float num = 0f;
		num = (Application.isPlaying ? (Time.deltaTime * fudge) : 0f);
		if (num > 0.05f)
		{
			num = 0.05f;
		}
		Vector3 vector = Vector3.zero;
		if (Camera.main != null)
		{
			vector = Camera.main.transform.position;
		}
		float num2 = disableDist * disableDist;
		bool flag = true;
		if (Application.isPlaying && frameWait > 0)
		{
			frameNum++;
			if (frameNum < frameWait)
			{
				flag = false;
			}
			else
			{
				frameNum = 0;
			}
		}
		bool flag2 = false;
		if (startTime > 0f)
		{
			startTime -= Time.deltaTime;
			flag2 = true;
		}
		for (int i = 0; i < spans.Count; i++)
		{
			Vector3 vector2 = (spans[i].start.position + spans[i].end.position) * 0.5f;
			if (disableOnDistance)
			{
				Vector3 vector3 = (spans[i].connections[0].masses[0].pos + spans[i].connections[0].masses[spans[i].connections[0].masses.Count - 1].pos) * 0.5f;
				distfromcamera = Vector3.SqrMagnitude(vector3 - vector);
				if (distfromcamera < num2)
				{
					spans[i].AllowUpdates = true;
				}
				else
				{
					spans[i].AllowUpdates = false;
				}
			}
			else
			{
				spans[i].AllowUpdates = true;
			}
			spans[i].buildmesh = false;
			if (spans[i].AllowUpdates)
			{
				if (disableOnNotVisible)
				{
					if (spans[i].visible)
					{
						spans[i].buildmesh = true;
					}
				}
				else
				{
					spans[i].buildmesh = true;
				}
			}
			if (!flag)
			{
				spans[i].buildmesh = false;
			}
			if (flag2)
			{
				spans[i].buildmesh = true;
			}
			if (spans[i].time > 0f)
			{
				spans[i].buildmesh = true;
				spans[i].time -= Time.deltaTime;
			}
			if ((bool)wind)
			{
				for (int j = 0; j < spans[i].connections.Count; j++)
				{
					Vector3 pos = vector2 + spans[i].connections[j].inOffset;
					Vector3 vector4 = wind.Force(pos);
					spans[i].connections[j].windFrc = vector4 * windEffect;
				}
			}
			else
			{
				Vector3 vector5 = windFrc * windDir;
				for (int k = 0; k < spans[i].connections.Count; k++)
				{
					spans[i].connections[k].windFrc = vector5 * windEffect;
				}
			}
		}
		while (num > 0f)
		{
			for (int l = 0; l < spans.Count; l++)
			{
				if (spans[l].buildmesh)
				{
					spans[l].UpdateSpan(this, timeStep);
				}
			}
			num -= timeStep;
		}
	}

	public void RunPhysics(float t)
	{
		RebuildWire();
		float num = t;
		if (spans.Count < 1)
		{
			return;
		}
		Matrix4x4 startTm = spans[0].start.transform.localToWorldMatrix;
		for (int i = 0; i < spans.Count; i++)
		{
			Matrix4x4 localToWorldMatrix = spans[i].end.transform.localToWorldMatrix;
			spans[i].startTm = startTm;
			spans[i].endTm = localToWorldMatrix;
			spans[i].time = 0f;
			startTm = localToWorldMatrix;
		}
		while (num > 0f)
		{
			for (int j = 0; j < spans.Count; j++)
			{
				spans[j].UpdateSpan(this, timeStep);
			}
			num -= timeStep;
		}
		for (int k = 0; k < spans.Count; k++)
		{
			spans[k].MoveMasses(this);
		}
		for (int l = 0; l < spans.Count; l++)
		{
			spans[l].BuildMesh(this);
		}
	}

	public Vector3 SetWeight(float alpha, int strand, float weight, bool snap)
	{
		alpha = Mathf.Clamp(alpha, 0f, 0.9999f);
		float num = alpha * (float)spans.Count;
		int num2 = (int)num;
		float num3 = num - (float)num2;
		MegaWireSpan megaWireSpan = spans[num2];
		MegaWireConnection megaWireConnection = megaWireSpan.connections[strand];
		float num4 = num3 * (float)(megaWireConnection.masses.Count - 1);
		int num5 = (int)num4 + 1;
		float num6 = num4 - (float)(num5 - 1);
		if (snap)
		{
			num6 = ((!(num6 > 0.5f)) ? 0f : 0.999f);
		}
		Vector3 vector = megaWireConnection.masspos[num5 - 1];
		Vector3 vector2 = megaWireConnection.masspos[num5];
		Vector3 vector3 = megaWireConnection.masspos[num5 + 1];
		Vector3 vector4 = megaWireConnection.masspos[num5 + 2];
		Vector3 zero = Vector3.zero;
		zero.y = (0f - weight) * (1f - num6);
		megaWireConnection.masses[num5 - 1].forcec = zero;
		zero.y = (0f - weight) * num6;
		megaWireConnection.masses[num5].forcec = zero;
		return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num6 * num6 * num6) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num6 * num6) + (-vector + vector3) * num6 + 2f * vector2);
	}

	public Vector3 GetPos(float alpha, int strand, bool snap)
	{
		alpha = Mathf.Clamp(alpha, 0f, 0.9999f);
		float num = alpha * (float)spans.Count;
		int num2 = (int)num;
		float num3 = num - (float)num2;
		MegaWireSpan megaWireSpan = spans[num2];
		MegaWireConnection megaWireConnection = megaWireSpan.connections[strand];
		float num4 = num3 * (float)(megaWireConnection.masses.Count - 1);
		int num5 = (int)num4 + 1;
		float num6 = num4 - (float)(num5 - 1);
		if (snap)
		{
			num6 = ((!(num6 > 0.5f)) ? 0f : 0.999f);
		}
		Vector3 vector = megaWireConnection.masspos[num5 - 1];
		Vector3 vector2 = megaWireConnection.masspos[num5];
		Vector3 vector3 = megaWireConnection.masspos[num5 + 1];
		Vector3 vector4 = megaWireConnection.masspos[num5 + 2];
		return 0.5f * ((-vector + 3f * vector2 - 3f * vector3 + vector4) * (num6 * num6 * num6) + (2f * vector - 5f * vector2 + 4f * vector3 - vector4) * (num6 * num6) + (-vector + vector3) * num6 + 2f * vector2);
	}

	private void Start()
	{
	}

	public void SetWireVisible(bool show)
	{
		for (int i = 0; i < spans.Count; i++)
		{
			spans[i].gameObject.SetActive(show);
		}
	}

	[ContextMenu("Rebuild Wire")]
	public void RebuildWire()
	{
		Init();
		for (int i = 0; i < spans.Count; i++)
		{
			spans[i].MoveMasses(this);
		}
		for (int j = 0; j < spans.Count; j++)
		{
			spans[j].BuildMesh(this);
		}
	}

	private void LateUpdate()
	{
		if (!Enabled || DisableAll)
		{
			return;
		}
		Matrix4x4 matrix4x = Matrix4x4.identity;
		if (spans.Count > 0)
		{
			matrix4x = spans[0].start.transform.localToWorldMatrix;
		}
		for (int i = 0; i < spans.Count; i++)
		{
			Matrix4x4 localToWorldMatrix = spans[i].end.transform.localToWorldMatrix;
			if (matrix4x != spans[i].startTm)
			{
				spans[i].startTm = matrix4x;
				spans[i].time = awakeTime;
			}
			if (localToWorldMatrix != spans[i].endTm)
			{
				spans[i].endTm = localToWorldMatrix;
				spans[i].time = awakeTime;
			}
			matrix4x = localToWorldMatrix;
		}
		if (Rebuild)
		{
			Rebuild = false;
			RebuildWire();
		}
		WireUpdate(timeStep);
		for (int j = 0; j < spans.Count; j++)
		{
			if (spans[j].buildmesh)
			{
				spans[j].MoveMasses(this);
				spans[j].BuildMesh(this);
				spans[j].buildmesh = false;
			}
		}
		builduvs = false;
	}
}
