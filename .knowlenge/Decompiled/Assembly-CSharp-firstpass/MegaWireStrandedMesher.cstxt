using System;
using UnityEngine;

[Serializable]
public class MegaWireStrandedMesher : MegaWireMesher
{
	private Matrix4x4 wtm;

	public int sides = 4;

	public int segments = 20;

	public float uvtwist;

	public float uvtilex = 1f;

	public float uvtiley = 1f;

	public int strands = 1;

	public float offset;

	public float Twist;

	public bool cap = true;

	public float strandRadius;

	public float SegsPerUnit = 0.02f;

	public float TwistPerUnit;

	public bool calcBounds = true;

	public bool calcTangents;

	public bool genuv = true;

	public bool linInterp;

	private Vector3 ropeup;

	private Vector3[] cross;

	private Vector3[] cnorms;

	public void Copy(MegaWireStrandedMesher src)
	{
		sides = src.sides;
		segments = src.segments;
		uvtwist = src.uvtwist;
		uvtilex = src.uvtilex;
		uvtiley = src.uvtiley;
		strands = src.strands;
		offset = src.offset;
		Twist = src.Twist;
		cap = src.cap;
		strandRadius = src.strandRadius;
		SegsPerUnit = src.SegsPerUnit;
		TwistPerUnit = src.TwistPerUnit;
		calcBounds = src.calcBounds;
		linInterp = src.linInterp;
		genuv = src.genuv;
	}

	public override void BuildMesh(MegaWire rope, MegaWireSpan span)
	{
		int count = span.connections.Count;
		float num = uvtiley * span.WireLength;
		Twist = TwistPerUnit * span.WireLength;
		segments = (int)(span.WireLength * SegsPerUnit);
		if (segments < 1)
		{
			segments = 1;
		}
		int num2 = (segments + 1) * (sides + 1) * strands * count;
		int num3 = sides * 2 * segments * strands * count;
		if (span.verts == null || span.verts.Length != num2)
		{
			span.verts = new Vector3[num2];
		}
		bool flag = false;
		if ((span.uvs == null || span.uvs.Length != num2) && genuv)
		{
			span.uvs = new Vector2[num2];
			rope.builduvs = true;
		}
		if (span.tris == null || span.tris.Length != num3 * 3)
		{
			span.tris = new int[num3 * 3];
			flag = true;
		}
		if (span.norms == null || span.norms.Length != num2)
		{
			span.norms = new Vector3[num2];
		}
		int num4 = 0;
		int num5 = 0;
		BuildCrossSection(1f);
		for (int i = 0; i < span.connections.Count; i++)
		{
			MegaWireConnection megaWireConnection = span.connections[i];
			float num6 = rope.connections[i].radius * 0.5f + offset;
			float num7 = 0f;
			if (strands == 1)
			{
				num6 = offset;
				num7 = rope.connections[i].radius;
			}
			else
			{
				num7 = rope.connections[i].radius * 0.5f + strandRadius;
			}
			Vector2 zero = Vector2.zero;
			Vector3 zero2 = Vector3.zero;
			for (int j = 0; j < strands; j++)
			{
				int num8;
				if (strands == 1)
				{
					num8 = num4;
					if (linInterp)
					{
						for (int k = 0; k <= segments; k++)
						{
							float num9 = (float)k / (float)segments;
							float num10 = num9 * uvtwist;
							wtm = megaWireConnection.GetDeformMatLin(num9);
							for (int l = 0; l <= cross.Length; l++)
							{
								Vector3 vector = cross[l % cross.Length];
								ref Vector3 reference = ref span.verts[num4];
								reference = wtm.MultiplyPoint3x4(vector * num7);
								ref Vector3 reference2 = ref span.norms[num4];
								reference2 = wtm.MultiplyVector(vector);
								if (genuv && rope.builduvs)
								{
									zero.y = num9 * num;
									zero.x = (float)l / (float)cross.Length * uvtilex + num10;
									span.uvs[num4] = zero;
								}
								num4++;
							}
						}
					}
					else
					{
						for (int m = 0; m <= segments; m++)
						{
							float num11 = (float)m / (float)segments;
							float num12 = num11 * uvtwist;
							wtm = megaWireConnection.GetDeformMat(num11);
							for (int n = 0; n <= cross.Length; n++)
							{
								Vector3 vector2 = cross[n % cross.Length];
								ref Vector3 reference3 = ref span.verts[num4];
								reference3 = wtm.MultiplyPoint3x4(vector2 * num7);
								ref Vector3 reference4 = ref span.norms[num4];
								reference4 = wtm.MultiplyVector(vector2);
								if (genuv && rope.builduvs)
								{
									zero.y = num11 * num;
									zero.x = (float)n / (float)cross.Length * uvtilex + num12;
									span.uvs[num4] = zero;
								}
								num4++;
							}
						}
					}
				}
				else
				{
					float num13 = (float)j / (float)strands * (float)Math.PI * 2f;
					zero2.x = Mathf.Sin(num13) * num6;
					zero2.z = Mathf.Cos(num13) * num6;
					num8 = num4;
					if (linInterp)
					{
						for (int num14 = 0; num14 <= segments; num14++)
						{
							float num15 = (float)num14 / (float)segments;
							float num16 = num15 * uvtwist;
							float num17 = num15 * Twist * (float)Math.PI * 2f;
							zero2.x = Mathf.Sin(num13 + num17) * num6;
							zero2.z = Mathf.Cos(num13 + num17) * num6;
							wtm = megaWireConnection.GetDeformMatLin(num15);
							for (int num18 = 0; num18 <= cross.Length; num18++)
							{
								Vector3 vector3 = cross[num18 % cross.Length];
								ref Vector3 reference5 = ref span.verts[num4];
								reference5 = wtm.MultiplyPoint3x4(vector3 * num7 + zero2);
								ref Vector3 reference6 = ref span.norms[num4];
								reference6 = wtm.MultiplyVector(vector3);
								if (genuv && rope.builduvs)
								{
									zero.y = num15 * num;
									zero.x = (float)num18 / (float)cross.Length * uvtilex + num16;
									span.uvs[num4] = zero;
								}
								num4++;
							}
						}
					}
					else
					{
						for (int num19 = 0; num19 <= segments; num19++)
						{
							float num20 = (float)num19 / (float)segments;
							float num21 = num20 * uvtwist;
							float num22 = num20 * Twist * (float)Math.PI * 2f;
							zero2.x = Mathf.Sin(num13 + num22) * num6;
							zero2.z = Mathf.Cos(num13 + num22) * num6;
							wtm = megaWireConnection.GetDeformMat(num20);
							for (int num23 = 0; num23 <= cross.Length; num23++)
							{
								Vector3 vector4 = cross[num23 % cross.Length];
								ref Vector3 reference7 = ref span.verts[num4];
								reference7 = wtm.MultiplyPoint3x4(vector4 * num7 + zero2);
								ref Vector3 reference8 = ref span.norms[num4];
								reference8 = wtm.MultiplyVector(vector4);
								if (genuv && rope.builduvs)
								{
									zero.y = num20 * num;
									zero.x = (float)num23 / (float)cross.Length * uvtilex + num21;
									span.uvs[num4] = zero;
								}
								num4++;
							}
						}
					}
				}
				if (!flag)
				{
					continue;
				}
				int num24 = sides + 1;
				for (int num25 = 0; num25 < segments; num25++)
				{
					for (int num26 = 0; num26 < cross.Length; num26++)
					{
						int num27 = (num25 + 1) * num24 + num26 + num8;
						int num28 = (num25 + 1) * num24 + (num26 + 1) % num24 + num8;
						int num29 = num25 * num24 + num26 + num8;
						int num30 = num25 * num24 + (num26 + 1) % num24 + num8;
						span.tris[num5++] = num27;
						span.tris[num5++] = num28;
						span.tris[num5++] = num29;
						span.tris[num5++] = num28;
						span.tris[num5++] = num30;
						span.tris[num5++] = num29;
					}
				}
			}
		}
		if ((!genuv && rope.builduvs) || flag)
		{
			span.mesh.Clear(keepVertexLayout: false);
		}
		span.mesh.vertices = span.verts;
		if (genuv && rope.builduvs)
		{
			span.mesh.uv = span.uvs;
		}
		if ((!genuv && rope.builduvs) || flag)
		{
			span.mesh.triangles = span.tris;
		}
		if (calcBounds)
		{
			span.mesh.RecalculateBounds();
		}
		span.mesh.normals = span.norms;
		if (calcTangents && genuv)
		{
			MegaWireMesher.BuildTangents(span.mesh, span.verts, span.uvs, span.mesh.normals, span.tris);
		}
		span.vcount = num2;
	}

	private void BuildCrossSection(float rad)
	{
		if (cross == null || cross.Length != sides)
		{
			cross = new Vector3[sides];
		}
		if (cnorms == null || cnorms.Length != sides)
		{
			cnorms = new Vector3[sides];
		}
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < sides; i++)
		{
			float f = (float)i / (float)sides * (float)Math.PI * 2f;
			zero.x = Mathf.Sin(f);
			zero.y = Mathf.Cos(f);
			cross[i] = zero;
		}
	}
}
