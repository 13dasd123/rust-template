using System;
using UnityEngine;

[Serializable]
public class MegaWireSolverVertlet : MegaWireSolver
{
	private void doCalculateForces(MegaWireConnection rope, MegaWire wire)
	{
		Vector3 gravity = wire.gravity;
		gravity.x += rope.windFrc.x;
		gravity.y += rope.windFrc.y;
		gravity.z += rope.windFrc.z;
		for (int i = 0; i < rope.masses.Count; i++)
		{
			rope.masses[i].force.x = rope.masses[i].mass * gravity.x + rope.masses[i].forcec.x;
			rope.masses[i].force.y = rope.masses[i].mass * gravity.y + rope.masses[i].forcec.y;
			rope.masses[i].force.z = rope.masses[i].mass * gravity.z + rope.masses[i].forcec.z;
		}
		for (int j = 0; j < rope.springs.Count; j++)
		{
			rope.springs[j].doCalculateSpringForce1(rope);
		}
	}

	private void DoConstraints(MegaWireConnection rope, MegaWire wire)
	{
		for (int i = 0; i < rope.constraints.Count; i++)
		{
			rope.constraints[i].ReActivate(rope, wire.timeStep);
		}
		for (int j = 0; j < wire.iters; j++)
		{
			for (int k = 0; k < rope.lenconstraints.Count; k++)
			{
				rope.lenconstraints[k].Apply(rope);
			}
			for (int l = 0; l < rope.constraints.Count; l++)
			{
				rope.constraints[l].Apply(rope);
			}
		}
	}

	public override void doIntegration1(MegaWireConnection rope, MegaWire wire, float dt)
	{
		doCalculateForces(rope, wire);
		float num = dt * dt;
		float num2 = 1f / dt;
		Vector3 vector = default(Vector3);
		Vector3 vector2 = default(Vector3);
		for (int i = 0; i < rope.masses.Count; i++)
		{
			Vector3 pos = rope.masses[i].pos;
			vector.x = rope.masses[i].pos.x - rope.masses[i].last.x;
			vector.y = rope.masses[i].pos.y - rope.masses[i].last.y;
			vector.z = rope.masses[i].pos.z - rope.masses[i].last.z;
			float num3 = rope.masses[i].oneovermass * num;
			vector2.x = rope.masses[i].force.x * num3;
			vector2.y = rope.masses[i].force.y * num3;
			vector2.z = rope.masses[i].force.z * num3;
			rope.masses[i].pos.x += wire.airdrag * vector.x + vector2.x;
			rope.masses[i].pos.y += wire.airdrag * vector.y + vector2.y;
			rope.masses[i].pos.z += wire.airdrag * vector.z + vector2.z;
			rope.masses[i].vel.x = (rope.masses[i].pos.x - pos.x) * num2;
			rope.masses[i].vel.y = (rope.masses[i].pos.y - pos.y) * num2;
			rope.masses[i].vel.z = (rope.masses[i].pos.z - pos.z) * num2;
			rope.masses[i].last = pos;
		}
		DoConstraints(rope, wire);
		if (wire.doCollisions)
		{
			DoCollisions(rope, wire);
		}
	}

	private void DoCollisions(MegaWireConnection rope, MegaWire wire)
	{
		if (wire.useraycast)
		{
			int value = wire.collisionmask.value;
			float maxDistance = wire.collisiondist + wire.collisionoff;
			Vector3 vector = Vector3.up * wire.collisiondist;
			for (int i = 0; i < rope.masses.Count; i++)
			{
				Vector3 origin = rope.masses[i].pos + vector;
				if (Physics.Raycast(origin, -Vector3.up, out var hitInfo, maxDistance, value))
				{
					rope.masses[i].pos.x = hitInfo.point.x;
					rope.masses[i].pos.y = hitInfo.point.y + wire.collisionoff;
					rope.masses[i].pos.z = hitInfo.point.z;
					float num = Vector3.Dot(Vector3.up, rope.masses[i].vel);
					Vector3 vel = Vector3.up * num;
					vel *= 0.9f;
					rope.masses[i].vel = vel;
					rope.masses[i].last = rope.masses[i].pos;
				}
			}
			return;
		}
		for (int j = 0; j < rope.masses.Count; j++)
		{
			if (rope.masses[j].pos.y < wire.floor)
			{
				rope.masses[j].pos.y = wire.floor;
				float num2 = Vector3.Dot(Vector3.up, rope.masses[j].vel);
				Vector3 vel2 = Vector3.up * num2;
				vel2 *= 0.9f;
				rope.masses[j].vel = vel2;
				rope.masses[j].last = rope.masses[j].pos;
			}
		}
	}
}
