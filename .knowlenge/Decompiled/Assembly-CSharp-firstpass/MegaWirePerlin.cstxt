using UnityEngine;

public class MegaWirePerlin
{
	private static MegaWirePerlin instance;

	private static int[] p = new int[512];

	private static int[] permutation = new int[256]
	{
		151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
		96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
		69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
		6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
		94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
		33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
		171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
		27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
		60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
		245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
		1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
		18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
		164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
		226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
		255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
		58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
		119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
		101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
		19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
		112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
		238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
		145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
		181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
		50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
		222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
		78, 66, 215, 61, 156, 180
	};

	public static MegaWirePerlin Instance
	{
		get
		{
			if (instance == null)
			{
				new MegaWirePerlin();
			}
			return instance;
		}
	}

	public MegaWirePerlin()
	{
		if (instance != null)
		{
			Debug.LogError("Cannot have two instances of ImprovedPerlin.");
			return;
		}
		instance = this;
		for (int i = 0; i < 256; i++)
		{
			p[256 + i] = (p[i] = permutation[i]);
		}
	}

	public int Perm(int i)
	{
		return p[i & 0xFF];
	}

	public float Noise(float x)
	{
		int num = (int)Mathf.Floor(x) & 0xFF;
		x -= Mathf.Floor(x);
		float t = fade(x);
		return lerp(t, grad(p[num], x), grad(p[num + 1], x - 1f));
	}

	public float Noise(float x, float y)
	{
		int num = (int)Mathf.Floor(x) & 0xFF;
		int num2 = (int)Mathf.Floor(y) & 0xFF;
		x -= Mathf.Floor(x);
		y -= Mathf.Floor(y);
		float t = fade(x);
		float t2 = fade(y);
		int num3 = p[num] + num2;
		int num4 = p[num + 1] + num2;
		return lerp(t2, lerp(t, grad(p[num3], x, y), grad(p[num4], x - 1f, y)), lerp(t, grad(p[num3 + 1], x, y - 1f), grad(p[num4 + 1], x - 1f, y - 1f)));
	}

	public float Noise(float x, float y, float z)
	{
		float num = Mathf.Floor(x);
		float num2 = Mathf.Floor(y);
		float num3 = Mathf.Floor(z);
		int num4 = (int)num & 0xFF;
		int num5 = (int)num2 & 0xFF;
		int num6 = (int)num3 & 0xFF;
		x -= num;
		y -= num2;
		z -= num3;
		float t = fade(x);
		float t2 = fade(y);
		float t3 = fade(z);
		int num7 = p[num4] + num5;
		int num8 = p[num7] + num6;
		int num9 = p[num7 + 1] + num6;
		int num10 = p[num4 + 1] + num5;
		int num11 = p[num10] + num6;
		int num12 = p[num10 + 1] + num6;
		return lerp(t3, lerp(t2, lerp(t, grad(p[num8], x, y, z), grad(p[num11], x - 1f, y, z)), lerp(t, grad(p[num9], x, y - 1f, z), grad(p[num12], x - 1f, y - 1f, z))), lerp(t2, lerp(t, grad(p[num8 + 1], x, y, z - 1f), grad(p[num11 + 1], x - 1f, y, z - 1f)), lerp(t, grad(p[num9 + 1], x, y - 1f, z - 1f), grad(p[num12 + 1], x - 1f, y - 1f, z - 1f))));
	}

	private float fade(float t)
	{
		return t * t * t * (t * (t * 6f - 15f) + 10f);
	}

	private float lerp(float t, float a, float b)
	{
		return a + t * (b - a);
	}

	private static float grad(int hash, float x)
	{
		return ((hash & 1) != 0) ? (0f - x) : x;
	}

	private float grad(int hash, float x, float y)
	{
		int num = hash & 3;
		float num2 = (((num & 2) != 0) ? (0f - x) : x);
		float num3 = (((num & 1) != 0) ? (0f - y) : y);
		return num2 + num3;
	}

	private float grad(int hash, float x, float y, float z)
	{
		int num = hash & 0xF;
		float num2 = ((num >= 8) ? y : x);
		float num3 = ((num < 4) ? y : ((num != 12 && num != 14) ? z : x));
		return (((num & 1) != 0) ? (0f - num2) : num2) + (((float)(num & 2) != 0f) ? (0f - num3) : num3);
	}

	public float fBm1(float x, float H, float lacunarity, float octaves)
	{
		float num = 0f;
		float num2 = 1f;
		for (int i = 0; i < (int)octaves; i++)
		{
			num = Noise(x) * Mathf.Pow(num2, 0f - H);
			x *= lacunarity;
			num2 *= lacunarity;
		}
		float num3 = octaves - (float)(int)octaves;
		if (num3 != 0f)
		{
			num += num3 * Noise(x) * Mathf.Pow(num2, 0f - H);
		}
		return num;
	}

	public float fBm1(Vector3 vertex, float H, float lacunarity, float octaves)
	{
		return fBm1(vertex.x, vertex.y, vertex.z, H, lacunarity, octaves);
	}

	public float fBm1(float x, float y, float z, float H, float lacunarity, float octaves)
	{
		float num = 0f;
		float num2 = 1f;
		for (int i = 0; (float)i < octaves; i++)
		{
			num += Noise(x, y, z) * Mathf.Pow(num2, 0f - H);
			x *= lacunarity;
			y *= lacunarity;
			z *= lacunarity;
			num2 *= lacunarity;
		}
		float num3 = octaves - (float)(int)octaves;
		if (num3 != 0f)
		{
			num += num3 * Noise(x, y, z) * Mathf.Pow(num2, 0f - H);
		}
		return num;
	}
}
