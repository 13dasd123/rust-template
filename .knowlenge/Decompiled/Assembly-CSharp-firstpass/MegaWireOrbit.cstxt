using System;
using UnityEngine;

[ExecuteInEditMode]
public class MegaWireOrbit : MonoBehaviour
{
	public GameObject target;

	private MeshRenderer render;

	private SkinnedMeshRenderer srender;

	private MeshFilter filter;

	public float distance = 10f;

	public float xSpeed = 250f;

	public float ySpeed = 120f;

	public float zSpeed = 120f;

	public float yMinLimit = -20f;

	public float yMaxLimit = 80f;

	public float xMinLimit = -20f;

	public float xMaxLimit = 20f;

	public float x;

	public float y;

	private Vector3 center;

	public bool Dynamic;

	public Vector3 offset;

	public Vector3 EditTest;

	private Vector3 tpos = default(Vector3);

	private float t;

	public float trantime = 4f;

	public float vx;

	public float vy;

	public float vz;

	public float nx;

	public float ny;

	public float nz;

	public float delay = 0.2f;

	public float delayz = 0.2f;

	public float mindist = 1f;

	private void Start()
	{
		NewTarget(target);
		if ((bool)target)
		{
			tpos = target.transform.position;
			Vector3 eulerAngles = Quaternion.LookRotation(tpos - base.transform.position).eulerAngles;
			x = eulerAngles.y;
			y = eulerAngles.x;
			distance = (tpos - base.transform.position).magnitude;
		}
		else
		{
			Vector3 eulerAngles2 = base.transform.eulerAngles;
			x = eulerAngles2.y;
			y = eulerAngles2.x;
		}
		vx = 0f;
		vy = 0f;
		vz = 0f;
		nx = x;
		ny = y;
	}

	private float easeInOutQuint(float start, float end, float value)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end / 2f * value * value * value * value * value + start;
		}
		value -= 2f;
		return end / 2f * (value * value * value * value * value + 2f) + start;
	}

	private float easeInQuad(float start, float end, float value)
	{
		value /= 1f;
		end -= start;
		return end * value * value + start;
	}

	private float easeInSine(float start, float end, float value)
	{
		end -= start;
		return (0f - end) * Mathf.Cos(value / 1f * ((float)Math.PI / 2f)) + end + start;
	}

	public void NewTarget(GameObject targ)
	{
		if (!(target != targ))
		{
			return;
		}
		target = targ;
		t = 0f;
		if (!target)
		{
			return;
		}
		filter = (MeshFilter)target.GetComponent(typeof(MeshFilter));
		if (filter != null)
		{
			center = filter.sharedMesh.bounds.center;
			return;
		}
		render = (MeshRenderer)target.GetComponent(typeof(MeshRenderer));
		if (render != null)
		{
			center = render.bounds.center;
			return;
		}
		srender = (SkinnedMeshRenderer)target.GetComponent(typeof(SkinnedMeshRenderer));
		if (srender != null)
		{
			center = srender.bounds.center;
		}
	}

	private void LateUpdate()
	{
		if ((bool)target)
		{
			if (Input.GetMouseButton(1))
			{
				nx = x + Input.GetAxis("Mouse X") * xSpeed * 0.02f;
				ny = y - Input.GetAxis("Mouse Y") * ySpeed * 0.02f;
			}
			if (Application.isPlaying)
			{
				x = Mathf.SmoothDamp(x, nx, ref vx, delay);
				y = Mathf.SmoothDamp(y, ny, ref vy, delay);
			}
			else
			{
				x = nx;
				y = ny;
			}
			nz -= Input.GetAxis("Mouse ScrollWheel") * zSpeed;
			y = ClampAngle(y, yMinLimit, yMaxLimit);
			if (Application.isPlaying)
			{
				distance = Mathf.SmoothDamp(distance, nz, ref vz, delayz);
			}
			else
			{
				distance = nz;
			}
			if (distance < mindist)
			{
				distance = mindist;
				nz = mindist;
			}
			Vector3 vector = ((!Dynamic) ? target.transform.TransformPoint(center + offset) : ((filter != null) ? target.transform.TransformPoint(filter.mesh.bounds.center + offset) : ((render != null) ? target.transform.TransformPoint(render.bounds.center + offset) : ((!(srender != null)) ? target.transform.TransformPoint(center + offset) : target.transform.TransformPoint(srender.bounds.center + offset)))));
			if (t < trantime)
			{
				t = trantime;
				tpos.x = easeInSine(tpos.x, vector.x, t / trantime);
				tpos.y = easeInSine(tpos.y, vector.y, t / trantime);
				tpos.z = easeInSine(tpos.z, vector.z, t / trantime);
			}
			else
			{
				tpos = vector;
			}
			Quaternion quaternion = Quaternion.Euler(y, x, 0f);
			Vector3 position = quaternion * new Vector3(0f, 0f, 0f - distance) + tpos;
			base.transform.rotation = quaternion;
			base.transform.position = position;
		}
	}

	private static float ClampAngle(float angle, float min, float max)
	{
		if (angle < -360f)
		{
			angle += 360f;
		}
		if (angle > 360f)
		{
			angle -= 360f;
		}
		return Mathf.Clamp(angle, min, max);
	}

	private void OnGUI()
	{
	}
}
