using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;

public class OrderedList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection, IReadOnlyList<T>, IReadOnlyCollection<T>
{
	private readonly List<T> _list;

	private readonly IComparer<T> _comparer;

	private const string _insertExceptionMsg = "SortedList detemines position to insert automatically - use add method without an index";

	public int Capacity
	{
		get
		{
			return _list.Capacity;
		}
		set
		{
			_list.Capacity = value;
		}
	}

	public int Count => _list.Count;

	object IList.this[int index]
	{
		get
		{
			return _list[index];
		}
		set
		{
			_list[index] = (T)value;
		}
	}

	public T this[int index]
	{
		get
		{
			return _list[index];
		}
		set
		{
			_list[index] = value;
		}
	}

	bool ICollection.IsSynchronized => false;

	object ICollection.SyncRoot => _list;

	bool IList.IsFixedSize => false;

	bool IList.IsReadOnly => false;

	bool ICollection<T>.IsReadOnly => false;

	private OrderedList(List<T> list, IComparer<T> comparer)
	{
		_list = list;
		_comparer = comparer;
	}

	public OrderedList()
		: this(new List<T>(), (IComparer<T>)Comparer<T>.Default)
	{
	}

	public OrderedList(IComparer<T> comparer)
		: this(new List<T>(), comparer)
	{
	}

	public OrderedList(IEnumerable<T> collection)
		: this(collection, (IComparer<T>)Comparer<T>.Default)
	{
	}

	public OrderedList(IEnumerable<T> collection, IComparer<T> comparer)
		: this(new List<T>(collection), comparer)
	{
		_list.Sort(comparer);
	}

	public OrderedList(int capacity)
		: this(new List<T>(capacity), (IComparer<T>)Comparer<T>.Default)
	{
	}

	public OrderedList(int capacity, IComparer<T> comparer)
		: this(new List<T>(capacity), comparer)
	{
	}

	void ICollection<T>.Add(T item)
	{
		Add(item);
	}

	public int Add(T item)
	{
		int num = BinarySearch(item);
		if (num < 0)
		{
			num = ~num;
		}
		_list.Insert(num, item);
		return num;
	}

	int IList.Add(object item)
	{
		return Add((T)item);
	}

	public void AddRange(IEnumerable<T> collection)
	{
		List<T> list = new List<T>(collection);
		if (list.Count == 0)
		{
			return;
		}
		if (_list.Count == 0)
		{
			_list.AddRange(collection);
			_list.Sort(_comparer);
			return;
		}
		list.Sort(_comparer);
		int num = _list.Count;
		int num2;
		for (num2 = list.Count - 1; num2 >= 0; num2--)
		{
			T val = list[num2];
			int num3 = BinarySearch(0, num, val);
			if (num3 < 0)
			{
				num3 = ~num3;
			}
			else
			{
				while (--num3 >= 0 && _list[num3].Equals(val))
				{
				}
				num3++;
			}
			if (num3 <= 0)
			{
				_list.InsertRange(0, list.GetRange(0, num2 + 1));
				break;
			}
			num = num3 - 1;
			val = _list[num];
			int num4 = num2;
			while (--num2 >= 0 && _comparer.Compare(list[num2], val) > 0)
			{
			}
			num2++;
			_list.InsertRange(num3, list.GetRange(num2, num4 - num2 + 1));
		}
	}

	public int BinarySearch(T item)
	{
		return _list.BinarySearch(item, _comparer);
	}

	public int BinarySearch(int index, int count, T item)
	{
		return _list.BinarySearch(index, count, item, _comparer);
	}

	public ReadOnlyCollection<T> AsReadOnly()
	{
		return _list.AsReadOnly();
	}

	public void Clear()
	{
		_list.Clear();
	}

	void IList.Clear()
	{
		//ILSpy generated this explicit interface implementation from .override directive in Clear
		this.Clear();
	}

	void ICollection<T>.Clear()
	{
		//ILSpy generated this explicit interface implementation from .override directive in Clear
		this.Clear();
	}

	public bool Contains(T item)
	{
		return BinarySearch(item) >= 0;
	}

	bool ICollection<T>.Contains(T item)
	{
		//ILSpy generated this explicit interface implementation from .override directive in Contains
		return this.Contains(item);
	}

	bool IList.Contains(object item)
	{
		return Contains((T)item);
	}

	public List<TOutput> ConvertAll<TOutput>(Converter<T, TOutput> converter)
	{
		return _list.ConvertAll(converter);
	}

	public void CopyTo(T[] array)
	{
		_list.CopyTo(array);
	}

	public void CopyTo(T[] array, int arrayIndex)
	{
		_list.CopyTo(array, arrayIndex);
	}

	void ICollection<T>.CopyTo(T[] array, int arrayIndex)
	{
		//ILSpy generated this explicit interface implementation from .override directive in CopyTo
		this.CopyTo(array, arrayIndex);
	}

	void ICollection.CopyTo(Array array, int arrayIndex)
	{
		_list.CopyTo((T[])array, arrayIndex);
	}

	public void CopyTo(int index, T[] array, int arrayIndex, int count)
	{
		_list.CopyTo(index, array, arrayIndex, count);
	}

	public void ForEach(Action<T> action)
	{
		foreach (T item in _list)
		{
			action(item);
		}
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return _list.GetEnumerator();
	}

	public IEnumerator<T> GetEnumerator()
	{
		return _list.GetEnumerator();
	}

	IEnumerator<T> IEnumerable<T>.GetEnumerator()
	{
		//ILSpy generated this explicit interface implementation from .override directive in GetEnumerator
		return this.GetEnumerator();
	}

	public List<T> GetRange(int index, int count)
	{
		return _list.GetRange(index, count);
	}

	public bool Remove(T item)
	{
		int num = BinarySearch(item);
		if (num < 0)
		{
			return false;
		}
		_list.RemoveAt(num);
		return true;
	}

	bool ICollection<T>.Remove(T item)
	{
		//ILSpy generated this explicit interface implementation from .override directive in Remove
		return this.Remove(item);
	}

	void IList.Remove(object item)
	{
		Remove((T)item);
	}

	public void RemoveAt(int index)
	{
		_list.RemoveAt(index);
	}

	void IList<T>.RemoveAt(int index)
	{
		//ILSpy generated this explicit interface implementation from .override directive in RemoveAt
		this.RemoveAt(index);
	}

	void IList.RemoveAt(int index)
	{
		//ILSpy generated this explicit interface implementation from .override directive in RemoveAt
		this.RemoveAt(index);
	}

	public void RemoveRange(int index, int count)
	{
		_list.RemoveRange(index, count);
	}

	public T[] ToArray()
	{
		return _list.ToArray();
	}

	public void TrimExcess()
	{
		_list.TrimExcess();
	}

	public int IndexOf(T item)
	{
		int num = BinarySearch(item);
		if (num < 0)
		{
			return -1;
		}
		while (--num >= 0 && _list[num].Equals(item))
		{
		}
		return num + 1;
	}

	int IList<T>.IndexOf(T item)
	{
		//ILSpy generated this explicit interface implementation from .override directive in IndexOf
		return this.IndexOf(item);
	}

	int IList.IndexOf(object item)
	{
		return IndexOf((T)item);
	}

	public int LastIndexOf(T item)
	{
		int num = BinarySearch(item);
		if (num < 0)
		{
			return -1;
		}
		while (++num < _list.Count && _list[num].Equals(item))
		{
		}
		return num - 1;
	}

	public T[] WithinRange(T min, T max)
	{
		if (_comparer.Compare(min, max) > 0)
		{
			throw new ArgumentException("min must be <= max");
		}
		int num = _list.BinarySearch(max, _comparer);
		int num2;
		if (num >= 0)
		{
			num2 = num + 1;
			while (++num < _list.Count && _comparer.Compare(max, _list[num]) == 0)
			{
			}
			num--;
		}
		else
		{
			num2 = ~num;
			if (num2 <= 0)
			{
				return Array.Empty<T>();
			}
			num = num2 - 1;
		}
		int num3 = _list.BinarySearch(0, num2, min, _comparer);
		if (num3 >= 0)
		{
			while (--num3 >= 0 && _comparer.Compare(max, _list[num3]) == 0)
			{
			}
			num3++;
		}
		else
		{
			num3 = ~num3;
			if (num3 > num)
			{
				return Array.Empty<T>();
			}
		}
		int num4 = num - num3 + 1;
		T[] array = new T[num4];
		_list.CopyTo(num3, array, 0, num4);
		return array;
	}

	void IList.Insert(int index, object item)
	{
		throw new NotImplementedException("SortedList detemines position to insert automatically - use add method without an index");
	}

	void IList<T>.Insert(int index, T item)
	{
		throw new NotImplementedException("SortedList detemines position to insert automatically - use add method without an index");
	}
}
