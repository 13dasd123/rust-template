using System;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Ext.Chaos.Json;

public class FormerlySerializedAsConverter : JsonConverter
{
	public override bool CanWrite => false;

	public override bool CanConvert(Type objectType)
	{
		return objectType.GetCustomAttribute(typeof(FormerlySerializedAsAttribute)) != null;
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		JObject jObject = JObject.Load(reader);
		object obj = Activator.CreateInstance(objectType);
		PropertyInfo[] properties = objectType.GetProperties();
		foreach (PropertyInfo propertyInfo in properties)
		{
			FormerlySerializedAsAttribute customAttribute = propertyInfo.GetCustomAttribute<FormerlySerializedAsAttribute>();
			if (customAttribute != null)
			{
				JToken jToken = jObject.SelectToken(customAttribute.OldName);
				if (jToken != null && jToken.Type != JTokenType.Null)
				{
					object value = jToken.ToObject(propertyInfo.PropertyType, serializer);
					propertyInfo.SetValue(obj, value);
				}
			}
			else
			{
				JToken jToken2 = jObject.SelectToken(propertyInfo.Name);
				if (jToken2 != null && jToken2.Type != JTokenType.Null)
				{
					object value2 = jToken2.ToObject(propertyInfo.PropertyType, serializer);
					propertyInfo.SetValue(obj, value2);
				}
			}
		}
		return obj;
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		serializer.Serialize(writer, value);
	}
}
