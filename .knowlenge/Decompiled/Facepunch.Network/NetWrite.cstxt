using System;
using System.IO;
using System.Text;
using Network;
using UnityEngine;

public class NetWrite : Stream
{
	private static MemoryStream buffer = new MemoryStream();

	private BaseNetwork netwrite;

	private MemoryStream stream;

	public override bool CanSeek => stream.CanSeek;

	public override bool CanRead => true;

	public override bool CanWrite => false;

	public override long Length
	{
		get
		{
			throw new NotImplementedException();
		}
	}

	public override long Position
	{
		get
		{
			throw new NotImplementedException();
		}
		set
		{
			throw new NotImplementedException();
		}
	}

	public NetWrite(BaseNetwork netwrite)
	{
		this.netwrite = netwrite;
		stream = new MemoryStream();
	}

	public void Shutdown()
	{
		stream.Dispose();
		stream = null;
		netwrite = null;
	}

	public bool Start()
	{
		stream.Position = 0L;
		stream.SetLength(0L);
		return true;
	}

	public void Send(SendInfo info)
	{
		netwrite.Send(info, stream);
	}

	public void PacketID(Message.Type val)
	{
		byte b = (byte)val;
		b += 140;
		UInt8(b);
	}

	public void UInt8(byte val)
	{
		Union8 u = default(Union8);
		u.u = val;
		Write8(u);
	}

	public void UInt16(ushort val)
	{
		Union16 u = default(Union16);
		u.u = val;
		Write16(u);
	}

	public void UInt32(uint val)
	{
		Union32 u = default(Union32);
		u.u = val;
		Write32(u);
	}

	public void UInt64(ulong val)
	{
		Union64 u = default(Union64);
		u.u = val;
		Write64(u);
	}

	public void Int8(sbyte val)
	{
		Union8 u = default(Union8);
		u.i = val;
		Write8(u);
	}

	public void Int16(short val)
	{
		Union16 u = default(Union16);
		u.i = val;
		Write16(u);
	}

	public void Int32(int val)
	{
		Union32 u = default(Union32);
		u.i = val;
		Write32(u);
	}

	public void Int64(long val)
	{
		Union64 u = default(Union64);
		u.i = val;
		Write64(u);
	}

	public void Bool(bool val)
	{
		stream.WriteByte((byte)(val ? 1 : 0));
	}

	public void Float(float val)
	{
		Union32 u = default(Union32);
		u.f = val;
		Write32(u);
	}

	public void Double(double val)
	{
		Union64 u = default(Union64);
		u.f = val;
		Write64(u);
	}

	public void Bytes(byte[] val)
	{
		stream.Write(val, 0, val.Length);
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		stream.Write(buffer, offset, count);
	}

	public override void WriteByte(byte value)
	{
		stream.WriteByte(value);
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		return stream.Seek(offset, origin);
	}

	private byte[] GetWriteBuffer()
	{
		return stream.GetBuffer();
	}

	private long GetWriteOffset(long i)
	{
		long position = stream.Position;
		if (stream.Length < position + i)
		{
			stream.SetLength(position + i);
		}
		stream.Position = position + i;
		return position;
	}

	private void Write8(Union8 u)
	{
		long writeOffset = GetWriteOffset(1L);
		GetWriteBuffer()[writeOffset] = u.b1;
	}

	private void Write16(Union16 u)
	{
		long writeOffset = GetWriteOffset(2L);
		byte[] writeBuffer = GetWriteBuffer();
		writeBuffer[writeOffset] = u.b1;
		writeBuffer[writeOffset + 1] = u.b2;
	}

	private void Write32(Union32 u)
	{
		long writeOffset = GetWriteOffset(4L);
		byte[] writeBuffer = GetWriteBuffer();
		writeBuffer[writeOffset] = u.b1;
		writeBuffer[writeOffset + 1] = u.b2;
		writeBuffer[writeOffset + 2] = u.b3;
		writeBuffer[writeOffset + 3] = u.b4;
	}

	private void Write64(Union64 u)
	{
		long writeOffset = GetWriteOffset(8L);
		byte[] writeBuffer = GetWriteBuffer();
		writeBuffer[writeOffset] = u.b1;
		writeBuffer[writeOffset + 1] = u.b2;
		writeBuffer[writeOffset + 2] = u.b3;
		writeBuffer[writeOffset + 3] = u.b4;
		writeBuffer[writeOffset + 4] = u.b5;
		writeBuffer[writeOffset + 5] = u.b6;
		writeBuffer[writeOffset + 6] = u.b7;
		writeBuffer[writeOffset + 7] = u.b8;
	}

	public void String(string val)
	{
		if (string.IsNullOrEmpty(val))
		{
			BytesWithSize((MemoryStream)null);
			return;
		}
		if (buffer.Capacity < val.Length * 8)
		{
			buffer.Capacity = val.Length * 8;
		}
		buffer.Position = 0L;
		buffer.SetLength(buffer.Capacity);
		int bytes = Encoding.UTF8.GetBytes(val, 0, val.Length, buffer.GetBuffer(), 0);
		buffer.SetLength(bytes);
		BytesWithSize(buffer);
	}

	public void Vector3(Vector3 obj)
	{
		Float(obj.x);
		Float(obj.y);
		Float(obj.z);
	}

	public void Quaternion(Quaternion obj)
	{
		Float(obj.x);
		Float(obj.y);
		Float(obj.z);
		Float(obj.w);
	}

	public void Ray(Ray obj)
	{
		Vector3(obj.origin);
		Vector3(obj.direction);
	}

	public void EntityID(uint id)
	{
		UInt32(id);
	}

	public void GroupID(uint id)
	{
		UInt32(id);
	}

	public void BytesWithSize(MemoryStream val)
	{
		if (val == null || val.Length == 0L)
		{
			UInt32(0u);
		}
		else
		{
			BytesWithSize(val.GetBuffer(), (int)val.Length);
		}
	}

	public void BytesWithSize(byte[] b)
	{
		BytesWithSize(b, b.Length);
	}

	public void BytesWithSize(byte[] b, int length)
	{
		if (b == null || b.Length == 0 || length == 0)
		{
			UInt32(0u);
		}
		else if ((uint)length > 10485760u)
		{
			UInt32(0u);
			Debug.LogError("BytesWithSize: Too big " + length);
		}
		else
		{
			UInt32((uint)length);
			Write(b, 0, length);
		}
	}

	public override void Flush()
	{
		throw new NotImplementedException();
	}

	public override int Read(byte[] buffer, int offset, int count)
	{
		throw new NotImplementedException();
	}

	public override int ReadByte()
	{
		throw new NotImplementedException();
	}

	public override void SetLength(long value)
	{
		throw new NotImplementedException();
	}
}
