using System.Collections.Generic;
using Facepunch;
using Network;
using Network.Visibility;
using Oxide.Core;
using UnityEngine;

public abstract class Server : BaseNetwork
{
	public static ulong MaxPacketsPerSecond = 1500uL;

	public static int MaxPacketSize = 5000000;

	public static int MaxConnectionsPerIP = 5;

	public static float MaxReceiveTime = 20f;

	public string ip = "";

	public int port = 5678;

	public bool compressionEnabled;

	public bool logging;

	public Manager visibility;

	public IServerCallback callbackHandler;

	public bool debug;

	internal uint lastValueGiven = 1024u;

	public List<Connection> connections = new List<Connection>();

	private Dictionary<ulong, Connection> connectionByGUID = new Dictionary<ulong, Connection>();

	private Dictionary<string, List<Connection>> connectionsByIP = new Dictionary<string, List<Connection>>();

	public virtual string ProtocolId => "none";

	public virtual bool AllowPassthroughMessages => false;

	public abstract bool IsConnected();

	public void Reset()
	{
		ResetUIDs();
	}

	public virtual bool Start()
	{
		return true;
	}

	public virtual void Stop(string shutdownMsg)
	{
	}

	public virtual void Cycle()
	{
	}

	public abstract void Disconnect(Connection cn);

	public abstract void Kick(Connection cn, string message, bool logfile = false);

	public uint TakeUID()
	{
		if (lastValueGiven > 4294967263u)
		{
			Debug.LogError("TakeUID - hitting ceiling limit!" + lastValueGiven);
		}
		lastValueGiven++;
		return lastValueGiven;
	}

	public void ReturnUID(uint uid)
	{
	}

	internal void ResetUIDs()
	{
		lastValueGiven = 1024u;
	}

	public Networkable CreateNetworkable()
	{
		Networkable networkable = Pool.Get<Networkable>();
		networkable.ID = TakeUID();
		networkable.sv = this;
		return networkable;
	}

	public Networkable CreateNetworkable(uint uid)
	{
		Networkable networkable = Pool.Get<Networkable>();
		networkable.ID = uid;
		networkable.sv = this;
		if (uid > lastValueGiven)
		{
			lastValueGiven = uid;
		}
		return networkable;
	}

	public void DestroyNetworkable(ref Networkable networkable)
	{
		networkable.Destroy();
		Pool.Free(ref networkable);
	}

	protected void OnDisconnected(string strReason, Connection cn)
	{
		if (cn != null)
		{
			cn.connected = false;
			cn.active = false;
			if (callbackHandler != null)
			{
				callbackHandler.OnDisconnected(strReason, cn);
			}
			Interface.CallHook("OnClientDisconnect", cn, strReason);
			RemoveConnection(cn);
		}
	}

	protected Connection FindConnection(ulong guid)
	{
		if (connectionByGUID.TryGetValue(guid, out var value))
		{
			return value;
		}
		return null;
	}

	protected virtual void OnNewConnection()
	{
	}

	protected virtual void OnNewConnection(Connection connection)
	{
		connection.connectionTime = Time.realtimeSinceStartup;
		connections.Add(connection);
		connectionByGUID.Add(connection.guid, connection);
		if (!connectionsByIP.TryGetValue(connection.ipaddress, out var value))
		{
			connectionsByIP.Add(connection.ipaddress, value = Pool.GetList<Connection>());
		}
		value.Add(connection);
		if (value.Count > MaxConnectionsPerIP)
		{
			Kick(connection, "Too many connections from this IP");
		}
		else if (base.write.Start())
		{
			base.write.PacketID(Message.Type.RequestUserInformation);
			base.write.Send(new SendInfo(connection));
		}
	}

	protected void RemoveConnection(Connection connection)
	{
		if (connectionsByIP.TryGetValue(connection.ipaddress, out var value))
		{
			value.Remove(connection);
		}
		if (value != null && value.Count == 0)
		{
			connectionsByIP.Remove(connection.ipaddress);
			Pool.FreeList(ref value);
		}
		connectionByGUID.Remove(connection.guid);
		connections.Remove(connection);
		connection.OnDisconnected();
	}

	public virtual int GetAveragePing(Connection connection)
	{
		return 0;
	}

	public virtual void SendUnconnected(uint netAddr, ushort netPort, byte[] steamResponseBuffer, int packetSize)
	{
	}
}
