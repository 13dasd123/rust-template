using System;
using System.IO;
using System.Text;
using Facepunch.Extend;
using UnityEngine;

public class NetRead : Stream
{
	private MemoryStream _stream;

	public byte[] Data = new byte[3145728];

	public long _length;

	public long _position;

	private static byte[] staticbuffer = new byte[1048576];

	public int Unread => (int)(Length - Position);

	public override bool CanRead => true;

	public override bool CanWrite => false;

	public override long Length => _length;

	public override long Position
	{
		get
		{
			return _position;
		}
		set
		{
			_position = value;
		}
	}

	public override bool CanSeek => true;

	public MemoryStream GetStreamForDecryption()
	{
		if (_stream == null)
		{
			_stream = new MemoryStream(Data, 0, Data.Length, writable: true, publiclyVisible: true);
		}
		_stream.SetLength(Length);
		return _stream;
	}

	public unsafe bool Start(IntPtr data, int length)
	{
		if (length > Data.Length)
		{
			throw new Exception($"Packet was too large (max is {Data.Length})");
		}
		SetLength(length);
		Position = 0L;
		if (_stream != null)
		{
			_stream.SetLength(length);
		}
		fixed (byte* data2 = Data)
		{
			Buffer.MemoryCopy((void*)data, data2, Data.Length, length);
		}
		return true;
	}

	public string String(uint maxLength = 1048576u)
	{
		int num = BytesWithSize(staticbuffer, maxLength);
		if (num <= 0)
		{
			return string.Empty;
		}
		return Encoding.UTF8.GetString(staticbuffer, 0, num);
	}

	public bool TemporaryBytesWithSize(out byte[] buffer, out int size)
	{
		buffer = staticbuffer;
		size = 0;
		uint num = UInt32();
		if (num == 0)
		{
			return false;
		}
		if (num > staticbuffer.Length)
		{
			return false;
		}
		size = Read(staticbuffer, 0, (int)num);
		if (size != num)
		{
			return false;
		}
		return true;
	}

	public uint EntityID()
	{
		return UInt32();
	}

	public uint GroupID()
	{
		return UInt32();
	}

	public int BytesWithSize(byte[] buffer, uint maxLength = uint.MaxValue)
	{
		uint num = UInt32();
		if (num == 0)
		{
			return 0;
		}
		if (num > buffer.Length || num > maxLength)
		{
			return -1;
		}
		if (Read(buffer, 0, (int)num) != num)
		{
			return -1;
		}
		return (int)num;
	}

	public byte[] BytesWithSize(uint maxSize = 10485760u)
	{
		uint num = UInt32();
		if (num == 0)
		{
			return null;
		}
		if (num > maxSize)
		{
			return null;
		}
		byte[] array = new byte[num];
		if (Read(array, 0, (int)num) != num)
		{
			return null;
		}
		return array;
	}

	public override int ReadByte()
	{
		if (_position == Length)
		{
			return -1;
		}
		byte result = Data[_position];
		_position++;
		return result;
	}

	public override void SetLength(long value)
	{
		_length = value;
	}

	public byte PacketID()
	{
		return UInt8();
	}

	public bool Bit()
	{
		return UInt8() != 0;
	}

	public byte UInt8()
	{
		return Read<byte>();
	}

	public ushort UInt16()
	{
		return Read<ushort>();
	}

	public uint UInt32()
	{
		return Read<uint>();
	}

	public ulong UInt64()
	{
		return Read<ulong>();
	}

	public sbyte Int8()
	{
		return Read<sbyte>();
	}

	public short Int16()
	{
		return Read<short>();
	}

	public int Int32()
	{
		return Read<int>();
	}

	public long Int64()
	{
		return Read<long>();
	}

	public float Float()
	{
		return Read<float>();
	}

	public double Double()
	{
		return Read<double>();
	}

	public Vector3 Vector3()
	{
		return Read<Vector3>();
	}

	public Quaternion Quaternion()
	{
		return Read<Quaternion>();
	}

	public Ray Ray()
	{
		return Read<Ray>();
	}

	public unsafe override int Read(byte[] buffer, int offset, int count)
	{
		if (_position + count > _length)
		{
			count = (int)(_length - _position);
		}
		fixed (byte* data = Data)
		{
			fixed (byte* ptr = buffer)
			{
				Buffer.MemoryCopy(data + _position, ptr + offset, count, count);
			}
		}
		_position += count;
		return count;
	}

	public override long Seek(long offset, SeekOrigin origin)
	{
		if (origin == SeekOrigin.Current)
		{
			_position += offset;
			return _position;
		}
		throw new NotImplementedException();
	}

	public unsafe T Read<T>() where T : unmanaged
	{
		if (Unread < sizeof(T))
		{
			return default(T);
		}
		T result = Data.ReadUnsafe<T>((int)_position);
		_position += sizeof(T);
		return result;
	}

	public override void Flush()
	{
		throw new NotImplementedException();
	}

	public override void Write(byte[] buffer, int offset, int count)
	{
		throw new NotImplementedException();
	}

	public override void WriteByte(byte value)
	{
		throw new NotImplementedException();
	}
}
