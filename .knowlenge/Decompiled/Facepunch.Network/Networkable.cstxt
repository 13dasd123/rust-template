#define UNITY_ASSERTIONS
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using Network;
using Network.Visibility;
using UnityEngine;

public class Networkable : Pool.IPooled
{
	public uint ID;

	public Group group;

	public Group secondaryGroup;

	public Subscriber subscriber;

	public NetworkHandler handler;

	private bool updateSubscriptions;

	public Server sv;

	internal Client cl;

	public Connection connection { get; private set; }

	public void Destroy()
	{
		CloseSubscriber();
		if (ID != 0)
		{
			SwitchGroup(null);
			if (sv != null)
			{
				sv.ReturnUID(ID);
			}
		}
	}

	public void EnterPool()
	{
		ID = 0u;
		connection = null;
		group = null;
		secondaryGroup = null;
		sv = null;
		cl = null;
		handler = null;
		updateSubscriptions = false;
	}

	public void LeavePool()
	{
	}

	public void StartSubscriber()
	{
		if (subscriber != null)
		{
			Debug.Log("BecomeSubscriber called twice!");
			return;
		}
		subscriber = sv.visibility.CreateSubscriber(connection);
		OnSubscriptionChange();
	}

	public void OnConnected(Connection c)
	{
		connection = c;
	}

	public void OnDisconnected()
	{
		connection = null;
		CloseSubscriber();
	}

	public void CloseSubscriber()
	{
		if (subscriber != null)
		{
			sv.visibility.DestroySubscriber(ref subscriber);
		}
	}

	public bool UpdateGroups(Vector3 position)
	{
		Debug.Assert(sv != null, "SV IS NULL");
		Debug.Assert(sv.visibility != null, "sv.visibility IS NULL");
		if (sv.visibility.IsInside(this.group, position))
		{
			return false;
		}
		Group group = sv.visibility.GetGroup(position);
		if (group == this.group && this.group != null)
		{
			Debug.LogWarning(string.Concat("UpdateGroups: IsInside isn't giving the same results as GetGroup (", position, ")"));
			return false;
		}
		return SwitchGroup(group);
	}

	public bool SwitchGroup(Group newGroup)
	{
		if (newGroup == group)
		{
			return false;
		}
		using (TimeWarning.New("SwitchGroup"))
		{
			if (group != null)
			{
				using (TimeWarning.New("group.Leave"))
				{
					group.Leave(this);
				}
			}
			Group oldGroup = group;
			group = newGroup;
			if (group != null)
			{
				using (TimeWarning.New("group.Join"))
				{
					group.Join(this);
				}
			}
			if (handler != null && group != null)
			{
				using (TimeWarning.New("OnNetworkGroupChange"))
				{
					handler.OnNetworkGroupChange();
				}
			}
			using (TimeWarning.New("OnSubscriptionChange"))
			{
				OnSubscriptionChange();
			}
			using (TimeWarning.New("OnGroupTransition"))
			{
				OnGroupTransition(oldGroup);
			}
		}
		return true;
	}

	internal void OnGroupTransition(Group oldGroup)
	{
		if (oldGroup == null)
		{
			if (group != null && handler != null)
			{
				handler.OnNetworkSubscribersEnter(group.subscribers);
			}
			return;
		}
		if (group == null)
		{
			if (oldGroup != null && handler != null)
			{
				handler.OnNetworkSubscribersLeave(oldGroup.subscribers);
			}
			return;
		}
		List<Connection> obj = Pool.GetList<Connection>();
		List<Connection> obj2 = Pool.GetList<Connection>();
		oldGroup.subscribers.Compare(group.subscribers, obj, obj2, null);
		if (handler != null)
		{
			handler.OnNetworkSubscribersEnter(obj);
		}
		if (handler != null)
		{
			handler.OnNetworkSubscribersLeave(obj2);
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
	}

	internal void OnSubscriptionChange()
	{
		if (subscriber == null)
		{
			return;
		}
		if (group != null && !subscriber.IsSubscribed(group))
		{
			subscriber.Subscribe(group);
			if (handler != null)
			{
				handler.OnNetworkGroupEnter(group);
			}
		}
		updateSubscriptions = true;
		UpdateHighPrioritySubscriptions();
	}

	public bool SwitchSecondaryGroup(Group newGroup)
	{
		if (newGroup == secondaryGroup)
		{
			return false;
		}
		using (TimeWarning.New("SwitchSecondaryGroup"))
		{
			secondaryGroup = newGroup;
			using (TimeWarning.New("OnSubscriptionChange"))
			{
				OnSubscriptionChange();
			}
		}
		return true;
	}

	private void AddVisibleFromNear(Group additionalGroup, List<Group> groupsVisible)
	{
		if (additionalGroup == null)
		{
			return;
		}
		List<Group> obj = Pool.GetList<Group>();
		sv.visibility.GetVisibleFromNear(additionalGroup, obj);
		for (int i = 0; i < obj.Count; i++)
		{
			Group item = obj[i];
			if (!groupsVisible.Contains(item))
			{
				groupsVisible.Add(item);
			}
		}
		Pool.FreeList(ref obj);
	}

	public bool UpdateSubscriptions(int removeLimit, int addLimit)
	{
		if (!updateSubscriptions)
		{
			return false;
		}
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateSubscriptions"))
		{
			updateSubscriptions = false;
			List<Group> obj = Pool.GetList<Group>();
			List<Group> obj2 = Pool.GetList<Group>();
			List<Group> obj3 = Pool.GetList<Group>();
			sv.visibility.GetVisibleFromFar(this.group, obj3);
			AddVisibleFromNear(secondaryGroup, obj3);
			subscriber.subscribed.Compare(obj3, obj, obj2, null);
			for (int i = 0; i < obj2.Count; i++)
			{
				Group group = obj2[i];
				if (removeLimit > 0)
				{
					subscriber.Unsubscribe(group);
					if (handler != null)
					{
						handler.OnNetworkGroupLeave(group);
					}
					removeLimit -= group.networkables.Count;
				}
				else
				{
					updateSubscriptions = true;
				}
			}
			for (int j = 0; j < obj.Count; j++)
			{
				Group group2 = obj[j];
				if (addLimit > 0)
				{
					subscriber.Subscribe(group2);
					if (handler != null)
					{
						handler.OnNetworkGroupEnter(group2);
					}
					addLimit -= group2.networkables.Count;
				}
				else
				{
					updateSubscriptions = true;
				}
			}
			Pool.FreeList(ref obj);
			Pool.FreeList(ref obj2);
			Pool.FreeList(ref obj3);
		}
		return true;
	}

	public bool UpdateHighPrioritySubscriptions()
	{
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateHighPrioritySubscriptions"))
		{
			List<Group> obj = Pool.GetList<Group>();
			List<Group> obj2 = Pool.GetList<Group>();
			sv.visibility.GetVisibleFromNear(this.group, obj2);
			AddVisibleFromNear(secondaryGroup, obj2);
			subscriber.subscribed.Compare(obj2, obj, null, null);
			for (int i = 0; i < obj.Count; i++)
			{
				Group group = obj[i];
				subscriber.Subscribe(group);
				if (handler != null)
				{
					handler.OnNetworkGroupEnter(group);
				}
			}
			Pool.FreeList(ref obj);
			Pool.FreeList(ref obj2);
		}
		return true;
	}
}
