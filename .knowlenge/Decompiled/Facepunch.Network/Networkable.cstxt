#define UNITY_ASSERTIONS
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using Network;
using Network.Visibility;
using UnityEngine;

public class Networkable : Pool.IPooled
{
	public uint ID;

	public Group group;

	public Subscriber subscriber;

	public NetworkHandler handler;

	internal Server sv;

	internal Client cl;

	public Connection connection { get; private set; }

	public void Destroy()
	{
		CloseSubscriber();
		if (ID != 0)
		{
			SwitchGroup(null);
			if (sv != null)
			{
				sv.ReturnUID(ID);
			}
		}
	}

	public void EnterPool()
	{
		ID = 0u;
		connection = null;
		group = null;
		sv = null;
		cl = null;
		handler = null;
	}

	public void LeavePool()
	{
	}

	public void StartSubscriber()
	{
		if (subscriber != null)
		{
			Debug.Log("BecomeSubscriber called twice!");
			return;
		}
		subscriber = sv.visibility.CreateSubscriber(connection);
		UpdateSubscriptions();
	}

	public void OnConnected(Connection c)
	{
		connection = c;
	}

	public void OnDisconnected()
	{
		connection = null;
		CloseSubscriber();
	}

	public void CloseSubscriber()
	{
		if (subscriber != null)
		{
			sv.visibility.DestroySubscriber(ref subscriber);
		}
	}

	public bool UpdateGroups(Vector3 position)
	{
		Debug.Assert(sv != null, "SV IS NULL");
		Debug.Assert(sv.visibility != null, "sv.visibility IS NULL");
		if (sv.visibility.IsInside(this.group, position))
		{
			return false;
		}
		Group group = sv.visibility.GetGroup(position);
		if (group == this.group && this.group != null)
		{
			Debug.LogWarning(string.Concat("UpdateGroups: IsInside isn't giving the same results as GetGroup (", position, ")"));
			return false;
		}
		return SwitchGroup(group);
	}

	public bool SwitchGroup(Group newGroup)
	{
		if (newGroup == group)
		{
			return false;
		}
		using (TimeWarning.New("SwitchGroup"))
		{
			if (group != null)
			{
				using (TimeWarning.New("group.Leave"))
				{
					group.Leave(this);
				}
			}
			Group oldGroup = group;
			group = newGroup;
			if (group != null)
			{
				using (TimeWarning.New("group.Join"))
				{
					group.Join(this);
				}
			}
			if (handler != null && group != null)
			{
				using (TimeWarning.New("OnNetworkGroupChange"))
				{
					handler.OnNetworkGroupChange();
				}
			}
			UpdateSubscriptions();
			using (TimeWarning.New("OnGroupTransition"))
			{
				OnGroupTransition(oldGroup);
			}
		}
		return true;
	}

	internal void OnGroupTransition(Group oldGroup)
	{
		if (oldGroup == null)
		{
			if (group != null && handler != null)
			{
				handler.OnNetworkSubscribersEnter(group.subscribers);
			}
			return;
		}
		if (group == null)
		{
			if (oldGroup != null && handler != null)
			{
				handler.OnNetworkSubscribersLeave(oldGroup.subscribers);
			}
			return;
		}
		List<Connection> obj = Pool.GetList<Connection>();
		List<Connection> obj2 = Pool.GetList<Connection>();
		oldGroup.subscribers.Compare(group.subscribers, obj, obj2, null);
		if (handler != null)
		{
			handler.OnNetworkSubscribersEnter(obj);
		}
		if (handler != null)
		{
			handler.OnNetworkSubscribersLeave(obj2);
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
	}

	internal void UpdateSubscriptions()
	{
		if (subscriber == null)
		{
			return;
		}
		List<Group> obj = Pool.GetList<Group>();
		List<Group> obj2 = Pool.GetList<Group>();
		List<Group> obj3 = Pool.GetList<Group>();
		sv.visibility.GetVisibleFrom(this.group, obj3);
		using (TimeWarning.New("UpdateSubscriptions"))
		{
			subscriber.subscribed.Compare(obj3, obj, obj2, null);
			for (int i = 0; i < obj2.Count; i++)
			{
				Group group = obj2[i];
				subscriber.Unsubscribe(group);
				if (handler != null)
				{
					handler.OnNetworkGroupLeave(group);
				}
			}
			for (int j = 0; j < obj.Count; j++)
			{
				Group group2 = obj[j];
				subscriber.Subscribe(group2);
				if (handler != null)
				{
					handler.OnNetworkGroupEnter(group2);
				}
			}
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		Pool.FreeList(ref obj3);
	}
}
