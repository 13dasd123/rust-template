using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using Azure.Storage;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Network;
using Newtonsoft.Json;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class FullServerDemos
{
	private DemoUploadManager upload;

	private DemoDiskManager disk = new DemoDiskManager();

	private string sessionId;

	private DateTime sessionStartTime;

	private int chunkIndex;

	private DateTime nextFlushTime;

	private DateTime timeStart;

	private FileStream fileStream;

	private GZipStream zipStream;

	private BinaryWriter writer;

	private long packetCount;

	private int playerIndex;

	private Dictionary<ulong, int> playerIndexes = new Dictionary<ulong, int>();

	private string localChunkFileId;

	private long uncompressedBytes;

	private bool isZipped;

	internal FullServerDemos(Func<bool> isConnected)
	{
		upload = new DemoUploadManager(isConnected);
	}

	internal void OnDemoThreadStart()
	{
		InitializeFullServerDemo();
	}

	internal void OnDemoThreadStop()
	{
		CleanupFullServerDemo();
	}

	internal void CycleDiskQuota()
	{
		try
		{
			disk.EnforceDemoDiskSpaceQuota();
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}

	private void InitializeFullServerDemo()
	{
		Directory.CreateDirectory(DemoConVars.ServerDemoDirectory);
		chunkIndex = 0;
		sessionId = Guid.NewGuid().ToString("N");
		sessionStartTime = DateTime.UtcNow;
		SetupNextDemoChunk(DateTime.UtcNow);
	}

	private void CleanupFullServerDemo()
	{
		FlushServerDemo(DateTime.UtcNow);
	}

	internal void RecordServerDemoPacket(ICollection<Connection> connections, byte[] data, int dataLength, bool isOutgoing)
	{
		if (connections == null)
		{
			connections = Array.Empty<Connection>();
		}
		packetCount++;
		if (DateTime.UtcNow > nextFlushTime)
		{
			DateTime utcNow = DateTime.UtcNow;
			FlushServerDemo(utcNow);
			SetupNextDemoChunk(utcNow);
		}
		int num = (isOutgoing ? 2 : 0) + connections.Count * 2;
		int num2 = 1 + num + dataLength;
		uncompressedBytes += num2;
		ProtocolParser.WriteUInt32(writer.BaseStream, (uint)num2);
		int num3 = (isOutgoing ? 1 : 0);
		writer.Write((byte)num3);
		if (isOutgoing)
		{
			writer.Write((ushort)connections.Count);
		}
		foreach (Connection connection in connections)
		{
			if (!playerIndexes.TryGetValue(connection.guid, out var value))
			{
				value = playerIndex++;
				playerIndexes[connection.guid] = value;
			}
			writer.Write((ushort)value);
		}
		writer.Write(data, 0, dataLength);
	}

	private void FlushServerDemo(DateTime endOfChunk)
	{
		Directory.CreateDirectory(DemoConVars.ServerDemoDirectory);
		if (fileStream != null)
		{
			if (zipStream != null)
			{
				zipStream.Flush();
			}
			fileStream.Flush();
			DemoChunkHeader header = CreateDemoHeader(timeStart, endOfChunk);
			SaveChunkHeader(header);
			writer.Dispose();
			if (zipStream != null)
			{
				zipStream.Dispose();
				zipStream = null;
			}
			fileStream.Dispose();
			if (DemoConVars.UploadDemos && !string.IsNullOrEmpty(DemoConVars.UploadEndpoint))
			{
				DemoUploadRequest request = new DemoUploadRequest(header, DemoPaths.GetLocalDemoPath(localChunkFileId), DemoPaths.GetLocalHeaderPath(localChunkFileId), DemoConVars.UploadEndpoint);
				upload.EnqueueUpload(request);
			}
			chunkIndex++;
		}
	}

	private void SetupNextDemoChunk(DateTime startTime)
	{
		Directory.CreateDirectory(DemoConVars.ServerDemoDirectory);
		localChunkFileId = Guid.NewGuid().ToString("N");
		fileStream = new FileStream(DemoPaths.GetLocalDemoPath(localChunkFileId), FileMode.OpenOrCreate, FileAccess.Write, FileShare.None, 4096, FileOptions.Asynchronous | FileOptions.SequentialScan);
		isZipped = DemoConVars.ZipServerDemos;
		if (isZipped)
		{
			zipStream = new GZipStream(fileStream, System.IO.Compression.CompressionLevel.Optimal);
			writer = new BinaryWriter(zipStream);
		}
		else
		{
			writer = new BinaryWriter(fileStream);
		}
		nextFlushTime = DateTime.UtcNow.AddSeconds(DemoConVars.ServerDemoFlushIntervalSeconds);
		playerIndexes.Clear();
		playerIndex = 0;
		packetCount = 0L;
		timeStart = startTime;
		uncompressedBytes = 0L;
	}

	private DemoChunkHeader CreateDemoHeader(DateTime startTime, DateTime endTime)
	{
		long length = fileStream.Length;
		return new DemoChunkHeader
		{
			ServerId = DemoConVars.ServerId,
			SessionId = sessionId,
			LocalChunkId = localChunkFileId,
			ChunkIndex = chunkIndex,
			SessionStartTime = sessionStartTime,
			TimeStart = startTime,
			TimeEnd = endTime,
			BytesDecompressed = (isZipped ? uncompressedBytes : length),
			BytesCompressed = length,
			PacketCount = packetCount,
			Players = playerIndexes.Select((KeyValuePair<ulong, int> x) => new DemoPlayerInfo
			{
				ChunkPlayerIndex = x.Value,
				Guid = x.Key
			}).ToList(),
			IsZipped = isZipped,
			NetworkVersion = DemoConVars.NetworkVersion,
			Changeset = DemoConVars.Changeset,
			Hostname = DemoConVars.Hostname,
			Seed = DemoConVars.Seed,
			WorldSize = DemoConVars.WorldSize,
			Level = DemoConVars.Level,
			LevelUrl = DemoConVars.LevelUrl,
			Checksum = DemoConVars.Checksum
		};
	}

	private void SaveChunkHeader(DemoChunkHeader header)
	{
		string localHeaderPath = DemoPaths.GetLocalHeaderPath(localChunkFileId);
		string contents = JsonConvert.SerializeObject((object)header, (Formatting)1);
		File.WriteAllText(localHeaderPath, contents);
	}

	public async Task BenchmarkDemoUpload(int concurrencyCount, string pathOverride, int transferSizeOverride)
	{
		ServicePointManager.FindServicePoint(new Uri(DemoConVars.UploadEndpoint)).ConnectionLimit = 4;
		Task task = CreateDemoUploadTask(concurrencyCount, pathOverride, transferSizeOverride);
		Task task2 = CreateDemoUploadTask(concurrencyCount, pathOverride, transferSizeOverride);
		await Task.WhenAll(task, task2);
	}

	private async Task CreateDemoUploadTask(int concurrencyCount, string pathOverride, int transferSizeOverride)
	{
		try
		{
			string path = "Bundles/shared/monuments.bundle";
			if (!string.IsNullOrEmpty(pathOverride))
			{
				path = pathOverride;
			}
			BlobClient blobClient = new BlobContainerClient(new Uri(DemoConVars.UploadEndpoint)).GetBlobClient($"benchmark/upload/{Guid.NewGuid()}");
			Stopwatch stopwatch = Stopwatch.StartNew();
			UnityEngine.Debug.Log("Beginning to upload file...");
			DateTime nextLogTime = default(DateTime);
			int num = 8388608;
			CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();
			cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(20.0));
			if (transferSizeOverride > 0)
			{
				num = transferSizeOverride;
			}
			await blobClient.UploadAsync(path, new BlobUploadOptions
			{
				ProgressHandler = new Progress<long>(delegate(long bytesTransferred)
				{
					if (DateTime.UtcNow > nextLogTime)
					{
						nextLogTime = DateTime.UtcNow.AddSeconds(1.0);
						int num2 = (int)(bytesTransferred / 1024 / 1024);
						UnityEngine.Debug.Log($"Transferred {num2}MB");
					}
				}),
				TransferOptions = new StorageTransferOptions
				{
					MaximumConcurrency = concurrencyCount,
					InitialTransferSize = num,
					MaximumTransferSize = num
				}
			}, cancellationTokenSource.Token);
			UnityEngine.Debug.Log($"Took {Math.Round(stopwatch.Elapsed.TotalSeconds, 1)}s to upload 1GB texture bundle");
		}
		catch (Exception exception)
		{
			UnityEngine.Debug.LogException(exception);
		}
	}
}
