using System;
using Facepunch;
using Network;
using Rust.Demo;
using UnityEngine;

public class DemoClient : Client, IDisposable
{
	protected Reader demoFile;

	public override bool IsPlaying => true;

	public bool PlayingFinished => demoFile.IsFinished;

	public DemoClient(Reader demoFile)
	{
		this.demoFile = demoFile;
		MultithreadingInit();
	}

	public virtual void Dispose()
	{
		demoFile?.Stop();
		demoFile = null;
	}

	public override bool IsConnected()
	{
		return true;
	}

	public void UpdatePlayback(long frameTime)
	{
		if (!PlayingFinished)
		{
			demoFile.Progress(frameTime);
			while (!demoFile.IsFinished && PlaybackPacket())
			{
			}
		}
	}

	private unsafe bool PlaybackPacket()
	{
		Packet packet = demoFile.ReadPacket();
		if (!packet.isValid)
		{
			return false;
		}
		fixed (byte* data = packet.Data)
		{
			HandleMessage((IntPtr)data, packet.Size);
		}
		return IsPlaying;
	}

	private void HandleMessage(IntPtr data, int size)
	{
		NetRead obj = Pool.Get<NetRead>();
		obj.Start(0uL, string.Empty, data, size);
		Decrypt(obj.connection, obj);
		byte b = obj.PacketID();
		if (b < 140)
		{
			Pool.Free(ref obj);
			return;
		}
		b -= 140;
		if (b > 25)
		{
			Debug.LogWarning(string.Concat("Invalid Packet (higher than ", Message.Type.ConsoleReplicatedVars, ")"));
			Disconnect($"Invalid Packet ({b}) {size}b");
			Pool.Free(ref obj);
			return;
		}
		Message obj2 = StartMessage((Message.Type)b, obj);
		if (callbackHandler != null)
		{
			try
			{
				using (TimeWarning.New("OnMessage"))
				{
					callbackHandler.OnNetworkMessage(obj2);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				if (!IsPlaying)
				{
					Disconnect(ex.Message + "\n" + ex.StackTrace);
				}
			}
		}
		obj2.Clear();
		Pool.Free(ref obj2);
		Pool.Free(ref obj);
	}
}
