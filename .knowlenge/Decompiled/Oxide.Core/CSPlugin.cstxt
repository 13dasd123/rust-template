using System;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

public abstract class CSPlugin : Plugin
{
	public struct HookMethod
	{
		public MethodInfo Method;

		public string Name;

		public ParameterInfo[] Parameters;

		public bool IsBaseHook;

		public HookMethod(MethodInfo method)
		{
			Method = method;
			Name = method.Name;
			Parameters = method.GetParameters();
			IsBaseHook = method.Name.StartsWith("base_");
		}
	}

	protected Dictionary<string, List<HookMethod>> hooks = new Dictionary<string, List<HookMethod>>();

	public static T GetLibrary<T>(string name = null) where T : Library
	{
		return Interface.Oxide.GetLibrary<T>(name);
	}

	public CSPlugin()
	{
		List<Type> list = new List<Type>();
		Type type = GetType();
		list.Add(type);
		while (type != typeof(CSPlugin))
		{
			list.Add(type = type.BaseType);
		}
		for (int num = list.Count - 1; num >= 0; num--)
		{
			MethodInfo[] methods = list[num].GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (MethodInfo methodInfo in methods)
			{
				object[] customAttributes = methodInfo.GetCustomAttributes(typeof(HookMethodAttribute), inherit: true);
				if (customAttributes.Length >= 1)
				{
					AddHookMethod((customAttributes[0] as HookMethodAttribute)?.Name, methodInfo);
				}
			}
		}
	}

	public override void HandleAddedToManager(PluginManager manager)
	{
		base.HandleAddedToManager(manager);
		foreach (string key in hooks.Keys)
		{
			Subscribe(key);
		}
		try
		{
			OnCallHook("Init", null);
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException($"Failed to initialize plugin '{base.Name} v{base.Version}'", ex);
			if (base.Loader != null)
			{
				base.Loader.PluginErrors[base.Name] = ex.Message;
			}
		}
	}

	protected void AddHookMethod(string name, MethodInfo method)
	{
		if (!hooks.TryGetValue(name, out var value))
		{
			value = new List<HookMethod>();
			hooks[name] = value;
		}
		value.Add(new HookMethod(method));
	}

	protected sealed override object OnCallHook(string name, object[] args)
	{
		if (!hooks.TryGetValue(name, out var value))
		{
			return null;
		}
		object result = null;
		for (int i = 0; i < value.Count; i++)
		{
			HookMethod method = value[i];
			object[] array = args;
			int num = ((args != null) ? args.Length : 0);
			ParameterInfo[] parameters = method.Parameters;
			if (num != parameters.Length)
			{
				array = new object[parameters.Length];
				if (num > 0 && array.Length != 0)
				{
					Array.Copy(args, array, Math.Min(num, array.Length));
				}
				if (array.Length > num)
				{
					for (int j = num; j < array.Length; j++)
					{
						ParameterInfo parameterInfo = parameters[j];
						if (parameterInfo.DefaultValue != null && parameterInfo.DefaultValue != DBNull.Value)
						{
							array[j] = parameterInfo.DefaultValue;
						}
						else if (parameterInfo.ParameterType.IsValueType)
						{
							array[j] = Activator.CreateInstance(parameterInfo.ParameterType);
						}
					}
				}
			}
			try
			{
				result = InvokeMethod(method, array);
			}
			catch (TargetInvocationException ex)
			{
				throw ex.InnerException;
			}
			if (num == parameters.Length)
			{
				continue;
			}
			for (int k = 0; k < parameters.Length; k++)
			{
				ParameterInfo parameterInfo2 = parameters[k];
				if (parameterInfo2.IsOut || parameterInfo2.ParameterType.IsByRef)
				{
					args[k] = array[k];
				}
			}
		}
		return result;
	}

	protected virtual object InvokeMethod(HookMethod method, object[] args)
	{
		return method.Method.Invoke(this, args);
	}
}
