using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.RemoteConsole;
using WebSocketSharp;
using WebSocketSharp.Net.WebSockets;
using WebSocketSharp.Server;

public class RemoteConsole
{
	private struct RconPlayer
	{
		public string SteamID { get; private set; }

		public string OwnerSteamID { get; private set; }

		public string DisplayName { get; private set; }

		public int Ping { get; private set; }

		public string Address { get; private set; }

		public int ConnectedSeconds { get; private set; }

		public float VoiationLevel { get; private set; }

		public float CurrentLevel { get; private set; }

		public float UnspentXp { get; private set; }

		public float Health { get; private set; }

		public RconPlayer(IPlayer player)
		{
			SteamID = player.Id;
			OwnerSteamID = "0";
			DisplayName = player.Name;
			Address = player.Address;
			Health = player.Health;
			Ping = player.Ping;
			ConnectedSeconds = 0;
			VoiationLevel = 0f;
			CurrentLevel = 0f;
			UnspentXp = 0f;
		}
	}

	public class RconListener : WebSocketBehavior
	{
		private readonly RemoteConsole Parent;

		private IPAddress Address;

		public RconListener(RemoteConsole parent)
		{
			base.IgnoreExtensions = true;
			Parent = parent;
		}

		public void SendMessage(RemoteMessage message)
		{
			base.Sessions.Broadcast(message.ToJSON());
		}

		protected override void OnClose(CloseEventArgs e)
		{
			string arg = (string.IsNullOrEmpty(e.Reason) ? "Unknown" : e.Reason);
			Interface.Oxide.LogInfo($"[Rcon] Connection from {Address} closed: {arg} ({e.Code})");
		}

		protected override void OnError(ErrorEventArgs e)
		{
			Interface.Oxide.LogException(e.Message, e.Exception);
		}

		protected override void OnMessage(MessageEventArgs e)
		{
			Parent?.OnMessage(e, base.Context);
		}

		protected override void OnOpen()
		{
			Address = base.Context.UserEndPoint.Address;
			Interface.Oxide.LogInfo($"[Rcon] New connection from {Address}");
		}
	}

	private readonly Covalence covalence = Interface.Oxide.GetLibrary<Covalence>();

	private readonly OxideConfig.OxideRcon config = Interface.Oxide.Config.Rcon;

	private RconListener listener;

	private WebSocketServer server;

	public void Initalize()
	{
		if (!config.Enabled || listener != null || server != null)
		{
			return;
		}
		if (string.IsNullOrEmpty(config.Password))
		{
			Interface.Oxide.LogWarning("[Rcon] Remote console password is not set, disabling");
			return;
		}
		try
		{
			server = new WebSocketServer(config.Port);
			server.WaitTime = TimeSpan.FromSeconds(5.0);
			server.ReuseAddress = true;
			server.AddWebSocketService($"/{config.Password}", () => listener = new RconListener(this));
			server.Start();
			Interface.Oxide.LogInfo($"[Rcon] Server started successfully on port {server.Port}");
		}
		catch (Exception ex)
		{
			Interface.Oxide.LogException($"[Rcon] Failed to start server on port {server.Port}", ex);
			RemoteLogger.Exception($"Failed to start RCON server on port {server.Port}", ex);
		}
	}

	public void Shutdown(string reason = "Server shutting down", CloseStatusCode code = CloseStatusCode.Normal)
	{
		if (server != null)
		{
			server.Stop(code, reason);
			server = null;
			listener = null;
			Interface.Oxide.LogInfo($"[Rcon] Service has stopped: {reason} ({code})");
		}
	}

	public void SendMessage(RemoteMessage message)
	{
		if (message != null && server != null && server.IsListening && listener != null)
		{
			listener.SendMessage(message);
		}
	}

	public void SendMessage(string message, int identifier)
	{
		if (!string.IsNullOrEmpty(message) && server != null && server.IsListening && listener != null)
		{
			listener.SendMessage(RemoteMessage.CreateMessage(message, identifier));
		}
	}

	public void SendMessage(WebSocketContext connection, string message, int identifier)
	{
		if (!string.IsNullOrEmpty(message) && server != null && server.IsListening && listener != null)
		{
			connection?.WebSocket?.Send(RemoteMessage.CreateMessage(message, identifier).ToJSON());
		}
	}

	private void OnMessage(MessageEventArgs e, WebSocketContext connection)
	{
		RemoteMessage message = RemoteMessage.GetMessage(e.Data);
		message.Message = message.Message.Replace("\"", string.Empty);
		if (message == null || covalence == null || string.IsNullOrEmpty(message.Message))
		{
			Interface.Oxide.LogError(string.Format("[Rcon] Failed to process command {0} is null", (message == null) ? "RemoteMessage" : "Covalence"));
			return;
		}
		string[] array = message.Message.Split(' ');
		string text = array[0].ToLower();
		string[] array2 = array.Skip(1).ToArray();
		if (Interface.CallHook("OnRconCommand", connection.UserEndPoint.Address, text, array2) == null)
		{
			switch (text)
			{
			case "broadcast":
			case "chat.say":
			case "global.say":
			case "say":
				BroadcastMessage(text, array2, message.Identifier, connection);
				break;
			case "global.playerlist":
			case "playerlist":
				PlayerListCommand(text, array2, message.Identifier, connection);
				break;
			case "hostname":
			case "server.hostname":
				HostnameCommand(text, array2, message.Identifier, connection);
				break;
			case "global.kick":
			case "kick":
				KickCommand(text, array2, message.Identifier, connection);
				break;
			case "save":
			case "server.save":
				covalence.Server.Save();
				SendMessage(connection, "Server saved", message.Identifier);
				break;
			case "ban":
			case "banid":
			case "global.ban":
			case "global.banid":
				BanCommand(text, array2, message.Identifier, connection);
				break;
			case "global.unban":
			case "unban":
				UnbanCommand(text, array2, message.Identifier, connection);
				break;
			case "server.version":
			case "version":
				SendMessage(connection, $"{covalence.Game} {covalence.Server.Version} - Protocol {covalence.Server.Protocol} with Oxide v{OxideMod.Version}", message.Identifier);
				break;
			case "global.teleport":
			case "global.teleportpos":
			case "teleport":
			case "teleportpos":
				TeleportCommand(text, array2, message.Identifier, connection);
				break;
			default:
				covalence.Server.Command(text, array2);
				break;
			}
		}
	}

	private void BroadcastMessage(string command, string[] args, int identifier, WebSocketContext connection)
	{
		string arg = string.Join(" ", args);
		string text = $"{config.ChatPrefix} {arg}";
		covalence?.Server.Broadcast(text);
		text = Regex.Replace(text, "<[^>]*>", string.Empty);
		SendMessage($"[Chat] {text}", identifier);
	}

	private void PlayerListCommand(string command, string[] args, int identifier, WebSocketContext connection)
	{
		List<RconPlayer> list = new List<RconPlayer>();
		foreach (IPlayer item in covalence.Players.Connected)
		{
			list.Add(new RconPlayer(item));
		}
		SendMessage(connection, JsonConvert.SerializeObject(list.ToArray(), Formatting.Indented), identifier);
	}

	private void HostnameCommand(string command, string[] args, int identifier, WebSocketContext connection)
	{
		string text = string.Join(" ", args);
		if (!string.IsNullOrEmpty(text))
		{
			covalence.Server.Name = text;
		}
		SendMessage(connection, $"server.hostname: \"{covalence.Server.Name}\"", identifier);
	}

	private void KickCommand(string command, string[] args, int identifier, WebSocketContext connection)
	{
		IPlayer player = covalence.Players.FindPlayer(args[0]);
		if (player != null && player.IsConnected)
		{
			string text = string.Join(" ", args.Skip(1).ToArray());
			player.Kick(text);
			SendMessage(connection, $"Player kicked {player} - {text}", identifier);
		}
		else
		{
			SendMessage(connection, $"Player not found {args[0]}", identifier);
		}
	}

	private void BanCommand(string command, string[] args, int identifier, WebSocketContext connection)
	{
		ulong result = 0uL;
		if (ulong.TryParse(args[0], out result))
		{
			if (covalence.Server.IsBanned(result.ToString()))
			{
				SendMessage(connection, $"Player already banned: {result}", identifier);
				return;
			}
			string reason = string.Join(" ", args.Skip(1).ToArray());
			covalence.Server.Ban(result.ToString(), reason);
			SendMessage(connection, $"Player banned: {result}", identifier);
		}
		else
		{
			IPlayer player = covalence.Players.FindPlayer(args[0]);
			if (player == null)
			{
				SendMessage(connection, $"Unable to find player: {args[0]}", identifier);
				return;
			}
			player.Ban(string.Join(" ", args.Skip(1).ToArray()));
			SendMessage(connection, $"Player {player.Name} banned", identifier);
		}
	}

	private void UnbanCommand(string command, string[] args, int identifier, WebSocketContext connection)
	{
		string text = string.Join(" ", args);
		ulong result = 0uL;
		if (ulong.TryParse(text, out result))
		{
			if (covalence.Server.IsBanned(text))
			{
				covalence.Server.Unban(text);
				SendMessage(connection, $"Unbanned ID {text}", identifier);
			}
			else
			{
				SendMessage(connection, $"ID {text} is not banned", identifier);
			}
			return;
		}
		IPlayer player = covalence.Players.FindPlayer(text);
		if (player != null)
		{
			if (!player.IsBanned)
			{
				SendMessage(connection, $"{player.Name} is not banned", identifier);
				return;
			}
			player.Unban();
			SendMessage(connection, $"{player.Name} was unbanned successfully", identifier);
		}
	}

	private void TeleportCommand(string command, string[] args, int identifier, WebSocketContext connection)
	{
		if (args.Length != 2 && args.Length != 4)
		{
			SendMessage(connection, "Usage: teleport <player> <target player>", identifier);
			return;
		}
		if (args.Length == 2)
		{
			IPlayer player = covalence.Players.FindPlayer(args[0]);
			IPlayer player2 = covalence.Players.FindPlayer(args[1]);
			if (player == null || player2 == null)
			{
				SendMessage(connection, "Unable to find target players", identifier);
				return;
			}
			player.Teleport(player2.Position().X, player2.Position().Y, player2.Position().Z);
			SendMessage(connection, $"{player.Name} was teleported to {player2.Name}", identifier);
			return;
		}
		IPlayer player3 = covalence.Players.FindPlayer(args[0]);
		if (player3 == null)
		{
			SendMessage(connection, "Unable to find target player", identifier);
			return;
		}
		float result = -1f;
		float result2 = -1f;
		float result3 = -1f;
		if (!float.TryParse(args[1], out result) && !float.TryParse(args[2], out result2) && !float.TryParse(args[3], out result3))
		{
			SendMessage(connection, $"Unable to parse coordinates X: {args[1]} Y: {args[2]} Z: {args[3]}", identifier);
			return;
		}
		player3.Teleport(result, result2, result3);
		SendMessage($"{player3.Name} was teleported to X: {result} Y: {result2} Z: {result}", identifier);
	}
}
