using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Permissions;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins.Watchers;

public sealed class FSWatcher : PluginChangeWatcher
{
	private class QueuedChange
	{
		internal WatcherChangeTypes type;

		internal Timer.TimerInstance timer;
	}

	private FileSystemWatcher watcher;

	private ICollection<string> watchedPlugins;

	private Dictionary<string, QueuedChange> changeQueue;

	private Timer timers;

	public FSWatcher(string directory, string filter)
	{
		watchedPlugins = new HashSet<string>();
		changeQueue = new Dictionary<string, QueuedChange>();
		timers = Interface.Oxide.GetLibrary<Timer>();
		LoadWatcher(directory, filter);
	}

	[PermissionSet(SecurityAction.Demand, Name = "FullTrust")]
	private void LoadWatcher(string directory, string filter)
	{
		watcher = new FileSystemWatcher(directory, filter);
		watcher.Changed += watcher_Changed;
		watcher.Created += watcher_Changed;
		watcher.Deleted += watcher_Changed;
		watcher.Error += watcher_Error;
		watcher.NotifyFilter = NotifyFilters.LastWrite;
		watcher.IncludeSubdirectories = true;
		watcher.EnableRaisingEvents = true;
		GC.KeepAlive(watcher);
	}

	public void AddMapping(string name)
	{
		watchedPlugins.Add(name);
	}

	public void RemoveMapping(string name)
	{
		watchedPlugins.Remove(name);
	}

	private void watcher_Changed(object sender, FileSystemEventArgs e)
	{
		FileSystemWatcher fileSystemWatcher = (FileSystemWatcher)sender;
		int length = e.FullPath.Length - fileSystemWatcher.Path.Length - Path.GetExtension(e.Name).Length - 1;
		string sub_path = e.FullPath.Substring(fileSystemWatcher.Path.Length + 1, length);
		if (!changeQueue.TryGetValue(sub_path, out var change))
		{
			change = new QueuedChange();
			changeQueue[sub_path] = change;
		}
		change.timer?.Destroy();
		change.timer = null;
		switch (e.ChangeType)
		{
		case WatcherChangeTypes.Changed:
			if (change.type != WatcherChangeTypes.Created)
			{
				change.type = WatcherChangeTypes.Changed;
			}
			break;
		case WatcherChangeTypes.Created:
			if (change.type == WatcherChangeTypes.Deleted)
			{
				change.type = WatcherChangeTypes.Changed;
			}
			else
			{
				change.type = WatcherChangeTypes.Created;
			}
			break;
		case WatcherChangeTypes.Deleted:
			if (change.type == WatcherChangeTypes.Created)
			{
				changeQueue.Remove(sub_path);
				return;
			}
			change.type = WatcherChangeTypes.Deleted;
			break;
		}
		Interface.Oxide.NextTick(delegate
		{
			change.timer?.Destroy();
			change.timer = timers.Once(0.2f, delegate
			{
				change.timer = null;
				changeQueue.Remove(sub_path);
				if (Regex.Match(sub_path, "include\\\\", RegexOptions.IgnoreCase).Success)
				{
					if (change.type == WatcherChangeTypes.Created || change.type == WatcherChangeTypes.Changed)
					{
						FirePluginSourceChanged(sub_path);
					}
				}
				else
				{
					switch (change.type)
					{
					case WatcherChangeTypes.Changed:
						if (watchedPlugins.Contains(sub_path))
						{
							FirePluginSourceChanged(sub_path);
						}
						else
						{
							FirePluginAdded(sub_path);
						}
						break;
					case WatcherChangeTypes.Created:
						FirePluginAdded(sub_path);
						break;
					case WatcherChangeTypes.Deleted:
						if (watchedPlugins.Contains(sub_path))
						{
							FirePluginRemoved(sub_path);
						}
						break;
					case WatcherChangeTypes.Created | WatcherChangeTypes.Deleted:
						break;
					}
				}
			});
		});
	}

	private void watcher_Error(object sender, ErrorEventArgs e)
	{
		Interface.Oxide.NextTick(delegate
		{
			Interface.Oxide.LogError("FSWatcher error: {0}", e.GetException());
			RemoteLogger.Exception("FSWatcher error", e.GetException());
		});
	}
}
