using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Oxide.Core.Plugins.Watchers;

public sealed class ExtensionManager
{
	private IList<Extension> extensions;

	private const string extSearchPattern = "Oxide.*.dll";

	private IList<PluginLoader> pluginloaders;

	private IDictionary<string, Library> libraries;

	private IList<PluginChangeWatcher> changewatchers;

	public CompoundLogger Logger { get; private set; }

	public ExtensionManager(CompoundLogger logger)
	{
		Logger = logger;
		extensions = new List<Extension>();
		pluginloaders = new List<PluginLoader>();
		libraries = new Dictionary<string, Library>();
		changewatchers = new List<PluginChangeWatcher>();
	}

	public void RegisterPluginLoader(PluginLoader loader)
	{
		pluginloaders.Add(loader);
	}

	public IEnumerable<PluginLoader> GetPluginLoaders()
	{
		return pluginloaders;
	}

	public void RegisterLibrary(string name, Library library)
	{
		if (libraries.ContainsKey(name))
		{
			Interface.Oxide.LogError("An extension tried to register an already registered library: " + name);
		}
		else
		{
			libraries[name] = library;
		}
	}

	public IEnumerable<string> GetLibraries()
	{
		return libraries.Keys;
	}

	public Library GetLibrary(string name)
	{
		if (libraries.TryGetValue(name, out var value))
		{
			return value;
		}
		return null;
	}

	public void RegisterPluginChangeWatcher(PluginChangeWatcher watcher)
	{
		changewatchers.Add(watcher);
	}

	public IEnumerable<PluginChangeWatcher> GetPluginChangeWatchers()
	{
		return changewatchers;
	}

	public void LoadExtension(string filename)
	{
		string fileNameWithoutExtension = Utility.GetFileNameWithoutExtension(filename);
		try
		{
			Assembly assembly = Assembly.LoadFile(filename);
			Type typeFromHandle = typeof(Extension);
			Type type = null;
			Type[] exportedTypes = assembly.GetExportedTypes();
			foreach (Type type2 in exportedTypes)
			{
				if (typeFromHandle.IsAssignableFrom(type2))
				{
					type = type2;
					break;
				}
			}
			if (type == null)
			{
				Logger.Write(LogType.Error, "Failed to load extension {0} ({1})", fileNameWithoutExtension, "Specified assembly does not implement an Extension class");
			}
			else if (Activator.CreateInstance(type, this) is Extension extension)
			{
				extension.Load();
				extensions.Add(extension);
				Logger.Write(LogType.Info, "Loaded extension {0} v{1} by {2}", extension.Name, extension.Version, extension.Author);
			}
		}
		catch (Exception ex)
		{
			Logger.WriteException($"Failed to load extension {fileNameWithoutExtension}", ex);
			RemoteLogger.Exception($"Failed to load extension {fileNameWithoutExtension}", ex);
		}
	}

	public void LoadAllExtensions(string directory)
	{
		string[] array = new string[7] { "Oxide.CSharp", "Oxide.JavaScript", "Oxide.Lua", "Oxide.MySql", "Oxide.Python", "Oxide.SQLite", "Oxide.Unity" };
		string[] array2 = new string[19]
		{
			"Oxide.Blackwake", "Oxide.Blockstorm", "Oxide.FortressCraft", "Oxide.FromTheDepths", "Oxide.GangBeasts", "Oxide.Hurtworld", "Oxide.InterstellarRift", "Oxide.MedievalEngineers", "Oxide.Nomad", "Oxide.PlanetExplorers",
			"Oxide.ReignOfKings", "Oxide.Rust", "Oxide.RustLegacy", "Oxide.SavageLands", "Oxide.SevenDaysToDie", "Oxide.SpaceEngineers", "Oxide.TheForest", "Oxide.Terraria", "Oxide.Unturned"
		};
		List<string> list = new List<string>();
		List<string> list2 = new List<string>();
		List<string> list3 = new List<string>();
		string[] files = Directory.GetFiles(directory, "Oxide.*.dll");
		foreach (string item in files.Where((string e) => !e.EndsWith("Oxide.Core.dll") && !e.EndsWith("Oxide.References.dll")))
		{
			if (item.Contains("Oxide.Core.") && Array.IndexOf(files, item.Replace(".Core", "")) != -1)
			{
				Cleanup.Add(item);
			}
			else if (item.Contains("Oxide.Ext.") && Array.IndexOf(files, item.Replace(".Ext", "")) != -1)
			{
				Cleanup.Add(item);
			}
			else if (item.Contains("Oxide.Game."))
			{
				Cleanup.Add(item);
			}
			else if (array.Contains(item.Basename()))
			{
				list.Add(item);
			}
			else if (array2.Contains(item.Basename()))
			{
				list2.Add(item);
			}
			else
			{
				list3.Add(item);
			}
		}
		foreach (string item2 in list)
		{
			LoadExtension(Path.Combine(directory, item2));
		}
		foreach (string item3 in list2)
		{
			LoadExtension(Path.Combine(directory, item3));
		}
		foreach (string item4 in list3)
		{
			LoadExtension(Path.Combine(directory, item4));
		}
		Extension[] array3 = extensions.ToArray();
		foreach (Extension extension in array3)
		{
			try
			{
				extension.OnModLoad();
			}
			catch (Exception ex)
			{
				extensions.Remove(extension);
				Logger.WriteException($"Failed OnModLoad extension {extension.Name} v{extension.Version}", ex);
				RemoteLogger.Exception($"Failed OnModLoad extension {extension.Name} v{extension.Version}", ex);
			}
		}
	}

	public IEnumerable<Extension> GetAllExtensions()
	{
		return extensions;
	}

	public bool IsExtensionPresent(string name)
	{
		return extensions.Any((Extension e) => e.Name == name);
	}

	public Extension GetExtension(string name)
	{
		try
		{
			return extensions.Single((Extension e) => e.Name == name);
		}
		catch (Exception)
		{
			return null;
		}
	}
}
