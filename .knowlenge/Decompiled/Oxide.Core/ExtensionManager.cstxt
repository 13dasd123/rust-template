using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Extensions;
using Oxide.Core.Libraries;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Oxide.Core.Plugins.Watchers;

public sealed class ExtensionManager
{
	private IList<Extension> extensions;

	private const string coreExtSearchPattern = "Oxide.Core.*.dll";

	private const string gameExtSearchPattern = "Oxide.Game.*.dll";

	private const string communitySearchPattern = "Oxide.Ext.*.dll";

	private IList<PluginLoader> pluginloaders;

	private IDictionary<string, Library> libraries;

	private IList<PluginChangeWatcher> changewatchers;

	public CompoundLogger Logger { get; private set; }

	public ExtensionManager(CompoundLogger logger)
	{
		Logger = logger;
		extensions = new List<Extension>();
		pluginloaders = new List<PluginLoader>();
		libraries = new Dictionary<string, Library>();
		changewatchers = new List<PluginChangeWatcher>();
	}

	public void RegisterPluginLoader(PluginLoader loader)
	{
		pluginloaders.Add(loader);
	}

	public IEnumerable<PluginLoader> GetPluginLoaders()
	{
		return pluginloaders;
	}

	public void RegisterLibrary(string name, Library library)
	{
		if (libraries.ContainsKey(name))
		{
			Interface.Oxide.LogError("An extension tried to register an already registered library: " + name);
		}
		else
		{
			libraries[name] = library;
		}
	}

	public IEnumerable<string> GetLibraries()
	{
		return libraries.Keys;
	}

	public Library GetLibrary(string name)
	{
		if (libraries.TryGetValue(name, out var value))
		{
			return value;
		}
		return null;
	}

	public void RegisterPluginChangeWatcher(PluginChangeWatcher watcher)
	{
		changewatchers.Add(watcher);
	}

	public IEnumerable<PluginChangeWatcher> GetPluginChangeWatchers()
	{
		return changewatchers;
	}

	public void LoadExtension(string filename)
	{
		string fileNameWithoutExtension = Utility.GetFileNameWithoutExtension(filename);
		try
		{
			Assembly assembly = Assembly.LoadFile(filename);
			Type typeFromHandle = typeof(Extension);
			Type type = null;
			Type[] exportedTypes = assembly.GetExportedTypes();
			foreach (Type type2 in exportedTypes)
			{
				if (typeFromHandle.IsAssignableFrom(type2))
				{
					type = type2;
					break;
				}
			}
			if (type == null)
			{
				Logger.Write(LogType.Error, "Failed to load extension {0} ({1})", fileNameWithoutExtension, "Specified assembly does not implement an Extension class");
			}
			else if (Activator.CreateInstance(type, this) is Extension extension)
			{
				extension.Load();
				extensions.Add(extension);
				Logger.Write(LogType.Info, "Loaded extension {0} v{1} by {2}", extension.Name, extension.Version, extension.Author);
			}
		}
		catch (Exception ex)
		{
			Logger.WriteException($"Failed to load extension {fileNameWithoutExtension}", ex);
			RemoteLogger.Exception($"Failed to load extension {fileNameWithoutExtension}", ex);
		}
	}

	public void LoadAllExtensions(string directory)
	{
		string[] files = Directory.GetFiles(directory, "Oxide.Core.*.dll");
		string[] files2 = Directory.GetFiles(directory, "Oxide.Game.*.dll");
		string[] files3 = Directory.GetFiles(directory, "Oxide.Ext.*.dll");
		foreach (string item in files.Concat(files2).Concat(files3))
		{
			if (item.Contains(".Ext.") && Array.IndexOf(files, item.Replace(".Ext.", ".Core.")) != -1)
			{
				Cleanup.Add(item);
			}
			else
			{
				LoadExtension(Path.Combine(directory, item));
			}
		}
		Extension[] array = extensions.ToArray();
		foreach (Extension extension in array)
		{
			try
			{
				extension.OnModLoad();
			}
			catch (Exception ex)
			{
				extensions.Remove(extension);
				Logger.WriteException($"Failed OnModLoad extension {extension.Name} v{extension.Version}", ex);
				RemoteLogger.Exception($"Failed OnModLoad extension {extension.Name} v{extension.Version}", ex);
			}
		}
	}

	public IEnumerable<Extension> GetAllExtensions()
	{
		return extensions;
	}

	public bool IsExtensionPresent(string name)
	{
		return extensions.Any((Extension e) => e.Name == name);
	}

	public Extension GetExtension(string name)
	{
		try
		{
			return extensions.Single((Extension e) => e.Name == name);
		}
		catch (Exception)
		{
			return null;
		}
	}
}
