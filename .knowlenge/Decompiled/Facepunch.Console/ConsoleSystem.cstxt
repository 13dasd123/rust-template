using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.Extend;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

public class ConsoleSystem
{
	public class Arg
	{
		public Option Option;

		public Command cmd;

		public string FullString = "";

		public string[] Args;

		public bool Invalid = true;

		public string Reply = "";

		public bool IsClientside => Option.IsClient;

		public bool IsServerside => Option.IsServer;

		public Connection Connection => Option.Connection;

		public bool IsConnectionAdmin
		{
			get
			{
				if (Option.Connection != null && Option.Connection.connected)
				{
					return Option.Connection.authLevel != 0;
				}
				return false;
			}
		}

		public bool IsAdmin
		{
			get
			{
				if (!IsConnectionAdmin)
				{
					return IsRcon;
				}
				return true;
			}
		}

		public bool IsRcon => Option.FromRcon;

		public Arg(Option options, string rconCommand)
		{
			Option = options;
			BuildCommand(rconCommand);
		}

		internal void BuildCommand(string command)
		{
			if (string.IsNullOrEmpty(command))
			{
				Invalid = true;
				return;
			}
			if (command.IndexOf('.') <= 0 || command.IndexOf(' ', 0, command.IndexOf('.')) != -1)
			{
				command = "global." + command;
			}
			int num = command.IndexOf('.');
			if (num <= 0)
			{
				return;
			}
			string text = command.Substring(0, num);
			if (text.Length <= 1)
			{
				return;
			}
			text = text.Trim().ToLower();
			string text2 = command.Substring(num + 1);
			if (text2.Length > 1)
			{
				int num2 = text2.IndexOf(' ');
				if (num2 > 0)
				{
					FullString = text2.Substring(num2 + 1);
					FullString = FullString.Trim();
					Args = FullString.SplitQuotesStrings();
					text2 = text2.Substring(0, num2);
				}
				text2 = text2.Trim().ToLower();
				if (cmd == null && Option.IsClient)
				{
					cmd = Index.Client.Find(text + "." + text2);
				}
				if (cmd == null && Option.IsServer)
				{
					cmd = Index.Server.Find(text + "." + text2);
				}
				Invalid = cmd == null;
			}
		}

		internal bool HasPermission()
		{
			if (cmd == null)
			{
				return false;
			}
			if (Option.IsUnrestricted)
			{
				return true;
			}
			if (IsClientside)
			{
				if (cmd.ClientAdmin)
				{
					if (ClientCanRunAdminCommands != null)
					{
						return ClientCanRunAdminCommands();
					}
					return false;
				}
				if (Option.IsFromServer && !cmd.AllowRunFromServer)
				{
					Debug.Log("Server tried to run command \"" + FullString + "\", but we blocked it.");
					return false;
				}
				return cmd.Client;
			}
			if (cmd.ServerAdmin)
			{
				if (IsRcon)
				{
					return true;
				}
				if (IsAdmin)
				{
					return true;
				}
			}
			if (cmd.ServerUser && Connection != null)
			{
				return true;
			}
			return false;
		}

		internal bool CanSeeInFind(Command command)
		{
			if (command == null)
			{
				return false;
			}
			if (Option.IsUnrestricted)
			{
				return true;
			}
			if (IsClientside)
			{
				return command.Client;
			}
			if (IsServerside)
			{
				return command.Server;
			}
			return false;
		}

		public void ReplyWith(string strValue)
		{
			Reply = strValue;
		}

		public void ReplyWith(object obj)
		{
			Reply = JsonConvert.SerializeObject(obj, Formatting.Indented);
		}

		public bool HasArgs(int iMinimum = 1)
		{
			if (Args == null)
			{
				return false;
			}
			return Args.Length >= iMinimum;
		}

		public string GetString(int iArg, string def = "")
		{
			if (HasArgs(iArg + 1))
			{
				return Args[iArg];
			}
			return def;
		}

		public int GetInt(int iArg, int def = 0)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (int.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public ulong GetULong(int iArg, ulong def = 0uL)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (ulong.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public uint GetUInt(int iArg, uint def = 0u)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (uint.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public ulong GetUInt64(int iArg, ulong def = 0uL)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (ulong.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public float GetFloat(int iArg, float def = 0f)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (float.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public bool GetBool(int iArg, bool def = false)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (@string == string.Empty || @string == "0")
			{
				return false;
			}
			if (@string.Equals("false", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("no", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("none", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("null", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			return true;
		}

		public void ReplyWithObject(object rval)
		{
			if (rval != null)
			{
				if (rval is string)
				{
					ReplyWith((string)rval);
					return;
				}
				string strValue = JsonConvert.SerializeObject(rval, Formatting.Indented);
				ReplyWith(strValue);
			}
		}

		public Vector3 GetVector3(int iArg, Vector3 def = default(Vector3))
		{
			return GetString(iArg, null)?.ToVector3() ?? def;
		}

		public Color GetColor(int iArg, Color def = default(Color))
		{
			return GetString(iArg, null)?.ToColor() ?? def;
		}

		public TimeSpan GetTimeSpan(int iArg)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return TimeSpan.FromSeconds(0.0);
			}
			if (TimeSpan.TryParse(@string, out var result))
			{
				return result;
			}
			return TimeSpan.FromSeconds(0.0);
		}
	}

	public class Factory : Attribute
	{
		public string Name;

		public Factory(string systemName)
		{
			Name = systemName;
		}
	}

	public class Command
	{
		public string Name;

		public string Parent;

		public string FullName;

		public Func<string> GetOveride;

		public Action<string> SetOveride;

		public Action<Arg> Call;

		public bool Variable;

		public bool Saved;

		public bool ServerAdmin;

		public bool ServerUser;

		public bool Replicated;

		public bool ClientAdmin;

		public bool Client;

		public bool ClientInfo;

		public bool AllowRunFromServer;

		public string Description = string.Empty;

		public string Arguments = string.Empty;

		public bool Server
		{
			get
			{
				if (!ServerAdmin)
				{
					return ServerUser;
				}
				return true;
			}
		}

		public string String => GetOveride();

		public int AsInt => String.ToInt();

		public float AsFloat => String.ToFloat();

		public bool AsBool => String.ToBool();

		public Vector3 AsVector3 => String.ToVector3();

		public event Action<Command> OnValueChanged;

		public Command()
		{
			Call = DefaultCall;
		}

		private void ValueChanged()
		{
			if (Saved)
			{
				HasChanges = true;
			}
			if (ClientInfo)
			{
				SendToServer(BuildCommand("setinfo", FullName, String));
			}
			if (this.OnValueChanged != null)
			{
				this.OnValueChanged(this);
			}
		}

		private void DefaultCall(Arg arg)
		{
			if (SetOveride != null && arg.HasArgs())
			{
				Set(arg.Args[0]);
			}
		}

		public void Set(string value)
		{
			if (SetOveride != null)
			{
				string @string = String;
				SetOveride(value);
				if (@string != String)
				{
					ValueChanged();
				}
			}
		}

		public void Set(float f)
		{
			string text = f.ToString("0.00");
			if (!(String == text))
			{
				Set(text);
			}
		}

		public void Set(bool val)
		{
			if (AsBool != val)
			{
				Set(val ? "1" : "0");
			}
		}
	}

	public interface IConsoleCommand
	{
		void Call(Arg arg);
	}

	public static class Index
	{
		public static class Server
		{
			public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static List<Command> Replicated = new List<Command>();

			public static Command Find(string strName)
			{
				if (!strName.Contains("."))
				{
					strName = "global." + strName;
				}
				if (Dict.TryGetValue(strName, out var value))
				{
					return value;
				}
				GlobalDict.TryGetValue(strName.Replace("global.", ""), out value);
				return value;
			}
		}

		public static class Client
		{
			public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Command Find(string strName)
			{
				if (!strName.Contains("."))
				{
					strName = "global." + strName;
				}
				if (Dict.TryGetValue(strName, out var value))
				{
					return value;
				}
				GlobalDict.TryGetValue(strName.Replace("global.", ""), out value);
				return value;
			}
		}

		public static Command[] All { get; set; }

		public static void Initialize(Command[] Commands)
		{
			All = Commands;
			Server.Dict = new Dictionary<string, Command>();
			Client.Dict = new Dictionary<string, Command>();
			Command[] all = All;
			foreach (Command command2 in all)
			{
				if (command2.Server)
				{
					if (Server.Dict.ContainsKey(command2.FullName))
					{
						Debug.LogWarning("Server Vars have multiple entries for " + command2.FullName);
					}
					else
					{
						Server.Dict.Add(command2.FullName, command2);
					}
					if (command2.Parent != "global" && !Server.GlobalDict.ContainsKey(command2.Name))
					{
						Server.GlobalDict.Add(command2.Name, command2);
					}
					if (command2.Replicated)
					{
						if (!command2.Variable || !command2.ServerAdmin)
						{
							Debug.LogWarning("Replicated server var " + command2.FullName + " has a bad config");
						}
						else
						{
							Server.Replicated.Add(command2);
							command2.OnValueChanged += delegate(Command command)
							{
								ConsoleSystem.OnReplicatedVarChanged?.Invoke(command.FullName, command.String);
							};
						}
					}
				}
				if (command2.Client)
				{
					if (Client.Dict.ContainsKey(command2.FullName))
					{
						Debug.LogWarning("Client Vars have multiple entries for " + command2.FullName);
					}
					else
					{
						Client.Dict.Add(command2.FullName, command2);
					}
					if (command2.Parent != "global" && !Client.GlobalDict.ContainsKey(command2.Name))
					{
						Client.GlobalDict.Add(command2.Name, command2);
					}
				}
			}
			Input.RunBind += delegate(string strCommand, bool pressed)
			{
				Run(Option.Client, $"{strCommand} {pressed}");
			};
		}
	}

	public struct Option
	{
		public static Option Unrestricted
		{
			get
			{
				Option result = default(Option);
				result.IsServer = true;
				result.IsClient = true;
				result.ForwardtoServerOnMissing = true;
				result.PrintOutput = true;
				result.IsUnrestricted = true;
				return result;
			}
		}

		public static Option Client
		{
			get
			{
				Option result = default(Option);
				result.IsClient = true;
				result.ForwardtoServerOnMissing = true;
				result.PrintOutput = true;
				return result;
			}
		}

		public static Option Server
		{
			get
			{
				Option result = default(Option);
				result.IsServer = true;
				result.PrintOutput = true;
				result.FromRcon = true;
				return result;
			}
		}

		public bool IsServer { get; set; }

		public bool IsClient { get; set; }

		public bool ForwardtoServerOnMissing { get; set; }

		public bool PrintOutput { get; set; }

		public bool IsUnrestricted { get; set; }

		public bool FromRcon { get; set; }

		public bool IsFromServer { get; set; }

		public Connection Connection { get; set; }

		public Option Quiet()
		{
			PrintOutput = false;
			return this;
		}

		public Option FromServer()
		{
			IsFromServer = true;
			return this;
		}

		public Option FromConnection(Connection connection)
		{
			FromRcon = false;
			Connection = connection;
			return this;
		}
	}

	public static bool HasChanges;

	public static Func<bool> ClientCanRunAdminCommands;

	public static Func<string, bool> OnSendToServer;

	public static string LastError;

	public static Arg CurrentArgs;

	public static event Action<string, string> OnReplicatedVarChanged;

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

	internal static bool SendToServer(string command)
	{
		if (OnSendToServer != null)
		{
			return OnSendToServer(command);
		}
		return false;
	}

	public static void RunFile(Option options, string strFile)
	{
		string[] array = strFile.Split(new char[1] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
		foreach (string text in array)
		{
			if (text[0] != '#')
			{
				Run(options, text);
			}
		}
		HasChanges = false;
	}

	public static string Run(Option options, string strCommand, params object[] args)
	{
		LastError = null;
		string text = BuildCommand(strCommand, args);
		Arg arg = new Arg(options, text);
		bool flag = arg.HasPermission();
		if (!arg.Invalid && flag)
		{
			Arg currentArgs = CurrentArgs;
			CurrentArgs = arg;
			bool flag2 = Internal(arg);
			CurrentArgs = currentArgs;
			if (options.PrintOutput && flag2 && arg.Reply != null && arg.Reply.Length > 0)
			{
				DebugEx.Log(arg.Reply);
			}
			return arg.Reply;
		}
		LastError = "Command not found";
		if (!flag)
		{
			LastError = "Permission denied";
		}
		if (!options.IsServer && (!options.ForwardtoServerOnMissing || !SendToServer(text)))
		{
			LastError = "Command '" + strCommand + "' not found";
			if (options.PrintOutput)
			{
				DebugEx.Log(LastError);
			}
			return null;
		}
		if (options.IsServer && options.PrintOutput)
		{
			LastError = "Command '" + strCommand + "' not found";
			DebugEx.Log(LastError);
		}
		return null;
	}

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null)
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

	public static string BuildCommand(string strCommand, params object[] args)
	{
		if (args == null || args.Length == 0)
		{
			return strCommand;
		}
		foreach (object obj in args)
		{
			strCommand = ((obj != null) ? ((obj is Color color) ? (strCommand + " " + Facepunch.Extend.StringExtensions.QuoteSafe($"{color.r},{color.g},{color.b},{color.a}")) : ((!(obj is Vector3 vector)) ? (strCommand + " " + Facepunch.Extend.StringExtensions.QuoteSafe(obj.ToString())) : (strCommand + " " + Facepunch.Extend.StringExtensions.QuoteSafe($"{vector.x},{vector.y},{vector.z}")))) : (strCommand + " \"\""));
		}
		return strCommand;
	}

	public static string SaveToConfigString(bool bServer)
	{
		string text = "";
		IEnumerable<Command> enumerable = ((!bServer) ? Index.All.Where((Command x) => x.Saved && x.Client) : Index.All.Where((Command x) => x.Saved && x.ServerAdmin));
		foreach (Command item in enumerable)
		{
			if (item.GetOveride != null)
			{
				text = text + item.FullName + " " + Facepunch.Extend.StringExtensions.QuoteSafe(item.String);
				text += Environment.NewLine;
			}
		}
		return text;
	}
}
