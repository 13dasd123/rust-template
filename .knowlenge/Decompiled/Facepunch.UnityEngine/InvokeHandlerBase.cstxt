using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using UnityEngine;

public abstract class InvokeHandlerBase<T> : SingletonComponent<T> where T : MonoBehaviour
{
	private struct InvokeTiming
	{
		public string InvokeName;

		public double InvokeTime;
	}

	public static bool performanceTracking = false;

	public static float maxTickTimeWarning = 0.5f;

	private List<InvokeTiming> performanceTimes = new List<InvokeTiming>();

	protected ListDictionary<InvokeAction, float> curList = new ListDictionary<InvokeAction, float>(2048);

	protected ListHashSet<InvokeAction> addList = new ListHashSet<InvokeAction>(1024);

	protected ListHashSet<InvokeAction> delList = new ListHashSet<InvokeAction>(1024);

	protected int nullIndex;

	protected const int nullChecks = 50;

	private Stopwatch tickStopWatch = new Stopwatch();

	private Stopwatch invokeStopWatch = new Stopwatch();

	protected void LateUpdate()
	{
		ApplyRemoves();
		ApplyAdds();
		DoTick();
		RemoveExpired();
		ApplyRemoves();
		ApplyAdds();
	}

	protected abstract float GetTime();

	protected void DoTick()
	{
		float[] buffer = curList.Values.Buffer;
		InvokeAction[] buffer2 = curList.Keys.Buffer;
		int count = curList.Count;
		float time = GetTime();
		if (performanceTracking)
		{
			tickStopWatch.Restart();
			tickStopWatch.Start();
			performanceTimes.Clear();
		}
		for (int i = 0; i < count; i++)
		{
			if (!(time >= buffer[i]))
			{
				continue;
			}
			InvokeAction invokeAction = buffer2[i];
			if ((bool)invokeAction.sender && !delList.Contains(invokeAction))
			{
				if (invokeAction.repeat >= 0f)
				{
					float num = time + invokeAction.repeat;
					if (invokeAction.random > 0f)
					{
						num += Random.Range(0f - invokeAction.random, invokeAction.random);
					}
					buffer[i] = num;
				}
				else
				{
					QueueRemove(invokeAction);
				}
				if (performanceTracking)
				{
					invokeStopWatch.Restart();
					invokeStopWatch.Start();
				}
				invokeAction.action();
				if (performanceTracking)
				{
					invokeStopWatch.Stop();
					performanceTimes.Add(new InvokeTiming
					{
						InvokeName = invokeAction.action.Method.Name,
						InvokeTime = invokeStopWatch.Elapsed.TotalMilliseconds
					});
				}
			}
			else
			{
				QueueRemove(invokeAction);
			}
		}
		if (!performanceTracking)
		{
			return;
		}
		tickStopWatch.Stop();
		if (!(tickStopWatch.Elapsed.TotalMilliseconds > (double)maxTickTimeWarning))
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Invokes took {tickStopWatch.Elapsed.TotalMilliseconds}ms which is over the warning threshold of {maxTickTimeWarning}ms. Invokes this tick:");
		foreach (InvokeTiming performanceTime in performanceTimes)
		{
			stringBuilder.AppendLine($"{performanceTime.InvokeName}:{performanceTime.InvokeTime}ms");
		}
		UnityEngine.Debug.LogWarning(stringBuilder.ToString());
		performanceTimes.Clear();
	}

	protected void RemoveExpired()
	{
		InvokeAction[] buffer = curList.Keys.Buffer;
		int count = curList.Count;
		if (nullIndex >= count)
		{
			nullIndex = 0;
		}
		int num = Mathf.Min(nullIndex + 50, count);
		while (nullIndex < num)
		{
			InvokeAction invoke = buffer[nullIndex];
			if (!invoke.sender)
			{
				QueueRemove(invoke);
			}
			nullIndex++;
		}
	}

	protected void QueueAdd(InvokeAction invoke)
	{
		if (invoke.action == null)
		{
			UnityEngine.Debug.LogError($"Trying to add an invoke with a null action: {new StackTrace()}");
			return;
		}
		delList.Remove(invoke);
		addList.Remove(invoke);
		addList.Add(invoke);
	}

	protected void QueueRemove(InvokeAction invoke)
	{
		delList.Remove(invoke);
		addList.Remove(invoke);
		delList.Add(invoke);
	}

	protected bool Contains(InvokeAction invoke)
	{
		if (!delList.Contains(invoke))
		{
			if (!curList.Contains(invoke))
			{
				return addList.Contains(invoke);
			}
			return true;
		}
		return false;
	}

	protected void ApplyAdds()
	{
		InvokeAction[] buffer = addList.Values.Buffer;
		int count = addList.Count;
		float time = GetTime();
		for (int i = 0; i < count; i++)
		{
			InvokeAction key = buffer[i];
			curList.Remove(key);
			curList.Add(key, time + key.initial);
		}
		addList.Clear();
	}

	protected void ApplyRemoves()
	{
		InvokeAction[] buffer = delList.Values.Buffer;
		int count = delList.Count;
		for (int i = 0; i < count; i++)
		{
			InvokeAction key = buffer[i];
			curList.Remove(key);
		}
		delList.Clear();
	}
}
