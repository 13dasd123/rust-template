using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ProtoBuf;
using Rust.Demo;
using UnityEngine;

public class Indexer
{
	public class Entity
	{
		public ProtoBuf.Entity Init;

		public ProtoBuf.Entity Data;

		public Vector3 Position;

		public Vector3 Rotation;

		public uint UId => Init.baseNetworkable.uid;

		public Entity Copy()
		{
			return new Entity
			{
				Init = Init,
				Data = Data,
				Position = Position,
				Rotation = Rotation
			};
		}
	}

	public class Keyframe
	{
		public long Position;

		public Entity[] Entities;

		public uint[] Updated;

		public Dictionary<uint, Entity> EntityDict;

		public void Init()
		{
			EntityDict = Entities.ToDictionary((Entity x) => x.UId, (Entity x) => x);
		}

		public bool HasEntity(uint iD)
		{
			return EntityDict.ContainsKey(iD);
		}
	}

	private List<Keyframe> keyframes = new List<Keyframe>();

	private long LastPacketTime;

	private long PacketCount;

	private Dictionary<uint, Entity> currentEnts = new Dictionary<uint, Entity>();

	private long NextKeyframe;

	private List<uint> Updated = new List<uint>();

	public TimeSpan TotalLength => TimeSpan.FromMilliseconds(LastPacketTime);

	public long Interval => 1000L;

	internal Indexer(Reader reader)
	{
		reader.Progress(long.MaxValue);
		while (!reader.IsFinished)
		{
			Packet packet = reader.ReadPacket();
			if (!packet.isValid)
			{
				break;
			}
			TryCreateKeyframe(packet);
			ProcessPacket(packet);
		}
		reader.ResetToStart();
		if (keyframes.Count > 1)
		{
			keyframes[0].Entities = keyframes[1].Entities;
			keyframes[0].EntityDict = keyframes[1].EntityDict;
			keyframes[0].Updated = keyframes[1].Updated;
		}
		Debug.Log($"Index created {keyframes.Count} keyframes");
	}

	private void ProcessPacket(Packet packet)
	{
		PacketCount++;
		LastPacketTime = Math.Max(LastPacketTime, packet.Time);
		using BinaryReader binaryReader = new BinaryReader(new MemoryStream(packet.Data));
		byte b = binaryReader.ReadByte();
		if (b > 140)
		{
			switch ((byte)(b - 140))
			{
			case 5:
				Entities(binaryReader);
				break;
			case 9:
				RpcMessage(binaryReader);
				break;
			case 10:
				EntityPosition(binaryReader);
				break;
			case 6:
				EntityDestroy(binaryReader);
				break;
			}
		}
	}

	private void EntityUpdated(uint ent)
	{
		if (!Updated.Contains(ent))
		{
			Updated.Add(ent);
		}
	}

	private void EntityPosition(BinaryReader reader)
	{
		uint num = reader.ReadUInt32();
		Vector3 position = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
		Vector3 rotation = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
		EntityUpdated(num);
		if (currentEnts.TryGetValue(num, out var value))
		{
			value.Position = position;
			value.Rotation = rotation;
		}
	}

	private void RpcMessage(BinaryReader reader)
	{
	}

	internal Keyframe LookupKeyframeForTime(long time)
	{
		int index = Mathf.FloorToInt(time / Interval);
		return GetKeyframe(index);
	}

	internal Keyframe GetKeyframe(int index)
	{
		index = Mathf.Clamp(index, 0, keyframes.Count - 1);
		return keyframes[index];
	}

	internal HashSet<uint> GetChangedEntities(long from, long to)
	{
		using (TimeWarning.New("GetChangedEntities"))
		{
			int num = Mathf.Min((int)from, (int)to) / (int)Interval - 1;
			int num2 = Mathf.Max((int)from, (int)to) / (int)Interval + 1;
			HashSet<uint> hashSet = new HashSet<uint>();
			for (int i = num; i <= num2; i++)
			{
				Keyframe keyframe = GetKeyframe(i);
				for (int j = 0; j < keyframe.Updated.Length; j++)
				{
					if (!hashSet.Contains(keyframe.Updated[j]))
					{
						hashSet.Add(keyframe.Updated[j]);
					}
				}
			}
			return hashSet;
		}
	}

	private void EntityDestroy(BinaryReader reader)
	{
		uint num = reader.ReadUInt32();
		currentEnts.Remove(num);
		EntityUpdated(num);
	}

	private void Entities(BinaryReader reader)
	{
		reader.ReadUInt32();
		ProtoBuf.Entity entity = ProtoBuf.Entity.Deserialize(reader.BaseStream);
		EntityUpdated(entity.baseNetworkable.uid);
		if (!currentEnts.TryGetValue(entity.baseNetworkable.uid, out var value))
		{
			value = new Entity();
			value.Init = entity;
			currentEnts[value.UId] = value;
		}
		value.Data = entity;
	}

	private void TryCreateKeyframe(Packet packet)
	{
		if (packet.Time >= NextKeyframe)
		{
			NextKeyframe += Interval;
			Keyframe keyframe = new Keyframe
			{
				Position = packet.Position,
				Entities = currentEnts.Select((KeyValuePair<uint, Entity> x) => x.Value.Copy()).ToArray(),
				Updated = Updated.ToArray()
			};
			keyframe.Init();
			keyframes.Add(keyframe);
			Updated.Clear();
		}
	}
}
