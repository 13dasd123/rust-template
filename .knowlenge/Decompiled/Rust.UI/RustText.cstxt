using System;
using Rust.Localization;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

[AddComponentMenu("Rust/UI/RustText")]
public class RustText : TextMeshProUGUI, ILocalize
{
	public bool IsLocalized;

	public string Token;

	[TextArea]
	public string English;

	[NonSerialized]
	public Translate.Phrase Phrase;

	[FormerlySerializedAs("AutoSizeContainer")]
	public bool AutoSetWidth;

	public bool AutoSetHeight;

	public bool AutoSizeParent;

	public float MinWidth = 30f;

	public float MaxWidth = float.PositiveInfinity;

	private object[] localizationArguments;

	public string LanguageToken => Token;

	public string LanguageEnglish => English;

	public void SetPhrase(Translate.Phrase phrase)
	{
		if (Application.isPlaying)
		{
			Phrase = phrase;
		}
		IsLocalized = true;
		Token = phrase.token;
		English = phrase.english;
		UpdateLocalizedText(forceEnglish: false);
	}

	protected override void Awake()
	{
		base.Awake();
		UpdateLocalizedText(forceEnglish: false);
	}

	public void SetPhraseArguments(params object[] args)
	{
		localizationArguments = args;
		UpdateLocalizedText(forceEnglish: false);
	}

	public void SetText(string str)
	{
		IsLocalized = false;
		base.text = str;
		DoAutoSize();
	}

	public virtual void DoAutoSize()
	{
		if (AutoSetWidth)
		{
			RectTransform trans = (RectTransform)base.transform;
			Vector2 preferredValues = GetPreferredValues(base.text, float.PositiveInfinity, float.PositiveInfinity);
			preferredValues.x = Mathf.Clamp(preferredValues.x, MinWidth, MaxWidth);
			trans.SetWidth(preferredValues.x);
			trans.DoAutoLayout();
			if (AutoSizeParent)
			{
				RectTransform trans2 = (RectTransform)base.transform.parent;
				trans2.SetWidth(preferredValues.x);
				trans2.DoAutoLayout();
			}
		}
		if (AutoSetHeight)
		{
			RectTransform obj = (RectTransform)base.transform;
			Rect rect = obj.rect;
			Vector2 preferredValues2 = GetPreferredValues(base.text, rect.width - (m_margin.x + m_margin.z), float.PositiveInfinity);
			preferredValues2.y = Mathf.Max(0f, preferredValues2.y);
			obj.SetHeight(preferredValues2.y);
			obj.DoAutoLayout();
			if (AutoSizeParent)
			{
				RectTransform trans3 = (RectTransform)base.transform.parent;
				trans3.SetHeight(preferredValues2.y);
				trans3.DoAutoLayout();
			}
		}
	}

	public override void Rebuild(CanvasUpdate update)
	{
		if (!(this == null))
		{
			base.Rebuild(update);
		}
	}

	private string GetLocalizedText(bool englishVersion)
	{
		if (Phrase != null)
		{
			if (localizationArguments != null)
			{
				return string.Format(Phrase.translated, localizationArguments);
			}
			return Phrase.translated;
		}
		string text = (englishVersion ? English : Translate.Get(Token, English));
		if (string.IsNullOrEmpty(text))
		{
			return string.Empty;
		}
		if (localizationArguments != null)
		{
			text = string.Format(text, localizationArguments);
		}
		return text;
	}

	private void UpdateLocalizedText(bool forceEnglish)
	{
		if (IsLocalized)
		{
			string localizedText = GetLocalizedText(forceEnglish);
			base.text = localizedText;
			DoAutoSize();
		}
	}

	public static void OnLanguageChanged()
	{
		RustText[] array = Resources.FindObjectsOfTypeAll<RustText>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateLocalizedText(forceEnglish: false);
		}
	}
}
