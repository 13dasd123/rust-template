using System.Collections;
using System.Collections.Generic;
using Rust;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.UI;

[RequireComponent(typeof(RawImage))]
public class HttpImage : MonoBehaviour
{
	public static Dictionary<string, UnityWebRequest> RequestCache = new Dictionary<string, UnityWebRequest>();

	public static Dictionary<string, Texture2D> TextureCache = new Dictionary<string, Texture2D>();

	private RawImage image;

	public string Url = "";

	private void Init()
	{
		image = GetComponent<RawImage>();
		image.enabled = false;
	}

	private void OnEnable()
	{
		Init();
		if (Url != string.Empty)
		{
			string url = Url;
			Url = string.Empty;
			Load(url);
		}
	}

	public void Load(string url)
	{
		if (Url == url)
		{
			return;
		}
		if (image == null)
		{
			Init();
		}
		Url = url;
		if (TextureCache.ContainsKey(url))
		{
			image.texture = TextureCache[url];
			image.enabled = true;
		}
		else if (base.isActiveAndEnabled)
		{
			if (RequestCache.ContainsKey(url))
			{
				image.enabled = false;
				Global.Runner.StartCoroutine(WaitForLoad(url));
			}
			else
			{
				image.enabled = false;
				Global.Runner.StartCoroutine(StartAndWaitForLoad(url));
			}
		}
	}

	private IEnumerator WaitForLoad(string url)
	{
		while (!TextureCache.ContainsKey(url))
		{
			yield return null;
		}
		if ((bool)this && (bool)image)
		{
			image.texture = TextureCache[url];
			image.enabled = true;
		}
	}

	private IEnumerator StartAndWaitForLoad(string url)
	{
		UnityWebRequest request = UnityWebRequestTexture.GetTexture(url);
		RequestCache.Add(url, request);
		yield return request.Send();
		RequestCache.Remove(url);
		TextureCache.Add(url, DownloadHandlerTexture.GetContent(request));
		request.Dispose();
		if ((bool)this && (bool)image)
		{
			image.texture = TextureCache[url];
			image.enabled = true;
		}
	}
}
