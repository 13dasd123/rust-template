using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

[AddComponentMenu("Facepunch/Skeleton")]
public class Skeleton : MonoBehaviour
{
	public SkeletonDefinition Source;

	public GameObject[] Bones;

	public Transform GetTransform(int id)
	{
		if (id < 0)
		{
			return null;
		}
		return Bones[id].transform;
	}

	public Transform GetTransformSlow(string name)
	{
		SkeletonDefinition.Bone bone = Source.FindBone(name);
		if (!string.IsNullOrEmpty(bone.Name))
		{
			return GetTransform(bone.Id);
		}
		if (Bones != null && Bones.Length != 0)
		{
			for (int i = 0; i < Bones.Length; i++)
			{
				Transform transform = Bones[i].transform.FindChildRecursive(name);
				if (transform != null)
				{
					return transform;
				}
			}
		}
		return null;
	}

	public IEnumerable<Transform> GetTransforms()
	{
		return Source.Bones.Select((SkeletonDefinition.Bone x) => GetTransform(x.Id));
	}

	public GameObject GetGameObject(int id)
	{
		if (id < 0)
		{
			return null;
		}
		return Bones[id];
	}

	public void CopyPositions(Skeleton to)
	{
		if (to.Source != Source)
		{
			throw new ArgumentException("Trying to copy transforms between different skeletons");
		}
		if (to.Bones.Length != Bones.Length)
		{
			throw new ArgumentException("Bone arrays are different sizes, skeleton might need rebuilding");
		}
		for (int i = 0; i < Bones.Length; i++)
		{
			if (!(Bones[i] == null) && !(to.Bones[i] == null))
			{
				to.Bones[i].transform.SetPositionAndRotation(Bones[i].transform.position, Bones[i].transform.rotation);
			}
		}
	}

	public void CopySkeletonSkins(SkeletonSkin[] renderers, LODGroup lodGroup = null)
	{
		SkinnedMeshRenderer[] array = new SkinnedMeshRenderer[renderers.Length];
		for (int i = 0; i < renderers.Length; i++)
		{
			array[i] = CopySkin(renderers[i]);
		}
		if (lodGroup != null)
		{
			CopyLodGroup(lodGroup, renderers, array);
		}
	}

	private void CopyLodGroup(LODGroup lodGroup, SkeletonSkin[] renderers, SkinnedMeshRenderer[] created)
	{
		LOD[] lODs = lodGroup.GetLODs();
		for (int i = 0; i < lODs.Length; i++)
		{
			LOD lOD = lODs[i];
			for (int j = 0; j < lOD.renderers.Length; j++)
			{
				int num = LookupRendererIndex(renderers, lOD.renderers[j]);
				lOD.renderers[j] = ((num >= 0) ? created[num] : null);
			}
		}
		LODGroup lODGroup = base.gameObject.AddComponent<LODGroup>();
		lODGroup.size = lodGroup.size;
		lODGroup.animateCrossFading = lodGroup.animateCrossFading;
		lODGroup.fadeMode = lodGroup.fadeMode;
		lODGroup.enabled = lodGroup.enabled;
		lODGroup.SetLODs(lODs);
	}

	private int LookupRendererIndex(SkeletonSkin[] renderers, Renderer renderer)
	{
		for (int i = 0; i < renderers.Length; i++)
		{
			if (renderers[i].SkinnedMeshRenderer == renderer)
			{
				return i;
			}
		}
		return -1;
	}

	private SkinnedMeshRenderer CopySkin(SkeletonSkin renderer)
	{
		GameObject gameObject = new GameObject();
		gameObject.transform.parent = base.transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localScale = Vector3.one;
		gameObject.layer = base.gameObject.layer;
		return renderer.DuplicateAndRetarget(gameObject, this);
	}

	public void CopySkeletonAttachments(SkeletonAttachment[] attachments)
	{
		for (int i = 0; i < attachments.Length; i++)
		{
			CopyAttachment(attachments[i]);
		}
	}

	private void CopyAttachment(SkeletonAttachment skeletonAttachment)
	{
		Skeleton componentInParent = skeletonAttachment.GetComponentInParent<Skeleton>();
		if (componentInParent == null)
		{
			throw new Exception("SkeletonAttachment has no Skeleton");
		}
		if (Source != componentInParent.Source)
		{
			throw new Exception("SkeletonAttachment uses different Skeleton");
		}
		int num = componentInParent.ReverseLookupBone(skeletonAttachment.transform.parent.gameObject);
		if (num < 0)
		{
			throw new Exception("SkeletonAttachment attached to bone that isn't in skeleton");
		}
		skeletonAttachment.CopyTo(Bones[num]);
	}

	private int ReverseLookupBone(GameObject bone)
	{
		return Array.IndexOf(Bones, bone);
	}
}
